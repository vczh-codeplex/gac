========================================================
Types
========================================================

sbyte	(Int8)
short	(Int16)
int		(Int32)
long	(Int64)
byte	(UInt8)
ushort	(UInt16)
uint	(UInt32)
ulong	(UInt64)
float	(Float32)
double	(Float64)

bool			: true, false
char			: 'a', 'b'
string			: "a", "b"

========================================================
Types Definitions (reference type)
========================================================

type Handle = int

enum Season = Spring | Summer | Autumn | Winter   (e.g. Season.Spring, ...)

data Point T = { x:T, y:T }

data Expression
= Nunmber { value:double }
| Binary { left:Expression, right:Expression, op:BinaryOpeartor }

========================================================
Type Constructors
========================================================

array T			: array [a, b, c:xs]
iterator T		: iterator [a, b, c:xs]
map T U			: map {a:b, c:d, e:f}
(T, U, V)		: (a, b, c)
()				: ()

data			: Point { x:10, y:20 }
				: new Point int { x:10, y:20 }

========================================================
Expressions
========================================================

function call	: function argument
				: argument -> function
field			: expression . name
association		: (a b c) d <==> a b c $ d
				: (a b c) . d <==> a b c $ . d

function		: pattern=>expression
				: x=>x+1
				: x=>y=>x+y

a <- b			: x=>a $ b x
(op)			: x=>y=>x op y
(? op value)	: x=>x ope value
(value op ?)	: x=>value op x

operator precedence
	=>
	field
	function call
	+ - not 
	* / %
	+ -
	<< >>
	== != < <= > >=
	&
	^
	|
	and
	xor
	or
	<-
	->
	custom operator
	$
	?: