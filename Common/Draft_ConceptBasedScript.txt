========================================================
Types
========================================================

sbyte	(Int8)
short	(Int16)
int		(Int32)
long	(Int64)
byte	(UInt8)
ushort	(UInt16)
uint	(UInt32)
ulong	(UInt64)
float	(Float32)
double	(Float64)

bool			: true, false
char			: 'a', 'b'
string			: "a", "b"

generic type	: Array int
function type	: argument -> result

========================================================
Types Definitions (reference type)
========================================================

type Handle = int

enum Season = Spring | Summer | Autumn | Winter   (e.g. Season.Spring, ...)

data Point T = { x:T, y:T }

data Expression
= Nunmber { value:double }
| Binary { left:Expression, right:Expression, op:BinaryOpeartor }

========================================================
Type Constructors
========================================================

array T			: array [a, b, c:xs]
iterator T		: iterator [a, b, c:xs]
map T U			: map {a:b, c:d, e:f}
(T, U, V)		: (a, b, c)
()				: ()

data			: Point { x:10, y:20 }
				: new { x:10, y:20 }

========================================================
Expressions
========================================================

function call	: function argument
				: argument -> function

field			: expression . name
association		: (a b c) d <==> a b c $ d
				: (a b c) . d <==> a b c $ . d

function		: pattern=>expression
				: x=>x+1
				: x=>y=>x+y

a <- b			: x=>a $ b x
(op)			: x=>y=>x op y
(? op value)	: x=>x ope value
(value op ?)	: x=>value op x

shallow copy	: shallow_copy x
deep copy		: deep_copy x

matching		: ( if condition then expression else expression )
				: ( match value { whhen pattern : value ... } )

specify type	: (value :: type)
				: (array [] :: array int)
				: (map {} :: map string int)

========================================================
Operators
========================================================

operator precedence
	=>
	field
	a[b]
	function call
	+ - not
	* / %
	+ -
	<< >>
	== != < <= > >=
	&
	^
	|
	and
	xor
	or
	<-
	->
	custom operator
	$

========================================================
Statements
========================================================

function definition ;
readonly value definition ;
variable definition ;

expression ;
pattern = value ;
pattern <= value ;

{ statements }

if condition then statement else statement
for a in b statement
for a in b to c statement
while condition statement
do statement while condition ;

break ;
continue ;
return ;
return expression ;

match value {
	when pattern : statement
	...
}

========================================================
Definitions
========================================================

def readonly_value [ :: type ] = value

var variable [ :: type ] = value

def function_name pattern1 pattern2 ... [ :: type ] 
	= value
	= do [continuation] statement

property function_name pattern1 pattern2 [ :: type ] = {
	get = function_body
	set pattern1 = function_body
	set pattern2 = function_body
}

========================================================
Interfaces
========================================================

interface Array T :: Enumerable T = {
	property Length :: int { get }
	property ([]) (index :: int) :: int { get set }
	def Resize :: int -> ()
}

========================================================
Interfaces Implementation
========================================================

interface instance Array 

========================================================
Concept
========================================================

========================================================
Concept Instance
========================================================

========================================================
Continuation
========================================================