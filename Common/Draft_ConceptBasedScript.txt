========================================================
Types
========================================================

Predefined types: (struct)
	int8			:0
	int16			:0
	int32			:0
	int64			:0
	uint8			:0
	uint16			:0
	uint32			:0
	uint64			:0
	float32			:0
	float64			:0
	bool			:false
	char			:'\0'
	string			:""
	void			:new void
	Pair<T, U>		:new Pair<T, U>{first=default(T), second=default(U)}
	Ref<T>			:empty reference (represent as "ref null")

Predefined types: (ref struct)
	T[]				:null
	object			:null
	R(params tuple)	:null (concept)
	Type			:type object for reflection (concept)

Type shortcut:
	(T0, T1, T2)	:Pair<T0, Pair<T1, Pair<T2, void>>>
	R(T0, T1, T2)	:R(params (T0, T1, T2)) // Invokable<R, (T0, T1, T2)>
	ref T			:Ref<T>

struct Ref<T>		//this is a special type, programmers will not see getter, setter. ref null is a shortcut to new Ref<T>
{
	T() getter;
	void(T) setter;
}

concept T as Invokable<TResult, TParameters>
{
	TResult Invoke(TParameters paremters);
}

reading to and writing from Ref<T> redirect to Ref<T>.Value

T Ref<T>.Value<T>
{
	get
	{
		if(this.getter == null) throw new EmptyReferenceException;
		return this.getter();
	}
	set
	{
		if(this.setter == null) throw new EmptyReferenceException;
		this.setter(value);
	}
}

========================================================
Expressions
========================================================

Constant for values:
	true, false, null
	123, 123.456, 123.456E-10
	'a', '\0', '\r', '\n', '\t', '\\', '\'', '\"', '\xFFFF'
	"a\0\r\n\t\\\'\"\xFFFF"
	@"	line1
		line2
		line3 ""
	"

Type constructors:
	default(T)		// default value of type T
	typeof(T)		// get the type object for T
	(a, b, c)		// create tuple with values for type (Ta, Tb, Tc)

	new Type		// create a struct value or ref struct value with all fields set to default values
					// for predefined struct, it gets its default value for the type
	new Type		// create a struct value or ref struct value with values for some fields and default values for others
	{
		Field=Value,
		///
	}

	new Type[count]	// create an array with a specified length and all elements set to default values
	new Type[]		// create an array with element values specified
	{
		Value,
		...
	}
	[a, b, c]		// create an array of automatically type inference

	new Concept		// go to concept DefaultImpl<T>, for ref concept T

	ref	a			// create a reference to a left value, a variable of a reference type can be redirected using <refA = ref a;>

Operators: (ordered in preference)
	+ - ! ~ ++ --
	<< >>
	* / %
	+ -
	< <= > >= == !=
	&
	^
	|
	&&
	||
	?:
	??
	a[b]			// this is a property
	= x=			// = is not overloadable

Implicit conversion:
	(struct, ref struct, ref concept) -> object

	ref struct From
	{
		mixin To;
	}

	ref concept TThis as From // TThis must be ref struct
		requires TThis as To
	{
	}

	instance From as To
	{
	}

	not satisfies then go to custom
		concept ImplicitConvertable<TSource, TDest>

	Predefined ImplicitConvertable implementation:
		int8 -> int16 -> int32 -> int64
		uint8 -> uint16 -> uint32 -> uint64
		float32 -> float64
		(int8, int16, uint8, uint16) -> float32
		(int32, uint32) -> float64

	implicit conversion always search 1 level only

Explicit conversion:
	(T)expr
	expr as T // same as (T)expr, except that cast fail returns null, not throw exception

	1. search for implicit conversion rule
	2. search for Convertable<TSource, TDest>
	3. read the real type (rtti) and perform implicit conversion rule without invoking ImplicitConvertable<TSource, TDesT>
	4. throw TypeCastException

	Predefine Convertable implementation:
		all numberic types <--> all numberic types
		char <--> all integer types

		instance<TSource, TDest> Convertable<TSource, TDest>
			requires ImplicitConvertable<TSource, TDest>
		{
			TDest Convert(TSource source)
			{
				return ImplicitConvertable<TSource, TDest>.Convert(source);
			}
		}

Member access:
	struct.field
	ref struct.field
	ref concept.function
	x.ExtensionProperty
	x.ExtensionFunction

Reference access:
	ref a // for variable, argument, field, get-set property, type of ref T (like return values from +=)

Function invoking:
	Function(arg0, arg1, arg2) is equivalent to Function(params (arg0, arg1, arg2))

	for void f(string a, params int[] arguments) arguments we have
	f("a", new int[]{1, 2, 3}) is equivalent to f("a", 1, 2, 3);

	for ref T argument we should only pass expressions of ref expr into it
	like for void f(ref a);
	we should invoke it like
		f(ref variable);
		f(ref a[b]);
		f(ref a.operator+=(b))
		etc..

Extension function invoking:
	expression.Function( ... )

Lambda expression:
	a=>b
	(a, ref b)=>b
	int(int a, int ref b){return b;}

yield as ContinuableType // so it can be used as c=>yield as Enumerable<int>{for(int i=0;i<c;i++)yield c;}
{
	a = yield b;
	yield a;
	yield return [expression] ;
}

========================================================
Generic Constraint
========================================================

requires [TypeConstraint] T [: ConceptConstraint, ...]

========================================================
Function Declaration
========================================================

========================================================
Property Declaration
========================================================
	
========================================================
Type Declaration
========================================================
	
========================================================
Concept Declaration
========================================================
	
========================================================
Instance Declaration
========================================================

========================================================
Statements
========================================================

{
	statement; ...
}

(type | var) variable [ = expression] ;

(variable | pattern) = expression ; // failing to match the pattern will raise a PatternAssignException
                                    // variables in the pattern can contains not-declared variables. in this case, those variable is declared.
									// assignment can use function result type to choose a correct overloaded function
									// like (int a, success) = TryConvert("abc"); will use TryConvertable<string, int>.TryConvert

if (boolean expression)
	statement;
[else
	statement;]

while (boolean expression)
	statement;

do
	statement;
while (boolean expression)

foreach ((type | var) variable in enumerable)
	statement;

using((type | var) variable = initialization)
	statement;

try
	statement;
[catch (catchable x)
	statement;]
[finally
	statement;]

continue;
break;
return [expression];

switch (expression)
{
	case pattern1 :
	case pattern2 :
		statement;
		break;
	default :
		// falling into a not-explicitly-declared default will raise a SwitchException
}

Pattern:
	Type variable // switch only
	(a, b, c)
	[a, b, c]
	([Dog a, Fox b, Cat c : remains], b (c, d))
	constant

========================================================
Continuation
========================================================

FunctionDeclaration yield
{
	a = yield b;				// call ContinuationBindable<TC, T, UC>.Bind(xb, a=>remains)
	yield a;					// call ContinuationYieldable<TC, UC>.Yield(xa, ()=>remains)
	yield return [expression] ;	// call ContinuationNullable<TC>.Null or ContinuationReturnable<T>.Return
}

ContinuableType PropertyName
{
	get yield
	{
		...
	}
	set // do not accept yield
	{
		...
	}
}

========================================================
Module System
========================================================

========================================================
Predefined Exceptions
========================================================

NullReferenceException
EmptyReferenceException
TypeCastException
IndexOutOfRangeException
SwitchException
PatternAssignException

========================================================
Predefined Functions
========================================================

========================================================
Predefined Concepts
========================================================

Concepts for operators

	concept Negatable<T>
	{
		T operator +(T value);
		T operator -(T value);
	}

	concept Increasable<T>
	{
		ref T operator prefix++(ref T value);
		ref T operator prefix--(ref T value);
		T operator postfix++(ref T value);
		T operator postfix--(ref T value);
	}

	concept Shiftable<T>
	{
		T operator <<(T value);
		T operator >>(T value);
		ref T operator <<=(ref T dst, T src);
		ref T operator >>=(ref T dst, T src);
	}

	concept Multable<T>
	{
		T operator *(T value);
		T operator /(T value);
		ref T operator *=(ref T dst, T src);
		ref T operator /=(ref T dst, T src);
		T One{get;}
	}

	concept Modulable<T>
	{
		T operator %(T value);
		ref T operator %=(ref T dst, T src);
	}

	concept Addable<T>
	{
		T operator +(T value);
		T operator -(T value);
		ref T operator +=(ref T dst, T src);
		ref T operator -=(ref T dst, T src);
		T Zero{get;}
	}

	concept BitOperatable<T>
	{
		T operator &(T value);
		T operator |(T value);
		T operator ^(T value);
		ref T operator &=(ref T dst, T src);
		ref T operator |=(ref T dst, T src);
		ref T operator ^=(ref T dst, T src);
	}

	concept Equable<T>
	{
		T operator ==(T value);
		T operator !=(T value);
	}

	concept Comparable<T>
	{
		T operator <(T value);
		T operator <=(T value);
		T operator >(T value);
		T operator >=(T value);
	}

	concept LogicalOperatable<T>
	{
		T operator &&(T value);
		T operator ||(T value);
		T operator ^(T value);
		ref T operator &&=(ref T dst, T src);
		ref T operator ||=(ref T dst, T src);
		ref T operator ^=(ref T dst, T src);
	}

Concepts for predefined types:

	concept T as Invokable<TResult, TParameters>
	{
		TResult Invoke(TParameters paremters);
	}

	concept T as Type
	{
		...
	}

Concepts for type conversions:

	concept Convertable<TSource, TDest>
	{
		TDest Convert(TSource source);
	}

	concept ImplicitConvertable<TSource, TDesT>
	{
		TDest Convert(TSource source);
	}

	concept TryConvertable<TSource, TDest>
	{
		(TDest, bool) TryConvert(TSource source);
	}

Concepts for exceptions:
	
	ref concept T as Throwable
	{
		string T.Message{get;}
	}

Concepts for statements;
	
	ref concept T as Disposable
	{
		void T.Dispose();
	}

	ref concept TThis as Enumerable<T>
	{
		Enumerator<T> TThis.CreateEnumerator();
	}

	ref concept TThis as Enumerator<T>
	{
		bool TThis.MoveNext();
		T TThis.Current{get;}
	}

Concepts for concept default implementations:

	concept DefaultImpl<T>
		requires ref concept T
	{
		T CreateDefaultImpl;
	}

Concepts for continuations:
	
	concept Continuable<TC>
	{
	}

	concept ContinuationNullable<TC>
	{
		TC Null{get;}
	}

	concept ContinuationReturnable<T, TC>
	{
		TC Return(T t);
	}

	concept ContinuationBindable<TC, T, UC>
	{
		UC Bind(TC closure, UC(T) continuation);
	}

	concept ContinuationYieldable<TC, UC>
	{
		UC Bind(TC closure, UC(T) continuation);
	}

========================================================
Predefined Instances
========================================================

	instance<T> Continuable<Enumerable<T>>
	instance<T> ContinuationNullable<Enumerable<T>>
	instance<T> ContinuationYieldable<T, Enumerable<T>>
	instance<T> ContinuationYieldable<Enumerable<T>, Enumerable<T>>

	instance<T> Continable<Task<T>>
	instance<T> ContinableReturnable<Task<T>>
	instance ContinuableNullable<Task<void>>
	instance<T, U> ContinableBindable<Task<T>, T, Task<U>>

========================================================
Intermediate Language Definition
========================================================