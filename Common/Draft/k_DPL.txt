========================================================
Data Processing Language for writing semantic analyzing
========================================================

========================================================
Types
========================================================

int/uint (according to architecture bits)
int8/int16/int32/int64
uint8/uint16/uint32/uint64
float/double
char/bool

========================================================
Data
========================================================

data Name;					// --> data Name()
Name						// --> Name()

data Group(A : Type, B : Type, C : Type);
Group(Name1/Value1, ...)

========================================================
Relations
========================================================

rel Relation(A : Type, B : Type, C? : Type);
// name without ? cannot be an output argument

Relation(<data>, <data>);
Relation(A?, B?) : SubRelation(A, C?) && Relation(C?, B);
Relation(A, B?) : SecondRelation(A, B), ThirdRelation(A, B);

========================================================
Relation Decorations
========================================================

cached <relation-declaration>
// "cached" means when the relation is evaluated, the value will be cached

========================================================
Patterns
========================================================
A?
_
[x,y,z:xs]
Type x
Data(A, B, C)
A{B:C, D:E}

========================================================
Predicate
========================================================

Relation(A, B, C)
Variable op Expression		// comparison operators
(Predicate)
A && B
A || B

========================================================
External Data Structures
========================================================

data Type [: Type]
{
	field : Type,
	...
}

========================================================
Expressions
========================================================

A op B
A.B
A[x]
A as Type
[x,y,z:xs]
null
if Expression then Expression else Expression
switch Expression case Pattern->Expression ...
(Expression)
A?							// a relation query result
A{B:C, D:E}					// data structure construction

<data-construction>
<relation-construction>		// importing function only
<set-querying>
<relation-querying>
{A, B, C}					// evaluating each expression and returning the last one

========================================================
Goals
========================================================

========================================================
Program Structure
========================================================

unit UnitName;
uses UnitName, UnitName, UnitName ...;

<data-declaration>
<relation-declaration>
<relation-construction>
<goal-declaration>