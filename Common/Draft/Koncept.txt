========================================================
Primitive Types
========================================================

void				system.Void			<>
object				system.Object
uint8				system.UInt8
uint16				system.UInt16
uint32				system.UInt32				(uint)
uint64				system.UInt64
int8				system.Int8
int16				system.Int16
int32				system.Int32				(int)
int64				system.Int64
float				system.Single
double				system.Double
bool				system.Boolean
char				system.Char
string				system.String

========================================================
Composite Types
========================================================

Pair<T, U>							T..U						default..default // right associative
Pair<T, Pair<U, Pair<V, void>>>		<T, U, V>, T..U..V..void	<default, default, default>

IDelegate<R, <T, U, V>>				func (T, U, V):R
									func (..<T, U, V>):R
									func (T, .. <U, V>):R

IEnumerable<T>						{T}
IMap<TKey, TValue>					{TKey : TValue}
IReadonlyMap<TKey, TValue>			const {TKey : TValue}
IArray<T>							[T]
IReadonlyArray<T>					const [T]
IList<T>
IReadonlyList<T>
ISortedList<T>
IReadonlySortedList<T>
ISet<T>
IReadonlySet<T>
IQueue<T>
IStack<T>

========================================================
Composite Type Constructors
========================================================

ExternalClassType*	// raw pointer
ExternalClassType	// shared pointer

default:T
null:T
new(args):T

x->x+1
(x,y)->x+y
func (int x, int y)->int = x+y
func (int x, int y)->int{ return x+y; }

// IArray
array(10) : int[]
[]
[1, 2, 3]
[1, 2, 3, 4, 5].Slice(1, 3) == [2, 3, 4] // reference, not copy

// IArray
[1, 2, 3] ++ [4, 5, 6]
// IEnumerable
{1, 2, 3} ++ {4, 5, 6}

// IMap
{}
{1:"a", 2:"b"}

========================================================
Custom Types
========================================================

class Link [ : base1, base2, ... ]
{
	value : object;
	next : Link;
}

class<T> Link
{
	value : T;
	next : Link<T>;
}

struct Point	// struct members are immutable
{
	x : int;
	y : int;
}

struct<T> Point
	where Numeric<T>
{
	x : T;
	y : T;
}

enum Season
{
	Spring,
	Summer,
	Autumn,
	Winter,
}

flags FileAccess
{
	Read,
	Write,
}

type Box = {int : string};
type<T> Box = {int : T};

========================================================
Custom Type Constructors
========================================================

Point{x:1, y:2}						{x:1, y:2}
Point{}								{}
DealWithPoint(Point{x:1, y:2})		DealWithPoint({x:1, y:2})

========================================================
Functions
========================================================

// arguments are <pattern-elements>

@Inline
func Add(a : int, b : int) : int = a+b;

func Add(a : int, b : int) : int
{
	return a+b;
}

// func<T> Add(a : T, b : T) : T where Addable
func Add(a, b) = a+b;

func<T> IsLastNode(node : Link<T>) : bool
{
	return node.next==null;
}

========================================================
Extension Functions
========================================================

@Inline
func<T> (this : Link<T>).IsLastNode() : bool
{
	return this.next==null;
}

@Inline
prop<T> (this : Link<T>).IsLastNode : bool
{
	get
	{
		return this.next==null;
	}
}

func<T> Link<T>.CreateLink() : Link<T> // static method
{
	return new();
}

========================================================
Dynamic Dispatching (plan: syntax merge with static dispatching and pattern matching)
========================================================

func DealWith(switch x : object) : void
{
	Console.WriteLine("x is an object");
}

func DealWith(case x : {object}) : void
{
	Console.WriteLine("x is an enumerable");
}

func DealWith(case x : string) : void
{
	Console.WriteLine("x is a string");
}

========================================================
Static Dispatching
========================================================

@Private
func<T> (this : string).Format_(args : T, start : int)
	where Tuple<T>; // { ... }

@Private
func (this : string).Format_<void>(args : void, start : int)
{
	return this;
}

@Private
func<A, B> (this : string).Format_<A..B>(a..b : A..B, int start)
{
	return message
		.Replace("{" + start.ToString() + "}", a.ToString())
		.Format(b, start + 1);
}

========================================================
Pattern Matching
========================================================

func<T> switch Length_(r : int, xs : {T}) : int;
func switch Length_; // simple header declaration for pattern matching
// a header is required if the following two declarations are pattern matching, not overloading

func case Length_(r, {}) = r;
func case Length_(r, {x:xs}) = Length_(r+1, xs);

func Length(xs) = Length_(0, xs);
// Length : func({T}):int

/*
if pattern matching and overloading appear at the same place, it should be written as

header_1
pattern_matching_1_1
pattern_matching_1_2

header_2
pattern_matching_2_1
pattern_matching_2_2

...
*/

Patterns:
<a, b, c>
[a, b, c: d]
{a, b, c: d}
a..b
a : Type			: infer a as type Type, new variable
id as Type			: cast
{x:id, y:id}		: match struct/type members
Point{x:id, y:id}	: match struct/type members

<pattern> = expression; // PatternMatchingFailedException

[partial] switch(value)
{
	case <pattern-element> -> ...
	// PatternMatchingFailedException if no partial keyword and default is hit and default is not implemented
}

if(<pattern-element> = expression) statement
while(<pattern-element> = expression) statement
[partial] foreach(<pattern-element> in xs) statement // PatternMatchingFailedException

<pattern-element>:
	_									: placeholder
	id									: new variable to receive a component
	constant							: a component with Equatable<T> that act like a filter
	// all <pattern-element> above cannot be a <pattern>
	// variable is not allowed to cover visible-with-the-same-name variables

	<pattern>							: internal pattern
	<pattern-element> if expr			: binding with a filter
	<pattern-element> :: <pattern>		: store values in both a and variables in <pattern>

partial foreach(even if even%2==0 in numbers)
{
	Console.WriteLine(even);
}

========================================================
Concepts
========================================================

// if a concept include a dynamic dispatch switch function, instances should have case functions.

concept<T> Equatable
{
	func AreEqual(a : T, b : T) : bool;
	@Inline func operator==(a, b) = AreEqual(a, b);
	@Inline func operator==(a, b) = !AreEqual(a, b);
}

concept<T> Comparable
{
	func Compare(a : T, b : T) : int;
	@Inline func operator<(a, b) = Compare(a, b)<0;
	@Inline func operator<=(a, b) = Compare(a, b)<=0;
	@Inline func operator>(a, b) = Compare(a, b)>0;
	@Inline func operator>=(a, b) = Compare(a, b)>=0;
	@Inline func operator==(a, b) = Compare(a, b)==0;
	@Inline func operator!=(a, b) = Compare(a, b)!=0;
}

concept<T> Addable
{
	prop Zero : T {get;}
	func operator+(a : T) : T;
	func operator-(a : T) : T;
	func operator+(a : T, b : T) : T;
	func operator-(a : T, b : T) : T;
}

concept<T, U> Differentiable
{
	func operator+(a : T, b : U) : T;
	func operator+(a : U, b : T) : T;
	func operator-(a : T, b : T) : U;
}

concept<T> HasDefaultValue
{
	prop Default : T {get;}
}

concept<T> HasNullValue
{
	prop Null : T {get;}
}

concept<TType, TArgs> Constructable
	where IsTuple<TArgs>
{
	func New(..args : TArgs) : TType;
}

concept<T> IsTuple{}
instance IsTuple<void>{}
instance<T, U> IsTuple<T..U> where IsTuple<U>{}

========================================================
Interfaces
========================================================

all functions in interface are switch-case-ing the this argument.

interface<T> IEnumerator
{
	prop T Current{get;}
	func MoveNext()->bool;
}

interface<T> IEnumerable
{
	func CreateEnumerator()->IEnumerator<T>;
}

interface<T> IReadonlyCollection
	where this.IEnumerable<T>
{
}

@Import
interface GuiControl
{
	func AddChild(child : GuiControl*) : bool
	prop Text : string {get; set;}
	event Clicked : func (GuiGraphicsComposition*, GuiEventArgs*) : void
}

implement<T> (this : seq_Enumerable).IEnumerable<T>
{
}

========================================================
Statements
========================================================

a : Type = b;
var a = b;
<pattern> = expression;
<left-value> = expression;
<function-call-expression>;
detach handler; // event handler, call IEventHandler.Detach()
raise this.Clicked(composition, args);

delete expression; // call IDisposable.Dispose()
return [expression];
break;
continue;
throw expression;

if (condition) statement [else statement]
while (condition) statement
do statement while (condition);
foreach(x[ : Type] in xs) statement

if(<pattern-element> = expression) statement
while(<pattern-element> = expression) statement
[partial] foreach(<pattern-element> in xs) statement // PatternMatchingFailedException

try statement { catch ([ex : ]Type) statement } [ finally statement ]
using (x[ : Type] = T where IDisposable(T)) statement
lock (object) statement

[partial] switch(value)
{
	{ case <pattern> -> statement }
	[ default -> statement ] // PatternMatchingFailedException
}

========================================================
Expressions
========================================================

a op b
op a
a op

f(a, b, c)
f(.. t)
f(a, b, ..t)
a.b
a as Type		// explicit type conversion, invoking Convertable

<continuation-control-flow>! [expression]
var handler = attach this.Clicked((a,b)->{});

<constructors>
<patterns>

(if (condition) value else value)
(switch (value) { case <pattern> -> value } [default -> value]) // PatternMatchingFailedException
(using (x = T where T.IDisposable) value)
(lock (object) value)

========================================================
Exceptions
========================================================

class Exception // base type for all exceptions
{
	message : string;
	callstack : CallstackSnapshot;
	innerException : Exception;
};

========================================================
Attributes
========================================================

class Attribute // base type for all attributes
{
};

@STAThread
func ThreadProc(){}

attribute marks
	function
	variable
	type
	concept
	instance
	field
	argument
	return
	property
	event

@Attribute
func Function(@Attribute a : int, @Attribute b : int) : @Attribute c;

@ThreadLocal
int a;

@Serializable
type Class
{
	@Item{name : "Name"}
	name : string;
}

========================================================
Type
========================================================

var one = 1;
// one : int

var inc = x->x+1;
// inc : func(int):int

var pinc = x->x+Convert(1);
// pinc : type<T> where Numeric<T>, Convertable<int, T> func(T):T

func Apply(f, x, c)
{
	foreach(i in 1..c)
		x=f(x);
	return x;
}
// Apply : type<T> func(func(T):T, T, int):T

var x = Apply(inc, 1, 100);
// x = 100

var x = Apply(pinc, 1.0, 100);
// x = 100.0

func Filter(xs, p) seq
{
	foreach(x in xs)
	    if (p) yield! x;
}
// Filter : type<T> func({T}, func (T)->bool)->{T}

func Concat(urls, cont) async
{
    var xs = new():IList<string>;
	foreach(url in urls)
		xs.Add(await! DownloadTextAsync(url))
	cont(xs);
}
// Concat : func({string}, func(IList<string>)->void)->Task<void>

========================================================
Continuations
========================================================

type seq
{
}

func<T> seq.CreateCps(func (seq_Enumerator<T>)->void startContinuation)->IEnumerable<T>
{
	return seq_Enumerable
	{
		startContinuation = startContinuation,
	};
}

type<T> seq_Enumerable
{
	func (seq_Enumerator<T>)->void	startContinuation;
}

implement<T> seq_Enumerable.IEnumerable<T>
{
	func CreateEnumerator()
	{
		return seq_Enumerator
		{
			startContinuation = this.startContinuation;
		};
	}
}

type<T> seq_Enumerator
{
	T							current;
	bool						available;
	func (seq_Enumerator<T>)	startContinuation;
	func ()->void				continuation;
}

implement<T> seq_Enumerator.IEnumerator<T>
{
	prop T Current
	{
		get
		{
			return this.current;
		}
	}

	func MoveNext()
	{
		this.available=false;
		if(this.continuation==null)
		{
			this.startContinuation(this);
		}
		else
		{
			this.continuation();
		}
		return this.available;
	}
}

@ContinuationControlFlow
@Inline
func<T> seq.yield(seq_Enumerator<T> state, T value, func ()->void continuation)
{
	state.current=value;
	state.available=true;
	state.continuation=continuation;
}

@ContinuationControlFlow
@Inline
func<T> seq.exit(seq_Enumerator<T> task)
{
}

---------------------------------------

type async
{
}

func<T> async.CreateCps(func (FuturePromiseTask<T>)->void startContinuation)->Task<T>
{
	var task = FuturePromiseTask<T>{};
	task.onStart = ()->startContinuation(task);
	return task;
}

@ContinuationControlFlow
@Inline
func<T, U> async.await(FuturePromiseTask<U> task, Task<T> source, func T->void continuation)
{
	source.ContinueWith(task->continuation(task.Result));
}

@ContinuationControlFlow
@Inline
func<T> async.exit(FuturePromiseTask<T> task, T source)
{
	task.SetResult(source);
}

---------------------------------------

func Find(src) async
{
    var urls=(await! DownloadAsync(src)).Split("\r\n");
	foreach(url in urls)
	{
		var content=await! DownloadAsync(url);
		if(content.Length>100)
		{
			return content;
		}
	}
	return null; // compiler will find exit!
}

=>

type _Find
{
	FuturePromiseTask<string>	_controller;
	string						_output0;
	func string->void			_output0_continuation;
	string						_output1;
	func string->void			_output1_continuation;
	int							_state;
	
	IEnumerator<string>			_x0;
	string						src;
	[string]					urls;
	string						url;
}

func _Find.RunStateMachine()
{
	this._output0_continuation = _output->
	{
		this._output0 = output;
		this.RunStateMachine();
	};
	this._output1_continuation = _output->
	{
		this._output1 = output;
		this.RunStateMachine();
	};

	while(true)
	{
		switch(this._state)
		{
			case 0:
			{
				this._state = 1;
				var input = DownloadAsync(this.src);
				async.await(this._controller, input, this._output0_continuation);
				return;
			}
			case 1:
			{
				this.urls = this._output0.Split("\r\n");
				this._x0 = this.urls.CreateEnumerator();
				this._state = 2;
			}
			case 2:
			{
				if(_x0.MoveNext())
				{
					this.url = _x0.Current;
					this._state = 4;
					var input = this.url;
					async.await(this._controller, input, this._output1_continuation);
					return;
				}
				else
				{
					this._state=3;
				}
			}
			case 3:
			{
				this._result = null;
				return;
			}
			case 4:
			{
				this.content = this._output1;
				if(this.content.Length>100)
				{
					var input = this.content;
					async.exit(this.controller, input);
					return;
				}
				else
				{
					this._state = 2;
				}
			}
		}
	}
}

func Find(string src)->Task<string>
{
	return async.CreateCps(controller->
	{
		var sm = _Find
		{
			_state = 0;
			src = src;
		};

		sm._controller=controller;
		sm.RunStateMachine();
	});
}

---------------------------------------

func<T> IEnumerable<T>.Where(func (T)->bool predicate) seq
{
	foreach(s in this)
		if(predicate(s))
			yield! s;
}

=>

type<T> _Where
{
	seq_Enumerator<T>	_controller;
	func ()->void		_output_continuation;
	int					_state;
	IEnumerable<T>		_this;

	IEnumerator<T>		_x0;
	func (T)->bool		predicate;
	T					s;
}

func _Where.RunStateMachine()
{
	this._output_continuation = this.RunStateMachine;

	while(true)
	{
		switch(this._state)
		{
			case 0:
			{
				this._x0 = this._this.CreateEnumerator();
				this._state = 1;
			}
			case 1:
			{
				if(this._x0.MoveNext())
				{
					this.s = this._x0.Current;
					this._state = 2;
					var input = this.s;
					seq.yield(this._controller, input, this._output_continuation);
					return;
				}
				else
				{
					this._state = 3;
				}
			}
			case 2:
			{
				this.state = 1;
			}
			case 3:
			{
				return;
			}
		}
	}
}

func<T> IEnumerable<T>.Where(func (T)->bool predicate)->IEnumerable<T>
{
	return seq.CreateCps(controller->
	{
		var sm = _Where
		{
			_state = 0;
			_this = this;
		};

		sm._controller=controller;
		sm.RunStateMachine();
	});
}

========================================================
Predefined Concepts
========================================================

concept<T> Equatable
{
	func AreEqual(a : T, b : T) : bool;
	@Inline func operator==(a, b) = AreEqual(a, b);
	@Inline func operator==(a, b) = !AreEqual(a, b);
}

concept<T> Comparable
{
	func Compare(a : T, b : T) : int;
	@Inline func operator<(a, b) = Compare(a, b)<0;
	@Inline func operator<=(a, b) = Compare(a, b)<=0;
	@Inline func operator>(a, b) = Compare(a, b)>0;
	@Inline func operator>=(a, b) = Compare(a, b)>=0;
	@Inline func operator==(a, b) = Compare(a, b)==0;
	@Inline func operator!=(a, b) = Compare(a, b)!=0;
}

instance<T, U> Comparable<T..U>
	where Comparable<T>
	where Comparable<U>
{
	@Inline
	func Compare(a, b)
	{
		var result = Compare(a.first, b.first);
		if(result==0) return Compare(a.second, b.second)
		else return result;
	}
}

// all flag (bitwise-enum) is BitwiseOperatable
concept<T> BitwiseOperatable
	where Comparable<T>
{
	func operator &(T a, T b)->T;
	func operator |(T a, T b)->T;
	func operator ^(T a, T b)->T;
	func operator ~(T a, T b)->T;
}

concept<T> BooleanOperatable
	where Comparable<T>
{
	func operator &&(T a, T b)->T;
	func operator ||(T a, T b)->T;
	func operator ^^(T a, T b)->T;
	func operator !(T a, T b)->T;
}

concept<T> Addable
	where Comparable<T>
{
	prop Zero : T {get;}
	func operator+(a : T) : T;
	func operator-(a : T) : T;
	func operator+(a : T, b : T) : T;
	func operator-(a : T, b : T) : T;
	func Sign(a : T) : T;
	func Abs(a : T) : T;
}

func (this).Sum() = this.Foldl(Zero, operator+);

concept<T, U> Differentiable
	where Comparable<T>
	where Addable<U>
{
	func operator+(a : T, b : U) : T;
	func operator+(a : U, b : T) : T;
	func operator-(a : T, b : T) : U;
}

concept<T> Multiplicable
	where Comparable<T>
{
	prop One : T {get;}
	func operator*(a : T, b : T) : T;
	func operator/(a : T, b : T) : T;
}

concept<T> Numeric
	where Addable<T>
	where Multiplicable<T>
{
}

concept<T> Integral
	where Numeric<T>
{
	func operator%(a : T, b : T) : T;
	func Even(a : T) : bool;
	func Odd(a : T) : bool;
	func Gcd(a : T, b : T) : T;
	func Lcm(a : T, b : T) : T;
	func operator<<(a : T, b : T) : T;
	func operator>>(a : T, b : T) : T;
}

concept<T> Fractional
	where Numeric<T>
{
	func Truncate(a : T) : T;
	func Round(a : T) : T;
	func Floor(a : T) : T;
	func Ceiling(a : T) : T;
}

concept<T> Floating
	where Fractional<T>
{
	prop Pi : T {get;}
	prop (this : T).IsNan : T {get;}
	prop (this : T).IsInfinite : T {get;}
	func Exp(a : T) : T;
	func Sqrt(a : T) : T;
	func Log(a : T) : T;
	func Sin(a : T) : T;
	func Cos(a : T) : T;
	func Tan(a : T) : T;
	func ASin(a : T) : T;
	func ACos(a : T) : T;
	func ATan(a : T) : T;
	func Cosh(a : T) : T;
	func Tanh(a : T) : T;
	func Sinh(a : T) : T;
	func ACosh(a : T) : T;
	func ATanh(a : T) : T;
	func ASinh(a : T) : T;
}

concept<T> HasDefaultValue
{
	prop Default : T {get;}
}

concept<T> HasNullValue
{
	prop Null : T {get;}
}

concept<TType, TArgs> Constructable
	where IsTuple<TArgs>
{
	func New(..args : TArgs) : TType;
}

// always success without losing semantic data
// e.g. SafeConvertable<byte, int>, but not SafeConvertable<int, byte>
concept<T, U> SafeConvertable
{
	func SafeConvert(a : T) : U;
}

concept<T, U> Convertable
	where HasDefaultValue<U>
{
	func Convert(a : T) : U;
	func TryConvert(a : T) : <T, bool>
	{
		try return <Convert(s), true>;
		catch(Exception) return <default, false>;
	}
}

instance<T, U> Convertable
	where SafeConvertable<T, U>
{
	func Convert(a) = SafeConvertable(a);
}

concept<T, U> ImplicitlyConvertable
	where SafeConvertable<T, U>
{
}

concept<T> Printable
{
	func (this : T).ToString() : string;
}

instance<T> Printable<T>
	where Convertable<T, string>
{
	func (this).ToString() = Convert(this);
}

concept<T> Parsable
{
	func Parse(s : string) : T;
	func TryParse(s : string) : <T, bool>
	{
		try return <Parse(s), true>;
		catch(Exception) return <default, false>;
	}
}

instance<T> Parsable
	where Convertable<string, T>
{
	func Parse(s) = Convert(s);
	func TryParse(s) = TryConvert(s);
}

concept<T> IsTuple{}
instance IsTuple<void>{}
instance<T, U> IsTuple<T..U> where IsTuple<U>{}

@TypeTrait
concept<T, U> InheritsFrom{}

instance<T, U> SafeConvertable
	where InheritsFrom<T, U>
{
	func SafeConvertable(a) = a;
}

instance<T, U> ImplicitConvertable
	where InheritsFrom<T, U>
{
}

========================================================
Predefined Interfaces
========================================================

========================================================
Predefined Functions
========================================================

func<T, U> {T}.Map(func U(T))->{U};
func<T> operator++({T}, {T})->{T};
func<T> operator++(const [T], const [T])->const [T]
func<T> const [T].Slice(int, int)->const [T]
func<T> [T].Slice(int, int)->[T]
func<T> {T}.Filter(func bool(T))->{T};
func<T> {T}.First()->T;
func<T> {T}.Last()->T;
func<T> {T}.Empty()->T;

func<T> {T}.Take(int)->{T};
func<T> {T}.TakeWhile(int, func bool(T))->{T};
func<T> {T}.Drop(int)->{T};
func<T> {T}.DropWhile(int, func bool(T))->{T};
func<T> {T}.Reverse()->{T};
func<T, U> {U}.Foldl(T, func T(T, U))->T;
func<T, U> {U}.Foldr(T, func T(T, U))->T;
func<T, U> {U}.Scanl(T, func T(T, U))->{T};
func<T, U> {U}.Scanr(T, func T(T, U))->{T};
func<T> {T}.All(func bool(T))->bool;
func<T> {T}.Any(func bool(T))->bool;
func<T> {T}.SplitAt(int count)->{T} .. {T};
func<T> {T}.Span(func bool(T))->{T} .. {T};
func<T> {T}.Break(func bool(T))->{T} .. {T};
func<T, U> {U}.GroupBy(func T(U))->{T .. U};
func<T, U> {U}.OrderBy(func T(U))->{U};

func<T> {T}.Sum()->T;
func<T> {T}.Product()->T;
func<T> {T}.Min()->T;
func<T> {T}.Max()->T;
func<T> {{T}}.Flatten()->{T};
func<T, U> {T}.Zip({U})->{(T, U)};