========================================================
Primitive Types
========================================================

object				system.Object		null
void				system.Void			<>
uint8				system.UInt8		0
uint16				system.UInt16		0
uint32	(uint)		system.UInt32		0
uint64				system.UInt64		0
int8				system.Int8			0
int16				system.Int16		0
int32	(int)		system.Int32		0
int64				system.Int64		0
float				system.Single		0.0
double				system.Double		0.0
bool				system.Boolean		false
char				system.Char			'\0'
string				system.String		""

========================================================
Custom Types
========================================================

data PointI
{
	x : int;
	y : int;
}
// default value : {x : default(int), y : default(int)}

data<T> Point
{
	x : T;
	y : T;
}

// {x : 10, y : 20} : Point<int>

data Derived : Base1, Base2
{
}

========================================================
Composite Types
========================================================

data<T, U> Pair
{
	first : T;
	second : U;
}

T..U				Pair<T, U>			default(T)..default(U)					// right associative
<T, U, V>			T..U..V..void		<default(T), default(U), default(V)
T?										null		// T??->T?, T^?->T?, object?->object
T^										default(T)	// T?^->T?, T^^->T^, cannot be interface. T should be DataType<T>
T[]					Array<T>
T[U]				Map<U, T>
func (T, U) : V		Delegate<<T, U>, V>

typeof(Expr)

========================================================
Interfaces
========================================================

interface<T> Enumerator
{
	get Current : T;
	func MoveNext() : bool;
}

interface<T> Enumerable
{
	func CreateEnumerator() : Enumerator<T>;
}

interface<T> EvaluatedEnumerable
{
	get Length : int;
	func SliceEnumerable(start : int, length : int) : EvaluatedEnumerable<T>;
}

interface<T> Disposable
{
	func Dispose();
}

interface<T> Observer
{
	func OnNext(value : T);
	func OnError(error : Exception);
	func OnComplete();
}

interface<T> Observable
{
	func Subscribe(observer : Observer<T>) : Disposable
}

// default value for an interface does not exists
// except the concept DefaultValue is implemented

instance<T> DefaultValue<Enumerable<T>>
{
	func Default() = Enumerable<T>
	{
		func CreateEnumerator() = Enumerator<T>
		{
			get Current : T { throw InvalidOperationException{}; }
			func MoveNext() : bool = false;
		};
	};
}

interface<TArguments, TReturn> Delegate
	where TupleType<TArgs>
{
	func Invoke(arguments : TArguments) : TReturn;
}

x=>x+1
(x,y)=>x+y
func (x : int, y : int) : int = x + y
func (x : int, y : int) : int { return x + y; }

// equivalent to the lambda expression above
Delegate<<int, int>, int>
{
	func Invoke(<x, y> : <int, int>) : int
	{
		return x + y;
	}
}

========================================================
Container Interfaces
========================================================

interface<TKey, TValue> ReadableMapping
{
	get Keys : Enumerable<TKey>;
	get Values : Enumerable<TValue>;
	get operator[](index : TKey) : TValue;
	func ContainsKey(key : TKey) : bool;
	func TryGet(key : TKey) : TValue?;
}

interface<TKey, TValue> Mapping : ReadableMapping
{
	set operator[](index : TKey) : TValue;
}

interface<T> ReadableArray : ReadableMapping<int, T>, EvaluatedEnumerable<T>
{
	func Slice(start : int, length : int) : ReadableArray<T>;
}

interface<T> Array : ReadableArray<T>, Mapping<int, T>
{
	func Slice(start : int, length : int) : Array<T>;
}

interface<T> Collection : Array<T>
{
	func Add(value : T) : int;
	func Remove(value : T) : bool;
	func RemoveAt(index : int) : T;
	func Contains(value : T) : bool;
	func IndexOf(value : T) : int;
}

interface<T> List : Collection<T>
{
	func Insert(index : int, value : T);
}

interface<TKey, TValue> Map : Mapping<TKey, TValue>, Enumerable<TKey..TValue>
{
	func Add(key : TKey, value : Value);
	func Set(key : TKey, value : Value) : bool;
}

func<T>				ArrayOf(length : int) : Array<T>;
func<T>				ArrayOf(values : Enumerable<T>) : Array<T>;
func<T>				ListOf(values : Enumerable<T>) : Array<T>;
func<T>				SortedListOf(values : Enumerable<T>) : Array<T>;
func<T>				SortedSetOf(values : Enumerable<T>) : Array<T>;
func<T>				HashSetOf(values : Enumerable<T>) : Array<T>;
func<TKey, TValue>	SortedMapOf(values : Enumerable<TKey..TValue>) : Map<TKey, TValue>;
func<TKey, TValue>	HashMapOf(values : Enumerable<TKey..TValue>) : Map<TKey, TValue>;

ArrayOf(10) : int[]
ArrayOf({1, 2, 3, 4, 5})
HashMapOf({1..1, 2..4, 3..9, 4..16, 5..25})
// {1, 2, 3} creates an EvaluatedEnumerable<int>

========================================================
Concepts
========================================================

concept<T> Addable
{
	get Zero : T;
	func operator+ (x : T) : T;
	func operator- (x : T) : T;
	func operator+ (x : T, y : T) : T;
	func operator- (x : T, y : T) : T;
}

concept<T, TDiff> Differentiable
{
	get Zero : TDiff;
	func operator+ (x : T, y : TDiff) : T;
	func operator+ (x : TDiff, y : T) : T;
	func operator- (x : T, y : T) : TDiff;
}

========================================================
Predefined Concepts
========================================================

DefaultValue<T>
SizeOf<T>
Tuplize<T>
Hashable<T>

NotNullType<T>
DataType<T>
InterfaceType<T>
TupleType<T>
InheritFrom<TDerived, TBase>

Convertable<TFrom, TTo>
ImplicitConvertable<TFrom, TTo>

concept Convertable<TFrom, TTo>
	where NotNull<TFrom>, NotNull<TTo>
{
	func TryConvert(value : TFrom) : TTo?;
	func Convert(value : TFrom) : TTo
	{
		if(result = TryConvert(value))
		{
			return result;
		}
		else
		{
			throw InvalidConvertionException{};
		}
	}
}

// all necessary or inherited constraints will be inferred and filled
// e.g. if T^ exists in the declaration body, then Data<T>
// e.g. if Texpr as U exists then Convertable<T, U>
instance<TFrom, TTo> Convertable<TFrom? TTo>
	where Convertable<TFrom, TTo>
{
	func TryConvert(value : TFrom?) : TTo?
	{
		if(expr = value)
		{
			return TryConvert(expr);
		}
		else
		{
			return null;
		}
	}
}

========================================================
Patterns
========================================================

Constant
Identifier		// can only be part of other patterns
X : Type
X^				// extract and convert to T^
X?				// extract and convert to T?
X..Y
<X, Y, Z>
{X, Y, Z: W}
{x:X, y:Y}

========================================================
Expressions
========================================================

Operator:
	++ -- []
	+ - not
	* / %
	+ -
	shl shr
	== != < <= > >=
	and
	xor
	or

<constructors>
Expr : Type

default(T)					// DefaultValue<T>.Default()
Expr as Type (or Type?)		// Convertable<typeof(Expr), Type>.Convert()/TryConvert()

========================================================
Statements
========================================================

<Pattern> | <LeftValue> | var Name = Expr
return [Expr];
break;
continue;
throw [Expr];

if(Expr) statement [else statement]
if(value = Expr) statement [else statement] // typeof(Expr) = typeof(value)?
for(<Pattern> in Expr) statement
while(Expr) statement
try statement {catch (<pattern>) statement} [finally statement]
switch (Expr) { {case <pattern> : statement} [default : statement] }
using(<pattern> = Expr) statement
lock(Expr) statement

========================================================
Functions
========================================================

func <generic-types> Name <instantiation-types> ( [case]<pattern>, .. ) <generic-requirements> (= Expr | statement )

func<T> WriteStream(this : Stream, value : T); // throw NotImplementedException{}

func WriteStream<int>(this : Stream, value : int);
func WriteStream<string>(this : Stream, value : string);
func<T, U> WriteStream<T..U>(this : Stream, value : T..U);
func WriteStream<string>(case this : StringStream, value : string);

get/set<T> operator[](this : Enumerable<T>, index : int);

namespace Name {}

========================================================
Continuations
========================================================

func<T, U> CreateCps(start : func (T):void) : U;

---------------------------------------------------------

data<T> CpsEnumerator
{
	current			: T;
	available		: bool;
	start			: func (CpsEnumerator<T>^) : void;
	continuation?	: func () : void;
}

// func<T> CreateCps<CpsEnumerator^, Enumerable<T>>(..):Enumerable<T> is inferred
func<T> CreateCps(start : func (CpsEnumerator<T>^):void )
{
	return Enumerable<T>
	{
		func CreateEnumerator()
		{
			state? = CpsEnumerator{ start : start };
			return Enumerable<T>
			{
				get Current : T { return state.current; }
				func MoveNext()
				{
					state.available=false;
					if(state.continuation==null)
					{
						state.startContinuation(state);
					}
					else
					{
						state.continuation();
					}
					return state.available;
				}
			};
		}
	};
}

func<T> yield(state : CpsEnumerator<T>^, value : T, continuation : func ():void)
{
	state.current=value;
	state.available=true;
	state.continuation=continuation;
}

func<T> exit(state : CpsEnumerator<T>)
{
}

---------------------------------------------------------

func<T> Where(this : Enumerable<T>, predicate : func(T):bool)
{
	for(s in this)
		if(predicate(s))
			yield! s;
	// return cannot be followed with an expression because exit function does not accept one
}

---------------------------------------------------------

func<T> CreateCps(start : func (Promise<T>^) : void) : Task<T>
{
	return CreateFuturePromiseTask<T>(start);
}

func<T> await(state : Promise<T>^, value : Task<T>, continuation : func (T):void)
{
	source.ContinueWith(task=>continuation(task.Result);
}

func<T> exit(state : Promose<T>^, value : T)
{
	state.SetResult(T);
}

---------------------------------------------------------

func Find(src)
{
    var urls=(await! DownloadAsync(src)).Split("\r\n");
	for(url in urls)
	{
		var content=await! DownloadAsync(url);
		if(content.Length>100)
		{
			return content;
		}
	}
	return null; // call exit
}