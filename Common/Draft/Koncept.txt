========================================================
Primitive Types
========================================================

object				system.Object		null
void				system.Void			<>
uint8				system.UInt8		0
uint16				system.UInt16		0
uint32	(uint)		system.UInt32		0
uint64				system.UInt64		0
int8				system.Int8			0
int16				system.Int16		0
int32	(int)		system.Int32		0
int64				system.Int64		0
float				system.Single		0.0
double				system.Double		0.0
bool				system.Boolean		false
char				system.Char			'\0'
string				system.String		""

========================================================
Custom Types
========================================================

data PointI
{
	x : int;
	y : int;
}
// default value : {x : default(int), y : default(int)}

data<T> Point
{
	x : T;
	y : T;
}

// {x : 10, y : 20} : Point<int>

data Derived : Base1, Base2
{
}

========================================================
Composite Types
========================================================

data<T, U> Pair
{
	first : T;
	second : U;
}

T..U				Pair<T, U>			default(T)..default(U)					// right associative
<T, U, V>			T..U..V..void		<default(T), default(U), default(V)
T?										null	// T can be all types except X? and object. All acceptable types T satisfies concept NotNull<T>
T[]					Array<T>
T[U]				Map<U, T>
func (T, U) : V		Delegate<<T, U>, V>

typeof(Expr)

========================================================
Interfaces
========================================================

interface<T> Enumerator
{
	prop Current : T {get;}
	func MoveNext() : bool;
}

interface<T> Enumerable
{
	func CreateEnumerator() : Enumerator<T>;
}

interface<T> EvaluatedEnumerable
{
	prop Length : int {get;}
	prop SliceEnumerable(start : int, length : int) : EvaluatedEnumerable<T>;
}

interface<T> Disposable
{
	func Dispose();
}

interface<T> Observer
{
	func OnNext(value : T);
	func OnError(error : Exception);
	func OnComplete();
}

interface<T> Observable
{
	func Subscribe(observer : Observer<T>) : Disposable
}

// default value for an interface does not exists
// except the concept DefaultValue is implemented

instance<T> DefaultValue<Enumerable<T>>
{
	func Default() = new Enumerable<T>
	{
		func CreateEnumerator() = new Enumerator<T>
		{
			prop Current : T { get { throw InvalidOperationException{}; } }
			func MoveNext() : bool = false;
		};
	};
}

interface<TArguments, TReturn> Delegate
	where Tuple<TArgs>
{
	func Invoke(arguments : TArguments) : TReturn;
}

x=>x+1
(x,y)=>x+y
func (x : int, y : int) : int = x + y
func (x : int, y : int) : int { return x + y; }

// equivalent to the lambda expression above
new Delegate<<int, int>, int>
{
	func Invoke(<x, y> : <int, int>) : int
	{
		return x + y;
	}
}

========================================================
Container Interfaces
========================================================

interface<TKey, TValue> ReadableMapping
{
	prop Keys : Enumerable<TKey>;
	prop Values : Enumerable<TValue>;
	prop operator[index : TKey] : TValue {get;}
	func ContainsKey(key : TKey) : bool;
	func TryGet(key : TKey) : TValue..bool;
}

interface<TKey, TValue> Mapping : ReadableMapping
{
	prop operator[index : TKey] : TValue {set;}
}

interface<T> ReadableArray : ReadableMapping<int, T>, EvaluatedEnumerable<T>
{
	func Slice(start : int, length : int) : ReadableArray<T>;
}

interface<T> Array : ReadableArray<T>, Mapping<int, T>
{
	func Slice(start : int, length : int) : Array<T>;
}

interface<T> Collection : Array<T>
{
	func Add(value : T) : int;
	func Remove(value : T) : bool;
	func RemoveAt(index : int) : T;
	func Contains(value : T) : bool;
	func IndexOf(value : T) : int;
}

interface<T> List : Collection<T>
{
	func Insert(index : int, value : T);
}

interface<TKey, TValue> Map : Mapping<TKey, TValue>, Enumerable<TKey..TValue>
{
	func Add(key : TKey, value : Value);
	func Set(key : TKey, value : Value) : bool;
}

func<T>				ArrayOf(length : int) : Array<T>;
func<T>				ArrayOf(values : Enumerable<T>) : Array<T>;
func<T>				ListOf(values : Enumerable<T>) : Array<T>;
func<T>				SortedListOf(values : Enumerable<T>) : Array<T>;
func<T>				SortedSetOf(values : Enumerable<T>) : Array<T>;
func<T>				HashSetOf(values : Enumerable<T>) : Array<T>;
func<TKey, TValue>	SortedMapOf(values : Enumerable<TKey..TValue>) : Map<TKey, TValue>;
func<TKey, TValue>	HashMapOf(values : Enumerable<TKey..TValue>) : Map<TKey, TValue>;

ArrayOf(10) : int[]
ArrayOf({1, 2, 3, 4, 5})
HashMapOf({1..1, 2..4, 3..9, 4..16, 5..25})
// {1, 2, 3} creates an EvaluatedEnumerable<int>

========================================================
Concepts
========================================================

concept<T> Addable
{
	prop Zero : T {get;}
	func operator+ (x : T) : T;
	func operator- (x : T) : T;
	func operator+ (x : T, y : T) : T;
	func operator- (x : T, y : T) : T;
}

concept<T, TDiff> Differentiable
{
	prop Zero : TDiff {get;}
	func operator+ (x : T, y : TDiff) : T;
	func operator+ (x : TDiff, y : T) : T;
	func operator- (x : T, y : T) : TDiff;
}

========================================================
Predefined Concepts
========================================================

DefaultValue<T>
SizeOf<T>
Tuplize<T>
Hashable<T>

NotNull<T>
Interface<T>
Tuple<T>
InheritFrom<TDerived, TBase>

Convertable<TFrom, TTo>
ImplicitConvertable<TFrom, TTo>

concept Convertable<TFrom, TTo>
	where NotNull<TFrom>, NotNull<TTo>
{
	func TryConvert(value : TFrom) : TTo?;
	func Convert(value : TFrom) : TTo
	{
		if(result = TryConvert(value))
		{
			return result;
		}
		else
		{
			throw InvalidConvertionException{};
		}
	}
}

// all necessary or inherited constraints will be inferred and filled
// e.g. if T? exists in the declaration body, then NotNull<T>
// e.g. if Texpr as U exists then Convertable<T, U>
instance<TFrom, TTo> Convertable<TFrom? TTo>
	where Convertable<TFrom, TTo>
{
	func TryConvert(value : TFrom?) : TTo?
	{
		if(expr = value)
		{
			return TryConvert(expr);
		}
		else
		{
			return null;
		}
	}
}

========================================================
Patterns
========================================================

Constant
Identifier		// can only be part of other patterns
X : Type
X..Y
<X, Y, Z>
{X, Y, Z: W}
{x:X, y:Y}

========================================================
Expressions
========================================================

Operator:
	++ -- []
	+ - not
	* / %
	+ -
	shl shr
	== != < <= > >=
	and
	xor
	or

<constructors>
Expr : Type

default(T)					// DefaultValue<T>.Default()
Expr as Type (or Type?)		// Convertable<typeof(Expr), Type>.Convert()/TryConvert()

========================================================
Statements
========================================================

<Pattern> | <LeftValue> = Expr
return [Expr];
break;
continue;
throw [Expr];

if(Expr) statement [else statement]
if(value = Expr) statement [else statement] // typeof(Expr) = typeof(value)?
for(<Pattern> in Expr) statement
while(Expr) statement
try statement {catch (<pattern>) statement} [finally statement]
switch (Expr) { {case <pattern> : statement} [default : statement] }
using(<pattern> = Expr) statement
lock(Expr) statement

========================================================
Functions
========================================================

========================================================
Predefined Convertions
========================================================

========================================================
Continuations
========================================================