$$include:..\Common.fpm

$$define $ADD_PARAMETER($index) $$begin
					AddParameter(new ParameterInfoImpl(this, parameterNames[$index], GetTypeDescriptor<typename ParameterTypeInfo<$TYPE_ITEM($index)>::Type>(), ParameterTypeInfo<$TYPE_ITEM($index)>::Decorator, ParameterTypeInfo<$TYPE_ITEM($index)>::Output));
$( )
$$end

$$define $PREPARE_PARAMETER($index) $$begin
					typename ParameterTypeInfo<$TYPE_ITEM($index)>::TempValueType $ARGUMENT_ITEM($index) = UnboxValue<typename ParameterTypeInfo<$TYPE_ITEM($index)>::TempValueType>(arguments[$index], GetParameter($index)->GetValueTypeDescriptor(), L$(")$ARGUMENT_ITEM($index)$("));
$( )
$$end

$$define $CONSTRUCTOR_DECLARATION($count) $$begin
$(/)***********************************************************************
Constructor: $FUNCTION_TYPE($count,1)
***********************************************************************$(/)
			template<$TYPENAME_LIST($count,1)>
			class CustomConstructorInfoImpl<$FUNCTION_TYPE($count,1)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
$loop($count,0,$PREPARE_PARAMETER)
					R result = new typename ParameterTypeInfo<R>::Type($ARGUMENT_LIST($count));
					return BoxValue<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, GetTypeDescriptor<typename ParameterTypeInfo<R>::Type>(), ParameterTypeInfo<R>::Decorator, true)
				{
$loop($count,0,$ADD_PARAMETER)
				}
			};
$$end

$$define $EXTERNAL_TYPE_ITEM($index) $(,) $TYPE_ITEM($index)
$$define $EXTERNAL_ARGUMENT_ITEM($index) $(,) $ARGUMENT_ITEM($index)

$$define $MEMBER_METHOD_DECLARATION($count,$function) $$begin
$(/)***********************************************************************
Member Method: $FUNCTION_TYPE($count,$function)
***********************************************************************$(/)
			template<typename TClass$if($add($count,$function),$(,),$( ))$TYPENAME_LIST($count,$function)>
			struct CustomMethodInfoImplSelector<TClass, $FUNCTION_TYPE($count,$function)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				$FUNCTION_DECL($count,$function,__thiscall TClass::* method);
$( )
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
$loop($count,0,$PREPARE_PARAMETER)
					$if($function,R result = ,$( )) (object->*method)($ARGUMENT_LIST($count));
					return $if($function,BoxValue(result, GetReturn()->GetValueTypeDescriptor()),Value());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], $FUNCTION_DECL($count,$function,__thiscall TClass::* _method))
					:MethodInfoImpl(0, $if($function,GetTypeDescriptor<typename ParameterTypeInfo<R>::Type>(),0), $if($function,ParameterTypeInfo<R>::Decorator,IParameterInfo::Text), false)
					,method(_method)
				{
$loop($count,0,$ADD_PARAMETER)
				}
			};
$( )
			class ExternalMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				$if($function,R,void)(*method)(TClass*$loop($count,0,$EXTERNAL_TYPE_ITEM));
$( )
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
					TClass* object=UnboxValue<TClass*>(thisObject, GetOwnerTypeDescriptor(), L"thisObject");
$loop($count,0,$PREPARE_PARAMETER)
					$if($function,R result = ,$( )) method(object$loop($count,0,$EXTERNAL_ARGUMENT_ITEM));
					return $if($function,BoxValue(result, GetReturn()->GetValueTypeDescriptor()),Value());
				}
			public:
				ExternalMethodInfoImpl(const wchar_t* parameterNames[], $if($function,R,void)(*_method)(TClass*$loop($count,0,$EXTERNAL_TYPE_ITEM)))
					:MethodInfoImpl(0, $if($function,GetTypeDescriptor<typename ParameterTypeInfo<R>::Type>(),0), $if($function,ParameterTypeInfo<R>::Decorator,IParameterInfo::Text), false)
					,method(_method)
				{
$loop($count,0,$ADD_PARAMETER)
				}
			};
			};
$$end

$$define $STATIC_METHOD_DECLARATION($count,$function) $$begin
$(/)***********************************************************************
Static Method: $FUNCTION_TYPE($count,$function)
***********************************************************************$(/)
			template<$TYPENAME_LIST($count,$function)>
			struct CustomMethodInfoImplSelector<void, $FUNCTION_TYPE($count,$function)>
			{
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				$FUNCTION_DECL($count,$function,* method);
$( )
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
$loop($count,0,$PREPARE_PARAMETER)
					$if($function,R result = ,$( )) method($ARGUMENT_LIST($count));
					return $if($function,BoxValue(result, GetReturn()->GetValueTypeDescriptor()),Value());
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[], $FUNCTION_DECL($count,$function,* _method))
					:MethodInfoImpl(0, $if($function,GetTypeDescriptor<typename ParameterTypeInfo<R>::Type>(),0), $if($function,ParameterTypeInfo<R>::Decorator,IParameterInfo::Text), true)
					,method(_method)
				{
$loop($count,0,$ADD_PARAMETER)
				}
			};
			};
$$end

/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection
	
本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/
$( )
#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER_GEN
#define VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER_GEN
$( )
#include "GuiTypeDescriptorBuilder.h"
$( )
namespace vl
{
	namespace reflection
	{
		namespace description
		{
			template<typename T>
			class CustomConstructorInfoImpl{};
			template<typename TClass, typename T>
			struct CustomMethodInfoImplSelector{};
$$define $CONSTRUCTOR_APPLY($count) $$begin
$( )
$CONSTRUCTOR_DECLARATION($count)
$( )
$$end
$loop($MAX_FUNCTION_NUMBER(),0,$CONSTRUCTOR_APPLY)

$$define $MEMBER_METHOD_APPLY($count) $$begin
$( )
$MEMBER_METHOD_DECLARATION($count,0)
$MEMBER_METHOD_DECLARATION($count,1)
$( )
$$end
$loop($MAX_FUNCTION_NUMBER(),0,$MEMBER_METHOD_APPLY)

$$define $STATIC_METHOD_APPLY($count) $$begin
$( )
$STATIC_METHOD_DECLARATION($count,0)
$STATIC_METHOD_DECLARATION($count,1)
$( )
$$end
$loop($MAX_FUNCTION_NUMBER(),0,$STATIC_METHOD_APPLY)
		}
	}
}
$( )
#endif