$$include:..\Common.fpm

$$define $ADD_PARAMETER($index) $$begin
					AddParameter(new ParameterInfoImpl(this, parameterNames[$index], GetTypeDescriptor<typename ParameterTypeInfo<$TYPE_ITEM($index)>::Type>(), ParameterTypeInfo<$TYPE_ITEM($index)>::Decorator, ParameterTypeInfo<$TYPE_ITEM($index)>::Output));
$( )
$$end

$$define $PREPARE_PARAMETER($index) $$begin
					$PARAMETER_ITEM($index) = UnboxValue<$TYPE_ITEM($index)>(arguments[$index], GetParameter($index)->GetValueTypeDescriptor(), L$(")$ARGUMENT_ITEM($index)$("));
$( )
$$end

$$define $CONSTRUCTOR_DECLARATION($count) $$begin
$(/)***********************************************************************
Constructor: $FUNCTION_TYPE($count,1)
***********************************************************************$(/)
			template<$TYPENAME_LIST($count,1)>
			class CustomConstructorInfoImpl<$FUNCTION_TYPE($count,1)> : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
$loop($count,0,$PREPARE_PARAMETER)
					R result = new typename ParameterTypeInfo<R>::Type($ARGUMENT_LIST($count));
					return BoxValue<R>(result, GetOwnerTypeDescriptor());
				}
			public:
				CustomConstructorInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, GetTypeDescriptor<typename ParameterTypeInfo<R>::Type>(), ParameterTypeInfo<R>::Decorator, true)
				{
$loop($count,0,$ADD_PARAMETER)
				}
			};
$$end

$$define $METHOD_DECLARATION($count,$function) $$begin
$(/)***********************************************************************
Method: $FUNCTION_TYPE($count,$function)
***********************************************************************$(/)
			template<typename TClass$if($add($count,$function),$(,),$( ))$TYPENAME_LIST($count,$function)>
			struct CustomMethodInfoImplSelector<TClass, $FUNCTION_TYPE($count,$function)>
			{
			template<$FUNCTION_DECL($count,$function,__thiscall TClass::* Method)>
			class CustomMethodInfoImpl : public MethodInfoImpl
			{
			protected:
				Value InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override
				{
$loop($count,0,$PREPARE_PARAMETER)
					return Value();
				}
			public:
				CustomMethodInfoImpl(const wchar_t* parameterNames[])
					:MethodInfoImpl(0, $if($function,GetTypeDescriptor<typename ParameterTypeInfo<R>::Type>(),0), $if($function,ParameterTypeInfo<R>::Decorator,IParameterInfo::Text), false)
				{
$loop($count,0,$ADD_PARAMETER)
				}
			};
			};
$$end

/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection
	
本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/
$( )
#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER_GEN
#define VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER_GEN
$( )
#include "GuiTypeDescriptorBuilder.h"
$( )
namespace vl
{
	namespace reflection
	{
		namespace description
		{
			template<typename T>
			class CustomConstructorInfoImpl{};
			template<typename TClass, typename T>
			struct CustomMethodInfoImplSelector{};
$$define $CONSTRUCTOR_APPLY($count) $$begin
$( )
$CONSTRUCTOR_DECLARATION($count)
$( )
$$end
$loop($MAX_FUNCTION_NUMBER(),0,$CONSTRUCTOR_APPLY)
$$define $METHOD_APPLY($count) $$begin
$( )
$METHOD_DECLARATION($count,0)
$METHOD_DECLARATION($count,1)
$( )
$$end
$loop($MAX_FUNCTION_NUMBER(),0,$METHOD_APPLY)
		}
	}
}
$( )
#endif