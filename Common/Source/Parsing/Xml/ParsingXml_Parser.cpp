#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"class Node"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Text : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CData : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeCData);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Attribute : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n" L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Comment : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeComment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Element : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Instruction : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Document : Node"
L"\r\n" L"{"
L"\r\n" L"\tNode[] prologs;"
L"\r\n" L"\tElement rootElement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token EQUAL = \"/=\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n" L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n" L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n" L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n" L"rule CData XCData = CDATA:content as CData;"
L"\r\n" L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n" L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n" L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n" L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n" L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4940; // 18057 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 844;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x9F\x71\x02\x80\x01\x7F\x05\x06\x83\x20\x0F\x30\x00\x36\x86\x00\x72\x00\x05\x82\x87\x02\x82\x2A\x00\x61\x00\x07\x30\x06\x25\x8C\x00\x6D\x00\x25\x27\x84\x8F\x81\x84\x81\x0B\x8D\x8F\x8D\x82\x8D\x92\x8A\x81\x41\x00\x34\x32\x9D\x8F\x8D\x91\x91\x04\x86\x88\x8A\x80\x8B\x95\x89\x89\x06\x88\x06\x91\x93\x9B\x9A\x2B\x8F\x0F\xF5\x22\x84\x9A\x9F\x90\x01\x94\x0E\x90\xAD\x86\x8F\x90\x00\x8C\x8D\x1C\x9E\x9A\x97\x9C\xA3\x82\xA6\xA8\x3E\xD3\x95\x97\x8F\x89\xAE\x9B\xA5\x39\xDE\xBC\x8A\x92\xA8\xA2\x80\xA1\x02\xC2\x10\x8A\xAE\x30\x00\x33\x8F\x12\xF9\x1D\xA6\x9B\xB1\xA8\x96\xB7\x00\x70\x80\x12\xBD\x84\xBA\xBA\xBC\x00\x7A\xA9\xBC\xB8\x95\x9D\xB7\x92\x82\x84\xC0\x06\xC7\xBA\x8D\xBD\xBD\x3B\x8D\xEC\xBF\xB0\xCE\x82\xC8\xCA\x88\x8A\xE5\x99\xCF\xA6\xC4\xCF\xA0\x9E\xF3\x80\x15\xB5\xCF\x9E\xD1\xA6\x7D\xE1\x80\xD1\xCA\xD4\xD5\xD0\xCC\x0C\x7D\xB5\xB3\x93\x90\x3C\x9A\xB0\x6D\x86\xB8\xDA\xD4\x9D\xDF\xDE\xD3\x3F\xC2\xCB\xC4\xD0\xE7\xD3\xB0\xCD\x20\xD1\xE3\x9B\xD1\xC6\x81\x05\xA1\x34\xB3\x92\x89\x30\x02\x33\xC9\xE2\x07\xFF\x62\xFF\xA0\x04\x23\x8F\x99\x1A\xE2\xE2\xF5\xA0\xA9\x90\xAE\xEA\xEA\xFF\x42\xC6\xFD\x83\x33\xEF\xF7\x34\xF1\xD5\xA5\x21\xAB\x90\xFD\x99\xF1\x4B\x06\x41\x12\xAB\x40\x03\x1C\x4D\x12\x4A\x56\x7F\x4C\xDC\x4D\x45\x5D\x7C\x04\x06\x4E\x45\x43\x77\x78\x4A\x79\x84\x02\x58\x46\x70\x80\xEA\x4D\x06\x74\x76\x45\x7F\x4C\x76\x77\x4A\x7C\x60\x00\x86\x05\x9B\x5B\x51\x49\xD7\x70\x49\x76\x88\xDD\x5F\x76\x8A\x53\x76\x08\x5F\x77\x48\x02\x06\x44\x7A\x79\x1A\x68\x70\x01\x55\xF6\x4E\x80\x78\x7C\xEA\x6C\x70\x46\x7B\x4B\x54\x70\x90\x44\xD4\x53\x79\x7E\x7A\xF3\x50\x46\x7E\x52\xFF\x7F\x86\x40\x1C\x3F\x5B\x6B\x46\x81\xE1\x62\x71\x95\x7D\xF7\x49\x94\x4E\x80\x02\x52\x4D\x41\x43\x33\x7C\x7F\x42\x7F\x62\x9C\x8B\x7A\x41\x6A\x8B\x55\x96\x02\x06\x7D\x88\x80\x00\x23\xB2\x8B\x53\x81\xFA\x70\x9D\x7E\x74\x05\xB3\x44\x98\x00\xF6\x7E\x47\x80\x77\x75\x66\x5A\x8B\x48\x28\xBB\x7F\x9D\x95\x28\xB5\x5B\xA0\x00\x03\x14\x5E\x9F\x9A\x80\x94\x72\x63\x81\x4A\x5E\x73\x87\x61\x23\x7C\x9A\x7B\xA0\x04\xB5\x57\x82\x76\xDF\x4B\x88\x9C\x93\x00\x34\x92\x42\x9D\xA8\xB9\x95\x8B\x9E\x5D\xBF\x34\xA9\x81\xA7\xBF\x4A\x80\x4D\x0D\x85\x81\xA7\x59\x23\x42\x78\x8A\x86\x00\x3E\x63\x4F\x92\x42\xA6\x84\x92\x78\x10\x06\x41\x0E\x41\xCD\x82\x72\xB5\xAD\xF1\x53\xB3\x41\x7C\xEA\x56\xB4\xB5\xB6\xD6\x98\xBA\x79\xB4\x00\x04\x8E\x47\x14\x56\x40\x02\x14\x00\x55\x25\x68\x44\x81\x4F\x35\x4F\x14\x00\xED\x90\x10\x00\x7F\x1E\x68\x8F\x08\x00\x3C\x00\x07\xBF\x0F\xD2\x8E\x51\x07\x80\x35\x64\xB8\x47\xB9\xE9\x8B\x4B\xB8\xBC\xEE\xA5\x6C\x10\xC2\xE4\xBC\x76\xBC\x00\xFC\xB7\xBE\x0C\x60\x06\x06\x44\x04\x4F\xED\x8D\x10\x02\xBC\x0B\xFC\x78\x14\x00\xEF\xBC\x7D\xC4\x00\x1A\xF4\xB5\xBB\xBB\xF1\xB3\xB5\x4F\xC3\xF9\xB7\xB7\xBD\x8E\xCF\x40\x07\xC6\x40\xE4\xA2\xB0\x03\x11\x00\x23\xC1\xC9\xCE\x2A\xE5\xC5\x4C\x46\xEF\x8B\x4B\xC1\xBB\x0D\xE7\x86\x42\xCB\xFA\x80\x03\xC5\xA5\x6F\x46\x49\x6E\x40\x22\xFD\xCA\xCA\x47\x40\xC8\xC2\xBE\xC9\x30\xC9\xD9\xBC\x8A\x2D\x80\x0E\x84\xD4\x3C\xFC\x7E\xCC\xD5\x20\xCA\xCC\xC2\xCA\x59\xD2\xC0\x02\x53\xAE\xAB\xDE\x9D\x14\xE8\x80\x01\x4F\xC2\x69\xC0\x0D\x0C\x00\x15\xD7\xB2\x78\x8A\x1E\x71\x4E\xCF\xBF\x02\x5B\x1F\x45\x0B\x00\x3A\x12\xDC\x00\x84\xDA\x10\x00\x0C\x88\xC0\x09\x0C\x00\x3A\x00\x0E\x09\xD9\xF7\x84\xED\x14\x00\x2B\x16\x92\x43\xA0\x82\x71\x48\x44\x46\x47\x73\xD1\xDC\x7F\x13\x06\x42\x08\x00\x82\xDE\x18\xBE\xD2\x00\x27\xE7\xE6\x0A\xAD\xC0\x0C\x1C\x00\x27\x28\xE0\x02\xEA\xF9\x93\xC5\xEF\xEB\xB4\xD5\x72\x43\xD3\x9A\xE5\x69\xC4\xC9\x53\xE5\xB7\xEA\x40\xF7\xAD\xC0\x01\x08\x8D\xC4\xE8\x0A\xED\xAA\xD5\xEC\xEB\xE5\xB3\xC4\xE9\xE9\xD2\x84\xD3\xC4\xF5\xF3\xD0\xD3\xF0\x01\x0A\x00\x30\xE4\xE0\xE1\x6A\xDD\xDF\xD6\xDB\x8D\x66\x7E\xE7\xE1\x2C\x07\xDB\xEB\xBD\xCC\xF7\xB2\xE3\x42\xEA\xE5\xB1\x4E\xFC\x00\x0F\xF7\xF7\xBD\x97\xDB\xFC\xFD\xF7\xFF\x7E\x7C\x00\x17\x7F\x7F\xEB\x5A\x7F\x7B\xE1\x69\x68\x01\x83\x89\x69\x89\x6D\x68\x42\x64\x3E\x61\xB9\x24\x06\x20\xFD\x77\x73\x75\x13\x77\x6F\xE9\x35\x70\x05\xA4\x52\x27\x5E\x75\x37\x5E\x8F\x04\x76\x71\x98\x09\x73\x71\x8D\x6F\x71\xE4\x13\x7F\x5C\xE9\x57\x70\x7C\x99\x73\x77\xE9\x33\x75\x77\x41\x71\x3D\x24\x4E\x24\x5E\xBC\x31\x2B\x20\xFE\x0C\x69\x69\x07\x59\x70\xF0\x71\x3F\x59",
"\xA6\x42\x27\x63\xE4\x5D\x51\x4D\x14\x4B\x28\x09\x06\x20\x89\xDF\x3E\x50\x44\x15\x42\x72\x73\x50\x20\x4D\x00\x04\x5E\x8F\x12\x23\x27\xF3\x4F\x1D\x04\x1D\x94\x81\xBE\x50\x8A\x89\x4F\x54\x8B\x62\x82\x24\x8D\x8C\x66\x8B\x29\x80\x07\x89\x8B\x51\x8B\x88\xA8\x55\x8A\x8A\xC4\x33\x20\x78\xB7\x00\x01\x07\xE3\x80\x8F\x32\x93\x8B\x29\x13\x6E\x2B\xC7\x44\x56\x59\xE0\x43\x93\x29\x85\x93\x73\xB3\x1F\x62\x20\x3E\x84\x94\x26\x13\x71\x71\x07\xFD\x64\x78\xFE\x1D\x82\x92\x84\x4C\x56\xB2\x34\x2D\x83\xD9\x5D\x84\x3F\x70\x69\x5E\xE8\x17\x9A\x8F\x4C\x89\x5D\x4D\xA5\x9E\x93\xE1\x1F\x70\x01\xD0\x7C\x61\x5D\x96\x90\x71\x29\xC1\x41\x50\x54\x9D\x95\x94\x18\x32\x80\x46\x24\x9D\x82\x5A\x8D\x4D\x96\x1D\x9A\x23\x81\x1D\x8F\x91\x99\x1F\x89\x6F\x00\x1F\x60\xFD\x67\x3F\x23\x34\xA5\x34\x47\x34\x3A\x22\x22\x80\x03\x04\x83\x3C\x8B\x99\x76\x5A\x21\x24\xA5\x9B\x99\xF5\x71\x24\x97\xA6\x95\x96\x93\x33\x21\x98\x2E\x5D\x80\x9B\xD1\x80\x03\x17\xCE\x9D\x3D\x4C\x74\x25\x6D\xCA\x87\x4A\x3B\xB3\x23\x9A\xF0\x4D\x91\x99\xA5\x2D\x20\x92\x63\x9C\x74\x4C\x8B\x23\x78\x63\x65\x5C\x38\xBE\x93\x48\x4E\x9F\x23\x98\xF9\x91\x39\x95\x6B\x9F\x88\x95\x58\x53\x4E\x0D\xB1\x4C\x9B\x7C\x93\x9A\x43\x16\x98\x9F\x12\xB3\x9D\x3F\xA5\x97\x75\x7C\x67\x77\x8B\x93\x87\x72\xCF\x60\x92\x52\x40\x5D\x83\x0F\xA5\x9F\x60\x51\x77\x42\x56\xF0\x20\x98\x56\x30\x44\x44\x78\x08\xAD\x0F\x52\x8F\x7D\x83\xA7\x6A\x6F\xE9\x37\x98\xA6\xD6\x7B\xA0\x00\x28\xBD\x82\x1A\xD2\x8C\x89\x91\x20\x9C\x53\x6B\x9F\x8D\xA8\x25\x95\xA7\x9E\x8A\x7F\xA7\x94\x83\xA6\x2C\xBD\x9E\x2E\x2E\x48\x53\x4B\x5A\x26\xA5\xEC\x13\x6F\xA6\xF0\x65\x98\xA1\x19\xB5\x4A\x33\xC9\x89\xA9\xA2\xAD\x55\xA1\x64\xA4\xAB\x1C\xD3\x95\x07\x8B\x83\xAA\x8E\x67\x93\xAB\xF2\x78\x95\x99\x54\xA5\x94\x79\xF1\x90\x9A\x8F\x3C\xA3\xAF\x78\xBA\x9A\xA3\x7C\xB8\xAE\x43\xF2\x48\x95\x2F\x82\x95\x5C\x1B\x5E\x69\x43\xF5\xA3\x73\x73\x67\x4C\x26\xFC\x36\x35\xDB\x62\x84\xAE\x44\x90\x95\x94\xC7\x8D\xA0\x3A\xBE\x4E\x8C\x7C\x9B\xB7\x23\x8D\xB7\x88\x64\x85\x47\x2F\x41\x54\xB1\xAF\xCC\x9A\x98\x66\xA5\x0C\x9C\x79\x95\x48\x5C\x7E\xAA\xA0\x2A\xA1\xBF\xB1\x34\x64\xB2\xB1\x02\x27\xB5\x42\xFB\x95\x97\x89\x5D\x87\x8B\x5D\x7F\x60\x7D\x19\x94\x4A\x54\x83\x52\xB8\x52\x41\x4C\x45\x80\x02\x06\x00\x20\x0E\xAD\xE5\x29\xB9\x71\xFC\x9B\x9B\xDF\xA5\x01\xA8\xF8\x85\x54\x97\x28\x5B\x56\x06\x6C\x50\x9C\x58\x46\x4D\x55\x9C\x28\xA0\x55\xB1\xB4\xB7\xD4\x20\xBD\x96\x63\xB6\x9C\x00\x0D\xA8\xA3\x8F\x56\x96\x5C\xE2\xB8\x8B\xB0\xB2\xBA\x98\xA5\x83\xBB\x94\x1A\xAE\x98\xFB\xBC\x98\x9E\x83\xB3\xA1\x2D\x93\x73\x06\x80\x14\x24\x8F\xFE\xBD\xB6\x5C\x9D\xA1\x77\x90\xBE\x6A\x65\x24\xA0\x5B\x6A\xD8\xBA\xA5\x17\x5B\x39\x46\xB3\x46\xAA\x5C\xB0\xA7\xC2\x99\xA6\x44\xA6\x36\xBC\xA1\x03\x8D\xC2\x76\x11\xDC\xAD\x94\x14\xDD\x8D\x59\xF3\x87\xA9\x38\xAC\x8B\xA9\x1D\x8F\xBC\x83\xF7\x50\xAA\x91\x90\xC2\xAE\x85\x50\x23\xA1\x05\x4A\x50\xAD\xA7\x77\xC4\x1D\x9E\xAB\x41\xA5\x99\xC0\xEA\x1E\x44\x4E\x08\xD1\xBC\x75\x8B\xCB\x75\x1A\xCF\xC1\x96\x98\x85\xA4\x57\x20\xA0\xA9\x94\x87\x71\x44\x1D\xDA\x4E\x86\x98\x9C\xC3\x55\x5E\xC4\x56\x31\xC1\xC5\x4F\xBA\xA6\xAF\x9E\x80\xCD\xCA\x42\xAA\xC6\x5A\xD4\x8D\xC4\x3F\xA6\xA8\xC4\x4E\xA9\x6A\x93\x95\x95\x94\x4C\xB9\xC5\x21\x3B\xC9\x51\x4D\x13\x56\xCC\x12\xC2\xC8\xBF\x9F\x8A\xC9\x2D\xE3\xAE\xC4\xA5\x80\x00\xB6\x6A\xD0\xAF\x52\x34\xB0\x22\xDB\xB6\x37\x7C\xBA\xA9\xAE\xA2\xA3\x2E\xB6\x75\xAC\xB1\xA2\x82\xD4\x38\x80\xC5\xC4\x27\xC9\x76\x06\xC0\xF7\x9F\x60\xA7\xB3\x25\xBB\xD8\x5E\xA5\x94\x51\xB7\xC5\x94\x92\xC7\xA4\x2B\xEB\xA1\x56\x18\xCE\xA7\x86\x96\xCE\xCA\x2D\xED\xBF\xBD\x37\xB1\x74\x99\xFC\xAF\xC6\x12\xDF\x89\xC5\x92\xCF\xC5\x9D\xA5\x98\xA9\x35\xE0\xCE\xBD\x22\xCF\xA8\xAA\xB6\xC0\xCB\x59\x95\xA9\xCF\x58\xAC\xD7\x56\xFE\xC5\x94\x40\xC1\xC2\xA3\x47\xCB\x76\xA8\x99\xD7\xB2\x4C\x8C\xC3\xCE\x52\xAB\xD4\x9F\xE8\xC8\x9F\x57\xF1\xA6\xD6\x2F\xB4\xD5\x4B\x9F\xCC\xA8\x31\xFA\xD6\xA7\x65\xD3\xDB\x47\xE0\x84\xDD\xB7\x82\xDD\xCD\x2B\xD4\x88\x9C\xA6\xD2\xCF\x65\xCF\xCB\xD8\x54\xA6\x53\xAA\x7A\xC9\xAA\xAE\x3D\xCD\xAB\xD5\xCD\xBF\xA8\x80\x00\x79\x8F\x5A\xB9\x57\x09\x59\x92\x77\xC2\x4D\xB2\x87\xF8\x57\x4E\xDD\xAB\x56\x90\x53\x90\x6F\x50\xE1\x5F\xE2\xDC\xB2\xE2\xC6\x85\x45\xD4\x06\xFC\x5B\xDE\x0E\xD4\xCD\x84\xE3\xD9\xC4\x73",
"\xD9\xC9\xC3\x00\xEC\x98\xAC\xDF\xC0\xC6\x64\xFD\xA4\x5F\x67\xD6\xDB\xC3\x98\xE2\xE5\x5E\x75\x2D\xBF\xDC\xD3\x27\xA6\xC1\xE5\x8B\xE6\x96\xA6\xE3\x0B\xE5\xE5\x93\xFE\xDA\xE4\xB9\x92\xCB\x29\xAD\xC9\xCE\xCB\xB5\xD0\xE7\x74\xD8\xCC\xEA\x33\xAD\xDD\x07\xB9\xD9\xA6\x78\xFC\xD6\xEB\xF5\xC9\xD3\xBD\xF2\xA5\xD9\x49\xF7\xD1\xD9\xFD\xC9\xE5\xB8\xCE\xD2\xE1\xAB\xBD\xC6\xE0\xF2\xC5\x97\x9F\x8A\xE4\xE9\x2F\x80\xC3\xEA\xEB\xCB\x29\xC3\xD7\xCC\xA5\x58\xE6\x43\x9A\xF9\x5E\xE0\xDE\xFE\xE0\x90\xB9\xA9\xD5\xD9\x1D\x8F\xEB\x48\x54\xC7\x74\x0D\xA5\x93\x7D\xA0\x67\x73\xC2\x30\x91\xE7\x1A\x5A\x21\x29\x50\xE3\xC9\x07\x83\xF4\xE6\xDF\x70\xBF\xA1\xA8\x83\xE8\xE8\xCB\xBD\xAD\xA3\xDA\xDF\xDA\x55\x4A\xEB\xA9\xEA\xEA\xD5\x52\x8A\xF0\xC5\xAE\xCA\xDC\xE1\xDB\xC9\xE1\xAB\xF9\xED\xE6\xB8\xC2\xC7\xAE\xA5\xC7\xE0\xD8\xE9\xC9\xD8\x86\xD8\xDE\xB1\xB8\xF8\xEC\x1A\xD6\xD4\xF5\x88\xF9\x91\xDB\xBC\xCB\xCE\x1F\xE0\xEB\xEE\x60\xA4\xEB\xDE\xBB\xE1\xE4\x55\x7E\xE0\x20\x0D\xB4\xFA\xAE\x3D\xEC\x55\xC9\x4D\xBC\x14\xD0\xBA\xF9\xC4\xD6\xFC\x54\xD5\xD0\x64\xC4\x87\xF1\xE7\xEB\xD4\xCD\xE4\xD9\xDD\xF6\xEA\x7D\xFD\xF3\xBE\xA7\x78\xE6\x12\xFA\xE0\xE4\xDB\xE4\xFE\x90\x59\xDC\x8E\xF1\xE9\x54\x57\xE5\x7C\x64\xF9\x27\x72\x4C\x7B\x76\x89\x72\x6D\xBF\x61\x7B\xB6\x73\x7B\x31\x7D\x65\xB7\x77\x76\x37\x70\x76\xF7\x76\x2A\x3C\x7A\x7F\x05\x20\x74\xA3\x75\x4B\x88\x6B\x70\x8C\x65\x5F\xB7\x50\x69\xA7\x79\x74\xAB\x51\x5C\xD1\x50\x26\xD3\x55\x4B\xC7\x55\x82\xC4\x5A\x51\xD3\x4F\x5C\x1E\x7A\x5F\xCA\x5A\x60\x98\x49\x62\xFE\x79\x71\xD7\x7A\x5E\xE2\x5E\x13\xE4\x51\x6F\xE7\x50\x58\x72\x51\x5E\xC8\x1B\x83\x61\x69\x66\x0B\x70\x4E\xF4\x53\x5A\x19\x89\x5E\x9A\x7A\x82\xFB\x5B\x50\x25\x07\x77\xEE\x76\x6B\x7B\x7C\x79\xB6\x6E\x7D\xAB\x32\x78\x51\x80\x73\xA5\x69\x7E\x2B\x7E\x7C\x8E\x74\x65\x90\x7D\x4A\x92\x73\x3A\x95\x76\x23\x4A\x1A\x61\xD6\x64\x85\x30\x78\x81\x84\x5F\x5F\x98\x69\x84\x9D\x60\x00\x37\x00\x00\xA6\x79\x64\x70\x84\x6A\x02\x88\x7E\xCC\x6A\x7E\xD2\x6D\x7E\x0B\x8F\x7E\xB3\x6F\x87\xB6\x6B\x6F\x5C\x73\x62\x3F\x5A\x4A\xBD\x6F\x53\xC0\x65\x68\x66\x52\x7C\x66\x73\x7F\xEF\x3A\x87\xFF\x63\x50\xCF\x63\x70\xD1\x63\x29\x8C\x7F\x7C\x09\x71\x7D\x77\x8C\x70\xD9\x78\x7F\xE3\x70\x80\x14\x7F\x89\x14\x85\x7D\xA2\x85\x20\x04\x60\x00\x1D\x77\x7A\x35\x8C\x7D\x42\x26\x7E\x04\x88\x7C\x7C\x8C\x72\x0A\x81\x7F\xE8\x61\x88\xB6\x80\x73\x90\x85\x7F\x3F\x53\x81\xDB\x59\x7F\xA7\x85\x17\xC0\x5D\x50\x30\x87\x82\xD4\x10\x38\xF8\x45\x8C\x2C\x86\x45\xB5\x5A\x32\xB6\x1D\x59\xBA\x5A\x8C\xA9\x7B\x5A\x50\x82\x88\x30\x73\x85\x59\x80\x1E\xA9\x81\x78\xA7\x7A\x86\xE0\x1B\x85\x7B\x8D\x85\x70\x7D\x78\x24\x61\x86\xAE\x43\x79\xAD\x7D\x41\x96\x71\x15\x67\x8B\x89\x8F\x79\x8D\x26\x2F\x45\xD3\x70\x8A\xFF\x73\x71\x05\x23\x33\xD9\x54\x8F\x36\x8D\x7D\xCC\x8D\x68\xCE\x87\x18\xC8\x8A\x5B\xAD\x86\x81\x75\x15\x69\x76\x7D\x50\xDE\x86\x22\x4E\x4F\x46\x09\x9B\x68\xFD\x8E\x81\xB6\x1F\x00\x06\x1A\x5B\x0D\x94\x69\xD4\x88\x90\xF0\x8B\x14\xF8\x85\x61\xD6\x8A\x8D\x0F\x94\x13\x75\x46\x19\x34\x12\x91\x02\x14\x65\x14\x99\x91\x16\x95\x8D\xB9\x80\x1E\x88\x65\x91\x74\x49\x4E\x5C\x48\x7D\x02\x19\x47\x7B\x45\x6E\x28\x9C\x3A\xC8\x48\x5A\xD9\x47\x68\x9A\x51\x5D\x3B\x9D\x81\x20\x90\x93\x63\x26\x10\x26\x97\x7A\x9F\x5A\x5A\x39\x9F\x4C\xA9\x5E\x89\x6F\x47\x94\x2F\x9B\x45\xEF\x46\x10\x34\x96\x94\x3E\x99\x4E\x68\x4D\x93\x7F\x55\x25\x0B\x9E\x59\xAE\x53\x5B\x1F\x93\x13\x21\x9F\x13\x5D\x44\x94\xF4\x6A\x5B\xED\x43\x8D\xAD\x59\x95\xA8\x45\x71\xBB\x5B\x8C\x61\x91\x93\x78\x45\x4A\xD7\x4D\x95\x4B\x6C\x86\x02\x64\x1D\x5B\x9B\x6D\x9D\x80\x94\x60\x92\x94\x63\x95\x92\x65\x91\x82\x44\x77\x95\x6F\x4B\x70\x6C\x9C\x81\x70\x40\x95\x77\x42\x95\x72\x9F\x79\x6D\x8A\x60\xF3\x85\x8A\xC0\x86\x8F\x75\x16\x01\xA4\x8F\x8B\xA1\x84\x99\x55\x4E\x58\xFE\x8F\x96\x34\x18\x8C\x45\x9D\x7F\xFA\x8E\x8A\x24\x7C\x94\xF9\x82\x99\x99\x93\x72\x75\x19\x97\x1F\x78\x9A\xF5\x8A\x9A\x4F\x96\x47\x3C\x93\x93\x8D\x96\x71\xAE\x9B\x8F\xAF\x88\x3E\x95\x59\x58\x24\x9B\x9B\xC5\x21\x87\x9C\x98\x45\x9E\x92\x74\x64\x91\x46\xA7\x75\x57\x81\x4B\x58\x96\x52\x28\xCA\x99\x58\x93\x33\x9C\x00\x0D\x35\x53\x9E\x48\xCB\x9C\x3A\x24\x82\x8D\xA8\x45\x3A\x6F\x48\x9D\xCB\x51\x9C\x41\x9A\x98\x32\x97\x7C\x00\x01\x8D\xD2\x5A\x51\x13\x37\x9D\xE5\x95\x25",
"\xBD\x98\x5C\x26\x8E\x96\x7E\x98\x5B\x00\x03\x9D\xC9\x89\x9E\xA8\x4E\x40\x18\x9D\x91\x26\x28\x8D\xF8\x9E\x90\x34\x07\x85\xDD\x87\x93\xE0\x83\x89\x4E\x72\x6D\xE4\x8F\x53\xE6\x83\x86\x94\x70\x4E\xEB\x88\x79\x68\x8D\x5E\x2E\x99\x59\x4D\x95\x95\x3E\x2D\x5A\x7A\x50\x5A\xCC\x54\x4D\xD0\x5E\x94\xA5\x6D\x4D\xF6\x31\x73\x04\x5B\x49\xE4\x4B\x84\x4E\x9C\x50\x11\xAA\x96\x6E\x85\xA2\xB2\x5B\x5C\xCD\x56\x4F\x54\x96\xA2\x32\x8C\x4D\x08\x3A\x31\x01\x5B\x4B\x38\x6A\x49\xF7\x5D\x5E\x67\x95\x58\x97\x65\x98\x44\x72\x7A\x8F\x94\x1D\x93\x3D\x9F\x75\x8E\x98\x77\x9D\x6D\x68\x70\x6E\xE9\x89\x22\x5A\x5E\x87\x2B\x96\x22\xF0\x73\x73\x83\x8A\x75\xF9\x3A\x7B\x60\x78\x88\x60\x7B\x88\x6E\x6C\x62\x64\x7C\x88\x73\x40\x89\xCA\x62\x8B\x94\x8B\x7C\x04\x74\xA0\x9A\x8F\x55\x44\x65\x77\x25\x01\x99\x98\x9F\x9A\xD7\x7C\x96\x03\x91\x8C\x55\x4D\x9F\xAB\x82\x9A\xB7\x94\x9A\x05\x99\x87\xB1\x85\x13\x02\xA2\x6E\x4B\xA5\x8B\x50\xA5\x75\xB8\x8F\xA7\x59\x73\x84\xB1\x3C\x8B\xEE\x8D\x41\x6F\xAA\x99\x86\x5D\x9C\xBF\x97\x2C\x8C\xA9\x48\x17\xAC\x48\xC7\x95\x9D\x01\xAD\x74\x76\x66\xA3\xFC\x4C\x57\xA0\x41\x37\xA3\x45\xA3\xA7\x49\xA9\xBC\x7B\x4A\xE5\x27\x8E\x64\x84\x89\x9F\xA0\x4C\xA1\xA9\x4B\x95\x56\xAA\xE2\x48\xAA\xD6\x65\x57\xC3\x8B\x9D\xF4\x9C\x4F\x29\x8C\x9D\x03\x60\x00\x05\x6E\x82\xA7\x76\xAB\xD4\x15\x6A\x34\x83\x9A\x04\x91\x73\x40\x8A\x25\x42\x81\xAA\x3D\x85\x25\x38\x81\x84\x10\x84\xA4\x3E\x88\x49\x47\x86\x5B\x9D\x86\xA6\x1D\x4C\xAB\x34\x14\xA2\x9E\x76\x6F\x86\x6C\x37\x86\x6A\x2D\xF1\x1A\x92\x82\xA6\x22\x5D\x3E\x92\xC2\x1C\x01\x3A\x1A\x1E\x49\x9E\x94\x3B\x2B\x94\xC2\x1E\x01\xE5\xAE\x25\x58\x99\xA2\xB5\x46\x24\x2E\xA4\x1D\xC2\x1D\x41\x7A\x32\x1F\x6F\x8F\xA3\x34\x1E\x28\x9D\x82\x1C\xC7\x35\x2B\x6A\xA0\x71\x6C\xAC\x2A\xB7\x25\xA7\xC1\xA2\x1C\x14\x47\xAF\x87\x55\x57\xC3\x25\x9D\xC2\x16\x02\xED\xAF\x0F\xE8\x9D\x9E\x62\x56\x10\xD4\xA3\x13\xC2\x1F\x3C\xF7\xA0\x01\x4C\x3B\x1C\xC2\x15\x12\xDA\x21\xB2\x22\xBC\xAD\xA3\x12\x18\x4E\x1A\x2D\x38\x46\x10\x20\xB6\x2D\x84\x69\xA5\x54\x48\x19\x6D\x39\x35\xDA\x29\x35\x4E\x1B\xB2\xD3\x2D\xB2\xF9\x6B\x22\xD6\x28\x2C\xAD\xA4\xAF\x3A\x2F\xA8\xF9\x13\x1A\x83\x22\xB3\xD6\x24\xB3\x2A\xB3\xB2\x38\xB3\x7C\x80\x12\x1C\x3C\xBF\x4B\x3E\xB2\x10\x0B\xB5\x9D\xCB\x10\x3C\x44\xB3\x2D\x46\xB2\x10\x36\xB2\x2D\x49\xB6\x76\x59\xBD\xB4\x05\x58\xB1\x3F\xBF\x46\x75\x5B\x1C\xE7\x38\x22\x33\xB1\xB6\x4B\xBC\xB2\x68\x5C\xA5\x54\x4D\xB5\x06\x1F\xA1\xA8\x42\x1C\x69\x90\xAF\xF0\x13\x1A\x9D\x5F\x43\x67\xB0\xB5\x47\xB2\xB2\x5B\xB2\x6C\x6E\xB2\x10\x70\xBC\x4F\xC2\x17\xAE\x12\xAF\x11\xCB\x1D\x9B\x55\xB2\x2D\x57\xB9\xB6\x37\xBB\xB6\x2E\xBA\xB3\xD3\x2E\xB5\x20\xAD\x2F\x40\xB8\xB1\xCB\x1E\x12\x23\xB9\xB5\xC2\x24\x16\x89\x52\x1C\x51\xB9\x58\xCB\x19\x35\xC8\x4F\xB1\x7B\xB4\x29\x23\xBD\xB0\x9D\xB8\xB6\x87\x49\x58\xC8\x4A\xB9\xAA\xB8\x58\x8D\xA6\xBA\x23\xB8\x1A\x6F\x40\x7C\x66\x53\xBB\x03\x13\x1A\x9D\x12\xB2\xAE\xBA\xB7\xE9\x3A\xAE\x06\x14\xB8\x15\xA9\x1E\xA3\x12\xBA\xD6\x25\x12\x25\x18\xB7\xD6\x29\xAE\x3B\x93\xB8\x3D\x93\xBC\x78\x35\xBA\xDA\x22\xBC\x4B\x9A\xBC\x7C\xBE\xB8\x39\xB1\x2C\xB8\xB7\xB9\x1F\x2C\xBB\x23\xB2\xAF\x74\xB4\x13\x72\xBF\xAE\xE8\x59\x1F\x3F\x4F\x0F\x59\x3D\x36\xA4\xB2\x10\x2C\xA6\xBD\xD2\x20\xBE\xE5\xB0\xB6\x46\x4C\x95\xF3\xA4\x13\xC8\x4C\xA2\xDA\x23\xB7\xF1\xB0\x00\x89\xB5\x15\xC3\xAC\x5E\x07\x22\x1C\x13\xBB\x82\x55\x28\xBE\x06\x1A\xBE\xA5\xBD\x36\xEE\xBC\xB4\x7D\x1B\xBF\xE3\xB8\xA2\xFB\xB8\x4C\x08\xCD\xB8\x10\xCA\x51\xFD\xB7\x25\xEB\x5A\x83\x5C\x22\xC0\xC4\x83\xAB\xB5\x46\xC0\x02\x13\xBA\xA5\xB9\xBC\xDF\xBD\xC0\x1A\x5F\xC0\xF4\xB1\xBE\x33\x1D\xBA\x48\xB4\xBE\x1A\x5B\xC0\x6A\xB5\xBB\x6C\xBB\x14\xB8\xB3\xB2\xCB\x13\x28\x83\x28\xB2\xD2\xB6\x10\xBF\x23\x29\x28\xCA\x97\xFA\xA2\xBF\xB9\xBA\x13\x25\x10\x3C\xB3\xB1\xBA\x06\x17\x3E\xEB\xB0\x9F\xC6\xB2\x10\x4A\xC1\xC3\xF8\x46\xBB\x73\x49\xB8\x9B\x23\xC3\x4B\x5F\xC3\xA8\x71\xB7\x35\xCB\xC5\x5C\xCD\xC5\x43\xC3\x10\x28\x2D\x59\x3A\xCE\xBB\x67\x52\xB2\x03\xCD\x84\x5A\xC8\x19\x26\xB9\xB9\x68\xB3\xC1\xD2\x27\xC6\x31\x8F\xB4\x98\x15\xB6\x23\xBB\xB8\x6E\xCC\xC1\xB2\xA4\xB1\xA8\x4F\xB7\xE1\x4E\xB4\xE2\xB4\xBB\x29\xCE\xC0\x24\xBA\x13\x55\x1D\x9B\xDB\xB3\x1A\xE6\x3C\xC5\x37\xC0\x2D\x75\xC8\xB6\x39\xC0\xC5\x40\xC5\xA4\x33\x19\xB5\x3D",
"\xC0\x28\xC2\x1E\xAD\xE7\x60\x73\x5E\xC3\xC8\x03\x18\x4C\xC8\x87\xC8\x3A\x1B\xC6\x22\xBB\xB8\x4F\xC4\xC1\xCC\xA5\x25\x35\xBD\xC2\x32\xCF\xB8\xC1\x2B\x1C\x31\xB3\xB2\x3F\x4E\x14\xA5\xCA\xB5\xF9\xA2\xC9\xBA\x9D\xBB\xD7\xA2\x76\x86\x6C\xC7\x81\xB5\x4B\x9E\xB5\xB9\x98\x13\xB4\xB0\xC8\xB6\xB3\xC8\xC5\x0B\x79\xCA\xD7\xBB\xCA\xD9\xBC\xB8\xC1\x3D\xCB\x72\xCF\xB9\xB1\xB3\xB5\x06\x19\xB8\xC2\x11\xCB\x49\xCA\xCA\xA7\xC8\x4A\xC8\xC1\xB2\x7D\xBB\xCB\x3B\xBF\xB6\x98\xAE\xCB\xAF\xB3\xB6\xA3\x14\xC7\x22\xB6\xCD\x4E\xC8\xCD\x91\xCA\x51\xDB\xC9\xBF\xD8\xBA\xB4\xBC\xC1\xCE\x72\xCA\xBF\x1A\x5B\x1C\x77\xB3\xCC\x64\xC5\xCC\x80\xCB\xCE\xA8\xCB\xC3\xA6\xC8\xAD\x66\x51\xCF\xA7\xA2\xC7\xD4\xBB\x93\x87\xB3\xCD\xF8\xCA\x9B\xFA\xC3\xBF\xFC\xCA\xCD\xFE\xC4\xCB\xCA\xC0\xCF\xDF\xC0\xB8\xF2\xCF\xC7\x64\xCB\xBA\xB1\xB6\xC3\x42\xB6\x10\x5B\x93\xC6\xCC\xC5\xC9\x5C\x12\x1C\x01\xB5\x81\x70\xA2\x2D\xDC\xB2\x10\xDA\x91\xB2\xB8\xCC\xAF\x41\xC0\xD1\xD9\xCC\x4F\xFF\x07\xBE\x59\x38\x8F\x4B\xCD\xBE\x25\xC0\x36\xFD\xAB\xCF\x59\xCC\x4F\xF7\xBA\xCE\x3B\xD5\x4B\x59\xB3\x28\xCF\xAF\xD3\x72\xC0\xC7\xC6\x89\x1F\x33\xD7\xBC\x07\xC6\x10\x30\xC1\x33\x0B\x76\xCC\x44\x72\xC1\x3E\xDB\x70\x41\xD6\x10\x43\xDF\xD4\xDD\xB3\x9F\x7A\xC0\xD3\x4D\xC2\x2D\xC8\xBC\xD4\x37\xD4\xD4\x16\xD9\xCB\x0B\x7C\xC2\xC9\xCF\xD2\xB5\x4D\xD4\x2E\xD0\xD0\x73\x4B\xC9\xCA\x13\x1A\x6D\x35\x01\x6E\xDA\xD1\x3A\x13\x28\x96\x9E\xBD\x58\xB6\x2D\x83\x27\x67\x56\x5C\x7C\x05\x74\xC3\x3A\xD8\xD5\xDD\x23\x1A\x4E\x17\x01\x6E\xDB\xC8\x02\x10\x2E\x79\xBA\x9B\x1D\xD6\x2D\x23\xD6\x8A\x9A\x94\xC9\x06\x1F\x7A\x97\xC7\x9F\x4D\xA0\xD8\x9B\xC7\xD2\x00\x08\x01\x6C\xC7\xD6\x17\xBF\xC6\x1D\xCB\xD5\xE2\xC3\xD7\x44\xCA\x13\xC0\x39\x01\x9D\xDC\xCC\x34\x26\x86\x98\xD5\xC6\x36\x9B\x9F\xDA\xB2\xB2\xCB\x1D\x35\x86\xCE\xC5\x9A\xDA\x01\xA9\xDA\x2D\x05\xBB\xA6\xB8\x95\x20\x22\xD7\x99\x02\xBD\xDB\x0F\x29\x35\x20\xCE\xDA\x35\xD0\xD6\x22\xBB\xDB\xC1\xD6\xA7\xD2\x2F\xD8\x93\x90\x9B\x3D\xD2\xB2\xCE\xD9\x9A\xD7\x77\xC1\x02\x1F\xBF\x1A\xC1\xC0\x59\xDC\x9E\x04\xC8\x4A\xC5\xDE\xC6\x25\x1A\xC0\x23\xBA\xDC\x24\xDA\x99\xBF\xDF\x46\x89\xA0\xDD\x4B\xD2\xDD\xC0\xD5\xDE\xB0\x96\xDD\x00\x08\xDD\x10\x1B\x83\x78\xCA\xD5\xDD\xD2\xB8\xA4\xD3\xD8\xA5\xD2\x10\x1B\x09\xDB\xD6\x21\xAE\x37\x95\xD9\x0C\x97\x93\xC5\xD5\xDC\x8D\xD9\xD7\x02\x1B\x95\x6A\xD0\xE0\xB0\xD2\x2D\x98\xCF\x72\xE0\x18\x4C\x07\xEE\xE0\x96\xDF\xAD\x4B\x19\xB8\x6D\x3E\x80\x0C\x8A\xDD\xBF\x3D\xDE\x90\xD0\x9B\xC5\xDF\xC8\x08\xE0\x00\x83\x2B\xE0\x20\x27\xD9\xB1\xDE\xDA\x1C\x98\xE2\xD1\xBB\x39\x23\xBF\xE0\x58\x76\x22\x18\xE5\x27\x37\x9C\xE1\x64\xD4\x74\xF9\xD4\xDA\x1E\xB6\x10\x1D\x09\xE3\x5D\xC8\xD8\xB3\x9A\xD2\x0F\xD0\xD2\xAD\xD0\xE3\x0F\x8F\xD6\x3A\x12\x1C\x1F\x0E\xE3\x99\xD6\xB7\xC8\xD2\xE4\x23\xEC\xC0\x14\xD3\xD0\x63\xD5\xD0\xE9\x48\x19\xC2\x1C\x3C\x4C\xEA\xC8\xE5\xCC\xC3\xA9\xD2\xD0\x3D\xB3\xD6\xF4\xC5\x25\x5F\xC7\x10\xC2\x15\x4D\x5B\xE2\xDB\x25\xB8\xB6\x4D\xE9\xE4\x06\x15\x02\x69\xE3\x2D\xCB\x11\xC6\x4C\xEB\xE3\x02\x15\x3B\x71\xEA\xE6\x3A\x1F\xCA\x78\xDC\xCC\x92\xB9\xC6\xBA\x98\xD1\x85\x40\xE4\xD4\xC3\xC2\x13\xDD\xC7\x5F\xB4\xB9\x62\xB2\xB5\xA3\x14\xB5\x5F\xE7\xE8\xCE\xC3\xD6\xD0\xC5\x48\x65\xEF\x0F\x88\xBF\xE8\x91\xB0\xCE\x54\xE2\xC4\x93\xE1\xB4\x6E\xEC\xBE\x79\xE8\xE4\x60\xC6\x10\x62\xCA\xD4\x64\xC8\xBF\xFF\xD1\xDA\xF7\xD3\xDA\xCB\x12\xCA\x50\xEA\x9B\xA8\xE3\x2D\x46\xD7\xC2\xFB\xD7\x10\xE6\xC1\xB2\x8B\xB1\xEB\xA0\xD9\xC7\xAB\xE4\x1D\x60\xEE\xC7\x42\xC3\xE6\x80\xE1\xEA\xC4\xE5\xEC\x35\xC0",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

			void XmlText::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlCData::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlAttribute::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlComment::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlElement::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlInstruction::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlDocument::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::parsing::xml;

			IMPL_TYPE_INFO_RENAME(XmlNode, system::XmlNode)
			IMPL_TYPE_INFO_RENAME(XmlText, system::XmlText)
			IMPL_TYPE_INFO_RENAME(XmlCData, system::XmlCData)
			IMPL_TYPE_INFO_RENAME(XmlAttribute, system::XmlAttribute)
			IMPL_TYPE_INFO_RENAME(XmlComment, system::XmlComment)
			IMPL_TYPE_INFO_RENAME(XmlElement, system::XmlElement)
			IMPL_TYPE_INFO_RENAME(XmlInstruction, system::XmlInstruction)
			IMPL_TYPE_INFO_RENAME(XmlDocument, system::XmlDocument)
			IMPL_TYPE_INFO_RENAME(XmlNode::IVisitor, system::XmlNode::IVisitor)

			BEGIN_CLASS_MEMBER(XmlNode)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(XmlNode)

			BEGIN_CLASS_MEMBER(XmlText)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlText>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlText::*)(), [](XmlText* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlText::*)(const vl::WString&), [](XmlText* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlText)

			BEGIN_CLASS_MEMBER(XmlCData)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlCData>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlCData::*)(), [](XmlCData* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlCData::*)(const vl::WString&), [](XmlCData* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlCData)

			BEGIN_CLASS_MEMBER(XmlAttribute)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlAttribute>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlAttribute::*)(), [](XmlAttribute* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlAttribute::*)(const vl::WString&), [](XmlAttribute* node, const vl::WString& value){ node->name.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(XmlAttribute::*)(), [](XmlAttribute* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(XmlAttribute::*)(const vl::WString&), [](XmlAttribute* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(XmlAttribute)

			BEGIN_CLASS_MEMBER(XmlComment)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlComment>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlComment::*)(), [](XmlComment* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlComment::*)(const vl::WString&), [](XmlComment* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlComment)

			BEGIN_CLASS_MEMBER(XmlElement)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlElement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlElement::*)(), [](XmlElement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlElement::*)(const vl::WString&), [](XmlElement* node, const vl::WString& value){ node->name.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_closingName, NO_PARAMETER, vl::WString(XmlElement::*)(), [](XmlElement* node){ return node->closingName.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_closingName, {L"value"}, void(XmlElement::*)(const vl::WString&), [](XmlElement* node, const vl::WString& value){ node->closingName.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_PROPERTY(closingName, get_closingName, set_closingName)
				CLASS_MEMBER_FIELD(attributes)
				CLASS_MEMBER_FIELD(subNodes)
			END_CLASS_MEMBER(XmlElement)

			BEGIN_CLASS_MEMBER(XmlInstruction)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlInstruction>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlInstruction::*)(), [](XmlInstruction* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlInstruction::*)(const vl::WString&), [](XmlInstruction* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(attributes)
			END_CLASS_MEMBER(XmlInstruction)

			BEGIN_CLASS_MEMBER(XmlDocument)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlDocument>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(prologs)
				CLASS_MEMBER_FIELD(rootElement)
			END_CLASS_MEMBER(XmlDocument)

			BEGIN_CLASS_MEMBER(XmlNode::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<XmlNode::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::XmlNode_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlText* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlCData* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlAttribute* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlComment* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlElement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlInstruction* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlDocument* node))
			END_CLASS_MEMBER(XmlNode)

			class XmlTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode)
					ADD_TYPE_INFO(vl::parsing::xml::XmlText)
					ADD_TYPE_INFO(vl::parsing::xml::XmlCData)
					ADD_TYPE_INFO(vl::parsing::xml::XmlAttribute)
					ADD_TYPE_INFO(vl::parsing::xml::XmlComment)
					ADD_TYPE_INFO(vl::parsing::xml::XmlElement)
					ADD_TYPE_INFO(vl::parsing::xml::XmlInstruction)
					ADD_TYPE_INFO(vl::parsing::xml::XmlDocument)
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool XmlLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new XmlTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}
