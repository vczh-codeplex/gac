#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n"L""
L"\r\n"L"class Node"
L"\r\n"L"{"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Text : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken content;"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class CData : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken content (XmlUnescapeCData);"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Attribute : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n"L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Comment : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken content (XmlUnescapeComment);"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Element : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n"L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n"L"\tAttribute[] attributes;"
L"\r\n"L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Instruction : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n"L"\tAttribute[] attributes;"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Document : Node"
L"\r\n"L"{"
L"\r\n"L"\tNode[] prologs;"
L"\r\n"L"\tElement rootElement;"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n"L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n"L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n"L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n"L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n"L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n"L"token EQUAL = \"/=\";"
L"\r\n"L""
L"\r\n"L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n"L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n"L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n"L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n"L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n"L""
L"\r\n"L"discardtoken SPACE = \"/s+\";"
L"\r\n"L""
L"\r\n"L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n"L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n"L"rule CData XCData = CDATA:content as CData;"
L"\r\n"L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n"L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n"L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n"L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n"L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4968; // 18057 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 872;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x9F\x71\x02\x80\x01\x7F\x05\x06\x83\x20\x0F\x30\x00\x36\x86\x00\x72\x00\x05\x82\x87\x02\x82\x2A\x00\x61\x00\x07\x30\x06\x25\x8C\x00\x6D\x00\x25\x27\x84\x8F\x81\x84\x81\x0B\x8D\x8F\x8D\x82\x8D\x92\x8A\x81\x18\x9A\x9C\x9E\x8A\x89\x93\x90\x82\x06\x88\x8A\x90\x8B\x91\x8B\x88\x83\x2F\x80\x31\x9B\x8D\x8F\x8E\x9A\x92\x39\xA7\x80\x09\x9E\x80\x89\x96\xA0\x06\xC1\x00\x14\x33\xAD\xA1\x9A\x91\x48\x83\x8A\xAC\xAD\x9F\xA6\x80\x04\x51\xD5\x94\xB6\x2F\x8F\x85\x3A\xAC\x38\xDA\xBB\x8A\x9E\xA7\x9F\xAE\x83\x42\x10\xA7\xAE\x30\x04\x33\x8E\x89\x79\x59\xA6\x8B\xBD\xA4\x96\xB6\x00\x60\x82\xB1\xAD\x83\xBD\xBB\xBA\x00\x79\xE9\xBB\xA8\x9C\x9D\xB5\x93\xC0\x00\x03\xC0\x05\xC6\xBA\x8C\xBC\xBD\x3A\x8C\xEC\xBE\xBF\xC0\xBA\xB8\x00\x74\x95\xFE\x89\xC5\x91\xCF\xA5\xC6\x9C\x86\x90\xD2\xC4\xCF\xC0\xD3\xA4\x7C\xDD\xBF\xAB\xDF\xC9\xD2\xD6\xCC\x0C\x7C\xB4\xB4\xA3\x90\x3D\xAA\xAE\x6D\x86\xB8\xDA\xD5\xAD\xDF\xDE\xD4\x3E\xC2\xCA\xC6\xD0\xE1\xD5\x8A\xBE\x21\xC7\xBB\xC0\xC6\x81\x05\xB0\xAA\x54\x92\xA9\x20\x02\x33\xC9\xE3\x83\xFF\x61\xDB\xA0\x04\x27\x8C\xAA\x8D\xE1\xE1\xC1\xAC\xA1\xE8\xAF\xE9\xF4\xFF\x10\xE5\xED\x83\x36\xEE\xE9\xAA\xF0\xC1\x85\x2D\xA3\x97\xF8\xAA\xF8\x0B\x06\x49\x10\x68\x00\x33\x15\x56\x44\x67\x75\x74\x57\x76\x0D\x74\x50\x7C\x01\x06\x5E\x4D\x42\x5D\x37\x69\x70\x84\x4C\x58\x7E\x6F\x7D\x7A\x0D\x15\x77\x77\x81\x00\x1B\x7D\x77\x59\xBC\x40\x07\x84\x81\x57\x63\x43\x02\x87\x02\x52\x58\x76\x4F\x22\x9E\x75\x8A\x52\x76\x25\x5E\x77\x48\x27\xA3\x75\x7A\x46\xE7\x40\x01\x51\x7D\x0D\x9F\x7F\x79\x7A\xEB\x50\x4D\x7B\x48\xD3\x7F\x80\x47\x74\x48\xB8\x79\x7A\x7C\x10\x75\x77\x5A\x7F\x3E\x86\x40\x1E\x4F\x9B\x44\x56\x80\x7C\x50\xB4\x76\x7E\x7B\x55\x41\x82\x42\x44\x0D\x4D\x44\x57\x7E\x0F\x7D\x70\x9B\x86\xEA\x46\x48\x98\x56\x54\x8A\x06\x40\x8F\x20\xB1\x84\x88\x56\x5B\x84\x9E\x98\x7F\x20\x6B\x90\x02\x98\x00\x35\x7D\x4E\x81\xDB\x74\x53\x4E\x51\x58\x42\x00\x56\x40\x6F\xAA\x9D\x90\x55\x27\xB4\x59\x8B\x5F\xFA\x7C\x94\x94\x64\x06\xA7\x5D\x76\x84\x86\x63\x49\x9D\x78\x80\x83\x84\x5E\x81\xD9\x5E\x7A\x81\x88\x4B\x80\x02\x9E\x40\x74\xA5\xA6\x9F\x77\x9F\xBF\x31\xA8\x81\xA4\xBE\x49\x81\x55\x0C\x84\x81\xA4\xA2\x23\x42\x77\x88\x46\xC6\x54\x5A\x91\x90\x25\x83\x91\x78\x04\x06\x71\x06\x40\xB2\xC2\x4D\xB0\x78\x7C\xE1\x4E\xB3\x40\xB4\xD1\x92\xB4\xB5\xB5\xCE\x97\xBF\x3C\xB3\x00\x03\x8E\x47\x14\x42\x40\x02\x14\x00\x55\x27\x68\x47\x80\x4F\x05\x5F\x14\x00\xE9\x90\x10\x03\x7E\x1E\x67\x8F\x08\x00\x3C\x00\x03\xBF\x0F\xCD\x8A\x51\x06\x80\x45\x60\xB8\x47\xB8\xE5\x8B\x47\xB8\xBB\xEA\xA7\x6C\x10\xC1\xE0\xBB\x72\xBC\x00\xF8\xB3\xBE\x0F\x5F\x06\x06\x44\x07\x4E\xE9\x8D\x10\x02\xBB\x07\xFB\x78\x14\x00\xEB\xBB\x79\xC4\x00\x16\xF0\xB1\xBB\xBA\xED\xAF\xB5\x53\xC2\xF5\xB3\xB3\xBE\xA2\xCF\x42\x43\xC6\x40\xE0\x9E\xB0\x03\x11\x00\x1F\xCD\xC5\xCD\x26\xE1\xC5\x50\x46\xEB\x8B\x47\xC1\xBA\x09\xE6\x86\x42\xCA\xF6\x80\x0F\xC3\x8A\x6F\x42\x49\x6C\xA3\x38\xFB\x7A\xCE\x47\x3C\xC4\xCE\xBA\xC8\x2C\xC5\xD5\xBF\x89\xD6\x42\x4D\x84\xD3\x1F\xCF\xD3\xCA\xC1\x08\xE6\xC5\xD6\xC3\x00\x0A\x5B\xA9\xD9\x7B\x91\x14\xB8\x00\x52\x47\xC3\xD8\x00\x3D\x00\x01\xC7\xB4\xE1\x67\x8E\x46\x54\x3A\xFB\xB2\x43\x16\x1F\x6D\x00\x02\x1E\x6C\xC0\x0E\xDE\x16\x00\x30\x02\xE0\x00\x39\x00\x0A\x0C\x00\x2E\x1C\xC5\xD2\xDF\x5D\x00\x0B\x09\x95\x02\x40\xA0\x66\x54\x18\x58\x44\x59\xDB\x6B\xFB\x73\x06\x41\x22\x00\x0C\xDE\x17\xF4\x86\xD0\x01\xE8\x91\xEA\x07\xE8\x00\x7C\x00\x07\x0A\xE8\x00\x24\xE5\xBF\xC3\xAF\xE9\xEE\xE8\x75\x4A\xCB\xA7\x69\xC5\x20\xE6\xC0\xD7\xEA\x02\x73\xB9\xC8\x00\x21\x07\xEE\xDC\x0A\xB0\xE4\xE3\xBE\xDF\x0F\xD1\xED\xEA\xDF\xA3\xCF\xE6\xEA\xF3\xC6\xC9\xF3\xF4\x00\x29\x00\x0A\xEA\xDF\x7E\xE4\xD9\xD4\x00\x5B\xE8\xDC\x61\x79\x98\xC1\xEC\x0B\xD0\xA5\xF3\xB5\xF3\xBC\x7C\xCB\x44\xF9\xB8\x52\x6C\xF0\x00\xF2\xD1\xF3\xB1\xE4\xF5\xF6\xD6\xF9\xFC\xFE\x00\x11\xE9\xFD\xF4\xCD\x78\x7A\xF6\x45\x6E\x7F\xFE\x45\x6F\x61\x67\x6F\x43\x45\x26\x6B\x62\x8C\x24\x06\x20\xF4\x71\x75\xE9\x0F\x61\x6F\xD0\x6F\x70\x04\x45\x72\x23\xBC\x74\x23\x5F\x1E\x7E\x68\x70\x52\x23\x71\xE1\x07\x79\x71\xC5\x4D\x73\x5D\xCB\x66\x81\xF6\x13\x7D\x75\xD0\x6D\x77\x75\x80\x50\x3D\x49\x4A\x20\x5C\x77\x52\x2B\x21\xFB\x28\x69\xD1\x06\x43\x73\xA5\x4F\x5F\x1F\xCA\x42\x22\x52\x0D\x89\x43",
"\xAA\x0F\x06\x20\x44\x81\x58\xE3\x62\x50\x22\x33\x40\x00\x5C\x3D\x52\x20\x55\x67\x6F\x19\x12\x18\x87\x81\xF5\x49\x88\x00\x1A\x46\x75\x21\xA1\x5A\x89\x80\x5A\x88\x17\x8D\x70\x8B\xC3\x14\x2F\x7B\xB7\x00\x00\x06\xD9\x8F\x8B\x2D\x95\x2F\x61\x5E\x80\x5A\x1B\xC2\x58\x89\x36\xA3\x88\x00\xCA\x5B\x62\x40\x6C\x82\x8E\x2E\x8F\x63\x71\x18\x97\x6D\xEF\x7B\x38\x82\x40\x81\x51\x55\xC5\x55\x28\x06\xAD\x78\x83\xFD\x2A\x6D\x5C\x9C\x65\x92\x1A\x87\x94\x58\x3F\x4B\x93\x92\xE5\x7A\x71\xE0\x07\x65\x5C\x42\x8A\x73\x92\x40\x44\x41\x22\xD4\x27\x92\x0C\x98\x22\x63\xE1\x52\x90\x06\xA1\x9C\x48\x51\x93\x92\x23\x06\x46\x95\x11\xD4\x25\x8B\x38\xB3\x90\x7C\x75\x9D\x8D\x55\x0D\x73\x5D\x32\x55\x2B\x3F\xB6\x27\x6C\x16\x80\x02\x8D\x37\x93\x95\x8A\x90\x3B\x60\xB8\x1A\x55\x29\x09\x58\x2F\x6C\xCA\x9E\x3B\xA6\x10\x24\x43\x25\x8A\x5D\x06\x06\x2C\x8F\x32\xDC\x3D\x99\x4E\x66\x76\x90\xC5\x65\x98\x29\xAC\x73\x93\x70\xA7\x33\x47\x55\x3A\x21\x29\xC4\x74\x99\xD3\x0D\x27\x48\xAE\x8B\x9E\x39\x8D\x5D\x4F\x47\x40\x00\x99\x75\x94\x9D\x9C\x79\x96\x52\x3F\x4D\x76\x06\x00\x34\x20\x1B\xFA\x9E\x4F\x3F\x93\x91\x74\xF5\x41\x75\x20\x81\x7A\x66\x55\xA8\x45\x9E\x93\x9B\x0F\x24\x9B\x6E\x45\x3A\x5C\x9F\x4E\x23\x2E\xA1\xAB\x30\x47\xA2\x58\x53\x95\x0F\x93\x88\x78\x06\xA1\x74\x6C\x85\xA4\x9B\xA4\xA6\x66\xA5\x15\x92\xA8\x83\x68\x8C\x9C\x53\xD5\x8E\xA1\xA6\x5C\x90\xA6\x3C\x5F\xA7\xA0\xE9\x6B\x77\x42\xF8\x66\x64\x87\x82\x50\x22\x84\x44\x43\xA1\x13\x58\xA5\x87\x66\xA1\x7B\x18\x90\x97\x24\x84\xA6\x9F\x0E\x72\x4B\xA0\xFD\x96\x9E\x41\xA8\xA9\xA1\x49\x82\x95\xA1\x9F\x98\x82\xA4\x10\xA8\x82\x96\xAD\x9D\xA2\xAE\x5D\xA1\x89\x1A\xA2\x2C\x8E\xA3\x46\xA3\x18\x80\xA4\x06\xA2\xAB\x75\x92\x93\x94\x91\xAB\x66\xAB\x3D\xD6\x80\x00\xAF\xAE\xA4\xA6\xD4\x98\x2A\x4C\xD2\x9D\x9B\x6A\xB1\x90\x00\x6A\xAB\x77\xF0\x26\xA7\xAB\x9E\x99\xAF\x90\x83\x48\x56\xA1\x56\x2C\xAB\xB8\xBA\xA2\x80\x49\xA5\x43\x52\xD1\xAE\x95\x64\x8F\x8C\xAF\x35\xA3\x24\xB7\x77\xA3\x9A\x67\xA3\x24\x97\x4D\x9F\x94\x81\x76\x21\x7D\x61\x9C\xB5\xAF\x58\x2F\x60\x06\xF8\x92\x21\x8D\x4C\xAE\x95\xD0\x86\x65\x9A\x10\xA3\x3B\xC6\x58\x9E\x10\xD9\x8D\x9F\x6B\xD3\x33\xAA\xC1\x8F\xB5\xB0\x9E\x86\x93\x56\xC7\x2D\xAB\x89\x81\x77\x45\xDA\x22\xAE\x5E\x87\xBB\xA3\xE4\xA7\xAD\x44\x7F\xA1\xB0\x5B\xA4\xA9\xA5\xB7\xB8\xA2\xAE\xC5\xAD\xA7\x65\xAF\xA9\xAF\x8C\x87\xB3\xA6\x9D\xBE\x99\x74\xB8\xA3\xB1\xB9\xBB\xA3\x90\x93\x86\x93\x4F\x8D\x21\xA9\xC5\xB4\x25\xB1\xA1\x78\xB8\x64\x9F\x2F\xAF\xDD\x95\x2B\x6E\xED\x8E\x7E\x79\x1F\x26\xB2\xFD\xB4\x4A\x23\x8D\x6A\x5B\x08\x39\xBB\x62\xFF\xA9\x9F\x9B\x93\x9A\xBD\xF9\x52\x2E\xA6\x44\x96\x94\xBE\x09\xC4\x3F\x7E\x9A\x2C\xB5\xFC\x86\x4C\xB6\x55\x31\xB4\x7B\x18\xC4\x2B\x00\xC2\x83\x8F\x16\xCF\x9C\x87\x88\xC8\x83\x85\x3C\x76\x6B\x18\x2D\xC1\x25\xF6\x91\xB3\xBF\x9B\xC4\x4A\x15\xCE\xB4\x65\xD3\x31\xB6\xFB\x9D\xC0\x8F\x00\x18\xB4\x88\xB2\xC3\xB6\x2A\x7D\xB0\xA1\xAB\x75\x8B\x79\xD8\xA2\xB8\x5E\x51\xA6\xB8\x60\xA6\xAE\x8C\x4B\xB6\x91\xE6\xA8\x57\xB9\x36\xA9\xAD\x48\xB8\xAE\xAD\x75\xB1\xBF\xB1\x76\xBB\xB8\x5E\x9E\xB9\xBD\x49\xA0\xB8\xB5\x9E\x57\xA4\x55\xC5\x64\xB0\x86\x86\xB2\xBD\x7D\x32\xB1\xA1\x44\x2F\xBC\xE2\x8E\xB7\xA8\xAF\x92\xB1\x23\xB3\xC5\x2A\xCB\xB6\xC2\x55\xFC\x9D\xC6\x3F\x80\x07\x07\x1C\xC4\xC2\xB6\x70\x45\xA3\x61\xC0\xC5\xCC\x9E\x81\xBB\x92\xC3\xAB\xB9\x96\xC9\xCE\xB9\x25\xDE\xBD\xC9\x65\xAD\xD0\x46\xF2\xC0\xB1\x29\xE8\xA5\xCA\x27\xAF\xCF\x91\xDA\xBB\x9B\xF0\xB1\xA7\xBB\x98\xBD\xB8\xA5\x81\xB0\xC9\x79\x45\xD0\xBD\x0D\xC9\xB3\x9A\xC3\xA0\xA2\x21\xDA\xD0\x83\x48\xB0\xC3\x9C\xFA\xC6\x9E\xFC\x85\xC2\xC2\xFF\xA0\x21\x1D\x86\xCD\x46\xD0\xBE\x97\x4C\xA3\xBF\x4E\x41\x26\xB7\x9D\x09\xE6\x73\xB5\x25\x1D\xBF\x85\xD4\x4B\xB2\x77\xBD\x4C\x4A\xBE\xD0\x20\xB0\xB6\x35\xB5\xD2\x77\xD2\xC4\x3E\xC7\x99\x09\x5F\x7B\x63\xF9\x07\x93\x4A\x7E\x41\x8E\x84\xDE\x40\xDC\x7B\x8D\x72\x06\x00\x00\x0F\x9F\xDE\xD2\x4B\x11\xFD\xB3\xA5\xC6\xA2\x56\x64\xA5\x57\x57\x05\x69\x56\xA1\x57\x44\x4D\x9A\x9C\x2F\xAE\xB8\x97\xDF\xD9\x0F\xC6\x91\xBE\xC8\x3C\xDE\x31\xFA\xB4\xCE\xE3\x86\x92\xBE\xCE\x87\xCF\x16\xD3\x94\xDD\x5F\x56\x9E\x9D\x88\xE8\xCF\xD6\x80\xD6\x51\xAE\x87\xDD\x40\xBB\xC7\xE2\x77\xC3\xD5\x74\xA7\xC4\xC8\xA2\xC6\xCE\xD5\x45\xD1\xD7\xC9\x8E\xDD\xC9\x64\xC8\xB8\xE5\x49",
"\xE3\xBB\xAD\x54\xD5\xBA\x95\xB2\xE5\xAE\xE3\x9D\xD0\xCC\x2A\xF2\xB0\x77\xDC\xCF\xE4\xDF\xA6\xD6\xAA\x66\xC7\xD3\x2A\xE9\xCD\xBC\x36\xC6\xCD\xA8\x8F\xB1\xD6\x52\xB3\xD1\xD1\xA6\xB8\xC8\xAA\xB4\xCE\x97\x8F\xA0\xE0\xE8\x43\xF9\xE1\xD1\xDE\xB0\xDE\x76\x8C\xDD\xE5\xEF\x24\xAC\xE5\xAF\x50\xBA\xC1\xD3\xB7\x81\xC7\xB0\xAF\xCA\x26\xB9\xCB\xCD\x99\xB9\xE7\x2F\xEC\xED\xE7\xA5\xDF\xB5\xD0\xB9\xEB\xBC\x35\xC2\xAC\xB1\x6E\xC8\xEF\x24\xCA\xE4\xD3\x3B\xD3\xE1\xEA\x34\xD9\xCD\xD3\x99\xE0\x01\x19\x3E\xCC\xE3\x77\xD3\xE9\x55\xC3\xC7\xCD\x91\xC4\xAD\xE6\x5B\xE7\xE5\xD8\xCC\xC1\xCE\xB0\xCA\xB9\xCC\x52\xD0\xE7\xA5\xB4\xE7\xEC\x9A\xEA\xE9\xD4\x5C\xDB\xAF\xCE\xE2\xB6\xE1\xB8\xE1\xE5\xF1\x43\xEA\xD7\xDD\xED\xCB\xB8\xBD\xF0\xD1\xCE\xF5\xB4\xE1\x15\xBE\x8B\x62\x79\xF5\x50\x41\x87\x96\xDD\x90\x01\x26\xE2\xDB\xE0\x45\xDE\xA8\x41\x4A\x87\xEA\x6C\xE2\xDF\xF4\xD9\xF7\xC1\xE4\x42\xE2\x8C\x61\xC8\xBA\x80\xBF\xEA\x47\xF0\xF3\x57\x92\xF7\xF3\x9C\xCE\xCB\xF2\x98\xF5\xD0\x4A\xF8\x52\xBF\xA5\xDD\x5C\x56\xBF\xE8\xF9\xAE\x74\x21\xB6\xAE\xD8\xF8\x00\xB4\xE7\xBA\x45\xD0\xCF\xB2\x1C\xF5\x5C\xE3\xE6\xF5\xF9\x6F\xCF\xFE\xA0\xAC\xE6\xBB\x75\x15\x98\x91\xB8\x1A\x9C\x73\x4E\xB9\xE5\x46\x1A\x16\x16\xCB\x5E\x7D\xF1\x7C\x7E\x00\x0C\x6D\xE3\x6F\x6D\x23\x62\x6E\x10\x75\x6E\x84\x7A\x2C\xEA\x6C\x71\x0D\x8E\x71\x86\x49\x65\xC6\x76\x2B\xE2\x77\x6F\x87\x53\x70\x59\x25\x70\xEB\x4F\x6F\xF0\x43\x1D\xF8\x68\x25\xFB\x63\x6A\xC6\x5D\x70\x87\x5B\x70\xA2\x50\x78\x8A\x42\x6B\x09\x8D\x6E\x30\x69\x6C\x82\x78\x71\xD3\x1D\x6C\x77\x61\x6D\x0C\x71\x6C\xD5\x60\x75\x83\x7C\x5B\xDA\x69\x7E\x17\x88\x7B\xA7\x23\x7E\xBA\x6D\x7B\xE0\x77\x7C\x43\x89\x2A\x1A\x74\x0A\x7F\x61\x84\xA6\x28\x2B\xA9\x2B\x7C\xF8\x27\x7A\x42\x7F\x50\x47\x15\x72\x48\x64\x7D\x06\x8F\x75\xEB\x79\x72\x70\x7C\x7C\xDD\x74\x69\x4E\x80\x7C\x44\x8E\x54\xD6\x6F\x7D\xA3\x21\x7E\x49\x81\x24\x52\x82\x77\x56\x75\x7F\xD1\x7A\x75\xD3\x76\x79\x5B\x8C\x5C\x5A\x8E\x85\xA5\x70\x86\x8F\x5E\x7D\x63\x89\x81\x41\x25\x7E\x77\x83\x69\xE9\x75\x80\x29\x7A\x71\xEF\x77\x86\x84\x83\x69\xF3\x73\x77\x70\x8F\x78\xA1\x39\x7F\xAE\x69\x49\x00\x0B\x39\x38\x3E\x7F\x0E\x50\x80\x4D\x17\x16\xDE\x54\x80\x81\x8F\x1D\x08\x83\x81\x54\x2A\x37\xED\x40\x8A\x7B\x6D\x4B\xD2\x66\x32\xB6\x1C\x7B\x00\x04\x6C\xA4\x82\x55\x3F\x85\x47\x7D\x8B\x86\x04\x2A\x8A\xB5\x77\x84\x18\x82\x8B\x74\x1D\x38\x86\x74\x7C\x67\x81\x8B\x50\x8C\x86\x1F\x75\x2F\x53\x85\x75\xA8\x67\x58\xF6\x79\x5D\x73\x8D\x85\x93\x6C\x85\x61\x56\x80\x5F\x8C\x7D\x7B\x82\x86\xB6\x82\x84\xBF\x84\x20\x55\x40\x88\x74\x89\x72\x83\x8D\x89\x25\x2A\x8B\xA5\x30\x7F\xDC\x89\x5A\x87\x54\x7F\xC6\x81\x7D\x8F\x8F\x58\x92\x84\x89\x9C\x48\x7A\x00\x08\x89\x02\x8B\x89\x94\x69\x88\xDF\x13\x7B\xB0\x83\x8D\x4F\x8A\x7B\x04\x2F\x32\xED\x4E\x8B\xF8\x89\x8B\x4C\x4F\x6B\xA8\x86\x18\xA2\x84\x6C\xFC\x89\x7C\x74\x1A\x5A\x73\x58\x8D\xCA\x8F\x1D\x12\x05\x47\xF2\x8D\x8D\xFF\x87\x8A\xC0\x46\x18\x47\x42\x10\xC4\x6F\x90\xE2\x88\x6C\xCA\x68\x6D\x7E\x2D\x90\x16\x7F\x62\xA5\x81\x5A\x54\x15\x46\x96\x15\x15\xE1\x3E\x6A\xC4\x60\x92\xAE\x8B\x91\x00\x76\x4F\xB4\x8E\x6C\x21\x8B\x4B\x97\x51\x45\x55\x1E\x43\x69\x4B\x46\x21\x6D\x92\x52\x77\x80\x75\x4D\x8A\xAE\x4F\x39\x16\x7E\x93\xB5\x51\x91\x4E\x44\x92\x3E\x14\x15\xAA\x88\x92\x67\x82\x94\xC6\x4F\x89\x51\x21\x71\xAE\x45\x91\xA3\x8F\x94\x0E\x83\x94\x46\x92\x45\xB8\x42\x10\x37\x9B\x94\x54\x9E\x71\x40\x86\x8F\x64\x89\x2A\x16\x05\x8F\x69\x88\x84\xD5\x8E\x8F\xA6\x85\x94\x07\x68\x95\xA2\x8A\x94\x6C\x45\x90\x44\x8F\x30\x5F\x95\x96\xB7\x87\x96\x00\x0E\x91\xFB\x80\x96\x7E\x84\x20\x64\x4B\x96\x55\x1C\x2D\x5B\x9F\x96\x7A\x98\x8B\xA6\x3F\x77\x3D\x85\x15\x78\x9C\x63\x87\x97\x63\x69\x95\x15\x57\x96\x92\x06\x1E\x96\x07\x7C\x82\x54\x1F\x30\x86\x94\x83\x55\x1F\x92\x37\x83\x93\x66\x48\x7E\x06\x11\x98\x93\x9B\x98\xA6\x3A\x90\xCD\x89\x72\xFA\x84\x51\xE1\x8D\x7E\x8D\x93\x92\x7E\x94\x15\x52\x92\x99\xA8\x99\x8D\x8A\x85\x71\xC9\x85\x9A\x93\x6D\x6C\x18\x9D\x7E\x8F\x98\x94\x9F\x93\x49\x6C\x49\x9B\xA6\x36\x6B\xC5\x69\x6B\xCD\x6C\x6B\x1F\x18\x83\x8E\x9D\x9A\xC2\x62\x10\xB0\x93\x9C\x07\x6F\x30\xC2\x96\x9C\x1A\x19\x7E\xD2\x9B\x44\xBB\x94\x9B\xA0\x97\x6B\xE8\x4D\x23\x96\x95\x47\x6B\x72\x6A\x89\x9A\x65\x9E\x68\x15\xC8\x9C\x9A\x34\x94\x15\x27\x94\x57",
"\xC4\x6F\x9D\x5C\x6D\x9D\x16\x7C\x9E\xDE\x4F\x92\xF0\x95\x4D\x7D\x97\x9E\x9E\x9A\x95\xBE\x9D\x4E\xF3\x92\x8E\xB6\x4A\x44\x41\x12\x4E\x4B\x48\x6E\x7A\x47\x86\xBA\x45\x99\xE3\x8C\x88\x87\x5C\x4A\x42\x2D\x82\x70\x5E\x48\x6B\x31\x49\x09\xAE\x60\x2C\x69\x69\xE9\x8B\x49\x9D\x34\x77\x12\xA1\x4F\x99\x67\x4A\xED\x49\x62\x11\xAB\x62\x1A\xAE\x7D\x05\xA3\x57\x2C\x91\x93\x53\x4B\x6B\xCB\x6B\x67\xE8\x69\x3D\x1C\x7A\x92\x3B\x96\x48\x26\x6D\x3B\x28\x68\xA1\x20\xA2\x82\x2E\x8E\xA2\xD3\x15\x45\x4E\x94\x6E\x0B\x8D\x93\x5D\x90\x6D\x85\x79\x6E\xEB\x6F\xA3\x82\x65\x81\xF1\x63\x98\x76\x93\x82\xFA\x6D\x13\x1E\x89\x69\x20\x83\x62\x4A\xA4\x70\x26\x8A\x5D\x28\x8A\x70\x22\x9D\x71\x54\x2E\x70\x18\x4C\x94\xB4\x45\x02\x73\x93\x6F\x75\x9D\x8F\x45\x89\x97\x74\x94\x8D\x62\xAD\x38\x34\x00\x00\xBC\x82\x98\x65\xA7\x8F\x06\x94\x62\xBE\x53\x8C\x8C\x75\x85\xC7\x82\x7D\xB1\x9B\x90\x63\x56\x87\xB2\x98\x56\xDA\x7B\x3A\xD0\x86\x52\x7C\x88\xA4\x62\xA1\x63\x58\xAE\x27\x35\x64\x71\x68\xA7\x78\x67\x89\x78\xC1\x8E\x86\xC5\x85\x64\x8F\x76\x72\x7B\xA9\xA7\x90\x63\xA9\x51\x6D\xA7\x64\x78\x69\x9D\x72\x5F\x9F\x73\x7A\x9F\x66\x48\x6E\x72\x6A\x5F\x85\x5E\x73\xA8\xA1\xAA\x7E\x5E\xE6\x84\x73\x7C\x71\x7B\x94\x99\x90\x0E\x99\x9A\xF7\x95\x9B\x4A\x63\x69\x89\xA7\x88\xBF\x90\xAB\x8B\x8F\x86\xE5\x8E\x88\x70\x38\x8E\xFB\x73\x89\x16\xA6\x89\x87\x5E\x8E\x37\x20\x7B\xFA\x76\xA9\x23\x15\x45\xD1\x98\x6B\x07\x6A\x6C\xDB\x97\x9C\x00\x08\x6E\x03\x6D\xA2\xCC\xAC\x9D\x87\x5A\x60\xF0\x34\xA3\xAE\x43\xA1\xDE\x75\x9D\x15\x6D\x9F\x73\x42\x34\x18\x2A\x44\xD2\x2F\x43\x25\xA3\x62\x45\x2C\x91\xF6\x42\x1C\x1C\x09\x13\xE9\x1B\xA3\x0A\x87\x29\x06\x1C\xA5\xCD\x2E\x01\xEE\xA1\x1E\x5F\xA7\x7B\x6E\xA4\x84\xB3\x2D\xA6\x61\x91\x24\xC2\x18\x41\x74\x31\x1F\x33\x88\xAE\x7B\x2D\xAA\xC2\x11\x3A\x03\xB4\x9A\xB3\xAE\x89\x1F\x26\x9B\xDF\x12\x1C\x0F\x43\xB0\xCB\xAF\xAC\x1A\x1A\x23\xC6\x62\x1C\x26\x07\xAF\x04\xBF\x9E\xA0\x7E\x4D\x76\x32\x6A\xC2\x18\x3C\x03\xB0\x01\x48\x3B\x1C\xC2\x15\x12\xE5\xAB\xB2\x2C\xBC\xB2\xCB\x17\x36\x55\x35\xAE\x25\x1A\xB2\xBA\x3A\xA0\xA3\x49\x2F\xB9\x47\x4B\xCB\x10\x28\x31\xB2\x2D\x33\xB2\x2D\xC3\x2B\xAD\xAE\x42\x1C\xE0\xAC\x45\xCB\x1E\x43\x3D\xBE\x2C\x3F\xBE\x2C\x41\xBD\x4A\xD3\x14\xB4\x39\xB4\xAE\x98\x12\x95\x49\xBD\x2C\x4B\xBD\x2C\x4D\xBB\xA0\x54\x10\xB5\x16\x73\xA2\x98\x15\x12\x3A\x42\xB3\x2D\xBF\x2B\xB7\x4C\xB5\x1D\xAA\xB3\xA5\x15\x35\x27\x29\xB2\x06\x1C\xA2\x00\x01\xB6\xD2\x24\xB6\x52\xB2\x44\x51\xB1\xAE\xF8\x5E\xB6\xE5\xA5\xB4\x55\x10\xB7\x2C\xB6\x59\xFB\x9D\x2B\x2D\xB1\xB8\xD9\x25\x1A\x25\x18\x5F\x81\xBB\x1C\x55\x3A\x14\x6C\xB4\xB7\x02\x15\x35\xF8\x5A\xB8\xD2\x2E\xB7\x1F\xB5\x4D\x55\xB8\x29\x93\xB6\x53\xC2\x17\x99\x23\x62\xB8\x83\xB9\x13\xF8\x51\x14\x82\xBB\x1C\x90\x17\x36\xE5\xA9\xB8\x06\x10\xB9\xCE\x2A\xB9\x54\x2A\x14\x78\xB1\xB9\xDE\x97\xB9\xBD\x2F\xB2\x06\x15\xB5\xC2\x1A\x43\x4A\x18\xBA\xCD\x2A\xBA\x7E\x2C\xBA\x2D\xB2\xB9\x9E\xA8\x15\x34\xBD\x32\x94\x42\xB4\x4F\xB7\xBA\x75\xB6\xB4\xA5\x1C\xB3\x2D\xB6\xBB\xC6\xBD\xB7\x05\xBB\xBA\x6D\xBD\xBB\xAF\xBF\xBB\x23\x11\xBC\x94\x33\xBC\x4E\xB5\x15\x66\xB0\xA0\x47\xB3\xBB\xCB\xBD\xBC\xE2\x3B\xB2\xBA\xB6\x4F\xBC\xBE\xBC\x1E\xB4\xBD\x7F\x12\x1C\x59\xB7\xB3\xDB\xB6\x47\xF8\x15\x1A\xE1\x3F\x3D\xE5\xAC\xBC\x8C\xB2\xBE\xCF\xBB\xBB\xD1\xB6\xBE\xFA\x90\xBB\xE9\xB5\xB3\x19\xA5\xBC\x49\x39\x93\x26\xA8\x19\xAA\x80\x19\xF3\xB0\xBE\xB8\xB9\xB9\xF7\xB4\xBE\xF9\xB6\xBF\xE7\xBB\x65\xDE\x46\xBD\xEB\xBE\x27\xC2\x15\xB1\xC6\x6B\x1C\x54\xBF\xBD\xF5\xB9\xC0\xAA\x1B\xC0\xAE\x45\xBE\x0E\xCB\xBF\xE8\xB2\xC1\x06\x16\xB3\x14\xC0\xBE\x00\xAC\xB9\xA1\xB9\xBC\x06\x10\x28\x62\xB2\x10\xD6\xB0\x28\x75\x75\x74\xAC\x67\x14\x0A\xC6\x71\x77\x6D\x2C\xCB\x15\x12\x3E\x4F\xC2\x2B\xB8\xB1\xB9\x65\xC1\x28\xA6\xB1\x98\x1A\xB6\x3E\xBD\xC0\x7C\xB8\xB3\xE3\x39\xB1\x06\x16\xC1\xB9\x67\xB7\x2D\xBE\xC4\x07\x69\xC4\xE5\xAE\xBB\x10\xC5\x4D\x9C\xBB\xC3\x06\x11\x3E\x3E\xC5\xAE\xE9\xAA\x93\x00\xC8\x3B\x02\xC3\x62\xFF\x0A\x43\xFF\x06\xC4\x4A\xB8\xC4\x2D\xBF\xC5\x03\xC7\xC3\x63\xC4\x25\x50\xCA\xBF\x4F\xA4\x25\x54\xCE\xBA\x0F\xC3\x9E\x37\x15\x35\xAA\x8B\xB8\x00\x0F\x01\x06\x15\xC7\xC2\xB8\xA3\xDA\xBD\xC1\x1F\x99\xA2\xB5\x66\x10\x7E\xC2\xC7\x30\x93\x62\x55\xB1\x14\x1C\x85\x82\x06\x22\x1C\xF0\xA0\x83\x7E",
"\x27\xC6\x06\x1B\xC7\x06\x15\x12\xAA\x80\xC8\xD7\xB2\xC8\x5B\xB4\xC8\x6F\xCE\x27\xF8\x58\xC9\xA9\xB8\xA2\xEA\xAE\x4A\x8D\xC6\x25\x24\x8C\xA4\x92\x52\xC9\x3E\xAC\xA3\x54\x2A\xC2\x2B\xBB\xB3\x06\x12\x95\x3E\xC6\xBD\xBB\x23\x29\x6E\xCA\x98\x98\x9F\xC9\x2D\xBB\x1C\xDF\x3C\x2D\xB2\xC3\xCC\xC4\xC9\x13\xA5\x17\x22\xA2\x8E\xC3\x4A\x14\xCA\xCD\x23\xC9\x50\x90\xC0\xA2\xB6\x10\xA4\xB7\xC4\xF5\xBC\xCC\xAE\xC1\x94\x44\xAB\xAE\xC6\xC9\x13\xF1\xBD\xB2\xA6\xB2\x10\xD6\xCC\x22\x53\x90\xCB\x7E\x24\xC2\x02\x16\xC2\xDA\xC1\xC0\x73\xC7\xC2\xD6\x25\x1A\x41\x12\xCC\x87\xB5\x1A\xDF\x3C\xC1\xED\xC9\x13\x80\x28\x97\xA5\xB0\xBE\xB6\xC6\xC7\xA1\x9D\xCB\xFD\xB2\x10\xB9\xC0\x51\xC2\x1C\xB0\x92\x61\xB1\xCA\x14\xB8\x12\x3D\xB2\xD6\xBA\xBE\x07\xB2\x9A\xBB\xC5\xA8\xF6\x45\xC6\x39\x18\xC6\x56\xBA\xC6\x2C\xB5\x29\x08\xB0\xCA\xBC\xC3\x62\x71\xC1\xC2\x1B\xD4\xC7\x2A\xC6\xC5\x78\xC7\x10\x55\x30\x94\x15\xD2\x10\x89\xCF\xB6\x6B\xCD\xD0\xFE\xCF\xD0\x77\x68\x5F\x29\xD5\xC5\x1E\xC3\x1D\x31\xC6\x10\x2A\x80\x6C\x19\xD2\x10\xCE\xC5\x95\xF8\x15\xD2\xD4\xC3\xA6\x9C\xC8\xD1\x0E\xDA\xD1\x10\xDE\x4A\xA3\xC2\xBD\x38\xC4\x71\x35\xD3\x26\x57\xA9\xC3\xE2\xCD\x6D\xD9\xC3\xB4\xC5\xC7\xD0\xF6\xC6\x10\x15\x0A\xD0\x99\xC1\xB7\x06\x16\x7F\xC2\x19\xAF\x6A\x86\x97\x59\xC5\x1A\x67\x33\x96\x53\xDA\xC5\x02\x17\x01\x58\xDA\xBF\xF4\xA7\xCD\xE3\xC1\xAF\xEC\xC3\xD5\xF1\xC0\x1B\x02\x18\x01\x65\xDC\xC2\x02\x18\xCF\xD2\x2F\xCD\x00\x07\xD5\x2C\xBE\xD5\x66\x92\xA6\xB8\xCB\xD5\x46\x63\xD0\xAF\xA8\xAC\xC3\xCD\xBD\x02\x19\x01\x69\xDF\xCF\xE1\xB4\xAC\x9A\x8D\x2C\x04\xDD\x75\x25\x25\xD7\xDB\xC2\x10\x1A\x0B\xD8\xE5\xAD\xAF\x60\xA6\xA6\x6F\xAD\xD5\x64\x9B\xD9\xFB\xA9\x2A\x96\xC3\x10\x7A\xCF\xD3\x29\xDC\xC9\x9A\xDA\xAF\xFF\xA4\x20\x9E\xD6\x84\xFE\xAB\x97\x74\x10\xD3\x2D\xBE\xD7\x61\xAF\xA6\xA9\xC2\x10\x8F\xCC\xCA\x91\xCF\xD4\x2F\x8F\xCC\x3D\xD7\xC9\x3F\xDB\xC9\x2D\xB9\xDA\x5F\xD2\xA6\xAD\xD4\xA6\xA0\xDB\xDA\xB1\xD0\xDC\x7D\xDF\xD9\xAA\xD0\xDB\x00\x07\xDB\x00\x09\xDB\x10\x15\x70\x6C\xD0\xD5\xE4\xC9\xCE\xBF\xC8\xD0\x02\x1B\x01\x98\xD2\x2D\xDF\x30\x9C\x84\xD6\x71\xC0\x93\xDA\x24\xD6\xD5\x3F\xDC\xD7\x2A\xDC\xB2\xE1\xD0\xAB\xE3\xD2\xAB\x05\xD5\x22\xF8\x5A\xDE\xE5\xA1\xD9\xE7\x75\xB5\x67\x37\x7D\xD5\x7B\xDB\xB9\x3E\xDA\xC9\xD0\xDD\xE6\xDB\xCF\x30\xC5\xCB\x7F\xCD\xB2\xED\xD6\xD8\xEF\xD7\xA7\x10\xB2\xDF\x04\xEC\xB2\xF6\xD5\x7D\xF8\xD3\x27\xB0\xAC\xDF\x62\xCF\xD1\x6F\xD0\xD7\x94\xD3\x10\xC2\x1D\x01\x18\xE0\xD7\xCB\x1D\xCD\x2C\xB7\xB5\x0C\xD7\xCE\xFF\xB3\xC8\xEA\xCB\xC8\xB1\xC8\x19\xC2\x11\xD3\x1D\xE5\xCF\x03\x18\xCC\x8B\xDA\x14\x2C\xEE\x2C\x3B\xDB\xB9\x03\x15\x1A\xA3\xB1\xE3\x88\xC6\xE0\xAF\xCE\xD6\xDA\xDF\xE1\xE2\xC9\xCF\xF5\xB3\xE3\xCD\xCD\xE3\x94\xC6\x4F\xE6\xC8\xBD\x5A\xB9\xBB\xA6\xC0\xC6\x83\xC8\xB2\x06\x15\x3C\x2D\xE3\xCB\xC7\xC6\x10\xC9\xC8\xE1\x50\xE2\x10\xD3\xA3\xE5\xDB\xD9\x13\x39\xEE\xE1\xA5\x12\x1C\x25\x0C\xE5\x2A\xC4\xCB\x77\xDB\xD8\x81\xD2\x10\x5C\xD2\xCD\x85\xD8\xA7\x58\x14\xD5\x1A\xE6\x10\xAF\x34\xE6\xB2\xCB\x1C\x05\xC8\xE6\x40\xB5\xC2\x25\xEE\xCB\x72\x33\xC4\x19\xB9\xE5\x1F\x64\xE7\xE5\xA1\xCD\x02\x13\xCD\x69\xC5\xBF\xAD\xB5\xCA\x77\xC8\x73\x98\x10\xB3\xDE\xC0\xBE\x89\xEC\xE4\x8B\xEC\x76\x49\xE8\xCE\x52\xD5\xBF\xDC\xB6\xD7\xD1\xDF\xE8\x88\xE8\xD4\x22\xC7\xC5\xC0\xB9\xE7\x24\xE5\xA3\x26\xE1\xBE\x99\xE9\x13\x48\xBC\xE9\xE1\xB1\xE9\x0F\xDF\xB7\x8C\xD3\xC1\xDA\xDA\xB7\xFF\x10\xBF\x41\xE9\xD7\x90\xEE\xE9\xA7\x54\xE9\xA2\xEA\xE4\xEC\xB4\xD4\x9E\xC4\xC0\xA0\xC2\xE4\xAB\xE8\xEB\xE2\x98\x73\x95\xEB\xE7\xCD\x22\xC5\x3D\x28\xC1\xDE\xBC\xB2\x7A\xDC\xEA\x44\xDE\xEA\xC7\xE4\xEA\x7C\xE2\xEB\x82\xE7\xED\xD8\xED\xE1",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

			void XmlText::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlCData::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlAttribute::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlComment::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlElement::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlInstruction::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlDocument::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::parsing::xml;

			IMPL_TYPE_INFO_RENAME(XmlNode, system::XmlNode)
			IMPL_TYPE_INFO_RENAME(XmlText, system::XmlText)
			IMPL_TYPE_INFO_RENAME(XmlCData, system::XmlCData)
			IMPL_TYPE_INFO_RENAME(XmlAttribute, system::XmlAttribute)
			IMPL_TYPE_INFO_RENAME(XmlComment, system::XmlComment)
			IMPL_TYPE_INFO_RENAME(XmlElement, system::XmlElement)
			IMPL_TYPE_INFO_RENAME(XmlInstruction, system::XmlInstruction)
			IMPL_TYPE_INFO_RENAME(XmlDocument, system::XmlDocument)
			IMPL_TYPE_INFO_RENAME(XmlNode::IVisitor, system::XmlNode::IVisitor)

			BEGIN_CLASS_MEMBER(XmlNode)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(XmlNode)

			BEGIN_CLASS_MEMBER(XmlText)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlText>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlText::*)(), [](XmlText* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlText::*)(const vl::WString&), [](XmlText* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlText)

			BEGIN_CLASS_MEMBER(XmlCData)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlCData>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlCData::*)(), [](XmlCData* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlCData::*)(const vl::WString&), [](XmlCData* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlCData)

			BEGIN_CLASS_MEMBER(XmlAttribute)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlAttribute>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlAttribute::*)(), [](XmlAttribute* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlAttribute::*)(const vl::WString&), [](XmlAttribute* node, const vl::WString& value){ node->name.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(XmlAttribute::*)(), [](XmlAttribute* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(XmlAttribute::*)(const vl::WString&), [](XmlAttribute* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(XmlAttribute)

			BEGIN_CLASS_MEMBER(XmlComment)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlComment>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlComment::*)(), [](XmlComment* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlComment::*)(const vl::WString&), [](XmlComment* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlComment)

			BEGIN_CLASS_MEMBER(XmlElement)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlElement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlElement::*)(), [](XmlElement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlElement::*)(const vl::WString&), [](XmlElement* node, const vl::WString& value){ node->name.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_closingName, NO_PARAMETER, vl::WString(XmlElement::*)(), [](XmlElement* node){ return node->closingName.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_closingName, {L"value"}, void(XmlElement::*)(const vl::WString&), [](XmlElement* node, const vl::WString& value){ node->closingName.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_PROPERTY(closingName, get_closingName, set_closingName)
				CLASS_MEMBER_FIELD(attributes)
				CLASS_MEMBER_FIELD(subNodes)
			END_CLASS_MEMBER(XmlElement)

			BEGIN_CLASS_MEMBER(XmlInstruction)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlInstruction>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlInstruction::*)(), [](XmlInstruction* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlInstruction::*)(const vl::WString&), [](XmlInstruction* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(attributes)
			END_CLASS_MEMBER(XmlInstruction)

			BEGIN_CLASS_MEMBER(XmlDocument)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlDocument>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(prologs)
				CLASS_MEMBER_FIELD(rootElement)
			END_CLASS_MEMBER(XmlDocument)

			BEGIN_CLASS_MEMBER(XmlNode::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<XmlNode::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::XmlNode_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlText* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlCData* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlAttribute* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlComment* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlElement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlInstruction* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlDocument* node))
			END_CLASS_MEMBER(XmlNode)

			class XmlTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode)
					ADD_TYPE_INFO(vl::parsing::xml::XmlText)
					ADD_TYPE_INFO(vl::parsing::xml::XmlCData)
					ADD_TYPE_INFO(vl::parsing::xml::XmlAttribute)
					ADD_TYPE_INFO(vl::parsing::xml::XmlComment)
					ADD_TYPE_INFO(vl::parsing::xml::XmlElement)
					ADD_TYPE_INFO(vl::parsing::xml::XmlInstruction)
					ADD_TYPE_INFO(vl::parsing::xml::XmlDocument)
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool XmlLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new XmlTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}
