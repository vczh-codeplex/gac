#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n"L""
L"\r\n"L"class Node"
L"\r\n"L"{"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Text : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken content;"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class CData : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken content (XmlUnescapeCData);"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Attribute : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n"L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Comment : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken content (XmlUnescapeComment);"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Element : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n"L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n"L"\tAttribute[] attributes;"
L"\r\n"L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Instruction : Node"
L"\r\n"L"{"
L"\r\n"L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n"L"\tAttribute[] attributes;"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"class Document : Node"
L"\r\n"L"{"
L"\r\n"L"\tNode[] prologs;"
L"\r\n"L"\tElement rootElement;"
L"\r\n"L"}"
L"\r\n"L""
L"\r\n"L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n"L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n"L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n"L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n"L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n"L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n"L"token EQUAL = \"/=\";"
L"\r\n"L""
L"\r\n"L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n"L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n"L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n"L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n"L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n"L""
L"\r\n"L"discardtoken SPACE = \"/s+\";"
L"\r\n"L""
L"\r\n"L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n"L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n"L"rule CData XCData = CDATA:content as CData;"
L"\r\n"L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n"L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n"L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n"L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n"L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4976; // 18057 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 880;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x9F\x71\x02\x80\x01\x7F\x05\x06\x83\x20\x0F\x30\x00\x36\x86\x00\x72\x00\x05\x82\x87\x02\x82\x2A\x00\x61\x00\x07\x30\x06\x25\x8C\x00\x6D\x00\x25\x27\x84\x8F\x81\x84\x81\x0B\x8D\x8F\x8D\x82\x8D\x92\x8A\x81\x41\x00\x34\x32\x9D\x8F\x8D\x91\x91\x04\x86\x88\x8A\x80\x8B\x95\x89\x89\x06\x88\x06\x91\x93\x9B\x9A\x2B\x8F\x0F\xF5\x22\x84\x9A\x9F\x90\x01\x94\x0E\x90\xAD\x86\x8F\x90\x00\x8C\x8D\x1C\x9E\x9A\x97\x9C\xA3\x82\xA6\xA8\x3E\xD3\x95\x97\x8F\x89\xAE\x9B\xA5\x39\xDE\xBC\x8A\x92\xA8\xA2\x80\xA1\x02\xC2\x10\x8A\xAE\x30\x00\x33\x8F\x12\xF9\x1D\xA6\x9B\xB1\xA8\x96\xB7\x00\x70\x80\x12\xBD\x84\xBA\xBA\xBC\x00\x7A\xA9\xBC\xB8\x95\x9D\xB7\x92\x82\x84\xC0\x06\xC7\xBA\x8D\xBD\xBD\x3B\x8D\xEC\xBF\xB0\xCE\x82\xC8\xCA\x88\x8A\xE5\x99\xCF\xA6\xC4\xCF\xA0\x9E\xF3\x80\x15\xB5\xCF\x9E\xD1\xA6\x7D\xE1\x80\xD1\xCA\xD4\xD5\xD0\xCC\x0C\x7D\xB5\xB3\x93\x90\x3C\x9A\xB0\x6D\x86\xB8\xDA\xD4\x9D\xDF\xDE\xD3\x3F\xC2\xCB\xC4\xD0\xE7\xD3\xB0\xCD\x20\xD1\xE3\x9B\xD1\xC6\x81\x05\xA1\x34\xB3\x92\x89\x30\x02\x33\xC9\xE2\x07\xFF\x62\xFF\xA0\x04\x23\x8F\x99\x1A\xE2\xE2\xF5\xA0\xA9\x90\xAE\xEA\xEA\xFF\x42\xC6\xFD\x83\x33\xEF\xF7\x34\xF1\xD5\xA5\x21\xAB\x90\xFD\x99\xF1\x4B\x06\x41\x12\xAB\x40\x03\x1C\x4D\x12\x4A\x56\x7F\x4C\xDC\x4D\x45\x5D\x7C\x04\x06\x4E\x45\x43\x77\x78\x4A\x79\x84\x02\x58\x46\x70\x80\xEA\x4D\x06\x74\x76\x45\x7F\x4C\x76\x77\x4A\x7C\x60\x00\x86\x05\x9B\x5B\x51\x49\xD7\x70\x49\x76\x88\xDD\x5F\x76\x8A\x53\x76\x08\x5F\x77\x48\x02\x06\x44\x7A\x79\x1A\x68\x70\x01\x55\xF6\x4E\x80\x78\x7C\xEA\x6C\x70\x46\x7B\x4B\x54\x70\x90\x44\xD4\x53\x79\x7E\x7A\xF3\x50\x46\x7E\x52\xFF\x7F\x86\x40\x1C\x3F\x5B\x6B\x46\x81\xE1\x62\x71\x95\x7D\xF7\x49\x94\x4E\x80\x02\x52\x4D\x41\x43\x33\x7C\x7F\x42\x7F\x62\x9C\x8B\x7A\x41\x6A\x8B\x55\x96\x02\x06\x7D\x88\x80\x00\x23\xB2\x8B\x53\x81\xFA\x70\x9D\x7E\x74\x05\xB3\x44\x98\x00\xF6\x7E\x47\x80\x77\x75\x66\x5A\x8B\x48\x28\xBB\x7F\x9D\x95\x28\xB5\x5B\xA0\x00\x03\x14\x5E\x9F\x9A\x80\x94\x72\x63\x81\x4A\x5E\x73\x87\x61\x23\x7C\x9A\x7B\xA0\x04\xB5\x57\x82\x76\xDF\x4B\x88\x9C\x93\x00\x34\x92\x42\x9D\xA8\xB9\x95\x8B\x9E\x5D\xBF\x34\xA9\x81\xA7\xBF\x4A\x80\x4D\x0D\x85\x81\xA7\x59\x23\x42\x78\x8A\x86\x00\x3E\x63\x4F\x92\x42\xA6\x84\x92\x78\x10\x06\x41\x0E\x41\xCD\x82\x72\xB5\xAD\xF1\x53\xB3\x41\x7C\xEA\x56\xB4\xB5\xB6\xD6\x98\xBA\x79\xB4\x00\x04\x8E\x47\x14\x56\x40\x02\x14\x00\x55\x25\x68\x44\x81\x4F\x35\x4F\x14\x00\xED\x90\x10\x00\x7F\x1E\x68\x8F\x08\x00\x3C\x00\x07\xBF\x0F\xD2\x8E\x51\x07\x80\x35\x64\xB8\x47\xB9\xE9\x8B\x4B\xB8\xBC\xEE\xA5\x6C\x10\xC2\xE4\xBC\x76\xBC\x00\xFC\xB7\xBE\x0C\x60\x06\x06\x44\x04\x4F\xED\x8D\x10\x02\xBC\x0B\xFC\x78\x14\x00\xEF\xBC\x7D\xC4\x00\x1A\xF4\xB5\xBB\xBB\xF1\xB3\xB5\x4F\xC3\xF9\xB7\xB7\xBD\x8E\xCF\x40\x07\xC6\x40\xE4\xA2\xB0\x03\x11\x00\x23\xC1\xC9\xCE\x2A\xE5\xC5\x4C\x46\xEF\x8B\x4B\xC1\xBB\x0D\xE7\x86\x42\xCB\xFA\x80\x03\xC5\xA5\x6F\x46\x49\x6E\x40\x22\xFD\xCA\xCA\x47\x40\xC8\xC2\xBE\xC9\x30\xC9\xD9\xBC\x8A\x2D\x80\x0E\x84\xD4\x3C\xFC\x7E\xCC\xD5\x20\xCA\xCC\xC2\xCA\x59\xD2\xC0\x02\x53\xAE\xAB\xDE\x9D\x14\xE8\x80\x01\x4F\xC2\x69\xC0\x0D\x0C\x00\x15\xD7\xB2\x78\x8A\x1E\x71\x4E\xCF\xBF\x02\x5B\x1F\x45\x0B\x00\x3A\x12\xDC\x00\x84\xDA\x10\x00\x0C\x88\xC0\x09\x0C\x00\x3A\x00\x0E\x09\xD9\xF7\x84\xED\x14\x00\x2B\x16\x92\x43\xA0\x82\x71\x48\x44\x46\x47\x73\xD1\xDC\x7F\x13\x06\x42\x08\x00\x82\xDE\x18\xBE\xD2\x00\x27\xE7\xE6\x0A\xAD\xC0\x0C\x1C\x00\x27\x28\xE0\x02\xEA\xF9\x93\xC5\xEF\xEB\xB4\xD5\x72\x43\xD3\x9A\xE5\x69\xC4\xC9\x53\xE5\xB7\xEA\x40\xF7\xAD\xC0\x01\x08\x8D\xC4\xE8\x0A\xED\xAA\xD5\xEC\xEB\xE5\xB3\xC4\xE9\xE9\xD2\x84\xD3\xC4\xF5\xF3\xD0\xD3\xF0\x01\x0A\x00\x30\xE4\xE0\xE1\x6A\xDD\xDF\xD6\xDB\x8D\x66\x7E\xE7\xE1\x2C\x07\xDB\xEB\xBD\xCC\xF7\xB2\xE3\x42\xEA\xE5\xB1\x4E\xFC\x00\x0F\xF7\xF7\xBD\x97\xDB\xFC\xFD\xF7\xFF\x7E\x7C\x00\x17\x7F\x7F\xEB\x5A\x7F\x7B\xE1\x69\x68\x01\x83\x89\x69\x89\x6D\x68\x42\x64\x3E\x61\xB9\x24\x06\x20\xFD\x77\x73\x75\x13\x77\x6F\xE9\x35\x70\x05\xA4\x52\x27\x5E\x75\x37\x5E\x8F\x04\x76\x71\x98\x09\x73\x71\x8D\x6F\x71\xE4\x13\x7F\x5C\xE9\x57\x70\x7C\x99\x73\x77\xE9\x33\x75\x77\x41\x71\x3D\x24\x4E\x24\x5E\xBC\x31\x2B\x20\xFE\x0C\x69\x69\x07\x59\x70\xF0\x71\x3F\x58",
"\x81\x0E\x2F\x63\xC4\x46\x58\x00\x0F\x06\x20\x24\x8B\x2A\x89\x93\x67\x5F\x99\x34\x24\x5C\x1F\x52\x23\x26\x6D\x6F\x19\x09\x1D\x84\x83\x7C\x4E\x8B\x43\xAC\x67\x89\xB9\x60\x83\x51\x2F\x85\x5C\x26\x93\x75\x88\x62\x33\x2D\x6B\x5B\x00\x05\x83\x5E\x83\x8F\x19\xB3\x23\x62\x31\x89\x8C\x26\x55\x26\x8C\x14\x80\x0F\x59\x8F\x42\x21\x8E\x77\x94\x8C\xE4\x6F\x85\x26\xBF\x6A\x65\x83\x91\x7D\x81\x90\x01\x5D\x4C\x42\xB3\x75\x83\xFC\x30\x6D\xBA\x22\x78\x90\x42\x8B\x95\x49\x8C\x9D\x83\x23\x87\x7F\x72\x00\x21\x74\x67\xE9\x5C\x3D\x25\x8A\x9C\x54\x65\x74\x22\x93\x84\x98\x22\x04\x98\x23\x94\x42\x65\x95\x91\x1D\x9A\x23\x81\x1D\x81\x90\x00\x1A\x8E\x8E\x4F\x94\x27\xF9\x7A\x88\x8C\x73\x50\x20\x4D\x2A\x76\x35\xDB\x5D\x80\x00\x5E\x82\x95\x83\x5A\x82\x33\xC7\x64\x5D\x53\x9A\x14\x43\x29\x6D\x6B\x9B\x77\x1E\x50\x23\x0A\x52\x74\x8F\x00\x15\x06\x41\x71\x8C\x99\x18\x5F\x56\x9A\x13\x69\x93\xF2\x45\x92\x8E\x25\xA8\x95\x83\xCC\x7F\x60\xFD\x67\x3F\x23\x73\xA3\x9A\x9D\x47\x59\x53\x29\xB2\x74\x91\x74\xAA\x60\x53\x55\x49\x99\x13\x80\x0D\x9A\x6A\x8F\x9B\x24\xE0\x52\x99\x33\xDF\x9B\x29\x28\xBF\x94\x26\xFC\x36\x37\xF9\x44\x92\xA0\x6F\x95\x9B\x29\x13\x68\x99\x09\x4A\x97\x9E\x39\x4D\x91\x9A\x15\xAC\x4E\x93\x33\x23\x72\x1A\x00\x24\x22\x71\x91\x4E\x46\x8C\x91\x9C\x42\xA7\x71\x5F\xA7\x7D\x81\xDF\x44\x72\x95\x41\x9D\x82\x52\x80\x5D\x83\x1E\x04\x9F\x62\xA2\x37\x4A\x56\xE0\x2D\x94\xAC\x30\x44\x44\xF0\x33\x90\x00\x7D\x04\x93\xF3\x1D\x87\x74\xB5\x69\xA4\x9E\x44\xAC\x77\xE9\x5A\x82\xA6\x9A\xBC\x9B\x9A\xCE\x80\x54\x21\xE2\x9C\x52\x87\xBF\x9C\x4B\x1D\x81\xA9\x52\xCA\x77\xA9\x95\xBE\x65\x95\x85\x50\x23\xA1\x05\x4A\x51\x98\xB1\x73\x62\x47\xA0\x7D\x2C\xD8\xA9\xA2\x79\xB3\x26\x43\x74\x41\xA7\xA3\x0D\x95\xA5\xAD\xB1\x72\xA5\x87\x7F\xAA\x4B\xA9\x46\xAD\x99\x9D\x85\xA6\x2F\x5B\x39\x8C\x33\x53\x24\x9D\x81\xB3\x55\x3D\xA6\x47\x4F\xDA\xA9\x7E\x93\x8D\x87\xAE\x48\xA7\xAC\x64\xDA\x8E\xAE\x72\xBD\x99\xAA\xD6\x8D\x95\x55\xFE\x92\xAB\xC5\x8E\xB4\xAB\x84\x9E\xAB\x21\xFB\xA1\xAD\x86\x23\xA9\x51\x35\x33\x51\x52\xE8\xA4\x90\xB5\x9F\x27\xA7\x22\xAE\xAE\xEF\x64\x91\xB7\x39\x7B\x9D\xB6\x8D\x93\x72\x0D\x00\x06\x11\x6D\xB4\xB3\xAE\x1B\xAC\x76\x38\xA7\xA0\xB2\xD1\xAD\xA2\x9C\x30\xBC\x29\x53\xFF\xA7\x71\x10\x42\xB1\xB1\x4B\x26\xB2\x73\x88\xBA\x4F\x50\x44\x94\xB1\x43\xB1\x76\x51\x8E\x9E\xB0\xD6\x8B\xBE\xB2\x50\xA4\xA1\x61\xFB\xAB\xB2\xCC\xB4\x51\xAB\x9F\xA9\x6B\x52\xDB\x85\x90\x96\x93\xAE\x92\x7E\x3C\x48\xA2\x5B\x4A\x2A\xB3\xA7\x76\xBB\x08\x8B\xAC\x6C\xC0\xBC\x91\xBC\x64\x9B\x9D\x76\x5A\x20\x45\x80\xC4\x26\x8D\x13\x77\x59\x23\x1E\xB4\x3C\xBC\x45\xC0\xE1\x84\x93\x9D\xEB\x71\x24\x58\xAF\x91\xB8\xFD\x8F\xC5\x3C\xEC\x9A\x22\x3E\x82\x20\x9F\x86\x08\x49\xB8\x18\xAD\x3E\x6C\x87\xC8\x81\x3F\xBF\xB9\x9E\x55\x55\xAE\xF0\x44\x73\x6D\x72\x53\xC1\x59\xB0\x8F\xB7\x85\x9E\xC2\xB7\x0D\xFF\xB0\x9F\x17\xB7\xB4\x7F\xD4\x34\xC5\xDE\xA6\xC7\x63\xB8\xA1\xBA\x8A\xC4\xBB\xBC\xBC\x86\x97\xB8\x84\x89\xB9\x74\x80\x05\xB2\xC0\x93\xB8\xA7\x26\x52\xBB\x4D\x83\xBE\xA7\xEB\x82\xAE\xB1\xDB\xAE\x9F\x7D\x90\xBD\xC9\xA7\x83\xA7\xA1\xE3\xB4\xA9\x78\xE0\xCC\xAC\xC6\x84\xBF\x5E\x5D\xB9\xAF\x68\xE2\x95\xB4\xF9\xA4\xA9\xB5\xF6\xAA\xA9\x6B\x84\x92\x96\x42\x81\xCC\x91\x14\xB7\xCC\x75\x18\xAA\xCF\x5E\xB7\x04\xB7\x0A\xCD\xAD\x8A\xFB\xA4\xC9\xD0\xAA\xC8\xC9\x2F\xA0\x58\x21\xDD\xC6\xA7\x58\x54\xC9\xCA\x7B\xBB\xA7\x73\xD5\xB5\xCD\x2B\xC9\xA9\xCB\x91\xBB\xCB\x51\xDD\xC7\xB2\xF1\xAF\xBD\x83\xE5\xBE\xD2\x67\xF6\xA8\xCC\x43\xC7\xCF\xD3\xAE\x86\x53\xAA\x28\xB5\xBE\xAE\x0C\xAA\xB2\x69\xB4\xCC\x5B\xFD\xC3\x26\xFF\x8B\xC1\xC3\x00\x3B\x9C\x81\xBE\x46\xA1\x29\xA9\x4D\x40\x77\x23\x50\x43\xA5\x3C\xC0\x1F\x51\xA6\x96\x25\x1D\x6B\xC7\x74\x3E\x94\x2A\x4D\x95\x8C\x18\xC0\x4E\xB3\xC1\xB3\x72\x19\x00\x00\x0C\x81\xCC\xDB\x94\x32\xBA\xC4\xCA\x8E\xAD\x54\x5C\x48\x57\xAE\x0C\x4C\x55\x56\x98\x4E\x4C\xF1\xBC\x23\x4F\x9B\x9D\xC3\xE8\x15\x4E\xDC\x59\x49\xDD\xA5\xCC\xB4\xD6\x54\xE8\xD8\x98\xF5\xD6\xC1\x07\xDA\xD1\x4D\xE0\x83\xC0\xC5\x8D\x81\xA1\x69\x34\xC5\x4B\x5E\xD0\x27\xD7\x0A\xA6\x23\xB0\xA2\xC3\xD0\x89\xB9\xCB\xC7\x34\x3C\xCC\xC4\x9C\xA0\x00\x6B\xCE\x00\xA4\x37\xD6\xA2\x90\x84\xDB\x75\x34\xE7\xD5\x95\x4A\xC3\x27\xAB\x8C\xD7\xB0\x28\xCB\xCA\x9C\x92\xD4\xB8\x61\xF3\xDD\xB1\x4B",
"\xF2\xCA\xCB\x2F\xEC\xCA\x53\x9D\xD4\xCC\xCD\xA3\xCF\xAA\xA3\xD1\x74\x68\xC6\xCE\xBD\x09\xEA\xD3\xBE\x65\xAA\xB8\xAC\xF3\xCA\xDE\x41\xCD\x90\xAE\xAB\x60\xCB\xC4\x8E\xC6\xAE\x8F\xFD\xE3\xAF\x21\xE4\x92\xB7\xCC\xBD\xD0\x9E\x94\xD2\xCA\x8E\xD0\xBA\x75\xE8\xBD\x83\xEC\x85\xA9\xE6\x9B\x9A\xD3\xA2\xB3\xE7\xE6\xA9\xB6\xE7\xCB\x38\xF6\xC8\xA9\xC5\xB7\xD0\x54\xED\xCF\xB4\xF4\xAA\xD3\x6A\x90\xBE\xB5\x3A\xD0\x93\xE9\x0F\xF8\xC4\x88\xBA\xCA\xEE\x46\x93\x73\x06\x80\xDF\xC6\xD1\x9B\xE3\xB9\x8E\xE6\xD7\xE9\xC8\xB2\xEE\xCC\xD4\xE5\xE5\x47\xE7\xE2\xD6\x4F\xCE\xF3\xD6\xC0\xA6\xD2\xED\xA0\xED\xBB\x5C\xC4\xEC\xDA\xE6\xE4\xBD\xB2\xD6\x99\xE7\x67\xCC\xEF\xC7\xA4\xB1\xBE\xB8\xC1\xEB\xC9\x62\xFD\x81\xDD\xB3\xDB\xE8\x2D\x80\x7F\x63\xE0\xD9\x55\x82\x2E\x94\xDC\x21\x41\x24\xC3\xE1\x58\x57\x9D\x63\xDB\x54\x21\x64\xC0\x6E\x82\xF1\xF7\xEE\xB4\xFD\xF7\x02\x43\xCB\x75\xFC\x45\xC9\x7B\xFA\xA9\xF0\xD5\x8B\xF4\x9C\x55\xF3\xD3\xCA\xD8\xE6\xEB\x95\xE0\xF0\x62\x31\xF6\xED\xEE\xA6\x53\xF8\x55\x7D\x55\x2E\x18\xB1\xFA\xCA\xE0\x3F\xF5\xE6\x93\xCA\xEB\xD7\x8F\x59\xBE\x02\xF2\xFC\x93\xE3\x22\xC5\xC6\xA8\xD5\xD4\xAF\xD7\x74\x0D\x84\x93\x7D\xA0\x67\x73\xC2\x21\x98\xD5\x1A\x5A\x21\x29\x4B\x6A\x7D\xED\x72\x79\x00\x0A\x6C\xD1\x6D\x6C\xB2\x50\x6D\xFC\x63\x6D\x7E\x78\x4D\xD8\x62\x78\x0B\x8C\x6D\x7B\x5D\x65\xC2\x72\x6E\xC4\x7F\x7D\xA8\x67\x6E\xC8\x1A\x6E\xDC\x5C\x5C\x0C\x71\x63\xE2\x4A\x81\x5A\x2C\x81\x5C\x79\x71\x23\x54\x1D\xAD\x47\x6F\x08\x5B\x74\x45\x71\x81\xF9\x43\x51\x7C\x7A\x71\x8C\x42\x70\xF5\x66\x70\xF8\x60\x6C\x5E\x3A\x70\x49\x73\x78\x24\x52\x75\x25\x05\x7E\x15\x8A\x2B\x17\x8C\x2A\xB7\x74\x4E\x41\x83\x7B\xDE\x7C\x2A\x7F\x70\x00\xA4\x01\x68\x47\x89\x2A\xBC\x2C\x2A\xC7\x79\x2F\xC9\x77\x78\xCC\x79\x64\x8A\x73\x75\xD0\x7D\x78\xE8\x74\x7D\xD2\x75\x65\x25\x87\x3A\xFC\x28\x5F\xDA\x7F\x84\xBC\x78\x81\x48\x71\x47\x66\x83\x84\x42\x23\x85\xD8\x7E\x74\x57\x89\x68\x93\x23\x72\x4E\x53\x80\x5D\x81\x69\x5C\x84\x69\xD7\x73\x86\x90\x55\x86\xBA\x76\x81\x49\x82\x24\xE1\x79\x87\x2B\x75\x7E\x76\x84\x69\xD5\x6B\x3A\xEC\x74\x88\xE0\x10\x7F\x6D\x70\x72\x8A\x75\x7F\xB1\x3F\x6A\xF8\x7E\x49\xFA\x73\x3A\xFD\x76\x23\x4A\x13\x5E\x02\x8C\x88\x26\x26\x80\x2E\x8D\x48\x80\x34\x4E\xA1\x84\x6D\xBE\x4E\x6B\xC1\x47\x18\x45\x83\x6C\xA5\x8D\x83\x12\x50\x84\x7F\x82\x84\x81\x85\x20\x45\x80\x7B\xB1\x88\x84\x51\x8E\x7B\x15\x70\x00\xC0\x7B\x83\x6B\x83\x8B\x75\x1E\x86\x55\x8C\x73\x71\x8C\x57\x42\x74\x72\x91\x77\x87\x28\x7E\x89\xE7\x54\x79\x49\x5C\x87\x47\x5E\x87\xDC\x70\x88\xB9\x85\x20\x5A\x43\x88\xC9\x84\x69\x86\x8C\x8C\x23\x1B\x84\xEB\x7B\x83\x87\x8B\x72\x8E\x83\x7A\xCD\x71\x67\xF6\x7D\x41\x95\x8F\x49\xFB\x7B\x66\x84\x4E\x7F\x51\x1B\x89\xB2\x6F\x53\xE1\x80\x1E\xAE\x7B\x4F\xBF\x85\x8D\x75\x13\x33\x46\x87\x8B\x50\x85\x7B\x05\x26\x83\x2B\x86\x1B\xA3\x83\x6C\xF7\x8E\x8F\xC1\x8E\x83\xD8\x87\x7E\x94\x62\x01\xFB\x43\x8F\x26\x20\x90\x08\x77\x18\x4C\x42\x10\xC3\x6E\x90\x10\x5E\x83\xA0\x82\x25\xFD\x6C\x48\xA5\x38\x7B\xAD\x8C\x63\xA7\x87\x70\x4F\x56\x45\x34\x15\x84\xAF\x6C\x8A\x1A\x9C\x80\xD4\x13\x31\x19\x92\x6D\xB2\x53\x91\xA4\x89\x92\x23\x63\x92\x6B\x49\x83\x02\x1E\x46\x70\x41\x93\x2E\x93\x68\xFF\x64\x70\x8D\x4C\x90\xB8\x7F\x81\xA6\x82\x45\x22\x9A\x46\x96\x1A\x4B\x06\x17\x92\x3B\x82\x94\x3D\x8D\x93\xEE\x6D\x48\xB5\x83\x70\x4F\x96\x8A\x46\x9F\x13\x33\x10\x3C\x38\x9B\x94\x00\x7B\x71\x09\x99\x75\x94\x6A\x8F\x4E\x6A\x90\x2B\x70\x91\x34\x97\x94\x33\x10\x93\x4A\x91\x47\x16\x9F\x7E\xAD\x2D\x90\xDC\x80\x00\x02\x7B\x96\xD7\x45\x95\x57\x49\x6B\x37\x94\x48\x6A\x9F\x96\x13\x34\x51\x34\x77\x55\x40\x90\x5E\x9B\x76\x4D\x64\x94\x97\x48\x92\x10\x69\x90\x98\x56\x52\x55\x7B\x9B\x4F\x7D\x92\x55\x51\x9D\x98\x82\x95\x96\x56\x90\x00\x58\x98\x97\x88\x9C\x59\xE0\x48\x37\xBA\x68\x61\x01\x60\x97\x9B\x95\x6C\x1F\x13\x98\x0D\x65\x97\x83\x27\x98\xB7\x6D\x99\x13\x36\x6B\xC4\x68\x6B\xE5\x7B\x6B\xA1\x92\x99\x75\x9D\x36\x59\x91\x47\xAE\x9A\x11\x8B\x98\x7B\xF5\x6F\x97\x4A\x7D\x77\x20\x94\x94\xC0\x44\x98\x6F\x59\x94\xEC\x53\x6C\xF5\x67\x9B\x26\x82\x5B\x51\x95\x83\xB0\x94\x13\x95\x99\x93\xBB\x92\x83\x2B\x94\x99\xF6\x8C\x8F\x67\x8C\x2A\x16\x03\x9D\xD3\x82\x8B\xF8\x87\x4D\xBE\x94\x45\xA3\x94\x13\xA3\x86\x9A\xDB\x71\x6E\xDA\x96\x90\xAC\x30\x8B\xD9\x98\x8B",
"\xE6\x9A\x9B\xE3\x92\x7B\xFD\x85\x7C\x75\x19\x46\xDF\x93\x13\xE0\x23\x9B\xFB\x89\x9E\xEF\x98\x81\x75\x4B\x4F\xB5\x49\x47\xE5\x4D\x4B\xD6\x6E\x47\x3B\x85\x4B\xE3\x88\x78\xF0\x50\x63\x15\x61\x59\x91\x41\x37\x94\x44\x7A\x08\xA9\x49\x91\x59\x8E\x97\x8C\x7F\x2F\x6C\x48\x09\xAB\x49\xAA\x44\x4E\xAC\x4E\xA0\x16\xA0\xA1\xDA\x75\x4B\x5A\x4D\x92\x08\x85\x25\x0A\x82\x93\x05\x70\x00\x80\x7F\x80\x3B\x8F\x91\x34\x1A\x62\x14\x84\x9D\x6C\x85\x20\xF0\x68\x6E\x3E\x14\x82\x91\x5D\x6E\x1F\x60\xA1\x21\x81\x6F\x35\xAC\x72\xCF\x97\x82\xF3\x42\x4E\x2A\x8F\x6B\xBC\x93\x4F\xDA\x7C\xA2\x33\x16\x63\x38\xA2\x5B\x21\x6B\x95\x0D\x86\x6D\xE0\x32\x78\x4C\x91\x9D\xE2\x4B\x10\xC3\x3D\x62\x1B\xAC\x66\x14\x6E\xA1\x6C\x53\xA5\x34\x17\x8D\x6E\x99\x8D\x85\x81\xA6\x62\x90\x1E\x1D\x5A\x88\xE0\x8A\x97\x7B\x51\x7F\x90\x8E\x7C\x92\x87\x54\x12\xA2\x3A\x14\xAB\x57\xEE\x80\x80\x9C\x8C\x56\x72\x9A\x45\xAA\x95\x9B\xB3\x57\x9A\x0D\x69\x88\x09\x62\xA5\x9C\x9D\x60\x2A\x60\x61\xF6\x3E\x76\x5B\xA8\x82\x32\x6D\x41\x7C\xAA\xA4\x3C\x8B\x67\x31\x80\xA4\x14\x7A\x4D\x3E\x6B\x83\xC5\x9C\x71\x28\x56\x85\xEC\x82\x87\x7D\x55\x87\x6F\x9E\x85\xE3\x7A\x58\x6A\x7D\x72\x96\x78\x5F\x61\x71\x73\x9C\x6E\x79\x8F\x70\x6A\xAA\xA3\x79\x66\x6F\x3E\xA2\x76\xA0\xA4\x4F\x73\x6F\x6D\x6A\xA8\x71\x73\xAB\x7B\x5F\x45\xA9\xA4\x3F\x88\x9D\xE4\x9A\x9E\xF0\x96\x97\xF7\x9F\xAB\xF9\x9A\x84\x00\x0E\x51\xBD\x8A\x86\x30\xA0\x8C\x4C\x7A\x73\x6F\x8A\xA9\x88\x66\x8C\x4B\x68\x8C\x65\xA0\x69\xCB\x82\xA6\x60\x8E\x8C\xB1\x30\x8D\xF1\x84\x48\x05\x91\xAC\x36\x68\x4B\x60\x43\x2C\xB9\x43\x13\xDA\x21\x1F\x22\xAB\x6D\x55\x2F\x25\x23\xAD\x48\xC2\x1C\x01\x3A\x10\x25\x9B\x9E\x93\xC1\x56\x24\xF4\xAC\x48\xC2\x1E\x01\xF1\xA2\x1E\x5D\x95\x7D\xE0\x1D\x35\x72\x92\x1C\x1D\x4A\x37\xF2\x1C\x98\xAD\xA6\x34\x02\x1E\x69\xC2\x17\x3C\xB5\x2B\xA7\x83\xAE\x23\x3B\x28\x6B\xC2\x14\x41\x04\xB9\x77\xD0\x98\x47\x97\x27\xB1\xE6\xA6\x10\x26\x0B\xAF\xFF\x08\x9E\xC4\xA5\x9D\x42\x27\x2B\xF8\x92\xB2\x05\x22\x1C\xCF\x34\xB0\x10\x0C\x34\xCB\x12\x1C\x25\x1A\x2D\x30\xB1\xB3\x31\xBB\x1C\x6D\x39\x35\xDA\x25\x12\x2F\xB6\x29\x02\x17\x49\x43\x24\x13\xC2\x12\xAE\x73\x48\x19\x83\x26\xB3\xD6\x28\xB3\xD6\x28\x2C\x1D\xA4\x1D\x3F\xBC\x9F\xE5\xA3\x1C\x02\x14\xB4\xD3\x26\xB4\xD3\x28\xB4\x98\x4A\xB4\x3A\x2C\xB4\x60\x43\x10\xA3\x10\x93\x50\xB2\x2D\x52\xB2\x2D\x54\xBD\xB3\x1B\xB6\x44\x58\xB1\xB4\x98\x15\x12\x3F\x47\xB3\x32\xB4\xAE\x59\xB7\xB5\xB8\x75\x4B\xCB\x19\x35\x28\x2E\xB2\x06\x11\xA8\x94\x2B\xB6\x64\x1D\xB6\x64\xBF\xB6\x4D\xBE\x5F\x76\xBA\x2D\x40\xBA\x44\x69\xB2\xB3\x7C\x97\xB0\x32\xB7\xB8\xDD\x23\x1A\x38\x48\xB8\x5A\xBA\x13\x59\x3E\x5F\x74\xB2\x10\xFE\x5F\xB8\x06\x10\xB9\xD6\x25\xB8\x81\x9B\x14\x5D\xBB\x29\x07\xB7\x20\xC2\x16\xB1\x92\xAC\xB8\xA2\xB9\xB8\x3A\x1E\x5F\x55\x18\xB8\xCB\x12\x18\x6D\x3A\x2D\x59\x3E\x14\x96\xB3\x2D\xA0\xB2\x5B\x4E\x1F\xB7\x97\xB6\xB0\x99\xB1\x2C\x34\xB6\x10\x5D\xB2\x1C\x3F\x4E\xBA\x84\xB1\xA9\xB2\xB5\xB7\xBF\xB8\x7B\x90\x9B\x22\x47\xB6\x10\x3C\xB6\x4A\x63\xB8\x3E\x1A\xAD\xB4\xCB\x13\xB4\x32\xBD\xBB\x95\xB3\xBC\xC7\x95\x25\xB3\xB4\xBD\x0D\x58\x99\xC6\xB3\xB5\xC8\xB9\xA8\x3E\xBE\xB6\xCD\xB0\x46\xCB\x10\x3C\xBB\xB6\x10\xD2\xB2\xB9\xD8\xBF\xA8\x34\x17\xBD\x31\xB8\xB9\x89\x96\x4D\x39\xB1\x33\xC9\xBE\xAE\xE0\xB6\x4C\x98\x17\x3E\x5D\x3A\x2D\xE7\xBA\x99\xED\xB0\xBC\xD6\xB2\xBC\xFD\xB4\xBC\x07\xB1\xBF\xC1\x33\xBF\xC1\x5F\xB9\xF3\xA3\x95\x8C\x4B\x1C\x45\x82\x18\xFA\xB0\xBE\xAF\xB2\x2D\xB1\xBF\xBF\x02\x14\xBB\xB0\xB6\xBB\xEF\xBB\xBD\x60\xBD\xBD\x0F\xA6\xB5\xE8\xB1\x94\x0F\xBF\x11\xCB\x1C\xB5\xD1\xB0\xC1\xE9\xB5\x6F\xEC\xB0\xB3\xEE\xBA\xBD\x23\x14\xC0\x61\xBA\xBC\xFD\x25\xB6\x4A\x42\xB3\xCF\xB6\x10\x83\x2A\xB6\x02\x14\xC0\x83\x2F\x76\xAB\x61\x77\x93\x28\xC0\xB8\x9B\x74\xD2\x2B\x1C\x25\x10\x3C\x38\xC0\xB3\x11\xBD\x99\xC2\x1E\xB0\xA0\x99\x1E\xA3\x12\xB7\x45\xB0\xC0\x77\xB1\xB3\x49\xCD\x60\x4B\xCF\x99\xB8\x6E\xB7\x32\xBC\xC4\xB8\x63\xB8\x01\xC7\x99\xE6\x51\x2C\xA8\xBA\xB8\x06\x15\x84\x47\xCA\x2D\xF6\xAA\xC0\x1E\xCD\xA7\x52\x99\xA3\xF0\x1F\x43\xFF\x00\xC5\x51\xB2\xC5\x5E\xCB\xC1\xD0\x1E\xC6\xDF\xBD\x34\x20\xC7\xAF\xD4\x1A\xC5\x5F\xCB\xA4\x55\x25\xC7\xDA\x2B\xC2\x61\xC7\x10\x59\x37\x3E\x91\xB0\x00\x1D\x06\xBE\x32\xB9\xC6\x78\xCB\xBC\x4E\x9F\xC8\xFC\xBA\xC8\xE9",
"\xBE\xA5\x33\x1D\xB5\x55\x12\x82\xF2\x6E\xB9\x1F\x2E\x91\x26\xAD\x48\x71\xC6\x10\x88\xC6\x10\x25\x17\x3E\x82\xCA\xB3\x6D\xC2\x5B\x40\xC7\x62\x7C\xC4\x13\xFE\x53\xCA\x17\xCB\xC7\x6A\xC4\x13\x98\xC7\x25\x3C\xA0\x11\x1C\x82\x1C\xE9\xAB\x91\x6B\xC3\xBA\xCA\x13\x1A\x83\x20\x93\x47\xC4\xC0\xBF\x2F\xC3\xA8\x11\xC4\xBB\xAC\xB8\xCB\x1D\x35\xE0\x2E\xCB\xCE\xCA\x13\xA3\x18\x22\xA3\x87\xC4\x4E\x10\xCB\xD2\x2B\xCB\x2A\x99\xC7\xA9\xB6\x10\xAB\xB1\xC5\x7B\xB6\x93\x30\xB8\xCD\xAA\xC0\xCD\x3A\x18\xBF\x32\xBD\xBA\xA2\xC2\xB3\xE2\xC5\x25\x2E\xCC\xC1\x49\xB9\xC7\x6C\xC6\xC9\xCF\xC4\xBA\x03\x15\x15\xCD\xC7\xB8\xCB\xC3\xBD\xA2\xB5\xC3\x02\x1F\x97\xAC\xB0\xBE\xC2\xC5\xBB\xC8\xCA\xB1\x80\x12\x2C\x06\x11\x75\xC2\x1D\xAF\x5F\x86\x22\x43\xC4\xC6\x02\x1A\x8F\x67\xC7\xBC\x60\x39\xCC\xAB\xCF\xA3\xB2\x5F\x0F\x70\xC2\xC7\x5E\xB4\xC7\x8D\xC9\xB1\xA1\xB5\xD1\xEA\xB5\x6B\x52\xC3\xC8\xFE\xBD\x48\xA7\xC1\xCB\x60\xCE\x69\xA1\xC2\x10\x1D\x9B\xD1\x02\x1B\xC8\x02\x17\xD2\xC1\x35\x6F\x20\xD5\x6F\xFE\x50\xD3\x2A\xC5\xD2\xC1\x5A\xC3\x06\x13\xA4\x21\xD7\xCD\xFB\x48\xA4\x86\xC6\x10\x2D\xD9\xC8\xA6\xCD\xD1\x13\xD4\xD0\x35\xDB\x74\xAF\xC7\xC2\x4B\x7C\xD3\x65\x27\x50\x44\xAA\xD4\x9D\xCA\x93\xED\xA7\xC0\xF3\xC4\xCE\x03\x13\x28\x15\x02\xB3\x5F\xB6\xD0\x02\x18\xD0\x4E\x3E\xAB\xEE\x96\xB2\x75\x1A\xCC\xA3\x1D\x36\xD7\x93\xCF\x44\xC6\x10\x17\x0E\xD5\xD4\xB2\xD4\xBA\xC1\xD4\x9F\xC8\xD5\x59\xD8\xCF\xA3\x1E\x14\x18\x0C\xD6\xC0\xC6\x10\xFE\xC6\x2D\xE8\xC2\x10\x5D\xD1\xB3\x20\xB5\xD6\x31\xA5\x17\xC4\xC7\xD0\x8A\x69\xD0\x64\xAE\x95\x2B\x73\xBA\xE3\xB6\x10\x19\x00\xD7\x39\xC6\x2D\x34\x2A\x89\x4B\x1C\xD8\xB8\x71\xB0\xCF\xCD\xD6\x02\x1A\x01\x94\xD0\xB3\x24\xB1\xB2\x87\xD2\x2D\x85\xDD\x7D\xDB\x9B\xD2\x43\xD2\x10\xD6\xC5\x12\x38\xD2\xD3\xA3\xD6\xD8\xCC\xA2\x1C\xA7\xD4\x8D\xE6\x97\xD3\x32\xB5\xDB\xE5\x91\xAC\xB5\xC2\x10\x9A\xCD\xA3\x9C\xC2\x10\xEB\xC0\xCA\x87\xCE\xCD\xE0\xC0\xDB\x00\x35\xB2\xA5\xD4\xDB\x64\xD8\xDA\xB7\xD9\xCE\x84\xDD\xDC\xB6\xDC\xDB\x12\xD0\x00\xBF\xD8\xCB\x5C\x23\xD7\x9E\xCB\x93\xF4\xB8\xD7\x5A\xD0\x00\x1B\x01\xDA\xDA\x20\xB0\x6F\x9A\xD9\x5B\x88\xAD\x26\x2A\xDA\xAA\xD3\xD8\x2E\xD0\x00\xEC\xD2\xD3\xE4\xD8\xDE\x99\xDC\xCD\x8D\xDE\xAF\x26\x2E\x5F\xEC\xDA\x2D\x0A\xD1\xAA\x9A\xB6\x2D\x6D\x39\x72\xEE\x79\xDD\x63\xD8\x7B\xDF\xA8\x81\xAA\xD1\xD0\x95\xD2\x10\x30\x90\xDF\x20\x25\xAD\xF3\xD2\x10\xFB\xD1\xE0\xFE\x58\xE0\xD2\x21\xE1\x04\x8D\xB5\xFF\xDF\x96\xC1\xDC\xC6\x34\xD7\xD7\x77\xDD\xB2\x06\x18\xD3\x1E\xE7\xAE\xD1\xC6\x10\xD3\xC6\xDC\x4E\x12\xE2\xD6\x23\xDC\x76\xDB\xCD\x10\xE1\xDA\x29\xEA\xCE\x74\xDC\xDD\x76\xD7\xBF\x55\xDF\xCF\xDF\xCA\xE2\xD3\x2C\xE2\x8C\x4D\xCE\x3B\xBE\xBD\x90\xC9\xC0\x92\xCD\xB8\x03\x12\x1C\x1F\x03\xE2\x9D\xD3\x1A\xE6\xC1\xB3\x5F\xD8\xCA\x06\xC8\xAF\xC7\xCC\xCA\xB3\xCB\xB1\x20\xE2\x10\xCC\x38\xE4\xFB\xCD\xD7\xFD\xC1\xDA\x89\xD1\xD6\x8B\xD4\xDF\x9B\xD5\xDE\xDF\xDF\x0F\xC2\x16\xC1\x58\xE3\x2D\x2E\xED\x96\x4C\xE0\xBE\x66\xE0\xD2\xC5\xB8\xBB\x69\xDA\xBB\xE7\xCC\xE6\xE9\xBF\xE6\x05\xDE\xE4\x40\xE1\xC3\x7C\xB2\xBE\x5A\xE0\x00\xE5\xBF\xB4\x74\xEF\xC7\x5E\x69\xC1\x2D\xC5\xDD\x4F\xEB\xC6\x81\xB9\x1F\xA3\x14\xBE\x73\xEF\xCD\x6D\xE1\xE5\xD9\xB5\xC8\x3E\xEE\x4A\x1D\xC0\xCF\x89\xE0\x20\x4A\xE7\xE3\x80\xD1\xE8\x39\xD2\xC0\xB7\xB7\xE7\xF2\xB9\xE7\x20\xD2\xCF\x0C\xC1\xE5\x38\xEC\xBC\x8F\xEA\xC7\x29\xD4\x66\x93\xE7\xE8\xF0\xCC\xC5\x9D\x93\xC2\x72\xE1\xB3\x81\xD0\x00\xA9\xEC\xC6\x76\xED\xEA\xA2\xE5\xBF\xFF\x98\xE9\x3A\x12\x1C\x25\x07\xE6\xBE\xC5\xEA\xAA\xE3\xCC\x86\xEB\xEB\x1F\xC7\x62\x4D\xC4\xE4\x07\x12\x1C\xB5\x32\xEC\x30\xB9\xE6\xDD\xC3\xEC\xA3\x12\x1C\x51\xA0\xED\x63\xE2\xCD\xD8\xEB\xED\xDC\xED\xED\x87\xB0",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

			void XmlText::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlCData::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlAttribute::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlComment::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlElement::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlInstruction::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlDocument::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::parsing::xml;

			IMPL_TYPE_INFO_RENAME(XmlNode, system::XmlNode)
			IMPL_TYPE_INFO_RENAME(XmlText, system::XmlText)
			IMPL_TYPE_INFO_RENAME(XmlCData, system::XmlCData)
			IMPL_TYPE_INFO_RENAME(XmlAttribute, system::XmlAttribute)
			IMPL_TYPE_INFO_RENAME(XmlComment, system::XmlComment)
			IMPL_TYPE_INFO_RENAME(XmlElement, system::XmlElement)
			IMPL_TYPE_INFO_RENAME(XmlInstruction, system::XmlInstruction)
			IMPL_TYPE_INFO_RENAME(XmlDocument, system::XmlDocument)
			IMPL_TYPE_INFO_RENAME(XmlNode::IVisitor, system::XmlNode::IVisitor)

			BEGIN_CLASS_MEMBER(XmlNode)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(XmlNode)

			BEGIN_CLASS_MEMBER(XmlText)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlText>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlText::*)(), [](XmlText* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlText::*)(const vl::WString&), [](XmlText* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlText)

			BEGIN_CLASS_MEMBER(XmlCData)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlCData>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlCData::*)(), [](XmlCData* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlCData::*)(const vl::WString&), [](XmlCData* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlCData)

			BEGIN_CLASS_MEMBER(XmlAttribute)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlAttribute>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlAttribute::*)(), [](XmlAttribute* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlAttribute::*)(const vl::WString&), [](XmlAttribute* node, const vl::WString& value){ node->name.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(XmlAttribute::*)(), [](XmlAttribute* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(XmlAttribute::*)(const vl::WString&), [](XmlAttribute* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(XmlAttribute)

			BEGIN_CLASS_MEMBER(XmlComment)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlComment>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlComment::*)(), [](XmlComment* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlComment::*)(const vl::WString&), [](XmlComment* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlComment)

			BEGIN_CLASS_MEMBER(XmlElement)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlElement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlElement::*)(), [](XmlElement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlElement::*)(const vl::WString&), [](XmlElement* node, const vl::WString& value){ node->name.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_closingName, NO_PARAMETER, vl::WString(XmlElement::*)(), [](XmlElement* node){ return node->closingName.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_closingName, {L"value"}, void(XmlElement::*)(const vl::WString&), [](XmlElement* node, const vl::WString& value){ node->closingName.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_PROPERTY(closingName, get_closingName, set_closingName)
				CLASS_MEMBER_FIELD(attributes)
				CLASS_MEMBER_FIELD(subNodes)
			END_CLASS_MEMBER(XmlElement)

			BEGIN_CLASS_MEMBER(XmlInstruction)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlInstruction>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlInstruction::*)(), [](XmlInstruction* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlInstruction::*)(const vl::WString&), [](XmlInstruction* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(attributes)
			END_CLASS_MEMBER(XmlInstruction)

			BEGIN_CLASS_MEMBER(XmlDocument)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlDocument>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(prologs)
				CLASS_MEMBER_FIELD(rootElement)
			END_CLASS_MEMBER(XmlDocument)

			BEGIN_CLASS_MEMBER(XmlNode::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<XmlNode::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::XmlNode_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlText* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlCData* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlAttribute* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlComment* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlElement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlInstruction* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlDocument* node))
			END_CLASS_MEMBER(XmlNode)

			class XmlTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode)
					ADD_TYPE_INFO(vl::parsing::xml::XmlText)
					ADD_TYPE_INFO(vl::parsing::xml::XmlCData)
					ADD_TYPE_INFO(vl::parsing::xml::XmlAttribute)
					ADD_TYPE_INFO(vl::parsing::xml::XmlComment)
					ADD_TYPE_INFO(vl::parsing::xml::XmlElement)
					ADD_TYPE_INFO(vl::parsing::xml::XmlInstruction)
					ADD_TYPE_INFO(vl::parsing::xml::XmlDocument)
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool XmlLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new XmlTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}
