#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"class Node"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Text : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CData : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeCData);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Attribute : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n" L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Comment : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeComment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Element : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Instruction : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Document : Node"
L"\r\n" L"{"
L"\r\n" L"\tNode[] prologs;"
L"\r\n" L"\tElement rootElement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token EQUAL = \"/=\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n" L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n" L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n" L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n" L"rule CData XCData = CDATA:content as CData;"
L"\r\n" L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n" L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n" L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n" L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n" L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4917; // 18057 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 821;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x9F\x71\x02\x80\x01\x7F\x05\x06\x83\x20\x0F\x30\x00\x36\x86\x00\x72\x00\x05\x82\x87\x02\x83\x20\x00\x74\x19\x80\x0E\x20\x01\x30\x00\x6D\x00\x25\x27\x84\x8F\x81\x84\x81\x0B\x8D\x8F\x8D\x82\x8D\x90\x05\x8B\x1B\x9A\x96\x3E\x8E\x80\x01\x3A\x91\x24\x86\x88\x8A\x80\x8B\x95\x89\x89\x06\x96\x82\x94\x24\x9F\x30\x8E\x9A\x21\xA3\x84\x9A\x97\x90\x01\x95\x9A\x2C\xC0\x95\x86\x84\xA7\x8E\xA3\x8E\x1F\xC9\xB9\x83\x8D\xA7\xA6\x9F\x96\x41\xD4\x85\xA7\xA9\xA8\x9F\xA4\xAE\x3C\xAA\x90\x80\xB2\x87\x96\x80\x21\x10\xB7\xAE\x20\x04\x34\x9A\x89\x3C\x5B\xA6\xA9\xB0\xAF\x9E\x96\x82\xB8\x0D\xF2\xB4\xB6\xB0\x00\xBF\xB2\xBD\x28\xBD\xAB\xB2\xA0\x06\xB4\x00\xC0\x36\x80\x33\xB5\xBF\x8F\xB9\xBD\x9D\x89\xEA\x91\xBE\xBF\xB1\xBA\xC9\xC1\x95\x85\xD7\xDD\xAA\xC3\xCE\x82\xC7\x90\x82\xD4\xDF\x96\xC5\x90\xCC\xA7\xA5\xFD\xA7\xDF\xBE\xCB\xC8\xC3\xD6\x3A\x8C\x3B\xB3\xBA\x8B\x90\x3D\x8D\x5E\x8B\xC6\x97\xCA\xD9\xCF\xCF\xDE\x00\x3F\xDA\x81\xE1\xAB\xE3\xC3\xD7\xCC\xB2\xD3\xA6\xE1\x92\xAC\xDF\xC6\x06\x89\x30\x9A\x8A\x8A\x89\x34\x00\x62\x11\xC8\xFF\x74\xF0\xE8\x00\x22\x34\x9A\x9F\x85\xFF\x7A\xA0\xD9\x86\xD5\xB8\x97\xEC\xFE\xC0\xF5\x87\x31\x91\xD6\xDB\x8C\xFE\xF5\x21\x9B\x91\xFA\x5A\x4C\x7B\x02\x06\x49\x1F\x67\x1C\x1B\x52\x47\x4C\x7E\x1A\x5F\x7D\x43\x5C\xEC\x44\x06\x41\x47\x0D\x75\x5A\x51\x79\x12\x83\x58\x4E\x72\x07\x65\x7D\x01\x76\xDB\x49\x80\x03\x77\xE1\x77\x48\x71\x86\x9F\x65\x53\x4B\x70\xDA\x42\x48\x44\x77\x3F\x64\x82\x78\x4E\x4D\x76\x14\x4F\x43\x37\x63\x45\x48\x69\xE8\x5F\x4A\x78\x00\xEE\x78\x7F\x83\x46\x23\x73\x75\x7A\x7B\x4F\x71\x75\x93\x46\x41\x90\x47\x77\x92\x02\xA5\x75\x7C\x44\xF8\x77\x41\x80\x90\x06\x70\x1F\x4E\x66\x00\x06\x58\x80\x7D\x06\x76\x70\x01\x95\x20\x72\x7B\x44\x81\x02\x52\x4D\x41\x43\x1A\x7E\x7F\x40\x80\x66\x91\x94\x79\x7F\xFF\x65\x90\x94\x00\x0A\x06\x4E\x8E\x88\x32\xA6\x88\x4F\x97\x47\x86\x4E\x98\x4E\x57\xA8\x93\x98\x5F\x08\x9F\x73\x5F\x55\x48\x78\x43\x01\x58\x02\x43\xA0\x9F\x9D\x28\xB3\x5A\x88\x00\x02\x10\xA0\x02\xA4\x76\x87\x78\x76\x40\x08\xB7\x41\x78\x85\x83\x63\x40\xA0\x79\x86\x86\x83\x5C\x82\xDD\x51\x6C\x83\x88\x4E\xB8\x9A\x9D\x4C\x31\xA0\x73\x8E\xA9\x1D\xA8\xA5\x83\x81\x22\x8B\x8B\x46\x83\x9F\x55\xAD\xA3\x48\x28\xA8\x84\x52\x6F\x4C\x86\x42\x92\xA7\x77\xAC\x70\x06\x41\x31\x06\x4F\xB3\x70\xD4\xB9\xAC\x7B\x3F\xD5\x83\x47\xB4\x79\xD9\x96\xBC\x79\xB7\xDB\xA4\x73\xB4\x00\x06\x9D\x43\x14\x00\x44\x52\x10\x01\x15\xB0\x44\x56\x83\x13\x47\x5F\x10\x00\xBC\x50\x1B\xA7\x50\x8A\x2F\x00\x0C\x0C\x00\xF9\xBF\x04\xB5\x53\x11\x3B\xA6\xB8\xBA\x00\x2A\xBC\xBB\x42\xEE\xB3\xB1\xBC\x6C\x4C\x0A\xC7\xBA\x7F\xF8\x80\x0E\xBD\xBE\x3E\x0C\x66\x02\x41\x14\x3C\x40\xBD\x13\x00\x35\xBD\xC2\x7F\x58\x00\x02\xBE\x7F\x1F\xC0\x0C\xC6\x7F\x1D\x44\x52\xBC\xBD\xF6\x9D\x41\xC7\xBE\xF9\xB9\xB9\xA7\x74\x00\x19\xC2\x43\xB9\xE5\x80\x07\x10\x00\x25\xE3\xCC\xCE\xBD\x27\xC7\x5A\xC8\xC3\x0E\xF6\xB1\xC5\xCC\x00\x15\xCF\xA1\x5B\x06\x45\x76\xBD\xC9\x41\xE9\xC2\xCA\xC2\xF5\xA8\xC8\xA6\x41\xF9\xBB\xB8\x89\x8B\x00\x1F\x81\xA7\xCF\xFE\x51\xD4\xC2\xBC\x0B\x4D\xC0\xBF\xC3\x57\xC2\x44\xC4\x00\x4D\x79\x92\x41\x53\xFE\x51\x1B\xB8\x00\x18\x4D\xC3\xCC\xBF\x00\x3D\x00\x03\xC5\xDA\xA4\x78\x89\x47\x18\x41\xD1\xC2\x40\x5B\x34\x4D\x08\x00\x7A\x34\xD0\x03\xE1\x5A\x00\x00\x0F\xE2\x00\x39\x00\x02\x0E\x00\x2E\x03\xD5\xBE\x87\xDD\x10\x03\x0A\x58\x82\x46\xA2\x63\x18\x44\x54\x53\x4C\x75\xF3\xDE\x7F\x04\x06\x62\x00\x01\xE1\x5E\x3A\xB9\xD0\x00\xAA\xDA\xEA\x08\xEC\x00\x3C\x10\x03\x09\xAB\xC0\x0D\xEB\xBE\x15\xF8\xE2\xEF\xED\x9F\x80\x0E\xD0\x92\x0A\xDC\xC2\xD8\x51\xAA\xEA\xDE\xE9\xBE\x21\x10\xE7\xE0\x0A\xB9\xED\xE8\xE7\xEB\x9A\xF6\xE7\xE0\xEB\x78\xC7\xE5\xC5\xF5\xCE\xD1\xF4\xF4\x00\x29\x00\x03\xEF\xE1\x87\xEB\xDC\xD6\xD7\x6C\xFC\x48\x79\xE8\x8A\xEC\x08\xD7\xF2\x00\x0D\xF9\xBD\xE1\x0B\x6B\xF4\xC0\x46\xF3\xC0\x00\xF4\xF6\xF9\x9A\xEC\xF5\xFF\xDE\x60\x83\xFF\x00\x0A\x72\x00\x98\x7B\x7B\xE0\x62\x7C\xDE\x05\x84\x80\xBC\x55\x66\x6D\xD6\x46\x5A\xBD\x21\x64\x28\x12\x06\x23\x7F\xBA\x6E\x75\xC5\x7A\x6A\x74\xDC\x60\x00\x6F\x12\x39\x5F\x5C\x79\x5F\x47\xC3\x49\x70\x23\x8C\x6E\x70\xE4\x12\x74\x72\xCB\x72\x5B\x7A\x9A\x61\x7C\xE7\x36\x7A\x74\xDB\x78\x76\x50\xEC\x3B\x46\x41\x67\x55\x5E\x8C\x0B\x26\x3F\x4B\x78\x6C\x82\x1C\x7E\x68",
"\xF6\x11\x5C\x69\x02\x21\x65\x92\x1D\x57\x3A\x09\x06\x22\x89\x10\x2A\x4A\xA7\x16\x7A\x5D\x35\x5B\x27\x5C\x3F\x52\x22\x46\x68\x70\x08\x00\x1F\x86\x82\xFB\x50\x88\x7C\x4C\x8B\x23\x8A\x4E\x32\x8C\x65\x57\x49\x40\x49\x8F\x3D\x34\xB1\x4D\x72\x00\x18\x88\x61\x1A\x2E\x69\x2E\x9F\x81\x8C\x6D\x92\x8B\x75\x66\x8F\x89\x3C\xA4\x8A\x23\x10\x88\x8E\x1E\x9B\x26\x73\x68\x61\x7A\x20\x78\x8B\x8B\x95\x15\x64\x73\x0F\x8B\x23\x63\x26\x6D\x64\xC1\x1F\x8D\x91\x43\x43\x48\x39\xD7\x3F\x83\x47\x08\x4E\x91\x28\xBF\x88\x00\x5D\x87\x8E\x1F\xD7\x43\x5C\x41\x9F\x94\x8A\x10\x2C\x4E\xBD\x36\x38\x7C\x30\x80\x06\x94\x8B\x9E\x88\x28\x80\x0C\x6B\x90\x62\x4C\x4C\x85\x5D\x8F\x2D\xF9\x3F\x8C\xCB\x72\x00\x00\x60\x06\x20\x1E\xBB\x96\x4B\x37\x8C\x92\x96\x5D\x9B\x0E\x2C\xA1\x6A\x54\x00\x2C\x57\x27\xBE\x4D\x41\xAC\x14\x92\x96\x2D\x6A\x4C\x2F\x5E\x52\x96\xED\x1F\x80\x97\x37\x94\x9F\x83\xD6\x91\x35\x36\x9F\x8D\x0F\x65\xB6\x5F\x4D\x9F\x9F\x9B\x96\x10\x2D\x4D\x3A\x57\x4A\x93\xCE\x92\x94\x31\x9F\x92\x95\x73\x62\x57\x28\x15\x58\x25\x20\xF1\x81\x33\x51\x50\x26\x42\x70\x91\x59\x0D\x42\x9F\x94\x7E\xB7\x9C\x54\x00\xA7\x9B\x07\xCD\x74\x83\x0D\x5B\x27\x83\xDB\x91\x7D\x41\xF5\x79\x3C\x9A\x10\xA2\x96\x0C\xA3\x96\x37\xB5\x78\xA3\x82\x9C\x57\x4A\xA1\x9D\x8F\x47\xEF\x8B\x9F\x91\xB7\x4D\x90\x00\x06\x10\x41\xA1\x66\xA4\x4F\x4A\xA4\x76\xFB\x4A\x76\x1D\xC7\x21\x70\x7B\x6A\x9E\x52\x9D\x5F\x82\x32\xDC\x9A\x70\x18\x5E\x3E\x56\x7E\x43\x26\x3A\xFB\x4D\x55\x3E\x44\x49\x9E\xE4\x92\x94\xF4\x1F\x8A\x75\xB5\x6A\x77\xA2\x4C\xAF\x77\x53\x80\x0B\xA7\x82\xB6\x9E\x56\x08\xB8\x26\x3A\xA1\x58\xAB\x7F\xBF\x4A\x96\xE5\x91\xA8\xCC\x34\x7F\x82\xC0\x51\x96\x3F\xEA\x98\x3E\x4F\x09\x5F\x32\x46\x57\x51\xAA\x15\x73\xA9\xF8\x70\x9C\x93\x73\x84\x57\x8D\x4E\x6C\x98\xAF\x2D\x51\x9A\x58\x43\x4B\x8D\x05\xAD\x9B\x33\x8A\x47\x50\x69\x83\x48\xA5\x72\x68\x91\x60\xFB\xA0\x9B\xC2\xBE\xAF\x33\x2F\xAA\x77\xBE\x7E\x52\xA6\x59\xA6\xA9\x68\x37\xA3\x5A\x2C\xD5\xA1\x65\x17\x7C\x48\xA8\x47\xA3\xA8\xAD\x3F\xA5\x45\xA3\xB5\xA9\xAC\xB4\x7E\x5D\x5C\xB2\x9B\x92\x59\x82\xB5\x57\x8E\xA0\x5B\x5C\x22\x9D\xA5\xEB\x25\xA6\x9D\xBD\x80\x02\x0D\x00\x24\x22\x3C\xB5\xB5\x8C\x93\x72\x96\x64\xE4\xA4\xA7\xB3\xB2\x95\x92\x38\xBA\x2A\x4E\xE6\x9E\xB3\xA2\xA0\xB0\x39\xA2\xBE\xA4\xAC\x25\xB8\x39\xD3\x8A\xAA\xB8\x0E\x84\xB9\x44\xAA\x7B\xB5\x0F\x89\x9E\x9C\x57\xBE\x9D\x3E\xC2\xA1\xB9\x0F\x9C\xAA\xBC\xA5\x48\xA8\x00\x28\xB3\xB9\x7C\x53\xAF\xB2\x36\xA5\xBF\xA1\x6B\xA0\x57\x45\x64\x29\xA7\xB4\x7D\xB9\x02\xF4\xA2\x97\xDF\x9B\x8A\x56\xBE\xB8\xB7\x9D\x11\xBE\x75\xF7\x8A\x70\xB3\xF2\xA9\xBA\x56\xD4\xAC\xB9\xD1\x93\xBF\x56\xC7\xAC\xB6\x83\xC6\xA5\xBA\xB0\x97\xB9\xAA\x4E\xBA\x98\x76\xAB\xB3\xA6\xCE\x86\xA5\xAB\xE3\xB1\xC2\x79\xFD\x98\x9F\xF4\x96\xBA\xAC\x78\x66\xC1\x4D\xE8\xA2\xBE\xB5\x90\x24\xAD\xF6\xB8\x28\x7E\xDC\xB4\xB9\xB9\xB4\x25\xAE\xFE\xA1\x79\xC8\x61\xB5\xC4\x80\xA5\x97\xC3\xE8\xA0\xA0\x2A\xD6\x8D\x9C\x56\x86\x26\x95\x3B\xC4\xC5\x56\xA3\x25\x62\xEF\xBA\xC6\xAE\x93\x5E\x53\x6D\xE8\x97\x4A\x5F\xBC\xB2\xB1\x2C\xA2\xC2\x4B\xF2\xB3\xB8\x15\xC6\xB9\xB3\x97\x5D\xC1\x83\xD2\xB4\xC3\x05\xD5\x94\xA8\xB5\x54\xBB\x57\xC9\xAF\x83\xA5\xB4\x71\xC3\x50\xB9\xBC\x71\x9E\xCC\xC7\x25\xE2\xC1\x9E\x07\xBE\xA8\xAE\x6C\xC0\xA7\x14\xD6\xB7\xC0\xF1\xB5\x92\x8B\x8D\x20\xC7\x2E\x77\xBA\xB9\x72\xD2\xAE\x84\xB8\xCA\xCB\xEB\x1F\x41\x4F\x01\xD4\xCA\x31\xDC\xC5\xC1\x3F\xEB\xC7\xCE\x0A\xC4\xBF\x77\xBC\xAD\xB9\x34\xD0\xC1\xBA\x9F\xAA\xCF\x9E\xEB\xB7\xC3\x37\xD2\xAA\xC3\x70\xB3\xCC\x78\xCA\xCA\xCF\x3B\xE7\xBD\xC7\x6B\xC4\xD4\x8A\xEE\xB6\xD3\x2F\xED\xC0\x51\xF5\xA6\xD2\x8C\x88\xD4\xC6\x45\xFC\xBF\x83\x39\xD9\xAC\xB9\x0C\xB4\xB1\x57\x72\xB0\x20\x7D\x8F\xB4\x5F\xB1\xB1\x56\x2B\xE4\x13\xA5\xC3\xCB\x54\x6C\xC6\xD1\x56\x02\xD3\xB4\xB8\xF0\xAC\xC4\x72\x9A\xB2\xCC\x4E\xD3\xC7\xB9\x66\xD2\xC0\x99\xE0\xD3\xD4\xF6\x92\x67\xD4\xBF\xD1\xD9\x3C\xCB\xD4\xDB\x21\x4F\xD6\x75\x7A\xB2\xD8\xBB\xBF\x55\xDA\x4A\xD7\xDE\xCB\x08\xDB\xDB\x5B\xB3\x9E\xC3\x4E\xE4\xB7\xD3\xF2\xA8\xCF\xBF\xC1\xAA\xBC\x73\xEA\xB4\xB8\xAD\xBF\x82\xB2\x8D\xBD\xDD\xCF\x34\xB5\xD1\x1B\x33\xCB\x5D\xA7\xA0\x01\x81\xAA\xA0\xCB\x50\xDF\x92\xB5\xD8\xD0\xD0\x6D\xF2\x91\xD3\x9B\xA3\xCD\xA8\x80\xE7\xCD\x6F\xE2\xD5\xE0\xA5\xCD\xA8\xBA\x9C\xA9\xD5\xA9",
"\xB4\xCC\xD5\x21\xDB\xA8\xCC\xA6\xC6\xC3\x59\xF4\x73\xA6\xD9\xD7\xCF\xA0\xF1\x9A\x50\x5D\xDA\xB5\xE5\xB2\x96\xC5\xC2\x99\xE7\x4B\xA6\x0D\xA0\x59\x1A\x2E\x3F\xD1\xC9\x34\x90\x00\x11\x59\x64\x18\xE7\x58\xD3\x9A\x2F\xA5\x9C\xE9\xA9\x56\x98\x8F\xA0\xCB\xF6\x52\x6E\x76\x65\x77\xEA\x97\x9B\xA1\x44\xEC\x73\x74\xC5\x4D\x64\x5D\x1E\xFF\x83\xB2\x4F\x4E\x53\x38\xC4\x28\x64\x93\x97\xD5\xD8\xF7\x49\xDC\xA9\xDC\x45\x8B\x7C\x73\xA3\x79\x15\xAF\x22\x51\x94\xA3\x4F\x1F\x28\xA7\x08\x50\xDF\xEF\x8D\x1F\x27\xA5\x14\xAC\x7C\x46\x60\xEC\x59\xB6\xF7\xC2\x96\x85\xFF\x45\x48\xEC\x89\xC6\x89\xD1\xCF\x3A\x96\x73\x05\x4A\xD0\xD9\xC7\x8D\xF8\xD9\xD0\x1F\xFF\xE4\x83\xDE\xD3\xDD\x93\xE0\xD6\xB9\x27\xE7\xC6\xFE\x58\xB0\xCF\xAD\xFD\xD1\xE4\x3C\xB5\xCD\xAB\xB2\xE9\xCF\x10\xEA\xF5\xBD\x1C\xF7\xD3\xD5\xF4\xBD\xE6\xB7\xB3\xC3\xE5\x42\xEA\xBD\x8E\xDD\x8B\x9E\x7F\xCF\xC4\xE0\xC2\xC6\xF9\x99\xA3\x28\xA5\x7D\x58\xE2\xF9\xE4\xCF\x75\x25\xD6\xE9\xC0\x6E\xD8\xBC\x83\xB2\x84\xEC\x00\x24\x7F\x66\xB4\xF7\xCE\x46\x1F\x38\x47\x82\xC3\xE0\xFB\x93\xC2\xDB\xE1\xC5\xD4\xDF\x5F\xC9\xD4\xD8\x57\x6A\xFF\x33\x99\xE0\x01\x62\xF0\xDA\xDD\xC1\xAE\xFE\xB0\x90\xB6\xDF\xB9\x9F\xF9\xED\x14\x78\xBD\xDF\x26\x74\x72\xE2\x63\x72\x04\x77\x7B\xE7\x6A\x5F\x43\x78\x7E\xF7\x7F\x58\x73\x13\x79\x1E\x50\x71\x80\x42\x52\x10\x80\x47\x37\x0B\x79\x18\x7D\x79\xFA\x7C\x7F\x98\x62\x7A\x00\x85\x7A\x02\x80\x4F\x1E\x85\x80\x35\x7B\x7A\x18\x6B\x72\xDB\x5B\x72\x2F\x75\x7B\xE9\x54\x7B\x20\x64\x73\x7C\x68\x7B\x1A\x8B\x7B\x2F\x69\x6B\xBE\x7A\x15\x33\x5F\x7A\x1F\x41\x7C\x8C\x62\x69\x77\x26\x74\x04\x38\x74\x5D\x3D\x47\x76\x7D\x74\x55\x4C\x4E\xAB\x43\x18\x10\x48\x64\x3F\x83\x75\xAF\x3E\x64\x79\x70\x45\x3D\x26\x78\xC8\x6C\x46\x91\x74\x13\x43\x66\x84\xFE\x16\x1B\x86\x2A\x84\x55\x87\x78\xC8\x4F\x64\x39\x6F\x63\x39\x67\x85\xAA\x49\x85\x83\x1D\x4A\xF4\x78\x81\x4E\x65\x4B\x7B\x77\x1F\xBC\x47\x27\x86\x26\x4B\x54\x2F\x86\x53\x4E\x74\xC0\x40\x6D\xF3\x41\x4B\x95\x4E\x61\x0A\x8D\x57\xC7\x6A\x4E\xE1\x4C\x25\xE3\x4B\x75\xDD\x44\x77\xF2\x51\x88\xD8\x48\x72\x3C\x59\x63\xEA\x47\x4D\x65\x83\x81\xE9\x69\x87\x6F\x44\x7C\x7D\x45\x7E\x10\x69\x7C\x01\x84\x70\x56\x6E\x7C\xF4\x76\x89\x04\x75\x75\x1D\x7B\x81\xFB\x6A\x3A\xD8\x73\x53\xDA\x7C\x7D\x67\x70\x7A\x1F\x40\x7E\x35\x19\x23\x8B\x69\x7D\x99\x87\x54\xE7\x7D\x7E\x7E\x81\x2B\x36\x3B\x58\xF2\x6C\x70\xEF\x73\x17\x64\x8B\x11\x66\x85\x17\x83\x30\x00\x4A\x8D\x87\xCC\x63\x24\x4D\x63\x4B\x6C\x82\x89\x77\x21\x8C\x72\x8E\x86\xC5\x44\x71\x45\x8F\x88\xB6\x10\x58\x4A\x8A\x8C\x5B\x6E\x64\xC5\x71\x8B\xC8\x18\x89\x21\x87\x54\xF1\x7C\x89\x78\x4E\x89\x47\x50\x8A\xBA\x75\x7D\xA3\x89\x37\xC4\x57\x8A\x66\x76\x3A\xDF\x77\x23\x91\x14\x5E\xE4\x7A\x8D\x38\x14\x89\x6C\x42\x8E\xC8\x1E\x44\xF5\x82\x8F\xCC\x75\x30\xA9\x4E\x8B\x9F\x15\x17\x0F\x07\x64\x9D\x8A\x8F\x4D\x83\x4B\xB3\x89\x8B\xE9\x78\x7F\x73\x16\x01\xEC\x78\x90\x0B\x87\x6C\xBD\x8A\x11\x72\x41\x1A\x1A\x11\x8C\x33\x53\x8C\xB4\x85\x8C\xF9\x77\x90\xEB\x6A\x8B\x0A\x90\x00\xF8\x88\x8B\x1D\x99\x90\x0C\x80\x47\x13\x9F\x13\x1A\x13\x2E\x33\x58\x47\xC4\x8D\x70\x73\x1C\x47\x94\x73\x81\x21\x99\x65\x3C\x85\x87\xD1\x87\x45\x52\x8A\x45\x41\x82\x10\x17\x99\x86\x13\x80\x93\x0F\x85\x93\xD7\x10\x58\x34\x93\x71\x75\x87\x92\x3A\x95\x47\xB2\x41\x69\x46\x9B\x47\xE9\x3C\x46\x43\x8A\x11\x01\x90\x95\x0E\x5A\x11\x11\x9C\x4F\x59\x41\x71\x06\x1D\x93\x78\x41\x95\xAF\x3E\x83\x5E\x91\x87\x4B\x8C\x21\x96\x38\x94\x1B\x1C\x35\x2B\x95\x50\x5E\x95\x31\xC9\x83\x87\xCF\x8E\x29\xA8\x3C\x46\xD6\x88\x79\xFC\x84\x64\x58\x93\x47\x53\x83\x4B\x5F\x44\x7F\x73\x90\x5C\x6D\x9E\x8C\x9F\x43\x95\x05\x5D\x97\x56\x97\x97\x14\x9B\x93\x7A\x9C\x97\x6E\x9A\x71\x4F\x62\x7B\x21\x63\x93\x40\x60\x6B\xFB\x87\x93\x12\x99\x93\x1B\x1C\x45\xB2\x4A\x84\x8E\x99\x5E\x40\x99\x64\x2A\x80\x50\x44\x91\x99\x76\x65\x96\x96\x94\x47\x5B\x9B\x94\x56\x53\x73\x09\x52\x2B\xF9\x8D\x8D\xC8\x17\x8B\x9D\x54\x90\x57\x96\x96\x52\x97\x9A\x7B\x91\x8E\x04\x9F\x40\x95\x84\x90\x3F\x66\x8F\x38\x14\x9A\x59\x9A\x11\x80\x59\x96\xB1\x9E\x9A\x38\x15\x31\x4F\x80\x1B\x51\x8F\x23\x3F\x6D\x85\x70\x44\x99\x86\x98\x92\x00\x06\x28\x5C\x9A\x77\xCB\x94\x13\xC8\x9D\x47\xCE\x92\x6C\xCE\x90\x9C\x78\x90\x41\xC4\x9A\x9C\x7C\x7F\x3A\x7E\x7E\x49\x57\x2B\x4F\x8A\x49\x5B",
"\xBF\x47\x48\xF4\x79\x9E\x03\x62\x5F\x8F\x41\x49\xC7\x3A\x73\x58\x7B\x51\x43\x7E\x9E\x9E\x2D\x45\x1C\x96\x7F\xB5\x8B\x7E\x6C\x4D\x92\xBB\x80\x47\x34\x02\x7F\xD0\x60\xA0\x1F\x9B\x71\x94\x55\x6B\xF9\x61\x7A\xFB\x6D\x81\x04\x81\x5A\x01\x74\x90\x06\x87\x70\x53\x59\x80\x19\x9E\x92\xB3\x4F\x70\x42\x9A\x95\x31\x9B\xA1\x85\x93\xA0\x17\x7E\x93\x1E\xA2\x7D\xD8\x51\x53\x0A\xAA\x8A\xFE\x78\x68\x0E\xA8\x7A\x1F\x85\x51\x2C\xA2\x82\x7C\x6E\x66\x2A\x7A\x5F\x27\x8A\x5F\x29\x8D\x82\x00\x5C\x82\x41\x61\x6B\xE6\x63\x56\x31\x87\x6B\xBC\x7D\x56\x87\x6B\x60\x38\x8B\x5F\x8F\x70\x6C\x13\x8D\x45\x60\x95\x95\x9D\x3A\x96\x4C\xA6\x65\x50\x74\x7F\x6B\x92\x5F\xD4\x72\x68\xF5\x96\x88\x11\x51\x37\x73\x3F\x75\x72\x7D\x78\x99\x4B\x75\xEA\x85\x3A\xDE\x7C\x78\x6C\x7F\xA5\x11\x5F\x76\x4E\xA4\xA6\x47\x5F\xA5\x43\x7E\x95\x5D\x4F\x97\x87\x2F\x96\xD7\x12\x96\x84\x90\x47\x9A\x71\x4C\x18\x75\xA7\x2F\x5C\x87\x17\xA1\xA0\x80\x8B\x4E\x3E\x13\x88\x11\x55\x88\x8E\x75\x49\x88\x81\xA8\x8A\x81\x94\x4D\x9A\x75\x95\x4E\x88\xFE\x83\xA2\x91\x8B\x98\x20\x5C\x9A\x05\x5E\x9B\x23\x1C\x8D\x0F\xA8\x1C\x96\x33\xA0\xE0\x85\xA9\xB9\x94\xA5\xA1\x80\x66\xBF\x78\x7D\x1F\x41\xA6\xDD\x78\xA2\xAC\x82\x7E\xF0\x8A\x5E\x96\xA3\x4B\xC9\x9E\x9C\xE5\x97\x9D\x81\x70\x00\xBF\x43\x78\x18\x7E\x9C\x88\x7B\x77\x8A\x74\x9F\x73\x7E\x78\xF7\x9B\x77\x80\x79\xA1\xB3\x14\x85\xE6\x9F\x46\xC4\x33\x46\x57\x20\x2E\xE5\x1B\x9F\xD3\x61\xA0\xA9\x2D\xA7\x1F\x93\x1C\x1C\x0A\x13\x52\x22\x81\x23\xA4\x27\x23\xA3\x1C\x1E\x04\xAD\xE4\x1B\xA4\x40\x82\x41\x40\x83\x1C\x1F\x4D\x37\xFF\x00\xA7\xB8\x4F\x46\x53\x20\x98\xC9\xA9\x3A\xDC\xAF\x0F\xF5\x4A\x9A\x38\x1F\x37\xAD\x63\x1C\x16\x44\xAE\xD9\x86\x9C\x23\x1C\x35\xAD\xA3\x1C\x26\x0D\xAE\xAF\xA0\xAC\x52\x8C\x23\xE3\x93\x1C\xD0\x34\xAE\x10\x0B\x34\xCF\x13\x1C\x25\x1D\x2D\x0C\xBD\xB0\x0E\xB3\x10\xAE\x18\x3E\x77\x3D\x2D\x25\x1B\xB0\x9A\x2B\x76\x6B\xAB\x11\xC3\x15\x9E\xC8\xAF\x46\x3A\x1E\x1A\x25\x11\x44\x14\xBE\xB0\xC7\xAE\x46\x77\x2B\xB1\xDA\x95\xAC\xCD\x21\x44\xFF\x07\x37\x4D\x1A\xB0\x06\x15\x02\x06\x12\xB2\xD9\x25\xB2\x83\x4A\x11\x28\xB4\xAC\x1D\xB7\x27\x79\x72\xB3\x0D\xBC\xB1\x26\xBE\x29\x34\xBF\xB3\x7D\x4B\x99\x00\x5D\xB2\x06\x18\x22\x30\xB2\x10\xB6\xA0\x00\x43\xB4\x2D\x36\xBF\x49\x39\xBA\x77\x3B\xBE\x29\x79\x7D\xB4\xDD\x20\xB4\x37\xB9\x36\x50\xB9\x25\x80\xA0\x11\xD9\x4C\x22\xBA\x42\xA9\x6F\x48\xB4\x02\x1A\xB4\x06\x15\x12\x28\x2F\xB4\xC3\x11\xB5\xEB\xA8\x44\x54\xB1\xB4\xD7\x19\x77\x68\xB5\x2D\x5A\xBF\x49\x13\xBA\x29\x87\xA0\xB6\xF1\x42\xB6\x72\x94\xB6\x27\xBF\xB0\x82\xB9\x2D\xCF\x18\x22\xEE\x13\xB2\x6F\x39\xB4\x0E\xB6\xAE\x74\x87\x1D\x1F\xBA\x13\x8E\x19\x77\x88\xBF\x94\x00\x05\xB7\xD4\x2C\xB8\x72\xAA\xB1\x8F\xB3\x10\x12\xBE\xB0\x2E\xBA\xB8\x0D\xB8\xB9\x9F\x46\xB1\x34\x38\xB1\x59\x78\xB3\xC3\xA1\xB7\x5B\xBB\xB9\x79\x1C\x35\x0F\xBF\x1C\x77\x3E\x18\x4B\xB1\x3C\x77\x39\x77\xB2\xB9\x2D\xEF\xAF\x99\x38\x19\xB7\x70\xBF\x6A\x76\x68\x20\x53\xB5\x94\x97\x7A\xB9\x83\xB0\x2E\xAE\x16\x28\x10\x43\xB9\xA4\xB5\xB9\x06\x10\x72\xC1\xB4\x74\x1E\xB3\xB8\xCF\x16\x28\x86\x2A\xBC\xD9\x22\x2C\x97\x23\x1C\xCC\xA3\x6F\xD1\xAC\xB0\xCF\x19\x77\x4E\x32\xB8\xCF\x11\xB9\x9E\xB6\x10\x4D\x17\xBB\x76\xB6\xAD\x8B\xAA\x11\x4D\x1E\xB3\x0C\xB9\xBB\x38\xA8\x13\x97\x10\x41\xE8\x3D\x2D\x41\x47\xBE\x0E\xBA\xA1\xEB\xB4\xB9\xEE\xB9\xB5\x45\xB0\xAF\x3A\x25\xB3\xCA\x27\xA5\x9E\x23\x1C\xDE\xAC\x84\xD3\xB6\x10\xF5\xB9\x2D\xF7\xB9\xBA\xFE\xBD\xA1\xFB\xBD\xBE\xF9\xBF\xBF\xBA\xB1\xC0\xD5\x2D\x24\xBD\xAE\xB8\xE6\xB2\x84\x4C\xAF\x1C\x4E\x3B\xC0\xD5\x2D\xC0\x70\xBF\xC0\x8A\xA3\xBC\xEC\xB1\xB3\x13\xCC\x46\x46\xB8\x13\xCB\xB8\xC1\x5E\xA4\xBC\x94\xBB\x74\x1C\x2F\x1C\x9D\xBD\xB0\x22\xC1\x3C\x24\xC2\xBC\x9F\x42\xC1\x44\xBA\xC2\x00\xCC\x18\x6D\xB3\xC0\x19\xC0\xC3\x77\xB7\x25\xCF\x10\x58\x80\x56\xBF\x1B\xC3\xC2\xB8\xBA\xBE\x26\xCC\xBF\x29\xC9\x9A\x15\xC0\xC4\x17\xB4\xC0\x1A\xC2\x10\xFF\xA2\xAB\x97\x12\x98\x20\xC4\x2D\x37\xC8\xBE\xD4\x2A\xBF\x4F\xCC\xC3\xEF\xB4\xC1\xF1\xB6\xC1\x5D\xB2\x10\xA6\xB1\xBD\x89\xB4\x95\xE1\xA5\xBC\x84\xBE\x1A\xEE\x12\x98\xE2\xBE\x1A\x5C\x30\xC6\xDE\xB7\xBC\xD2\x25\xBE\x6D\xC4\xA9\x39\xC0\xBD\x77\x2B\xBC\xD8\xBD\x29\xC3\x17\xAF\x99\xA2\xBF\xC6\xBC\x14\x06\x11\x8C\x70\xC7\x19\x86\x23\x2E\xDD\x2F\xB9\x9E\x3E\xB0\xDB",
"\xBE\x91\x25\x92\xC8\xCD\xBA\x59\x85\xCB\x9B\xF8\xA0\xC7\x09\xC2\x10\x21\x96\xBD\xD5\x26\x28\x3B\x75\x68\x35\x88\xC8\x70\xBA\xC3\x6F\xB0\xB1\xAC\xB1\x97\x0C\xBB\xBC\xC3\x10\xAE\x4C\x86\xC0\x1C\xC0\x84\xB0\xBB\xC4\xD4\x25\x12\xEE\xBC\xB6\xA0\xB3\x96\x30\xC7\xC0\x1C\x2D\xB3\x0E\xB0\xCC\x1B\x1C\xCB\xE9\xBE\xC3\x53\xC2\xBD\x20\xB8\x31\x0E\xB0\xCB\xB8\xCE\x9C\xC3\x19\xC5\xE3\x97\xCB\x7D\xC3\xBB\xBB\xC3\xCC\xEA\x33\xB0\x06\x12\xCD\xC1\xA2\xCC\x0D\xBC\xCD\x52\x86\xCC\x61\xC6\xC6\x3B\xAB\x22\x75\xCC\xBA\x15\x0D\xCC\x24\xB2\x28\x13\x8F\xBC\x39\x6F\x0F\x2C\xB2\xC9\xB9\xC8\xC2\x02\x12\xCE\xD8\xAB\xBF\xEE\xC3\x81\xDE\xC5\xC6\x10\xCF\xC4\xE2\xCF\xBC\x2B\xCA\x14\x77\x3C\x90\xD5\x25\x12\x4D\xB6\xCF\xEC\xC9\xAD\xA9\xBA\xCA\x6F\x47\xB5\x51\xCC\xD0\x81\xC9\x2D\x86\x2E\xA8\xED\x4A\xD0\x02\x12\xBA\x46\xC3\xD0\xD9\x2A\xB6\x33\xBB\xCE\x5F\x36\xD1\x60\x8A\xCF\xBD\xCF\xC7\x39\x6B\xBC\x13\xDD\x8F\x15\xD8\xCF\x20\x2F\xB7\xEA\xAC\xC6\x8D\xCC\xBA\xFF\x00\x41\x17\x0F\xD2\x30\xD5\x12\x18\x0A\xCE\x0D\xBF\xAC\x0E\x9D\x9F\x9F\x1A\xBD\x0D\x93\x92\x0F\x91\x2B\x66\xB7\x10\x77\x36\xB9\x06\xDD\xD1\x39\xDB\x2B\x3B\xDA\x91\x73\x1E\xD3\xFF\x90\xAD\x25\x9E\xD0\x0D\xB5\xC9\x24\x97\x6C\xBC\xBD\xA4\x7B\xBD\x10\x61\xBB\xD2\x83\x90\xB8\x9E\x23\xD4\x46\xDD\xCB\xE2\xCA\xD3\x40\xDC\xD3\x4D\xDD\x34\x3F\xDC\x9F\x4C\xDB\x37\x23\xD9\x2D\x54\xD1\xD4\x43\x27\xD5\xEE\x19\xD5\x86\x60\xBC\x5C\xDD\x8C\x71\xA2\xB5\x34\xDC\xCA\x03\x1C\x35\x74\xCB\xD7\x80\xD1\xD8\x35\xD6\x10\x19\x08\xD3\xFC\xCD\x86\x79\xDB\xCA\x18\xDE\xD2\x81\xDE\xC1\x06\x1A\x01\x86\xDB\xBC\x35\x2E\x8E\xAE\x8B\xC9\xAD\x97\xC8\xE6\xC2\xD8\x0E\xBF\x1C\x25\x1B\x01\x86\xDD\x2D\xFA\xA4\x90\x96\xDE\xA9\x9D\xC3\xD4\x43\xD5\xBD\x69\xB6\x10\x86\x22\xCE\xA1\xDD\xC9\xA3\xD5\x9C\x98\xDC\xD6\x93\xCD\xB0\x86\xCF\xA2\x47\x57\xD5\x10\x42\x70\xC7\x76\x5A\xD4\x2F\xD6\x66\xD4\xD4\x06\x19\xBC\xA9\xD2\x10\x10\x4C\xDA\x21\x26\xDB\xC8\x1F\xDA\x3D\x51\xDB\x79\x72\xDC\xD5\x25\xDB\x9E\x64\x70\xB8\xD3\x2B\x9D\xC6\xD7\xA9\xC0\xC8\x05\xCA\xD9\xCE\x1E\x1A\xC3\x1D\x01\xDA\xD9\xC7\x3A\x16\xB8\xDF\xD9\xB0\x06\x1F\x01\xDF\xDF\xBA\xAE\x14\xBE\x80\xD4\xDE\x02\x1D\x3C\xE7\xD8\xDE\x3A\x14\xBF\x91\xD2\xC0\x6A\xC6\xC5\xBF\xC5\xCB\x08\xCA\xC7\x02\x1D\xC5\xB3\xBD\xC2\x42\xCF\xC2\xA8\xBD\xC7\x32\xCB\x1F\xAE\x1F\xC1\xF3\xD7\xC1\xFF\xD5\xA6\xF7\xDE\xC6\xB3\xCB\xC5\x0A\xC7\xE0\x69\xC6\x49\x00\xEF\x2F\xF8\xD3\xC3\xDC\xD6\x10\x58\xBF\xDE\x7C\xD7\x10\xE2\xDD\xB0\x3A\x4C\xB4\x8B\xB3\xB6\x2D\xD1\xB8\x97\x1A\xDE\xAF\xC8\xCB\x19\xE5\x2D\x8B\xD4\xE2\x97\x15\xC3\x0C\xB2\xCF\x29\xE7\xB9\x22\xE9\xD8\x6F\x4E\xDF\xF5\xD3\xC4\x01\xEF\x64\xF8\x9A\xC1\xEC\xD0\x00\xFD\xBA\xE1\xD4\x23\xBE\xDB\xC6\xD8\x64\xCF\xC7\x01\xDB\xE1\x31\xDF\xE0\x0D\xB2\xCF\x3F\xE7\xCC\x52\xC7\xC6\x54\xC5\xBA\xF6\xD9\xE3\xC4\xC2\x20\xFA\xD8\x98\x91\xC8\xCB\x4D\xE3\xCE\xC8\xC0\xE5\x36\xE2\xE1\x0A\xE4\xE5\x15\xE4\xE0\xB9\x1A\xE4\x2F\xEA\xE5\x0F\xD2\x9A\xAD\x6F\xE5\x6B\xCC\xE2\x55\xED\xE2\x06\x17\xD5\xC3\x1C\xE4\x69\xE7\xE4\x6C\xE3\xE5\x5C\xEA\xBA\x9F\x47\xC4\x06\x19\xC4\xD9\x24\xE7\x3D\xCF\xE4\xE5\xC1\xE5\x4D\xAD\xE6\xD9\xD8\xC5\x29\xBA\xC5\xCF\x1C\xC5\x7C\xC0\xC5\x81\xEE\x99\x5E\xE4\xDF\x60\xE9\xB1\x62\xEC\xE0\x16\xEA\x13\xC3\x18\x3B\x40\xED\xB0\x9F\xC0\x00\x90\xCB\xD1\xC3\xD4\x2D\x83\xCA\x15\xCA\xDB\xAF\x30\xD3\x1C\xEC\x9B\xE9\x9C\xEE\x1A\x48\xC0\xE1\x41\xC7\xE3\x13\xE1\xCD\x89\xEA\xCD\xAA\xE5\xEB\xB6\xEF\xB0",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

			void XmlText::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlCData::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlAttribute::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlComment::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlElement::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlInstruction::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlDocument::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::parsing::xml;

			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlNode, system::XmlNode)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlText, system::XmlText)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlCData, system::XmlCData)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlAttribute, system::XmlAttribute)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlComment, system::XmlComment)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlElement, system::XmlElement)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlInstruction, system::XmlInstruction)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlDocument, system::XmlDocument)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlNode::IVisitor, system::XmlNode::IVisitor)

			BEGIN_CLASS_MEMBER(XmlNode)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(XmlNode)

			BEGIN_CLASS_MEMBER(XmlText)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlText>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlText::*)(), [](XmlText* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlText::*)(const vl::WString&), [](XmlText* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlText)

			BEGIN_CLASS_MEMBER(XmlCData)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlCData>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlCData::*)(), [](XmlCData* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlCData::*)(const vl::WString&), [](XmlCData* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlCData)

			BEGIN_CLASS_MEMBER(XmlAttribute)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlAttribute>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlAttribute::*)(), [](XmlAttribute* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlAttribute::*)(const vl::WString&), [](XmlAttribute* node, const vl::WString& value){ node->name.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_value, NO_PARAMETER, vl::WString(XmlAttribute::*)(), [](XmlAttribute* node){ return node->value.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_value, {L"value"}, void(XmlAttribute::*)(const vl::WString&), [](XmlAttribute* node, const vl::WString& value){ node->value.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_PROPERTY(value, get_value, set_value)
			END_CLASS_MEMBER(XmlAttribute)

			BEGIN_CLASS_MEMBER(XmlComment)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlComment>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_content, NO_PARAMETER, vl::WString(XmlComment::*)(), [](XmlComment* node){ return node->content.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_content, {L"value"}, void(XmlComment::*)(const vl::WString&), [](XmlComment* node, const vl::WString& value){ node->content.value = value; })

				CLASS_MEMBER_PROPERTY(content, get_content, set_content)
			END_CLASS_MEMBER(XmlComment)

			BEGIN_CLASS_MEMBER(XmlElement)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlElement>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlElement::*)(), [](XmlElement* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlElement::*)(const vl::WString&), [](XmlElement* node, const vl::WString& value){ node->name.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_closingName, NO_PARAMETER, vl::WString(XmlElement::*)(), [](XmlElement* node){ return node->closingName.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_closingName, {L"value"}, void(XmlElement::*)(const vl::WString&), [](XmlElement* node, const vl::WString& value){ node->closingName.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_PROPERTY(closingName, get_closingName, set_closingName)
				CLASS_MEMBER_FIELD(attributes)
				CLASS_MEMBER_FIELD(subNodes)
			END_CLASS_MEMBER(XmlElement)

			BEGIN_CLASS_MEMBER(XmlInstruction)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlInstruction>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_name, NO_PARAMETER, vl::WString(XmlInstruction::*)(), [](XmlInstruction* node){ return node->name.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_name, {L"value"}, void(XmlInstruction::*)(const vl::WString&), [](XmlInstruction* node, const vl::WString& value){ node->name.value = value; })

				CLASS_MEMBER_PROPERTY(name, get_name, set_name)
				CLASS_MEMBER_FIELD(attributes)
			END_CLASS_MEMBER(XmlInstruction)

			BEGIN_CLASS_MEMBER(XmlDocument)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlDocument>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(prologs)
				CLASS_MEMBER_FIELD(rootElement)
			END_CLASS_MEMBER(XmlDocument)

			BEGIN_CLASS_MEMBER(XmlNode::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<XmlNode::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::XmlNode_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlText* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlCData* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlAttribute* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlComment* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlElement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlInstruction* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlDocument* node))
			END_CLASS_MEMBER(XmlNode)

			class XmlTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode)
					ADD_TYPE_INFO(vl::parsing::xml::XmlText)
					ADD_TYPE_INFO(vl::parsing::xml::XmlCData)
					ADD_TYPE_INFO(vl::parsing::xml::XmlAttribute)
					ADD_TYPE_INFO(vl::parsing::xml::XmlComment)
					ADD_TYPE_INFO(vl::parsing::xml::XmlElement)
					ADD_TYPE_INFO(vl::parsing::xml::XmlInstruction)
					ADD_TYPE_INFO(vl::parsing::xml::XmlDocument)
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool XmlLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new XmlTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}
