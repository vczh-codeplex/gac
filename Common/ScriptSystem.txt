========================================================
Primitive Types
========================================================

Int8		sbyte		0
Int16		short		0
Int32		int			0
Int64		long		0
UInt8		byte		0
UInt16		ushort		0
UInt32		uint		0
UInt64		ulong		0
Boolean		bool		false
Char		char		'\0'
String		string		""
Float32		float		0.0f
Float64		double		0.0
DateTime				0000-00-00 00:00:00
Guid					00000000-0000-0000-0000-000000000000
Void		void		void
Object		object		null

========================================================
Composite Types
========================================================

Pair<T, U>							(T..U)					(default(T)..default(U))
Pair<T, Pair<U, Pair<V, void>>>		(T, U, V)				(default(T), default(U), default(V))

IDelegate<R, (T, U, V)>				func (T, U, V):R
									func (..(T, U, V)):R

IEnumerable<T>						{T}

IMap<TKey, TValue>					{TKey => TValue}
	: IDelegate<TValue, (TKey)>
	: IEnumerable<(TKey, TValue)>

IArray<T>							[T]
	: IDelegate<int, (T)>
	: IEnumerable<T>

========================================================
Composite Type Constructors
========================================================

default(T)
create(T)

x:x+1
(x,y):x+y
func (int x, int y):int{ return x+y; }

// IArray
int[10]
[]
[1, 2, 3]

// IEnumerable
[1, 2, 3] ++ [4, 5, 6]
[1, 2, 3 : [4, 5, 6]]		// each expression will be evaluated in MoveNext function

// IMap
{}
{1=>"a", 2=>"b"}
{1, 2, 3}

========================================================
Custom Types
========================================================

type Link [ : base1, base2, ... ]
{
	object value;
	Link next;
}

type<T> Link
{
	T value;
	Link<T> next;
}

struct Point	// struct members are immutable
{
	int x;
	int y;
}

struct<T> Point
	where Numeric<T>
{
	T x;
	T y;
}

enum Season
{
	Spring,
	Summer,
	Autumn,
	Winter,
}

type Box = {int => string};
type<T> Box = {int => T};

========================================================
Custom Type Constructors
========================================================

Point{1, 2}
Point{x=1, y=2}
Point{}
Point x = {x=1, y=2};
DealWithPoint({x=1, y=2});

========================================================
Variables
========================================================

int a[ = default(int)];
int a = 0;
var a = 0;

========================================================
Functions
========================================================

func Add(int a, int b):int inline = a+b ;
func Add(int a, int b):int
{
	return a+b;
}

func Add(a, b) = a+b ;
func<T> Add(T a, T b):T
	where Numeric<T>
{
	return a+b;
}

func<T> IsLastNode(Link<T> node):bool
{
	return node.next==null;
}

prop<T> Config
	where Creatable<T>
{
	get
	{
		(config, exists)=globalConfigs.Find(typeof(T));
		if(!exists)
		{
			config=create(T);
			globalConfigs[typeof(T)]=config;
		}
		return config;
	}
	set
	{
		globalCOnfigs[typeof(T)]=value;
	}
}

========================================================
Extension Functions
========================================================

func<T> bool Link<T>.IsLastNode() inline
{
	return this.next==null;
}

prop<T> bool Link<T>.IsLastNode inline
{
	return this.next==null;
}

func<T, U> {T}.Map(func U(T)):{U};
func<T> operator++({T}, {T}):{T};
func<T> {T}.Filter(func bool(T)):{T};
func<T> {T}.First():T;
func<T> {T}.Last():T;
func<T> {T}.Empty():T;

func<T> {T}.Take(int):{T};
func<T> {T}.TakeWhile(int, func bool(T)):{T};
func<T> {T}.Drop(int):{T};
func<T> {T}.DropWhile(int, func bool(T)):{T};
func<T> {T}.Reverse():{T};
func<T, U> {U}.Fold(T, func T(T, U)):T;
func<T, U> {U}.Scan(T, func T(T, U)):{T};
func<T> {T}.All(func bool(T)):bool;
func<T> {T}.Any(func bool(T)):bool;
func<T> {T}.SplitAt(int count):({T}, {T});
func<T> {T}.Span(func bool(T)):({T}, {T});
func<T> {T}.Break(func bool(T)):({T}, {T});
func<T, U> {U}.GroupBy(func T(U)):{(T, U)};
func<T, U> {U}.OrderBy(func T(U)):{U};

func<T> {T}.Sum():T;
func<T> {T}.Product():T;
func<T> {T}.Min():T;
func<T> {T}.Max():T;
func<T> {{T}}.Flatten():{T};
func<T, U> {T}.Zip({U}):{(T, U)};

========================================================
Concepts
========================================================

concept<T> Equlable
{
	func AreEqual(T a, T b):bool;
	func operator==(T a, T b):bool inline = AreEqual(a, b);
	func operator!=(T a, T b):bool inline = !AreEqual(a, b);
}

concept<T> Comparable
{
	func Compare(T a, T b):int;
	func operator<(T a, T b):bool inline = Compare(a, b)<0;
	func operator<=(T a, T b):bool inline = Compare(a, b)<=0;
	func operator>(T a, T b):bool inline = Compare(a, b)>0;
	func operator>=(T a, T b):bool inline = Compare(a, b)>=0;
	func Min(a, b):T inline = (if (Compare(a, b)<0) a else b);
	func Max(a, b):T inline = (if (Compare(a, b)>0) a else b);
}

concept<T> Enumerable
	where Comparable<T>
{
	func Next(T a):T;
	func Prev(T a):T;
	prop T LowerBound{get;}
	prop T UpperBound{get;}
	func EnumFrom(T a, T b):IEnumerable<T>;
	func EnumFrom(T a, T b, int step):IEnumerable<T>;
	func ReverseEnumFrom(T a, T b):IEnumerable<T>;
	func ReverseEnumFrom(T a, T b, int step):IEnumerable<T>;
}

concept<T> Bitwise
	where Comparable<T>
{
	func operator &&(T a, T b):T;
	func operator ||(T a, T b):T;
	func operator !(T a, T b):T;
}

concept<T> Numeric
	where Comparable<T>
{
	prop T Zero{get;}
	func operator+(T a, T b):T;
	func operator+(T a):T;
	func operator-(T a, T b):T;
	func operator-(T a):T;
	func operator*(T a, T b):T;
	func operator/(T a, T b):T;
	func Abs(T a):T;
	func Sign(T a):T;
}

concept<T> Integral
	where Numeric<T>
{
	func operator%(T a, T b):T;
	func Even(T a):bool;
	func Odd(T a):bool;
	func Gcd(T a):bool;
	func Lcm(T a):bool;
}

concept<T> Fractional
	where Numeric<T>
{
	func Truncate(T a):T;
	func Round(T a):T;
	func Floor(T a):T;
	func Ceiling(T a):T;
}

concept<T> Floating
	where Fractional<T>
{
	prop T Pi{get;}
	prop bool T.IsNan{get;}
	prop bool T.IsInfinite{get;}
	func Exp(T a):T;
	func Sqrt(T a):T;
	func Log(T a):T;
	func Sin(T a):T;
	func Cos(T a):T;
	func Tan(T a):T;
	func ASin(T a):T;
	func ACos(T a):T;
	func ATan(T a):T;
	func Sinh(T a):T;
	func Cosh(T a):T;
	func Tanh(T a):T;
	func ASinh(T a):T;
	func ACosh(T a):T;
	func ATanh(T a):T;
}

concept<T, U> Convertable
{
	func Convert(T a):U;
}

concept<T, U> ImplicitlyConvertable
	where Convertable<T, U>
{
}

concept<T> Printable
{
	func T.ToString():string;
}

concept<T> Parsable
{
	func Parse(string s):T;
}

concept<T> Tuple // predefined
{
}

concept<T=>U> Tuplizable // predefined
	where Tuple<U>
{
	func ToTuple(T value):U;
	func FromTuple(U tuple):T;
}

instance<T> Equlable<T>
	where Comparable<T>
{
	func AreEqual(T a, T b):bool inline = Compare(a, b)==0;
}

instance<T, U> Comparable<(T..U)>
{
	func Compare((T..U) a, (T..U) b):int
	{
		int result=Compare(a.first, b.first);
		if(result==0)
		{
			return Compare(a.second, b.second);
		}
		else
		{
			return result;
		}
	}
}

instance<T> Printable
	where Convertable<T, string>
{
	func T.ToString():string inline = Convert(this);
}

instance<T> Parsable
	where Convertable<string, T>
{
	func Parse(string s):T inline = Convert(s);
}

========================================================
Interfaces
========================================================

concept<out T> this.IEnumerator
{
	func MoveNext():bool;
	prop T Current{get;}
}

concept<out T> this.IEnumerable
{
	func CreateEnumerator():IEnumerator<T>;
}

concept<T> this.IReadonlyCollection
	where this.IEnumerable<T>
{
	prop int Count{get;}
	func Contains(T value):bool;
}

concept<T> this.IReadonlyArray
	where this.IReadonlyCollection<T>
	where this.IDelegate<T, (int)>
{
	prop T operator[](int index){get;}
	func IndexOf(T value):int;
}

concept<T> this.IArray
	where this.IReadonlyArray<T>
{
	prop T operator[](int index){get; set;}
}

concept<T> this.ICollection
	where this.IReadonlyCollection<T>
{
	func void Clear();
	func Add(T value):bool;
	func Remove(T value):bool;
}

concept<T> this.IList
	where this.ICollection<T>
	where this.IArray<T>
{
	func Insert(T value, int index):int;
	func RemoveAt(int index):T;
}

concept<TKey, TValue> this.IReadonlyMap
	where this.IReadonlyCollection<(TKey, TValue)>
	where this.IDelegate<TKey, (TValue)>
{
	prop IReadonlyCollection<TKey> Keys{get;}
	prop IReadonlyCollection<TValue> Values{get;}
	func Find(TKey key):(TValue, bool);
}

concept<TKey, TValue> this.IMap
	where this.ICollection<(TKey, TValue)>
	where this.IReadonlyMap<TKey, TValue>
{
	func Set(TKey key, TValue value):bool;
	func Remove(TKey key):bool;
}

========================================================
Pattern Matching
========================================================

Patterns:
(a, b, c)
[a, b, c: d]
Point{x, y}
{x, y}
{x=a, y=b}
a :: Type

<pattern> = expression;

switch(value)
{
	case <pattern> : ....
}

========================================================
Statments
========================================================

<variable-declaration>
<pattern> = expression;
<variable> = expression;

return [expression];
break;
continue;
throw expression;

if (condition) statement [else statement]
while (condition) statement
do statement while (condition);
foreach(([type x] | <pattern>) in xs) statement

try statement { catch (Type [ex]) statement } [ finally statement ]
using (x = T where T.IDisposable) statement
lock (object) statement

switch(value)
{
	{ case <pattern> : statement }
	[ default : statement ]
}

========================================================
Expressions
========================================================

a op b
op a
a op

f(a, b, c)
f(.. t)
a.b

<constructors>
<patterns>

(if (condition) value else value)
(switch (value) { case <pattern> : value } [default : value]) // PatternMatchingFailedException
(using (x = T where T.IDisposable) value)
(lock (object) value)

========================================================
Exceptions
========================================================

type Exception // base type for all exceptions
{
	string message;
	CallstackSnapshot callstack;
	Exception innerException;
};

========================================================
Multiple Dispatching
========================================================

func DealWith(switch object x) // switch only for reference type
{
	Console.WriteLine("x is an object");
}

func DealWith(case {object} x)
{
	Console.WriteLine("x is an enumerable");
}

func DealWith(case string x)
{
	Console.WriteLine("x is a string");
}

========================================================
Continuations
========================================================