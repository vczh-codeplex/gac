========================================================
Primitive Types
========================================================

Int8		sbyte		0
Int16		short		0
Int32		int			0
Int64		long		0
UInt8		byte		0
UInt16		ushort		0
UInt32		uint		0
UInt64		ulong		0
Boolean		bool		false
Char		char		'\0'
String		string		""
Float32		float		0.0f
Float64		double		0.0
Void		void		void
Object		object		null

========================================================
Composite Types
========================================================

Pair<T, U>							(T..U)					(default(T)..default(U))
Pair<T, Pair<U, Pair<V, void>>>		(T, U, V)				(default(T), default(U), default(V))

IDelegate<R, (T, U, V)>				func R(T, U, V)
									func R(..(T, U, V))

IMap<TKey, TValue>					{TKey : TValue}
	: IDelegate<TValue, (TKey)>
	: IEnumerable<(TKey, TValue)>

IArray<T>							[T]
	: IDelegate<int, (T)>
	: IEnumerable<T>

IEnumerable<T>
IReadableArray<T>
IArray<T>
IList<T>
IMap<TKey, TValue>

========================================================
Composite Type Constructors
========================================================

default(T)
create(T)

x=>x+1
(x,y)=>x+y
func int(int x, int y){ return x+y; }

// IArray
int[10]
[]
[1, 2, 3]

// IEnumerable
[1, 2, 3] ++ [4, 5, 6]
[1, 2, 3 : [4, 5, 6]]

// IMap
{}
{1:"a", 2:"b"}
{1, 2, 3}

========================================================
Custom Types
========================================================

type Link
{
	object value;
	Link next;
}

type<T> Link
{
	T value;
	Link<T> next;
}

struct Point	// struct members are immutable
{
	int x;
	int y;
}

struct<T> Point
	where Numeric<T>
{
	T x;
	T y;
}

type Box = {int : string};
type<T> Box = {int : T};

========================================================
Custom Type Constructors
========================================================

Point{ x=1, y=2 }
Point{}

========================================================
Variables
========================================================

int a[ = default(int)];
int a = 0;
var a = 0;

========================================================
Functions
========================================================

func int Add(int a, int b) inline = a+b ;
func int Add(int a, int b)
{
	return a+b;
}

func Add(a, b) = a+b ;
func<T> T Add(T a, T b)
	where Numeric<T>
{
	return a+b;
}

func<T> bool IsLastNode(Link<T> node)
{
	return node.next==null;
}

prop<T> Config
	where Creatable<T>
{
	get
	{
		(config, exists)=globalConfigs.Find(typeof(T));
		if(!exists)
		{
			config=create(T);
			globalConfigs[typeof(T)]=config;
		}
		return config;
	}
	set
	{
		globalCOnfigs[typeof(T)]=value;
	}
}

========================================================
Extension Functions
========================================================

func<T> bool Link<T>.IsLastNode() inline
{
	return this.next==null;
}

prop<T> bool Link<T>.IsLastNode inline
{
	return this.next==null;
}

========================================================
Concepts
========================================================

concept<T> Equlable
{
	func bool AreEqual(T a, T b);
	func operator==(T a, T b) inline = AreEqual(a, b);
	func operator!=(T a, T b) inline = !AreEqual(a, b);
}

concept<T> Comparable
{
	func int Compare(T a, T b);
	func operator<(T a, T b) inline = Compare(a, b)<0;
	func operator<=(T a, T b) inline = Compare(a, b)<=0;
	func operator>(T a, T b) inline = Compare(a, b)>0;
	func operator>=(T a, T b) inline = Compare(a, b)>=0;
}

instance<T> Equlable<T>
	where Comparable<T>
{
	func bool AreEqual(T a, T b) inline = Compare(a, b)==0;
}

========================================================
Pattern Matching
========================================================

========================================================
Statments
========================================================

========================================================
Expressions
========================================================

========================================================
Exceptions
========================================================

========================================================
Continuations
========================================================