========================================================
Primitive Types
========================================================

Int8		sbyte		0
Int16		short		0
Int32		dshort		0
Int64		long		0	(int)
UInt8		byte		0
UInt16		word		0
UInt32		dword		0
UInt64		ulong		0	(uint)
Boolean		bool		false
Char		char		'\0'
String		string		""
Float32		float		0.0f
Float64		double		0.0
DateTime				0000-00-00 00:00:00
Guid					00000000-0000-0000-0000-000000000000
Void		void		<>
Object		object		null

========================================================
Composite Types
========================================================

Pair<T, U>							T..U					default(T)..default(U) // right associative
Pair<T, Pair<U, Pair<V, void>>>		<T, U, V>, T..U..V..<>	<default(T), default(U), default(V)>

IDelegate<R, <T, U, V>>				func (T, U, V)->R
									func (..(T, U, V))->R

IEnumerable<T>						{T}

IMap<TKey, TValue>					{TKey : TValue}
	: IDelegate<TValue, <TKey>>
	: IEnumerable<TKey..TValue>

IArray<T>							[T]
	: IDelegate<int, <T>>
	: IEnumerable<T>

========================================================
Composite Type Constructors
========================================================

default(T)
new(T)

x->x+1
(x,y)->x+y
func (int x, int y)->int = x+y
func (int x, int y)->int{ return x+y; }

// IArray
array(10) :: int[]
[]
[1, 2, 3]

// IEnumerable
[1, 2, 3] ++ [4, 5, 6]
{1, 2, 3}
{1, 2, 3 : [4, 5, 6]}		// each expression will be evaluated in MoveNext function

// IMap
{}
{1:"a", 2:"b"}

========================================================
Custom Types
========================================================

type Link [ : base1, base2, ... ]
{
	object value;
	Link next;
}

type<T> Link
{
	T value;
	Link<T> next;
}

struct Point	// struct members are immutable
{
	int x;
	int y;
}

struct<T> Point
	where Numeric<T>
{
	T x;
	T y;
}

enum Season
{
	Spring,
	Summer,
	Autumn,
	Winter,
}

type Box = {int : string};
type<T> Box = {int : T};

========================================================
Custom Type Constructors
========================================================

Point{x=1, y=2}						{x=1, y=2}
Point{}								{}
DealWithPoint(Point{x=1, y=2})		DealWithPoint({x=1, y=2})

========================================================
Variables
========================================================

int a[ = default(int)];
int a = 0;
var a = 0;

========================================================
Functions
========================================================

@Inline
func Add(int a, int b)->int = a+b ;
func Add(int a, int b)->int
{
	return a+b;
}

func Add(a, b) = a+b ;
func<T> Add(T a, T b)->T
	where Numeric<T>
{
	return a+b;
}

func<T> IsLastNode(Link<T> node)->bool
{
	return node.next==null;
}

prop<T> Config
	where Creatable<T>
{
	get
	{
		config..exists=globalConfigs.Find(typeof(T));
		if(!exists)
		{
			config=new(T);
			globalConfigs[typeof(T)]=config;
		}
		return config;
	}
	set
	{
		globalConfigs[typeof(T)]=value;
	}
}

========================================================
Extension Functions
========================================================

@Inline
func<T> bool Link<T>.IsLastNode()
{
	return this.next==null;
}

@Inline
prop<T> bool Link<T>.IsLastNode
{
	return this.next==null;
}

func<T, U> {T}.Map(func U(T))->{U};
func<T> operator++({T}, {T})->{T};
func<T> {T}.Filter(func bool(T))->{T};
func<T> {T}.First()->T;
func<T> {T}.Last()->T;
func<T> {T}.Empty()->T;

func<T> {T}.Take(int)->{T};
func<T> {T}.TakeWhile(int, func bool(T))->{T};
func<T> {T}.Drop(int)->{T};
func<T> {T}.DropWhile(int, func bool(T))->{T};
func<T> {T}.Reverse()->{T};
func<T, U> {U}.Fold(T, func T(T, U))->T;
func<T, U> {U}.Scan(T, func T(T, U))->{T};
func<T> {T}.All(func bool(T))->bool;
func<T> {T}.Any(func bool(T))->bool;
func<T> {T}.SplitAt(int count)->{T} .. {T};
func<T> {T}.Span(func bool(T))->{T} .. {T};
func<T> {T}.Break(func bool(T))->{T} .. {T};
func<T, U> {U}.GroupBy(func T(U))->{T .. U};
func<T, U> {U}.OrderBy(func T(U))->{U};

func<T> {T}.Sum()->T;
func<T> {T}.Product()->T;
func<T> {T}.Min()->T;
func<T> {T}.Max()->T;
func<T> {{T}}.Flatten()->{T};
func<T, U> {T}.Zip({U})->{(T, U)};

========================================================
Concepts
========================================================

concept<T> Equatable
{
	func AreEqual(T a, T b)->bool;
	@Inline
	func operator==(T a, T b)->bool = AreEqual(a, b);
	@Inline
	func operator!=(T a, T b)->bool = !AreEqual(a, b);
}

concept<T> Comparable
{
	func Compare(T a, T b)->int;
	@Inline
	func operator<(T a, T b)->bool = Compare(a, b)<0;
	@Inline
	func operator<=(T a, T b)->bool = Compare(a, b)<=0;
	@Inline
	func operator>(T a, T b)->bool = Compare(a, b)>0;
	@Inline
	func operator>=(T a, T b)->bool = Compare(a, b)>=0;
	@Inline
	func Min(a, b)->T = (if (Compare(a, b)<0) a else b);
	@Inline
	func Max(a, b)->T = (if (Compare(a, b)>0) a else b);
}

concept<T> Enumerable
	where Comparable<T>
{
	func Next(T a)->T;
	func Prev(T a)->T;
	prop T LowerBound{get;}
	prop T UpperBound{get;}
	func EnumFrom(T a, T b)->IEnumerable<T>;
	func EnumFrom(T a, T b, int step)->IEnumerable<T>;
	func ReverseEnumFrom(T a, T b)->IEnumerable<T>;
	func ReverseEnumFrom(T a, T b, int step)->IEnumerable<T>;
}

concept<T> Bitwise
	where Comparable<T>
{
	func operator &&(T a, T b)->T;
	func operator ||(T a, T b)->T;
	func operator !(T a, T b)->T;
}

concept<T> Numeric
	where Comparable<T>
{
	prop T Zero{get;}
	func operator+(T a, T b)->T;
	func operator+(T a)->T;
	func operator-(T a, T b)->T;
	func operator-(T a)->T;
	func operator*(T a, T b)->T;
	func operator/(T a, T b)->T;
	func Abs(T a)->T;
	func Sign(T a)->T;
}

concept<T> Integral
	where Numeric<T>
{
	func operator%(T a, T b)->T;
	func Even(T a)->bool;
	func Odd(T a)->bool;
	func Gcd(T a)->bool;
	func Lcm(T a)->bool;
	func operator<<(T a, T b)->T;
	func operator>>(T a, T b)->T;
}

concept<T> Fractional
	where Numeric<T>
{
	func Truncate(T a)->T;
	func Round(T a)->T;
	func Floor(T a)->T;
	func Ceiling(T a)->T;
}

concept<T> Floating
	where Fractional<T>
{
	prop T Pi{get;}
	prop bool T.IsNan{get;}
	prop bool T.IsInfinite{get;}
	func Exp(T a)->T;
	func Sqrt(T a)->T;
	func Log(T a)->T;
	func Sin(T a)->T;
	func Cos(T a)->T;
	func Tan(T a)->T;
	func ASin(T a)->T;
	func ACos(T a)->T;
	func ATan(T a)->T;
	func Sinh(T a)->T;
	func Cosh(T a)->T;
	func Tanh(T a)->T;
	func ASinh(T a)->T;
	func ACosh(T a)->T;
	func ATanh(T a)->T;
}

concept<T, U> Convertable
{
	func Convert(T a)->U;
}

concept<T, U> ImplicitlyConvertable
	where Convertable<T, U>
{
}

concept<T> Printable
{
	func T.ToString()->string;
}

concept<T> Parsable
{
	func Parse(string s)->T;
}

concept<T> Tuple // predefined
{
}

concept<T:U> Tuplizable // predefined
	where Tuple<U>
{
	func ToTuple(T value)->U;
	func FromTuple(U tuple)->T;
}

instance<T> Equatable<T>
	where Comparable<T>
{
	@Inline
	func AreEqual(T a, T b)->bool = Compare(a, b)==0;
}

instance<T, U> Comparable<T..U>
{
	func Compare(T..U a, T..U b)->int
	{
		int result=Compare(a.first, b.first);
		if(result==0)
		{
			return Compare(a.second, b.second);
		}
		else
		{
			return result;
		}
	}
}

instance<T> Printable
	where Convertable<T, string>
{
	@Inline
	func T.ToString()->string = Convert(this);
}

instance<T> Parsable
	where Convertable<string, T>
{
	@Inline
	func Parse(string s)->T = Convert(s);
}

instance<T, U> Convertable<IEnumerable<T>, IEnumerable<U>>
	where Convertable<T, U>
{
}

========================================================
Interfaces
========================================================

concept this.IWeakTypedPair
{
	prop object WeakTypedFirst{get;}
	prop object WeakTypedSecond{get;}
}

concept this.IWeakTypedTuple
	where this.IWeakTypedEnumerable
{
}

concept this.IWeakTypedEnumerator
{
	func MoveNext()->bool;
	prop object WeakTypedCurrent{get;}
}

concept<T> this.IEnumerator
	where this.IWeakTypedEnumerator
{
	prop T Current{get;}
}

concept this.IWeakTypedEnumerable
{
	func CreateWeakTypedEnumerator()->IWeakTypedEnumerator;
}

concept<T> this.IEnumerable
	where this.IWeakTypedEnumerable
{
	func CreateEnumerator()->IEnumerator<T>;
}

concept<T> this.IReadonlyCollection
	where this.IEnumerable<T>
{
	prop int Count{get;}
	func Contains(T value)->bool;
}

concept<T> this.IReadonlyArray
	where this.IReadonlyCollection<T>
	where this.IDelegate<T, (int)>
{
	prop T operator[](int index){get;}
	func IndexOf(T value)->int;
}

concept<T> this.IArray
	where this.IReadonlyArray<T>
{
	prop T operator[](int index){get; set;}
}

concept<T> this.ICollection
	where this.IReadonlyCollection<T>
{
	func void Clear();
	func Add(T value)->bool;
	func Remove(T value)->bool;
}

concept<T> this.IList
	where this.ICollection<T>
	where this.IArray<T>
{
	func Insert(T value, int index)->int;
	func RemoveAt(int index)->T;
}

concept<TKey, TValue> this.IReadonlyMap
	where this.IReadonlyCollection<(TKey, TValue)>
	where this.IDelegate<TKey, (TValue)>
{
	prop IReadonlyCollection<TKey> Keys{get;}
	prop IReadonlyCollection<TValue> Values{get;}
	func Find(TKey key)->(TValue, bool);
}

concept<TKey, TValue> this.IMap
	where this.ICollection<(TKey, TValue)>
	where this.IReadonlyMap<TKey, TValue>
{
	func Set(TKey key, TValue value)->bool;
	func Remove(TKey key)->bool;
}

========================================================
Pattern Matching
========================================================

Patterns:
(a, b, c)
{a, b, c: d}
Point{x, y}
{x, y}
{x=a, y=b}
a :: Type		// infer a as type Type

<pattern> = expression;

switch(value)
{
	case <pattern> : ....
}

========================================================
Statments
========================================================

<variable-declaration>
<pattern> = expression;
<variable> = expression;
<invoke-expression>;

return [expression];
break;
continue;
throw expression;

if (condition) statement [else statement]
while (condition) statement
do statement while (condition);
foreach(([type] x | <pattern>) in xs) statement

try statement { catch (Type [ex]) statement } [ finally statement ]
using ([type] x = T where T.IDisposable) statement
lock (object) statement

switch(value)
{
	{ case <pattern> : statement }
	[ default : statement ]
}

if (x = y) --> (x, success) = y; if(success)
while the same

========================================================
Expressions
========================================================

a op b
op a
a op

f(a, b, c)
f(.. t)
a.b
a as Type		// explicit type conversion, invoking Convertable

<continuation-control-flow>! expression

<constructors>
<patterns>

(if (condition) value else value)
(switch (value) { case <pattern> : value } [default : value]) // PatternMatchingFailedException
(using (x = T where T.IDisposable) value)
(lock (object) value)

========================================================
Exceptions
========================================================

type Exception // base type for all exceptions
{
	string message;
	CallstackSnapshot callstack;
	Exception innerException;
};

========================================================
Attributes
========================================================

type Attribute // base type for all attributes
{
};

@STAThread
func ThreadProc(){}

attribute marks
	function
	variable
	type
	concept
	instance
	field
	argument
	return
	property

@Attribute
func Function(@Attribute int a, @Attribute int b) : @Attribute c;

@ThreadLocal
int a;

@Serializable
type Class
{
	@Item{name="Name"}
	string name;
}

========================================================
Multiple Dispatching
========================================================

func DealWith(switch object x) // switch only for reference type
{
	Console.WriteLine("x is an object");
}

func DealWith(case {object} x)
{
	Console.WriteLine("x is an enumerable");
}

func DealWith(case string x)
{
	Console.WriteLine("x is a string");
}

========================================================
Type
========================================================

var one = 1;
// one :: int

var inc = x:x+1;
// inc :: func(int)->int

var pinc = x:x+Convert(1);
// pinc :: type<T> where Numeric<T>, Convertable<int, T> func(T)->T

func Apply(f, x, c)
{
	foreach(i in 1..c)
		x=f(x);
	return x;
}
// Apply :: type<T> func(func(T)->T, T, int)->T

var x = Apply(inc, 1, 100);
// x = 100

var x = Apply(pinc, 1.0, 100);
// x = 100.0

func Filter(xs, p) seq
{
	foreach(x in xs)
	    if (p) yield! x;
}
// Filter :: type<T> func({T}, func (T)->bool)->{T}

func Concat(urls, cont) async
{
    var xs = new(IList<string>);
	foreach(url in urls)
		xs.Add(await! DownloadTextAsync(url))
	cont(xs);
}
// Concat :: func({string}, func(IList<string>)->void)->Task<void>

========================================================
Continuations
========================================================

concept<M<>> this.Continuation
{
	func<T> Nop() : M<T>;
	func<T> Delay(func ()->M<T> body) : M<T>;
	func<T, U> Combine(M<T> source, M<U> next) : M<U>;
	func<T> Return(T value) : M<T>;
	func<T, U> Bind(M<T> source, func (T)->M<U> bind) : M<U>;
	func<T> Yield(T value) : M<T>;
	func<T> YieldFrom(M<T> source) : M<T>;
	func<T> Try(M<T> source, func (Exception)->M<T> bind) : M<T>;
}

---------------------------------------

type seq
{
}

instance<T> seq.Continuation<{T}>
{
}

@ContinuationControlFlow
@Inline
func seq.yield(T value) = this.Yield(value);

---------------------------------------

type async
{
}

instance<T> async.Continuation<Task<T>>
{
}

@ContinuationControlFlow
@Inline
func async.await(source, bind) = this.Bind(source, bind);

========================================================
External Types
========================================================

@External
@NotImplemented
concept<T> this.ExternalPointer
	where Interface<T>
{
	@External
	func Delete():void

	@External
	prop T Handle{get;}
}

@External
@NotImplemented
concept<T> this.ExternalReference
	where Interface<T>
{
	@External
	prop T Handle{get;}
}

instance<T> Convertable<ExternalReference<T>, ExternalPointer<T>>
{
}