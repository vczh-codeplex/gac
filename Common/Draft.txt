A library like the old Syngram in VL++1.0 that receives code to generate parser in memory or in C++.

Parser Syntax
In-Memory Parser
In-Memory Data Structure

Generated C++ Recursive Descent Parser
Generated C++ Data Structure + Visitor Pattern <--> In-Memory Data Structure

XML/JSON in-memory parser / C++ parser
========================================================
parse intel manual 2A and 2B to get binary code table
x86 and x64 assembler
intermediate code
enriched C language
design a language for Calculation, AsyncIO, Server and GUI programming
========================================================

primitive types: (struct)
	int8, int16, int32, int64
	uint8, uint16, uint32, uint64
	float, double, char, bool, string
	void (can use new void)

primitive types: (ref struct)
	T[]
	object

implicit type conversion
	int8 -> int16 -> int32 -> int64
	uint8 -> uint16 -> uint32 -> uint64
	float -> double
	everything -> object

	ref struct From
	{
		mixin To;
	}

	ref concept TThis as From // TThis must be ref struct
		requires TThis as To
	{
	}

	instance From as To
	{
	}

explicit type conversion
	all implicit type conversion
	integer|char <--> integer|char
	numeric <--> numeric
	object <--> ref struct | struct | ref concept
	ref struct|ref concept <--> ref struct|ref concept

concept Convertable<TSource, TDest>
{
	TDest Convert(TSource source);
}

concept ImplicitConvertable<TSource, TDesT>
{
	TDest Convert(TSource source);
}

========================================================

concept Equable<T>
{
	bool IsEqual(T a, T b);
}

bool operator==<T>(T a, T b)
	requires Equable<T>
{
	return IsEqual(a, b);
}

bool operator==<T>(T a, T b)
	requires Equable<T>
{
	return !IsEqual(a, b);
}

instance Equable<int32>
{
	bool IsEqual(int32 a, int32 b) __embedded_asm equ_i32;
}

instance Equable<int64>
{
	bool IsEqual(int64 a, int64 b) __inline __asm
	{
		push_i64 a;
		push_i64 b;
		equ_i64;
		ret;
	}
}

------------------------

ref concept T as TextWriter
{
	bool T.Write(string text);
}

concept Convertable<TSource, TDest>
{
	TDest Convert(TSource source);
}

concept Printable<T>
{
	bool TextWriter.Write(T value);
}

instance<T> Printable<T>
	requires Convertable<T, string>
{
	bool TextWriter.Print(T value)
	{
		string text=Convert(value);
		return Write(text);
	}
}

instance Convertable<int32, string>
{
	string Convert(int32 source) __foreign "Int32ToString";
}

instance<T> Convertable<T[], string>
	requires Convertable<T, string>
{
	string Convert(T[] source)
	{
		string result;
		foreach(var i in source)
		{
			string text=Convert(i); // Convertable<T, string>.Convert(i);
			result+=", {0}".Format(text);
		}
		return result==""?"":result.SubString(2);
	}
}

------------------------

ref concept T as Catchable
{
	string T.Message{get;}
}

ref struct Exception
{
	string message;
}

instance Exception as Catchable
{
	string ExceptionBase.Message
	{
		get return message;
	}
}

ref struct ArgumentException
{
	mixin Exception;
	string argument;
}

ref struct IndexOutOfRangeException
{
	mixin ArgumentException;
}

ref struct TypeConvertException
{
	mixin Exception;
	Type sourceType;
	Type destinationType;
}

------------------------

enum BinaryOperator
{
	Add, Sub, Mul, Div
}

ref struct Expression{}

ref struct NumberExpression
{
	// only ref struct can mixin another ref struct
	// mixin inherits concepts
	// mixin is equivalent to virtual & multiple inheritance
	mixin Expression;
	double number;
}

ref struct BinaryExpression
{
	mixin Expression;
	BinaryOperator op;
	Expression left;
	Expression right;
}

------------------------

// another way to achieve this
// double Evaluate(switch Expression expr);
double switch Expression.Evaluate();

double case NumberExpression.Evaluate()
{
	return number;
}

double case BinaryExpression.Evaluate()
{
	switch(op)
	{
	case BinaryOperator.Add:
		return left.Evaluate()+right.Evaluate();
	case BinaryOperator.Sub:
		return left.Evaluate()-right.Evaluate();
	case BinaryOperator.Mul:
		return left.Evaluate()*right.Evaluate();
	case BinaryOperator.Div:
		return left.Evaluate()/right.Evaluate();

	// if the switch statement needs to execute the "default" section
	// but there is no "default" section
	// then it will throw a SwitchFailException
	}
}

------------------------

intptr GetStdoutHandle() __foreign "GetStdoutHandle";
void WriteIOHandle(intptr handle, string text) __foreign "WriteIOHandle";

ref struct Stdout
{
	intptr stdoutHandle;
}

instance Stdout as TextWriter
{
	bool Stdout.Write(string text)
	{
		WriteIOHandle(stdoutHandle, text);
	}
}

Stdout stdout = new Stdout
{
	stdoutHandle = GetStdoutHandle();
};

ITextWriter Console
{
	get
	{
		try
		{
			return (TextWriter)stdout;
		}
		catch(TypeConvertException ex)
		{
			Stderr.Write(ex.Message);
			throw;
		}
	}
}

------------------------

void Main()
{
	int32[] numbers={1,2,3,4,5,6,7,8,9,10};
	Console.Write(numbers);
}

------------------------

ref concept T as Disposable
{
	void T.Dispose();
}

using (var v = expr){}

------------------------

void Function(int a, ref int b);

// function type
int(int, ref int)

struct Type
{
	int field;
}

int Type.Property
{
	get{}set{}
}

int Type.this[int index]
{
	get{}set{}
}

Type type;
Function(ref type.field);
Function(ref type.Property);
Function(ref type[0]);

------------------------

instance<T> Concept<int, T>{}
instance<T> Concept<T, string>{}

instance Concept<int, string>
{
	// A {mixin B}: foreach type argument in A and B there is A is not less general
	// e.g. A(T) B(string), A(Expression), B(NumberExpression), A(int), B(int)
	// but cannot mixin itself
	mixin instance Concept<int, T>

	... // like overridding
}

------------------------

ref struct A{}
ref struct B{mixin A;}

instance A as Concept{}

instance B as Concept
{
	mixin instance A as Concept

	... // like overridding
}

------------------------

// predefine concepts

// (T)e
// e as T
concept Convertable<TSource, TDest>
{
	TDest Convert(TSource source);
}

concept ImplicitConvertable<TSource, TDesT>
{
	TDest Convert(TSource source);
}

// catch(x)
ref concept T as Catchable
{
	string T.Message{get;}
}

// using(var x=y)
ref concept T as Disposable
{
	void T.Dispose();
}

// foreach(var x in xs)
ref concept TThis as Enumerable<T>
{
	Enumerator<T> TThis.CreateEnumerator();
}

ref concept TThis as Enumerator<T>
{
	bool TThis.MoveNext();
	T TThis.Current{get;}
}

// new InterfaceConceptType
concept DefaultImpl<T>
	requires ref concept T
{
	T CreateDefaultImpl;
}

------------------------

concept Negatable<T>			// + - (unary operator)
concept Increasable<T>			// ++ -- (unary operator), T operator prefix ++(ref T), T operator postfix ++(ref T), ...
concept Shiftable<T>			// << <<= >> >>=
concept Multable<T>				// * *= / /=
concept Modulable<T>			// % %=
concept Addable<T>				// + += - -=, T operator+(T, T), void operator+(ref T, T), ...
concept BitOperatable<T>		// & &= | |= ^ ^=
concept Equable<T>				// == !=
concept Comparable<T>			// < > <= >=
concept LogicalOperatable<T>	// && &&= || ||= ^ ^=  !(unary operator)

<< >>
* / %
+ -
< <= > >= == !=
&
^
|
&&
||
?:
??

------------------------

// generic requires statement

requires Concept<Ts...> // instance Concept<Ts...> exists
requires T as Concept<Ts...> // instance T as Concept<Ts...> exists
requires T as Type // (T is Type or T mixin Type)
requires T as new() // (T is struct) or (T is ref struct) or (T is ref concept with instance DefaultImpl<T>)
requires [struct | ref struct | ref concept] T as Concept<Ts...>, Type, new(), ...
          ^-- "|" is really can be used here

------------------------

a=>b
(int a)=>b
(a, b)=>c
(int a, int b)=>c
(int a, int b){return c;}
delegate int(int a, int b){return c;}

------------------------

concept Continuable<TC>
{
}

concept ContinuationNullable<TC>
{
	TC Null{get;}
}

concept ContinuationReturnable<T, TC>
{
	TC Return(T t);
}

concept ContinuationBindable<TC, T, UC>
{
	UC Bind(TC closure, UC(T) continuation);
}

------------------------

instance<T> ContinuationNullable<Enumerable<T>>;
instance<T> ContinuationBindable<T, T, Enumerable<T>>;
instance<T> ContinuationBindable<Enumerable<T>, Enumerable<T>, Enumerable<T>>;

instance<T> ContinuationReturnable<T, Task<T>>;
instance<T, U> ContinuationBindable<Task<T>, T, Task<U>>;

------------------------

Enumerable<T> Take<T>(Enumerable<T> ts, int count) yield
{
	Enumerator<T> e=ts.CreateEnumerator();
	while(count-->0)
	{
		if(!e.MoveNext()) return;
		yield e.Current;
	}
}

Enumerable<T> $Take$0<T>(Enumerable<T>, int count)
{
	Enumerator<T> e=ts.CreateEnumerator();
	if(count-->0)
	{
		if(!e.MoveNext()) return ContinuationNullable<Enumerable<T>>.Null;
		return ContinuationBindable<T, T, Enumerable<T>>.Bind(e.Current, $yield=>$Take$1<T>($yield, e, count));
	}
	return ContinuationNullable<Enumerable<T>>.Null;
}

Enumerable<T> $Take$1<T>(T $yield, Enumerator<T> e, int count)
{
	if(count-->0)
	{
		if(!e.MoveNext()) return ContinuationNullable<Enumerable<T>>.Null;
		return ContinuationBindable<T, T, Enumerable<T>>.Bind(e.Current, $yield=>$Take$1<T>($yield, e, count));
	}
	return ContinuationNullable<Enumerable<T>>.Null;
}

------------------------

Enumerable<T> Concat<T>(Enumerable<T> a, Enumerable<T> b) yield
{
	yield a;
	yield b;
}

Enumerable<T> $Concat$0<T>(Enumerable<T> a, Enumerable<T> b)
{
	return ContinuationBindable<Enumerable<T>, Enumerable<T>, Enumerable<T>>.Bind(a, $yield=>$Concat$1<T>($yield, b));
}

Enumerable<T> $Concat$1<T>(Enumerable<T> $yield, Enumerable<T> b)
{
	return b;
}

------------------------

Task<string[]> DownloadAndJoin(string[] urls) yield
{
	List<string> result = new List<string>;
	foreach(var url in urls)
	{
		result.Add(yield DownloadAsync(url));
	}
	return result.ToArray();
}

Task<string[]> $DownloadAndJoin$0(string[] urls)
{
	List<string> result = new List<string>;
	Enumerator<string> e=urls.CreateEnumerator();
	if(e.MoveNext())
	{
		return ContinuationBindable<Task<string>, string, Task<string[]>>.Bind(DownloadAsync(url), $yield=>$DownloadAndJoin$1($yield, result, e));
	}
	return ContinuationReturnable<Task<string[]>>.Return(result.ToArray());
}

Task<string[]> $DownloadAndJoin$1(string text, List<string> result, Enumerator<string> e)
{
	result.Add(text);
	if(e.MoveNext())
	{
		return ContinuationBindable<Task<string>, string, Task<string[]>>.Bind(DownloadAsync(url), $yield=>$DownloadAndJoin$1($yield, result, e));
	}
	return ContinuationReturnable<Task<string[]>>.Return(result.ToArray());
}

------------------------

int a=0;
ref int b=ref a;

------------------------

(T1, T2, T3) = Pair<T1, Pair<T2, Pair<T3, void>>>

R(Ts...) == R(params (Ts, ...))
f(a, b, c) == f(params (a, b, c))

tuple type		: (X<Ts>, ...)
tuple value		: (f(ts), ...)
				: (a, b, (ts, ...)) // because tuple is pair, (T0, (T1, T2)) == (T0, T1, T2)

function type	: R(T0, T1, X<Ts> ...)
				: R(params (T0, T1, (X<Ts>, ...)))

function decl	: R f(T0 t0, T1 t1, X<Ts> ts ...)
				: R f(params (T0, T1, (X<Ts>, ...)) values) // params tuple v.s. params array: R f(T0 t0, T1 t1, params X<T> values)

invoke function	: f(a, b, f(ts) ...)
				: f(params (a, b, (ts, ...)))

------------------------

concept ObjectArrayInitializable<T>
{
	T FromArray(params object[] values);
	object[] ToArray(T value);
}

instance<T> ObjectArrayInitializable<Pair<T, void>>
{
	Pair<T, void> FromArray(params object values)
	{
		if(values.Length!=1) throw ArgumentException
		{
			Message = "...";
		};
		return ((T)values[0], new void);
	}

	object[] ToArray(Pair<T, void> value)
	{
		return new object[]{value.First};
	}
}

instance<T, U> ObjectArrayInitializable<Pair<T, U>>
{
	Pair<T, U> FromArray(params object values)
	{
		if(values.Length<=2) throw ArgumentException
		{
			Message = "...";
		};
		return ((T)values[0], ObjectArrayInitializable<U>.FromArray(values.Skip(1).ToArray());
	}

	object[] ToArray(Pair<T, U> value)
	{
		return new object[]{value.First}.Concat(ObjectArrayInitializable<U>.ToArray(value.Second));
	}
}

object(object[]) ToProxy<R, Ts...>(R(Ts...) function)
{
	return ps=>R(params ObjectArrayInitializable<(Ts, ...)>.FromArray(parameters);
}

R(Ts...) FromProxy<R, Ts...>(object(object[]) proxy)
{
	return (Ts ts...)=>(R)proxy(ObjectArrayInitializable<(Ts, ...)>.ToArray((ts, ...));
}

------------------------