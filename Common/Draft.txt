A library like the old Syngram in VL++1.0 that receives code to generate parser in memory or in C++.

Parser Syntax
In-Memory Parser
In-Memory Data Structure

Generated C++ Recursive Descent Parser
Generated C++ Data Structure + Visitor Pattern <--> In-Memory Data Structure

XML/JSON in-memory parser / C++ parser
========================================================

class Type{}

class DecoratedType : Type
{
	enum Decoration
	{
		Pointer,
		Reference,
		Array,
	}
	Decoration		decoration;
	Type			elementType;
}

class PrimitiveType : Type
{
	token			name;
}

class GenericType : Type
{
	Type			type;
	Type[]			arguments;
}

class SubType : Type
{
	Type			type;
	token			name;
}

class FunctionType : Type
{
	Type			returnType;
	Type[]			arguments;
}

token SYMBOL		= <|>|\[|\]|\(|\)|,|::|\*|&
token NAME			= [a-zA-Z_]\w*

========================================================

rule Type SubableType	= NAME[name] as PrimitiveType
						= SubableType[type] '<' Type[arguments] { ',' Type[arguments] } '>' as GenericType
						= SubableType[type] '::' NAME[name] as SubType

rule Type Type			= use SubableType
						= Type[elementType](
								( '*' {decoration = DecoratedType::Pointer}
								| '&' {decoration = DecoratedType::Reference}
								| '[' ']' {decoration = ecoratedType::Array}
								)
							) as DecoratedType
						= Type[returnType] '(' Type[arguments] { ',' Type[arguments] } ')' as FunctionType

========================================================

rule PrimitiveType	PrimitiveType	= NAME[name]
rule GenericType	GenericType		= SubableType[type] '<' Type[arguments] { ',' Type[arguments] } '>'
rule SubType		SubType			= SubableType[type] :: NAME[name]
rule Type			SubableType		= use PrimitiveType | use GenericType | use SubType

rule DecoratedType	DecoratedType	= Type[elementType] '*' {decoration = DecoratedType::Pointer}
									= Type[elementType] '&' {decoration = DecoratedType::Reference}
									= Type[elementType] '[' ']' {decoration = DecoratedType::Array}
rule FunctionType	FunctionType	= Type[returnType] '(' Type[arguments] { ',' Type[arguments] } ')'
rule Type			Type			= use SubableType | use DecoratedType | use FunctionType

========================================================

_Seq	: a b
_Alt	: a | b // cast a and b to the nearest common parent type
_Loop	: { a }
_Opt	: [ a ]
_Token	: NAME
_Rule	: Type
_Create	: GRAMMAR as Type
_Assign	: RULE[name] / token[name]
_Use	: use RULE

Priority:
	_Use/_Assign > _Seq > _Create > _Alt

In a rule, any possible matching path should only contains one _Create or one _Use exclusively.
If a rule contains _Create or _Use, all possible matching path that doesn't contains any _Create or _Use is considered returning null.
If a rule doesn't contains any _Create or _Use, it is treated as always uses _Create(rule type).

========================================================
parse intel manual 2A and 2B to get binary code table
x86 and x64 assembler
intermediate code
enriched C language
design a language for Calculation, AsyncIO, Server and GUI programming