A library like the old Syngram in VL++1.0 that receives code to generate parser in memory or in C++.

Parser Syntax
In-Memory Parser
In-Memory Data Structure

Generated C++ Recursive Descent Parser
Generated C++ Data Structure + Visitor Pattern <--> In-Memory Data Structure

XML/JSON in-memory parser / C++ parser
========================================================
parse intel manual 2A and 2B to get binary code table
x86 and x64 assembler
intermediate code
enriched C language
design a language for Calculation, AsyncIO, Server and GUI programming
========================================================

concept Equable<T>
{
	bool IsEqual(T a, T b);
}

bool operator==<T>(T a, T b)
	requires Equable<T>
{
	return IsEqual(a, b);
}

bool operator==<T>(T a, T b)
	requires Equable<T>
{
	return !IsEqual(a, b);
}

instance Equable<int32>
{
	bool IsEqual(int32 a, int32 b) __embedded_asm equ_i32;
}

instance Equable<int64>
{
	bool IsEqual(int64 a, int64 b) __inline __asm
	{
		push_i64 a;
		push_i64 b;
		equ_i64;
		ret;
	}
}

------------------------

concept T as TextWriter
{
	bool T.Write(string text);
}

concept Convertable<TSource, TDest>
{
	TDest Convert(TSource source);
}

concept Printable<T>
{
	bool TextWriter.Write(T value);
}

instance<T> Printable<T>
	requires Convertable<T, string>
{
	bool TextWriter.Print(T value)
	{
		string text=Convert(value);
		return Write(text);
	}
}

instance Convertable<int32, string>
{
	string Convert(int32 source) __foreign "Int32ToString";
}

instance<T> Convertable<T[], string>
	requires Convertable<T, string>
{
	string Convert(T[] source)
	{
		string result;
		foreach(var i in source)
		{
			string text=Convert(i); // Convertable<T, string>.Convert(i);
			result+=", {0}".Format(text);
		}
		return result==""?"":result.SubString(2);
	}
}

------------------------

concept T as Catchable
{
	string T.Message{get;}
}

ref struct Exception
{
	string message;
}

instance Exception as Catchable
{
	string ExceptionBase.Message
	{
		get return message;
	}
}

ref struct ArgumentException
{
	mixin Exception;
	string argument;
}

ref struct IndexOutOfRangeException
{
	mixin ArgumentException;
}

ref struct TypeConvertException
{
	mixin Exception;
	Type sourceType;
	Type destinationType;
}

------------------------

enum BinaryOperator
{
	Add, Sub, Mul, Div
}

ref struct Expression{}

ref struct NumberExpression
{
	// only ref struct can mixin another ref struct
	// mixin inherits concepts
	// mixin is equivalent to virtual & multiple inheritance
	mixin Expression;
	double number;
}

ref struct BinaryExpression
{
	mixin Expression;
	BinaryOperator op;
	Expression left;
	Expression right;
}

------------------------

// another way to achieve this
// double Evaluate(switch Expression expr);
double switch Expression.Evaluate();

double case NumberExpression.Evaluate()
{
	return number;
}

double case BinaryExpression.Evaluate()
{
	switch(op)
	{
	case BinaryOperator.Add:
		return left.Evaluate()+right.Evaluate();
	case BinaryOperator.Sub:
		return left.Evaluate()-right.Evaluate();
	case BinaryOperator.Mul:
		return left.Evaluate()*right.Evaluate();
	case BinaryOperator.Div:
		return left.Evaluate()/right.Evaluate();

	// if the switch statement needs to execute the "default" section
	// but there is no "default" section
	// then it will throw a SwitchFailException
	}
}

------------------------

intptr GetStdoutHandle() __foreign "GetStdoutHandle";
void WriteIOHandle(intptr handle, string text) __foreign "WriteIOHandle";

ref struct Stdout
{
	intptr stdoutHandle;
}

instance Stdout as TextWriter
{
	bool Stdout.Write(string text)
	{
		WriteIOHandle(stdoutHandle, text);
	}
}

Stdout stdout = new Stdout
{
	stdoutHandle = GetStdoutHandle();
};

ITextWriter Console
{
	get
	{
		try
		{
			return (TextWriter)stdout;
		}
		catch(TypeConvertException ex)
		{
			Stderr.Write(ex.Message);
			throw;
		}
	}
}

------------------------

void Main()
{
	int32[] numbers={1,2,3,4,5,6,7,8,9,10};
	Console.Write(numbers);
}

------------------------

concept T as Disposable
{
	void T.Dispose();
}

using (var v = expr){}

------------------------

void Function(int a, ref int b);

// function type
int(int, int)

------------------------

instance<T> Concept<int, T>{}
instance<T> Concept<T, string>{}

instance Concept<int, string>
{
	// A {mixin B}: foreach type argument in A and B there is A is not less general
	// e.g. A(T) B(string), A(Expression), B(NumberExpression), A(int), B(int)
	// but cannot mixin itself
	mixin instance Concept<int, T>

	... // like overridding
}

------------------------

ref struct A{}
ref struct B{mixin A;}

instance A as Concept{}

instance B as Concept
{
	mixin instance A as Concept

	... // like overridding
}

------------------------

concept Continuation
{
	// disigning
}