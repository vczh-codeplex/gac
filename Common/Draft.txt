A library like the old Syngram in VL++1.0 that receives code to generate parser in memory or in C++.

Parser Syntax
In-Memory Parser
In-Memory Data Structure

Generated C++ Recursive Descent Parser
Generated C++ Data Structure + Visitor Pattern <--> In-Memory Data Structure

XML/JSON in-memory parser / C++ parser
========================================================
parse intel manual 2A and 2B to get binary code table
x86 and x64 assembler
intermediate code
enriched C language
design a language for Calculation, AsyncIO, Server and GUI programming
========================================================

concept Equable<T>
{
	bool IsEqual(T a, T b);
}

bool operator==<T>(T a, T b)
	with Equable<T>
{
	return IsEqual(a, b);
}

bool operator==<T>(T a, T b)
	with Equable<T>
{
	return !IsEqual(a, b);
}

instance Equable<int32>
{
	bool IsEqual(int32 a, int32 b) __embedded_asm equ_i32;
}

instance Equable<int64>
{
	bool IsEqual(int64 a, int64 b) __inline __asm
	{
		push_i64 a;
		push_i64 b;
		equ_i64;
		ret;
	}
}

------------------------

concept T as TextWriter
{
	bool T.Write(string text);
}

concept Convertable<TSource, TDest>
{
	TDest Convert(TSource source);
}

concept Printable<T>
{
	bool TextWriter.Write(T value);
}

instance<T> Printable<T>
	with Convertable<T, string>
{
	bool TextWriter.Print(T value);
	{
		string text=Convert(value);
		return Write(text);
	}
}

instance Convertable<int32, string>
{
	string Convert(int32 source) __foreign "Int32ToString";
}

instance<T> Convertable<T[], string>
	with Convertable<T, string>
{
	string Convert(T[] source)
	{
		string result;
		foreach(var i in source)
		{
			string text=Convert(i); // Convertable<T, string>.Convert(i);
			result+=", {0}".Format(text);
		}
		return result==""?"":result.SubString(2);
	}
}

------------------------

concept T as Catchable
{
	string T.Message{get;}
}

ref struct Exception
{
	string message;
}

instance Exception as Catchable
{
	string ExceptionBase.Message
	{
		get return message;
	}
}

ref struct ArgumentException
{
	mixin Exception;
	string argument;
}

ref struct IndexOutOfRangeException
{
	mixin ArgumentException;
}

ref struct TypeConvertException
{
	mixin Exception;
	Type sourceType;
	Type destinationType;
}

------------------------

enum BinaryOperator
{
	Add, Sub, Mul, Div
}

--begin--

ref struct Expression
{
	case NumberExpression
	{
		double number;
	}

	case BinaryExpression
	{
		BinaryOperator op;
		Expression left;
		Expression right;
	}
}

--or--

ref struct Expression{}

ref struct NumberExpression
{
	mixin Expression;
	double number;
}

ref struct BinaryExpression
{
	mixin Expression;
	Expression left;
	Expression right;
}

--end--

double Expression.Evaluate()
{
	switch(this)
	{
		case NumberExpression e:
			return e.number;
		case BinaryExpression e with e.op == BinaryOperator.Add:
			return e.left.Evaluate() + e.right.Evaluate();
		case BinaryExpression e with e.op == BinaryOperator.Sub:
			return e.left.Evaluate() - e.right.Evaluate();
		case BinaryExpression e with e.op == BinaryOperator.Mul:
			return e.left.Evaluate() * e.right.Evaluate();
		case BinaryExpression e with e.op == BinaryOperator.Div:
			return e.left.Evaluate() / e.right.Evaluate();
	}
	throw new ArgumentException
	{
		message = "Internal Error."
		argument = "this";
	};
}

double Expression.Evaluate()
{
	switch(this)
	{
		case NumberExpression e:
			return e.number;
		case BinaryExpression e:
			switch(e.op)
			{
			case BinaryOperator.Add:
				return e.left.Evaluate() + e.right.Evaluate();
			case BinaryOperator.Sub:
				return e.left.Evaluate() - e.right.Evaluate();
			case BinaryOperator.Mul:
				return e.left.Evaluate() * e.right.Evaluate();
			case BinaryOperator.Div:
				return e.left.Evaluate() / e.right.Evaluate();
			}
	}
	throw new ArgumentException
	{
		message = "Internal Error.";
		argument = "this";
	};
}

------------------------

intptr GetStdoutHandle() __foreign "GetStdoutHandle";
void ReleaseStdoutHandle(intptr handle) __foreign "ReleaseStdoutHandle";
void WriteIOHandle(intptr handle, string text) __foreign "WriteIOHandle";

concept __RAII<T>
{
	void T.Initialize() __invisible;
	void T.Finalize() __invisible;
}

struct Stdout
{
	intptr stdoutHandle;
}

instance Stdout as TextWriter
{
	bool Stdout.Write(string text)
	{
		WriteIOHandle(stdoutHandle, text);
	}
}

instance __RAII<Stdout>
{
	void Stdout.Initialize()
	{
		stdoutHandle = GetStdoutHandle();
	}

	void Stdout.Finalize()
	{
		ReleaseStdoutHandle(stdoutHandle);
		stdoutHandle=null;
	}
}

Stdout stdout;

ITextWriter Console
{
	get
	{
		try
		{
			return (TextWriter)stdout;
		}
		catch(TypeConvertException ex)
		{
			Stderr.Write(ex.Message);
			throw;
		}
	}
}

------------------------

void Main()
{
	int32[] numbers={1,2,3,4,5,6,7,8,9,10};
	Console.Write(numbers);
}