========================================================
Primitive Types
========================================================

void				system.Void
interface			system.Interface
object				system.Object
uint8				system.UInt8
uint16				system.UInt16
uint32				system.UInt32				(uint)
uint64				system.UInt64
int8				system.Int8
int16				system.Int16
int32				system.Int32				(int)
int64				system.Int64
float				system.Single
double				system.Double
bool				system.Boolean
char				system.Char
string				system.String
					system.DateTime
					system.Locale
					system.Enumerator
					system.Enumerable			{dynamic}
					system.ReadableList			const [dynamic]
					system.List					[dynamic]
					system.ReadableDictionary	const {dynamic:dynamic}
					system.Dictionary			{dynamic:dynamic}
					system.InterfaceProxy
					system.Function				func dynamic
dynamic

========================================================
Composite Types
========================================================

{T}					system.Enumerable<T>
[T]					system.List<T>
const [T]			system.ReadableList<T>
{U:T}				system.Dictionary<U, T>
const {U:T}			system.ReadableDictionary<U, T>
func (T1, T2):R		system.Function<R, T1, T2>
func (T1, T2)		system.Function<void, T1, T2>

ClassType*			raw pointer
CLassType			shared pointer

========================================================
Definitions
========================================================

struct Point
{
	x : int,
	y : int
}

enum Season
{
	Spring,
	Summer,
	Autumn,
	Winter
}

func Sum(xs : {int}) : int
{
	result : int = 0;
	for(x in xs)
	{
		result = result + x;
	}
	return x;
}

[extern []] interface IDerived : IBase1, IBase2
{
	[static] func Do(x : string);
	ctor (proxy : system.InterfaceProxy);
	event Clicked : func (GuiGraphicsComposition*, GuiEventArgs*);
	prop Text : string {get GetText, set SetText}
}

namespace system
{
}

========================================================
Constructors
========================================================

0
1.0
"fuck"
true
false

{}
[]
[1, 2, 3]
{
	"x" : 1,
	"y" : 2,
	"z" : 3
}

Point { x : 1, y : 2 }
{ x : 1, y : 2 }

Class(100) [{ ... }]
Class
{
	A : 0,
	B.C.D : 1,
	.Do("fuck"),

	obj1, obj2, obj3 ...
}

x => x+1
(x) => { return x+1; }
func (x : int) : int { return x+1; }

new IDerived
{
    func Do(x : string)
	{
		Print(x);
	}
}

========================================================
Expressions
========================================================

Unary:
	+
	-
	~
	!
Binary:
	* / %
	+ -
	<< >>
	< <= > >=
	== !=
	&
	^
	|
	&&
	||

a[b]
a(b, c)
a.b
(a)
(Type)a
cast a
this

========================================================
Statements
========================================================

a = b;
a : Type = b;
var a = b;

<function-call-expression>;
raise this.Clicked(composition, args);

delete exp;
return [exp];
break;
continue;

if (exp) statement [else statement]
try if(x [: Type] = exp) statement [else statement]
while (exp) statement
do statement while (exp);
for(x [: Type] in xs) statement
for(x [: Type] in a to b) statement
try statement [catch(ex [: string])] statement [finally statement]