Free Script 3.0

========================================================
Operator
========================================================

operator precedence
	=> <full expression>
	a[b]
	a(b)
	+ - !
	* / \ %
	+ - ++ // ++: join strings or arrays
	<< >>
	..
	== != < <= > >=
	^
	&&
	||

// operator prefix + is a function name which will be translated to @`$operator:prefix+`
function operator prefix +(switch obj);

property opeartor[](switch container, switch index);
property operator[](container of Array, index of Literal){ ... }
property operator[](container of Map, index of Object){ ... }

========================================================
Built-in types
========================================================

Object
Function
Array
Map
Enumerable
Literal
Null

========================================================
Expression
========================================================

a[b]
a(b)
x=>x+1
x=>y=>x+y
(x, y)=>x+y
()=>x+y
function(x, y){statements;}
function{statement;}
a.b
(a)
a+b

array:			[1,2,3,4]
map:			{key1:value1, key2:value2}
tuple:			(a,b,c,d)
enumerable:		@[x1, x2, x3:xs]

name
@keyword
@"complex-name"
@`complex-name`

null
1
1.1
"abc"
`abc``def` // syntax suger for: "abc`def"

value // new value in property setter
this
base(BaseClass)

========================================================
Declaration
========================================================

var variable [= expression]; // create a variable
const variable = expression; // create a readonly variable

enum Season
{
	Spring,
	Summer,
	Autumn,
	Winter
}

function name[(a,b,c)] // syntax suger for: const name=function(a,b,c){ body };
{
	body
}

property variable4
{
	get=>expression;
	get{ body }

	set=>expression;
	set{ body }
}

struct Point // value class
{
   x=0;
   y=0;
   z;
}

var p = new Point{z=0};

class Derived : Base1, Base2
{
	function new(parameters)
		:Base1(arguments1)
		,Base2(arguments2)
	{ ... }

	function Method1 ...
	function Method2 ...
	fixed variable1 ...
	var variable2 ...
	property variable3 ...
	shared variable4 ... // static and readonly
}

var d = new Derived(arguments){variable2=null};

namespace System.Collections
{
}

using System.Collections;

extension Enumerable
{
    function Select(selector){ ... }
}

class Array
{
	extent Enumerable;
}

extent class Array
{
	extent Enumerable;
}

========================================================
Attributes
========================================================

/*
multiple attributes can be put before

declaration
member
parameter
*/

#Class(parameters)	// construct an attribute value for a declaration from type ClassAttribute
#Class				// syntax suger for: #Class()

#DefaultEntry("http://*:80")
class Website
{
	#Get("/index.htm")
	function Index()
	{
		return `<html> ... </html>`;
	}

	// /hello/vczh.htm?language=zh-cn
	#Get("/hello/{name}.htm")
	function Hello(name, #query language)
	{
		...
	}
}

function main()
{
	new HttpServer(new Website()).Run();
}

========================================================
Context
========================================================

// dynamic context, fixed context

__context_global()					// the globa context
__context_current()					// the current context
__context_parent(context)			// the parent context
__context_base_count(context)		// the number of base contexts
__context_base(context, index)		// the specified base context by index

// when searching for context.variable, base contexts will count in

__context_get(context, name)				// get a field in a context
__context_get_base(context, name)			// including base contexts (in order)
__context_get_parent(context, name)			// including base contexts (in order) and parent context

__context_handle(context, name)				// get a handle in a context
__context_handle_base(context, name)		// including base contexts (in order)
__context_handle_parent(context, name)		// including base contexts (in order) and parent context
__context_handle_set(handle, value)			// set a new value to the handle

========================================================
Statement
========================================================

expression;
pattern = expression;
reference = expression;

if(condition) statement [else statement]
while(condition) statement
do statement while(condition);
foreach(pattern in xs) statement

switch(expression)
{
	case pattern: statement
	case value: statement
	...
	default: statement // fall in non-existing default branch throws MatchFailedException
}

break;
continue;
return [expression];

try
{
}
catch([pattern])
{
}
finally
{
}

========================================================
Continuation
========================================================

function TakeUntil(xs, p) Enumerator
{
	foreach(x in xs)
	{
		if(!p(x)) return;
		yield x;
	}
}

function Flatten(tree) Enumerator
{
	yield tree;
	join tree.children.Select(Flatten);
}

function Flatten(tree)
{
	return @[tree : tree.children.Select(Flatten)];
}

function button1_Click(sender, args) Async
{
    button1.Enabled=false;
	textBox1.Text=join DownloadAsync("url");
	button1.Enabled=true;
}

function InvokeExpression() Parser
{
    var name = join Expression();
	join Token("(");

	var arguments=new List;
	Parser.Try() yield
	{
		arguments.Add(join Expression());
		Parser.Repeat() yield
		{
			join Token(",");
			arguments.Add(join Expression());
		}
	}

	join Token(")");
	return new InvokeExpression
	{
		Name=name,
		Arguments=arguments
	};
}

yield expression;
return [expression];
join expression // one expression statement can contains up to one join expression

expression yield [(arguments)] {...} // syntax suger for: join expression(function (arguments) Continuation{...});

========================================================
Double Dispatch
========================================================

function Intersect(switch obj1, switch obj2);

function Intersect(obj1 of Rectangle, obj2 of Ellipse)
{
	...
}

function Intersect(obj1 of Rectangle, obj2 of Rectangle)
{
	...
}

...

// switch and match function should appear in the same scope
// namespaces under the same name is the same scope
// class and extension class is the same scope
// class and extension is not the same scope

========================================================
Pattern Matching
========================================================

(a, 2, c)
@[x1, x2, x3:xs]
[x1, "a", "b"]
((1, x, 3), 4, y)
name of Type
(a of Rectangle, b of Ellipse)
1
a.b

========================================================
Refactoring
========================================================

GetAppDomain().Assemblies.Types
GetAppDomain().FindType("...")
typeof(Type)
...