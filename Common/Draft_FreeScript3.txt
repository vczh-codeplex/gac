Free Script 3.0

========================================================
Operator
========================================================

operator precedence
	=> <full expression>
	a[b]
	a(b)
	+ - !
	* / \ %
	+ - ++ // ++: join strings or arrays
	<< >>
	..
	== != < <= > >=
	^
	&&
	||

========================================================
Expression
========================================================

a[b]
a(b)
x=>x+1
x=>y=>x+y
(x, y)=>x+y
function(x, y){statements;}
a.b
(a)
a+b

array:		[1,2,3,4]
map:		{key1:value1, key2:value2}
tuple:		(a,b,c,d)
iterator:	@[x1, x2, x3:xs]

null
1
1.1
"abc"
`abc``def` // syntax suger for: "abc`def"

value // new value in property setter
this
base(BaseClass)

========================================================
Declaration
========================================================

var variable [= expression]; // create a variable
const variable = expression; // create a readonly variable

function name(a,b,c) // syntax suger for: const name=function(a,b,c){ body };
{
	body
}

property variable4
{
	get=>expression;
	get{ body }

	set=>expression;
	set{ body }
}

struct Point // value class
{
   x=0;
   y=0;
   z;
}

var p = new Point{z=0};

class Derived : Base1, Base2
{
	function new(parameters)
		:Base1(arguments1)
		,Base2(arguments2)
	{ ... }

	function Method1 ...
	function Method2 ...
	fixed variable1 ...
	var variable2 ...
	property variable3 ...
	shared variable4 ... // static and readonly
}

var d = new Derived(arguments){variable2=null};

namespace System.Collections
{
}

using System.Collections;

extension Enumerable
{
    function Select(selector){ ... }
}

class Array
{
	extent Enumerable;
}

extent class Array
{
	extent Enumerable;
}

========================================================
Context
========================================================

// dynamic context, fixed context

__context_global()					// the globa context
__context_current()					// the current context
__context_parent(context)			// the parent context
__context_base_count(context)		// the number of base contexts
__context_base(context, index)		// the specified base context by index

// when searching for context.variable, base contexts will count in

__context_get(context, name)				// get a field in a context
__context_get_base(context, name)			// including base contexts (in order)
__context_get_parent(context, name)			// including base contexts (in order) and parent context

__context_handle(context, name)				// get a handle in a context
__context_handle_base(context, name)		// including base contexts (in order)
__context_handle_parent(context, name)		// including base contexts (in order) and parent context
__context_handle_set(handle, value)			// set a new value to the handle

========================================================
Statement
========================================================

expression;
match pattern = expression;

if(condition) statement [else statement]
while(condition) statement
do statement while(condition);
foreach(x in xs) statement

switch(expression)
{
	match pattern: statement
	case value: statement
	...
	default: statement // fall in non-existing default branch throws MatchFailedException
}

break;
continue;
return [expression];

try
{
}
catch([pattern])
{
}
finally
{
}

========================================================
Continuation
========================================================



========================================================
Double Dispatch
========================================================

function Intersect(switch obj1, switch obj2);

function Intersect(obj1 of Rectangle, obj2 of Ellipse)
{
	...
}

// switch and match function should appear in the same scope
// namespaces under the same name is the same scope
// class and extension class is the same scope
// class and extension is not the same scope

========================================================
Pattern Matching
========================================================

(a, 2, c)
@[x1, x2, x3:xs]
[x1, "a", "b"]
((1, x, 3), 4, y)
name of Type
typeof Type
(a of Rectangle, typeof Ellipse)