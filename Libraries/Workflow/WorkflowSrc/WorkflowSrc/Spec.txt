ReferenceType means pointer
ReferenceType^ means smart pointer
int[] is ValueList^
int[string] is ValueDictionary^
int{} is ValueEnumerable^
int(string, string) is ValueFunction^
int -> Int32/64
uint -> UInt32/64

captured variable cannot be modified
struct fields cannot be modified
argument cannot be modified
======================================================
^
* /
+ - not
shl shr
< > <= >= != ==
xor
and
or
----------------------------
"String" // can be implicitly converted to all other serializable types
$"1 + 2 = $(1 + 2)"
' and " is exchangable, '' in 'string' means ''', "" in "string" means '"'
true false null
----------------------------
let x = expression in expression
condition ? true_branch : false_branch
x in (a, b) | [a, b) | (a, b] | [a, b]
x in collection
----------------------------
// the meaning of the following patterns of expression dependes on the destination type
{a b c d}
{a:b c:d}
Spring
Spring | Summer | Autumn | Winter
----------------------------
int[]{a b c d}
int[string]{a:b c:d e:f}
Point{x:10 y:20}
----------------------------
x(y)
x(x, y, z)
x.y
[$+1]
[$1+$2]
func Type(Type a, Type b) <statement>
----------------------------
ptr(T^) -> T*
shared_ptr(T*) -> T^
expression :: Type		// infer
cast Type expression	// cast, exception if failed
expression as Type		// cast, null if failed
expression is Type		// test
======================================================
func Type Name(Type a, Type b) <statement>

{ statement ... }

var [Type] Name = <expression>;
<left-value> = <right-value>;
break;
continue;
return [<expression>];

if ([cast Type Name = ] <expression>) <statement> [else <statement>]
select (<expression>)
{
	{case condition : <statement>}
	[default : <statement>]
}

while condition do <statement>
do <statement> while condition;
for (x in (<collection> | [reversed] <range>)) <statement>