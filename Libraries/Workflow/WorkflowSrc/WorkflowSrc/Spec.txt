ReferenceType means pointer
ReferenceType^ means smart pointer
int[] is ValueList^
int[string] is ValueDictionary^
int{} is ValueEnumerable^
int(string, string) is ValueFunction^
int -> Int32/64
uint -> UInt32/64

captured variable cannot be modified
struct fields cannot be modified
argument cannot be modified
======================================================
^
* /
+ - not
shl shr
< > <= >= != ==
xor
and
or
----------------------------
"String" // can be implicitly converted to all other serializable types
$"1 + 2 = $(1 + 2)"
' and " is exchangable, '' in 'string' means ''', "" in "string" means '"'
true false null
----------------------------
let x = expression in expression
condition ? true_branch : false_branch
x in (a, b) | [a, b) | (a, b] | [a, b]
x in collection
----------------------------
// the meaning of the following patterns of expression dependes on the destination type
{a b c d}
{a:b c:d}
Spring
Spring | Summer | Autumn | Winter
----------------------------
int[]{a b c d}
int[string]{a:b c:d e:f}
Point{x:10 y:20}
----------------------------
x(y)
x(x, y, z)
x.y
[$+1]
[$1+$2]
func Type(Type a, Type b) <statements> end
----------------------------
ptr(T^) -> T*
shared_ptr(T*) -> T^
expression :: Type // infer
expression as Type // cast
expression is Type // test
======================================================
func Type Name(Type a, Type b) <statements> end

var [Type] Name = <expression>
break
continue
exit
return <expression>

<left-value> = <right-value>
if condition then <statements> {else if condition then <statements>} [else <statements>] end
select <expression> {case condition do <statements>} [else <statements>] end
// condition in if statement can be "<expression>" or "cast Type Name = <expression>"

while condition do <statements> end
loop <statements> until condition
for x in (<collection> | [reversed] <range>) do <statements> end