include:"../../../../Common/Source/Parsing/Parsing.h"
include:"../../../../Common/Source/Parsing/ParsingDefinitions.h"
include:"../../../../Common/Source/Parsing/ParsingAutomaton.h"
namespace:vl.workflow
reflection:Workflow
classPrefix:Wf
parser:ParseType(WorkflowType)
parser:ParseExpression(WorkflowExpression)
parser:ParseStatement(WorkflowStatement)
ambiguity:enabled
grammar:

class Type
{
}

class ReferenceType : Type
{
	token					name;
}

class SharedPointerType : Type
{
	Type					element;
}

class EnumerableType : Type
{
	Type					element;
}

class MapType : Type
{
	Type					key;
	Type					value;
}

class FunctionType : Type
{
	Type					result;
	Type[]					arguments;
}

class ChildType : Type
{
	Type					parent;
	token					name;
}

class Expression
{
}

enum LiteralValue
{
	Null,
	True,
	False,
}

class ReferenceExpression : Expression
{
	token					name;
}

class OrderedNameExpression : Expression
{
	token					name;
}

class OrderedLambdaExpression : Expression
{
	Expression				body;
}

class MemberExpression : Expression
{
	Expression				parent;
	token					name;
}

class LiteralExpression : Expression
{
	LiteralValue			value;
}

class FloatingExpression : Expression
{
	token					value;
}

class IntegerExpression : Expression
{
	token					value;
}

class StringExpression : Expression
{
	token					value;
}

class FormatExpression : Expression
{
	token					value;
}

enum UnaryOperator
{
	Positive,
	Negative,
	Not,
}

class UnaryExpression : Expression
{
	UnaryOperator			op;
	Expression				operand;
}

enum BinaryOperator
{
	Index,
	Exp,
	Add,
	Sub,
	Mul,
	Div,
	Concat,
	Shl,
	Shr,
	LT,
	GT,
	LE,
	GE,
	EQ,
	NE,
	Xor,
	And,
	Or,
	Not,
	FailedThen,
}

class BinaryExpression : Expression
{
	BinaryOperator			op;
	Expression				first;
	Expression				second;
}

class LetExpression : Expression
{
	token					name;
	Expression				value;
	Expression				exp;
}

class IfExpression : Expression
{
	Expression				condition;
	Expression				trueBranch;
	Expression				falseBranch;
}

enum RangeBoundary
{
	Inclusive,
	Exclusive,
}

class RangeExpression : Expression
{
	Expression				begin;
	RangeBoundary			beginBoundary;
	Expression				end;
	RangeBoundary			endBoundary;
}

enum ExpressionTesting
{
	Normal,
	Reversed,
}

class SetTestingExpression : Expression
{
	ExpressionTesting		test;
	Expression				element;
	Expression				collection;
}

class ConstructorArgument
{
	Expression				key;
	Expression				value;
}

class ConstructorExpression : Expression
{
	ConstructorArgument[]	arguments;
}

class InferExpression : Expression
{
	Expression				expression;
	Type					type;
}

enum TypeCastingStrategy
{
	Strong,
	Weak,
}

class TypeCastingExpression : Expression
{
	TypeCastingStrategy		strategy;
	Expression				expression;
	Type					type;
}

class TypeTestingExpression : Expression
{
	ExpressionTesting		test;
	Expression				expression;
	Type					type;
}

class NullTestingExpression : Expression
{
	ExpressionTesting		test;
	Expression				expression;
}

class TypeOfTypeExpression : Expression
{
	Type					type;
}

class TypeOfExpressionExpression : Expression
{
	Expression				expression;
}

class AttachEventExpression : Expression
{
	Expression				event;
	Expression				function;
}

class DetachEventExpression : Expression
{
	Expression				handler;
}

class BindExpression : Expression
{
	Expression				expression;
}

enum ObserveType
{
	SimpleObserve,
	ExtendedObserve,
}

class ObserveExpression : Expression
{
	Expression				parent;
	ObserveType				observeType;
	token					name;
	Expression				expression;
	Expression[]			events;
}

class CallExpression : Expression
{
	Expression				function;
	Expression[]			arguments;
}

class Statement
{
}

class VariableStatement : Statement
{
	Type					type;
	token					name;
	Expression				expression;
}

class AssignmentStatement : Statement
{
	Expression				left;
	Expression				right;
}

class BreakStatement : Statement
{
}

class ContinueStatement : Statement
{
}

class ReturnStatement : Statement
{
	Expression				expression;
}

class DeleteStatement : Statement
{
	Expression				expression;
}

class RaiseExceptionStatement : Statement
{
	Expression				expression;
}

class IfCastStatement : Statement
{
	Type					type;
	token					name;
	Expression				expression;
	Statement				trueBranch;
	Statement				falseBranch;
}

class IfStatement : Statement
{
	Expression				condition;
	Statement				trueBranch;
	Statement				falseBranch;
}

class SwitchCase
{
	Expression				expression;
	Statement				statement;
}

class SwitchStatement : Statement
{
	Expression				expression;
	SwitchCase[]			caseBranches;
	Statement				defaultBranch;
}

class WhileStatement : Statement
{
	Expression				condition;
	Statement				statement;
}

enum ForEachDirection
{
	Normal,
	Reversed,
}

class ForEachStatement : Statement
{
	token					name;
	ForEachDirection		direction;
	Expression				collection;
	Statement				statement;
}

class TryStatement : Statement
{
	Statement				protectedStatement;
	token					name;
	Statement				catchStatement;
	Statement				finallyStatement;
}

class BlockStatement : Statement
{
	Statement[]				statements;
}

class ExpressionStatement : Statement
{
	Expression				expression;
}

token EXP = "/^";
token ADD = "/+";
token SUB = "-";
token MUL = "/*";
token DIV = "//";
token CONCAT = "&";
token LE = "/</=";
token GE = "/>/=";
token LT = "/<";
token GT = "/>";
token EQ = "/=";
token NE = "/!/=";
token FAILED_THEN = "/?/?";
token QUESTION_MARK = "/?";
token SCOPE_DELIMITER = "::";
token COLON = ":";
token SEMICOLON = ";";
token COMMA = ",";
token DOT = ".";
token OPEN_ARRAY = "/[";
token CLOSE_ARRAY = "/]";
token OPEN_BRACE = "/{";
token CLOSE_BRACE = "/}";
token OPEN_BRACKET = "/(";
token CLOSE_BRACKET = "/)";

token KEYWORD_SHL = "shl";
token KEYWORD_SHR = "shr";
token KEYWORD_XOR = "xor";
token KEYWORD_AND = "and";
token KEYWORD_OR = "or";
token KEYWORD_NOT = "not";
token KEYWORD_NULL= "null";
token KEYWORD_TRUE= "true";
token KEYWORD_FALSE = "false";
token KEYWORD_LET = "let";
token KEYWORD_IN = "in";
token KEYWORD_RANGE = "range";
token KEYWORD_OF = "of";
token KEYWORD_AS = "as";
token KEYWORD_IS = "is";
token KEYWORD_CAST = "cast";
token KEYWORD_FUNC = "func";
token KEYWORD_TYPEOF = "typeof";
token KEYWORD_TYPE = "type";
token KEYWORD_BIND = "bind";
token KEYWORD_OBSERVE = "observe";
token KEYWORD_ON = "on";
token KEYWORD_ATTACH = "attach";
token KEYWORD_DETACH = "detach";
token KEYWORD_VAR = "var";
token KEYWORD_BREAK = "break";
token KEYWORD_CONTINUE = "continue";
token KEYWORD_RETURN = "return";
token KEYWORD_DELETE = "delete";
token KEYWORD_RAISE = "raise";
token KEYWORD_IF = "if";
token KEYWORD_ELSE = "else";
token KEYWORD_SWITCH = "switch";
token KEYWORD_CASE = "case";
token KEYWORD_DEFAULT = "default";
token KEYWORD_WHILE = "while";
token KEYWORD_FOR = "for";
token KEYWORD_REVERSED = "reversed";
token KEYWORD_TRY = "try";
token KEYWORD_CATCH = "catch";
token KEYWORD_FINALLY = "finally";

token NAME = "[a-zA-Z_]/w*";
token ORDERED_NAME = "/$[0-9]*";
token FLOAT = "/d+(./d+)?";
token INTEGER = "/d+(./d+)?";
token STRING = "('[^']*')+|(""[^""]*"")+";
token FORMATSTRING = "/$(('[^']*')+|(""[^""]*"")+)";

discardtoken SPACE = "/s+";

rule Type WorkflowType
	= NAME : name as ReferenceType
	= "func" "(" [WorkflowType : arguments {"," WorkflowType : arguments}] ")" ":" WorkflowType : result as FunctionType
	= WorkflowType : element "^" as SharedPointerType
	= WorkflowType : element "{" "}" as EnumerableType
	= WorkflowType : value "[" [WorkflowType : key] "]" as MapType
	= WorkflowType : parent "::" NAME : name as ChildType
	;

rule LiteralExpression Literal
	= "null" as LiteralExpression with {value = "Null"}
	= "true" as LiteralExpression with {value = "True"}
	= "false" as LiteralExpression with {value = "False"}
	;
rule IntegerExpression Integer
	= INTEGER : value as IntegerExpression
	;
rule FloatingExpression FloatingPoint
	= FLOAT : value as FloatingExpression
	;
rule StringExpression String
	= STRING : value as StringExpression
	;
rule FormatExpression FormatString
	= FORMATSTRING : value as FormatExpression
	;

rule ConstructorArgument CtorFragment
	= WorkflowExpression : key [ ":" WorkflowExpression : value] as ConstructorArgument
	;

rule Expression Exp0
	= !Literal
	= !Integer
	= !FloatingPoint
	= !String
	= !FormatString
	= NAME : name as ReferenceExpression
	= ORDERED_NAME : name as OrderedNameExpression
	= "(" !WorkflowExpression ")"
	= "[" WorkflowExpression : body "]" as OrderedLambdaExpression
	= "let" NAME : name "in" WorkflowExpression : value "=" WorkflowExpression : exp as LetExpression
	= "+" Exp0 as UnaryExpression with {op = "Positive"}
	= "-" Exp0 as UnaryExpression with {op = "Negative"}
	= "not" Exp0 as UnaryExpression with {op = "Not"}
	= "range"
		(("(" with {beginBoundary = "Exclusive"}) | ("[" with {beginBoundary = "Inclusive"}))
		WorkflowExpression : begin "," WorkflowExpression : end
		((")" with {beginBoundary = "Exclusive"}) | ("]" with {beginBoundary = "Inclusive"}))
		as RangeExpression
	= "{" {CtorFragment : arguments} "}" as ConstructorExpression
	= "bind" "(" WorkflowExpression : expression ")" as BindExpression
	= Exp0 : parent "." "observe" "(" WorkflowExpression : expression ["on" WorkflowExpression : events {"," WorkflowExpression : events}]")" as ObserveExpression with {observeType = "SimpleObserve"}
	= Exp0 : parent "." "observe" "as" NAME : name "(" WorkflowExpression : expression ["on" WorkflowExpression : events {"," WorkflowExpression : events}]")" as ObserveExpression with {observeType = "ExtendedObserve"}
	= Exp0 : function "(" [WorkflowExpression : arguments {"," WorkflowExpression : arguments}] ")" as CallExpression
	= Exp0 : parent "." NAME : name as MemberExpression
	= Exp0 : first "[" WorkflowExpression : second "]" as BinaryExpression with {op = "Index"}
	= Exp0 : element "in" WorkflowExpression : collection as SetTestingExpression with {test="Normal"}
	= Exp0 : element "not" "in" WorkflowExpression : collection as SetTestingExpression with {test="Reversed"}
	= Exp0 : expression "of" WorkflowType : type as InferExpression
	= Exp0 : expression "is" WorkflowType : type as TypeTestingExpression with {test="Normal"}
	= Exp0 : expression "is" "not" WorkflowType : type as TypeTestingExpression with {test="Reversed"}
	= Exp0 : expression "is" "null" as NullTestingExpression with {test="Normal"}
	= Exp0 : expression "is" "not" "null" as NullTestingExpression with {test="Reversed"}
	= Exp0 : expression "as" WorkflowType : type as TypeCastingExpression with {strategy = "Weak"}
	= "cast" WorkflowType : type Exp0 : expression as TypeCastingExpression with {strategy = "Strong"}
	= "typeof" "(" WorkflowType : type ")" as TypeOfTypeExpression
	= "type" "(" WorkflowExpression : expression ")" as TypeOfExpressionExpression
	= "attach" "(" WorkflowExpression : event "," WorkflowExpression : function ")" as AttachEventExpression
	= "detach" "(" WorkflowExpression : handler ")" as DetachEventExpression
	;

rule Expression Exp1
	= !Exp0
	= Exp1 : first "^" Exp0 : second as BinaryExpression with {op = "Exp"}
	;
rule Expression Exp2
	= !Exp1
	= Exp2 : first "*" Exp1 : second as BinaryExpression with {op = "Mul"}
	= Exp2 : first "/" Exp1 : second as BinaryExpression with {op = "Div"}
	;
rule Expression Exp3
	= !Exp2
	= Exp3 : first "+" Exp2 : second as BinaryExpression with {op = "Add"}
	= Exp3 : first "-" Exp2 : second as BinaryExpression with {op = "Sub"}
	= Exp3 : first "&" Exp2 : second as BinaryExpression with {op = "Concat"}
	;
rule Expression Exp4
	= !Exp3
	= Exp4 : first "shl" Exp3 : second as BinaryExpression with {op = "Shl"}
	= Exp4 : first "shr" Exp3 : second as BinaryExpression with {op = "Shr"}
	;
rule Expression Exp5
	= !Exp4
	= Exp5 : first "<" Exp4 : second as BinaryExpression with {op = "LT"}
	= Exp5 : first ">" Exp4 : second as BinaryExpression with {op = "GT"}
	= Exp5 : first "<=" Exp4 : second as BinaryExpression with {op = "LE"}
	= Exp5 : first ">=" Exp4 : second as BinaryExpression with {op = "GE"}
	= Exp5 : first "=" Exp4 : second as BinaryExpression with {op = "EQ"}
	= Exp5 : first "!=" Exp4 : second as BinaryExpression with {op = "NE"}
	;
rule Expression Exp6
	= !Exp5
	= Exp6 : first "xor" Exp5 : second as BinaryExpression with {op = "Xor"}
	;
rule Expression Exp7
	= !Exp6
	= Exp7 : first "and" Exp6 : second as BinaryExpression with {op = "And"}
	;
rule Expression Exp8
	= !Exp7
	= Exp8 : first "or" Exp7 : second as BinaryExpression with {op = "Or"}
	;
rule Expression Exp9
	= !Exp8
	= Exp9 : first "??" Exp8 : second as BinaryExpression with {op = "FailedThen"}
	;
rule Expression Exp10
	= !Exp9
	= Exp9 : condition "?" Exp10 : trueBranch ":" Exp10 : falseBranch as IfExpression
	;

rule Expression WorkflowExpression
	= !Exp10
	;

rule VariableStatement Variable
	= "var" NAME : name [":" WorkflowType : type] "=" WorkflowExpression : expression ";" as VariableStatement
	;

rule AssignmentStatement Assignment
	= WorkflowExpression : left "=" WorkflowExpression : right ";" as AssignmentStatement
	;

rule BreakStatement Break
	= "break" ";" as BreakStatement
	;
rule ContinueStatement Continue
	= "continue" ";" as ContinueStatement
	;
rule ReturnStatement Return
	= "return" [WorkflowExpression : expression] ";" as ReturnStatement
	;
rule DeleteStatement Delete
	= "delete" WorkflowExpression : expression ";" as DeleteStatement
	;
rule RaiseExceptionStatement RaiseException
	= "raise" WorkflowExpression : expression ";" as RaiseExceptionStatement
	;

rule IfStatement If
	= "if" "(" WorkflowExpression : condition ")" WorkflowStatement : trueBranch ["else" WorkflowStatement : falseBranch] as IfStatement
	;
rule IfCastStatement IfCast
	= "if" "(" NAME : name ":" WorkflowType : type "=" WorkflowExpression : expression ")" WorkflowStatement : trueBranch ["else" WorkflowStatement : falseBranch] as IfCastStatement	;

rule SwitchCase SwitchCaseFragment
	= "case" WorkflowExpression : expression ":" WorkflowStatement : statement as SwitchCase
	;
rule SwitchStatement Switch
	= "switch" "(" WorkflowExpression : expression ")" "{" {SwitchCaseFragment : caseBranches} ["default" ":" WorkflowStatement : defaultBranch] "}" as SwitchStatement
	;

rule WhileStatement While
	= "while" "(" WorkflowExpression : condition ")" WorkflowStatement : statement as WhileStatement
	;
rule ForEachStatement ForEach
	= "for" "(" NAME : name "in" WorkflowExpression : collection ")" WorkflowStatement : statement as ForEachStatement with {direction="Normal"}
	= "for" "(" NAME : name "in" "reversed" WorkflowExpression : collection ")" WorkflowStatement : statement as ForEachStatement with {direction="Reversed"}
	;

rule TryStatement Try
	= "try" WorkflowStatement : protectedStatement ["catch" "(" NAME : name ")" WorkflowStatement : catchStatement] ["finally" WorkflowStatement : finallyStatement] as TryStatement
	;

rule BlockStatement Block
	= "{" {WorkflowStatement : statements} "}" as BlockStatement
	;

rule ExpressionStatement ExprStat
	= WorkflowExpression : expression as ExpressionStatement
	;

rule Statement WorkflowStatement
	= !Variable
	= !Assignment
	= !Break
	= !Continue
	= !Return
	= !Delete
	= !RaiseException
	= !If
	= !IfCast
	= !Switch
	= !While
	= !ForEach
	= !Try
	= !Block
	= !ExprStat
	;