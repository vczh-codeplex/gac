include:"../../../../Common/Source/Parsing/Parsing.h"
include:"../../../../Common/Source/Parsing/ParsingDefinitions.h"
include:"../../../../Common/Source/Parsing/ParsingAutomaton.h"
namespace:vl.workflow
reflection:Workflow
classPrefix:Wf
parser:ParseExpression(WorkflowExpression)
ambiguity:enabled
grammar:

class Type
{
}

class ReferenceType : Type
{
	token					name;
}

class SharedPointerType : Type
{
	Type					element;
}

class EnumerableType : Type
{
	Type					element;
}

class MapType : Type
{
	Type					key;
	Type					value;
}

class FunctionType : Type
{
	Type					result;
	Type[]					arguments;
}

class ChildType : Type
{
	Type					parent;
	token					name;
}

class Expression
{
}

enum LiteralValue
{
	Null,
	True,
	False,
}

class ReferenceExpression : Expression
{
	token					name;
}

class MemberExpression : Expression
{
	Expression				parent;
	token					name;
}

class LiteralExpression : Expression
{
	LiteralValue			value;
}

class FloatingExpression : Expression
{
	token					value;
}

class IntegerExpression : Expression
{
	token					value;
}

class StringExpression : Expression
{
	token					value;
}

class FormatExpression : Expression
{
	token					value;
}

enum UnaryOperator
{
	Positive,
	Negative,
	Not,
}

class UnaryExpression : Expression
{
	UnaryOperator			op;
	Expression				operand;
}

enum BinaryOperator
{
	Index,
	Exp,
	Add,
	Sub,
	Mul,
	Div,
	Concat,
	Shl,
	Shr,
	LT,
	GT,
	LE,
	GE,
	EQ,
	NE,
	Xor,
	And,
	Or,
	Not,
	FailedThen,
}

class BinaryExpression : Expression
{
	BinaryOperator			op;
	Expression				first;
	Expression				second;
}

class LetExpression : Expression
{
	token					name;
	Expression				value;
	Expression				exp;
}

class IfExpression : Expression
{
	Expression				condition;
	Expression				trueBranch;
	Expression				falseBranch;
}

enum RangeBoundary
{
	Inclusive,
	Exclusive,
}

class RangeExpression : Expression
{
	Expression				begin;
	RangeBoundary			beginBoundary;
	Expression				end;
	RangeBoundary			endBoundary;
}

class SetTestingExpression : Expression
{
	Expression				element;
	Expression				collection;
}

class ConstructorArgument
{
	Expression				key;
	Expression				value;
}

class ConstructorExpression : Expression
{
	ConstructorArgument[]	arguments;
}

class InferExpression : Expression
{
	Expression				expression;
	Type					type;
}

enum TypeCastingStrategy
{
	Strong,
	Weak,
}

class TypeCastingExpression : Expression
{
	TypeCastingStrategy		strategy;
	Expression				expression;
	Type					type;
}

class TypeTestingExpression : Expression
{
	Expression				expression;
	Type					type;
}

class TypeOfTypeExpression : Expression
{
	Type					type;
}

class TypeOfExpressionExpression : Expression
{
	Expression				expression;
}

class CallExpression : Expression
{
	Expression				function;
	Expression[]			arguments;
}

token EXP = "/^";
token ADD = "/+";
token SUB = "-";
token MUL = "/*";
token DIV = "//";
token CONCAT = "&";
token LE = "/</=";
token GE = "/>/=";
token LT = "/<";
token GT = "/>";
token EQ = "/=";
token NE = "/!/=";
token FAILED_THEN = "/?/?";
token QUESTION_MARK = "/?";
token COLON = ":";
token SEMICOLON = ";";
token COMMA = ",";
token DOT = ".";
token OPEN_ARRAY = "/[";
token CLOSE_ARRAY = "/]";
token OPEN_BRACE = "/{";
token CLOSE_BRACE = "/}";
token OPEN_BRACKET = "/(";
token CLOSE_BRACKET = "/)";

token KEYWORD_SHL = "shl";
token KEYWORD_SHR = "shr";
token KEYWORD_XOR = "xor";
token KEYWORD_AND = "and";
token KEYWORD_OR = "or";
token KEYWORD_NOT = "not";
token KEYWORD_NULL= "null";
token KEYWORD_TRUE= "true";
token KEYWORD_FALSE = "false";
token KEYWORD_LET = "let";
token KEYWORD_IN = "in";
token KEYWORD_RANGE = "range";
token KEYWORD_OF = "of";
token KEYWORD_AS = "as";
token KEYWORD_IS = "is";
token KEYWORD_CAST = "cast";
token KEYWORD_FUNC = "func";
token KEYWORD_TYPEOF = "typeof";
token KEYWORD_TYPE = "type";

token NAME = "[a-zA-Z_]/w*";
token FLOAT = "/d+(./d+)?";
token INTEGER = "/d+(./d+)?";
token STRING = "('[^']*')+|(""[^""]*"")+";
token FORMATSTRING = "/$(('[^']*')+|(""[^""]*"")+)";

discardtoken SPACE = "/s+";

rule Type WorkflowType
	= NAME : name as ReferenceType
	= "func" "(" [WorkflowType : arguments {"," WorkflowType : arguments}] ")" ":" WorkflowType : result as FunctionType
	= WorkflowType : element "^" as SharedPointerType
	= WorkflowType : element "{" "}" as EnumerableType
	= WorkflowType : value "[" [WorkflowType : key] "]" as MapType
	;

rule LiteralExpression Literal
	= "null" as LiteralExpression with {value = "Null"}
	= "true" as LiteralExpression with {value = "True"}
	= "false" as LiteralExpression with {value = "False"}
	;
rule IntegerExpression Integer
	= INTEGER : value as IntegerExpression
	;
rule FloatingExpression FloatingPoint
	= FLOAT : value as FloatingExpression
	;
rule StringExpression String
	= STRING : value as StringExpression
	;
rule FormatExpression FormatString
	= FORMATSTRING : value as FormatExpression
	;

rule ConstructorArgument CtorFragment
	= WorkflowExpression : key [ ":" WorkflowExpression : value] as ConstructorArgument
	;

rule Expression Exp0
	= !Literal
	= !Integer
	= !FloatingPoint
	= !String
	= !FormatString
	= NAME : name as ReferenceExpression
	= "(" !WorkflowExpression ")"
	= "let" NAME : name "in" WorkflowExpression : value "=" WorkflowExpression : exp as LetExpression
	= "+" Exp0 as UnaryExpression with {op = "Positive"}
	= "-" Exp0 as UnaryExpression with {op = "Negative"}
	= "not" Exp0 as UnaryExpression with {op = "Not"}
	= "range"
		(("(" with {beginBoundary = "Exclusive"}) | ("[" with {beginBoundary = "Inclusive"}))
		WorkflowExpression : begin "," WorkflowExpression : end
		((")" with {beginBoundary = "Exclusive"}) | ("]" with {beginBoundary = "Inclusive"}))
		as RangeExpression
	= "{" {CtorFragment : arguments} "}" as ConstructorExpression
	= Exp0 : parent "." NAME : name as MemberExpression
	= Exp0 : first "[" WorkflowExpression : second "]" as BinaryExpression with {op = "Index"}
	= Exp0 : element "in" WorkflowExpression : collection as SetTestingExpression
	= Exp0 : expression "of" WorkflowType : type as InferExpression
	= Exp0 : expression "is" WorkflowType : type as TypeTestingExpression
	= Exp0 : expression "as" WorkflowType : type as TypeCastingExpression with {strategy = "Weak"}
	= "cast" WorkflowType : type Exp0 : expression as TypeCastingExpression with {strategy = "Strong"}
	= "typeof" "(" WorkflowType : type ")" as TypeOfTypeExpression
	= "type" "(" WorkflowExpression : expression ")" as TypeOfExpressionExpression
	= Exp0 : function "(" [WorkflowExpression : arguments {"," WorkflowExpression : arguments}] ")" as CallExpression
	;

rule Expression Exp1
	= !Exp0
	= Exp1 : first "^" Exp0 : second as BinaryExpression with {op = "Exp"}
	;
rule Expression Exp2
	= !Exp1
	= Exp2 : first "*" Exp1 : second as BinaryExpression with {op = "Mul"}
	= Exp2 : first "/" Exp1 : second as BinaryExpression with {op = "Div"}
	;
rule Expression Exp3
	= !Exp2
	= Exp3 : first "+" Exp2 : second as BinaryExpression with {op = "Add"}
	= Exp3 : first "-" Exp2 : second as BinaryExpression with {op = "Sub"}
	= Exp3 : first "&" Exp2 : second as BinaryExpression with {op = "Concat"}
	;
rule Expression Exp4
	= !Exp3
	= Exp4 : first "shl" Exp3 : second as BinaryExpression with {op = "Shl"}
	= Exp4 : first "shr" Exp3 : second as BinaryExpression with {op = "Shr"}
	;
rule Expression Exp5
	= !Exp4
	= Exp5 : first "<" Exp4 : second as BinaryExpression with {op = "LT"}
	= Exp5 : first ">" Exp4 : second as BinaryExpression with {op = "GT"}
	= Exp5 : first "<=" Exp4 : second as BinaryExpression with {op = "LE"}
	= Exp5 : first ">=" Exp4 : second as BinaryExpression with {op = "GE"}
	= Exp5 : first "=" Exp4 : second as BinaryExpression with {op = "EQ"}
	= Exp5 : first "!=" Exp4 : second as BinaryExpression with {op = "NE"}
	;
rule Expression Exp6
	= !Exp5
	= Exp6 : first "xor" Exp5 : second as BinaryExpression with {op = "Xor"}
	;
rule Expression Exp7
	= !Exp6
	= Exp7 : first "and" Exp6 : second as BinaryExpression with {op = "And"}
	;
rule Expression Exp8
	= !Exp7
	= Exp8 : first "or" Exp7 : second as BinaryExpression with {op = "Or"}
	;
rule Expression Exp9
	= !Exp8
	= Exp9 : first "??" Exp8 : second as BinaryExpression with {op = "FailedThen"}
	;
rule Expression Exp10
	= !Exp9
	= Exp9 : condition "?" Exp10 : trueBranch ":" Exp10 : falseBranch as IfExpression
	;

rule Expression WorkflowExpression
	= !Exp10
	;