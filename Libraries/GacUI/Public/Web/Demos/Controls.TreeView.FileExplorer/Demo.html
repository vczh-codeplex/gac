<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=8" />
<link rel="shortcut icon" href="../../favicon.ico"/>
<link rel="Stylesheet" type="text/css" href="../../PageStyle.css" />
<title>GacLib - Demos - Controls.ListView.VirtualMode</title>
</head>
<body>
<table class="ContainerTable">
    <tr>
        <td align="center" valign="top">
            <table class="NavigateTable" cellpadding="0" cellspacing="4" >
                <tr>
                    <td class="NavigateHeader" colspan="6" align="left">
                        <img src="../../GacLib_LogoAndTitle.gif" alt="GacLib -- GPU Accelerated C++ User Interface"/>
                    </td>
                </tr>
                <tr>
                    <td align="center" valign="middle">
                        <a class="MenuButton HomeButton" href="../../index.html">
                            HOME
                        </a>
                    </td>
                    <td align="center" valign="middle">
                        <a class="MenuButton GettingStartButton" href="../../GettingStart.html">
                            GETTING START
                        </a>
                    </td>
                    <td align="center" valign="middle">
                        <a class="MenuButton DemosButtonSelected" href="../../Demos.html">
                            DEMOS
                        </a>
                    </td>
                    <td align="center" valign="middle">
                        <a class="MenuButton DownloadButton" href="../../Download.html">
                            DOWNLOAD
                        </a>
                    </td>
                    <td align="center" valign="middle">
                        <a class="MenuButton DocumentButton" href="../../StaticHtmlDoc/reference_gacui.html">
                            DOCUMENT
                        </a>
                    </td>
                    <td align="center" valign="middle">
                        <a class="MenuButton ContactButton" href="../../Contact.html">
                            CONTACT
                        </a>
                    </td>
                </tr>
                <tr>
                    <td align="left" valign="top" colspan="6">
                        <h1>TreeView.FileExplorer</h1>
                        <img src="DXGUI_51.jpg" />
                        <img src="DXGUI_52.jpg" />
                        <p><strong>This demo contains the following code files:</strong></p>
                        <ul>
                            <li><a href="#MAIN_CPP">Main.cpp</a></li>
                            <li><a href="#FILE_H">FileSystemInformation.h</a></li>
                            <li><a href="#FILE_CPP">FileSystemInformation.cpp</a></li>
                        </ul>
                        <strong><a name="MAIN_CPP">Main.cpp</a></strong>
                        <pre class="CppCode">
#include "..\CommonLibrary\FileSystemInformation.h"

using namespace vl::collections;

int CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int CmdShow)
{
	return SetupWindowsDirect2DRenderer();
}

/***********************************************************************
SortingAndFilteringWindow
***********************************************************************/

class FileExplorerWindow : public GuiWindow
{
private:
	GuiTreeView*					treeView;
<strong>
	void OnNodeExpanded(GuiGraphicsComposition* sender, GuiNodeEventArgs& arguments)
	{
		tree::MemoryNodeProvider* parent=treeView->Nodes()->GetMemoryNode(arguments.node);
		if(parent->Children().Count()==1)
		{
			tree::MemoryNodeProvider* child=parent->Children()[0].Obj();
			Ptr&lt;tree::TreeViewItem&gt; childItem=child->GetData().Cast&lt;tree::TreeViewItem&gt;();
			if(childItem->text==L"Loading..." && !childItem->tag)
			{
				<strong class="ImportantCppCode">GetApplication()->InvokeAsync(</strong>[parent]()
				{
					// get back the full path from the item
					<strong class="ImportantCppCode">Ptr&lt;tree::TreeViewItem&gt; item=parent->GetData().Cast&lt;tree::TreeViewItem&gt;();</strong>
					<strong class="ImportantCppCode">WString path=item->tag.Cast&lt;ObjectBox&lt;WString&gt;&gt;()->Unbox();</strong>
					if(path[path.Length()-1]!=L'\\')
					{
						path+=L"\\";
					}

					// add sub folders and sub files
					List&lt;WString&gt; directories, files;
					SearchDirectoriesAndFiles(path, directories, files);

					tree::MemoryNodeProvider* directoryNode=parent;
					<strong class="ImportantCppCode">GetApplication()->InvokeInMainThreadAndWait(</strong>[directoryNode, path, &directories, &files]()
					{
						FOREACH(WString, file, directories.Wrap())
						{
							FileExplorerWindow::AddFolder(directoryNode, path+file);
						}
						FOREACH(WString, file, files.Wrap())
						{
							FileExplorerWindow::AddFile(directoryNode, path+file);
						}
						// remove the  "Loading..." node
						directoryNode->Children().RemoveAt(0);
					});
				});
			}
		}
	}
</strong>
	static int AddFile(tree::MemoryNodeProvider* parent, const WString& path)
	{
		<strong class="ImportantCppCode">Ptr&lt;tree::TreeViewItem&gt; item=new tree::TreeViewItem;</strong>
		// set the item text using the display name of the file
		<strong class="ImportantCppCode">item->text=GetFileDisplayName(path);</strong>
		// set the image using the file icon
		<strong class="ImportantCppCode">item->image=GetFileIcon(path, SHGFI_SMALLICON | SHGFI_ICON);</strong>
		// tag the full path to the item
		<strong class="ImportantCppCode">item->tag=new ObjectBox&lt;WString&gt;(path);</strong>

		<strong class="ImportantCppCode">int index=parent->Children().Add(new tree::MemoryNodeProvider(item));</strong>
		return index;
	}

	static void AddFolder(tree::MemoryNodeProvider* parent, const WString& path)
	{
		int index=AddFile(parent, path);

		// Add the "loading" item under a folder
		Ptr&lt;tree::TreeViewItem&gt; loading=new tree::TreeViewItem;
		loading->text=L"Loading...";
		parent->Children()[index]->Children().Add(new tree::MemoryNodeProvider(loading));
	}

	void InitializeFileSystem()
	{
		wchar_t drives[1024];
		GetLogicalDriveStrings(sizeof(drives), drives);

		wchar_t* reading=drives;
		while(true)
		{
			WString drive=reading;
			if(drive==L"")
			{
				break;
			}
			else
			{
				AddFolder(treeView->Nodes().Obj(), drive);
				reading+=drive.Length()+1;
			}
		}
	}
public:
	FileExplorerWindow()
		:GuiWindow(GetCurrentTheme()->CreateWindowStyle())
	{
		this->SetText(L"Controls.TreeView.FileExplorerWindow");
		
		// create tree view control to display the local file system
		treeView=g::NewTreeView();
		treeView->SetHorizontalAlwaysVisible(false);
		treeView->SetVerticalAlwaysVisible(false);
		treeView->GetBoundsComposition()->SetAlignmentToParent(Margin(4, 4, 4, 4));
		// listen to the NodeExpanded event to load the folder content when a folder node is opened
		<strong>treeView->NodeExpanded.AttachMethod(this, &FileExplorerWindow::OnNodeExpanded);</strong>
		this->AddChild(treeView);

		InitializeFileSystem();

		// set the preferred minimum client size
		this->GetBoundsComposition()->SetPreferredMinSize(Size(640, 480));
		// call this to calculate the size immediately if any indirect content in the table changes
		// so that the window can calcaulte its correct size before calling the MoveToScreenCenter()
		this->ForceCalculateSizeImmediately();
		// move to the screen center
		this->MoveToScreenCenter();
	}

	~FileExplorerWindow()
	{
	}
};

/***********************************************************************
GuiMain
***********************************************************************/

void GuiMain()
{
	GuiWindow* window=new FileExplorerWindow;
	GetApplication()->Run(window);
	delete window;
}
                        </pre>
                        <strong><a name="FILE_H">FileSystemInformation.h</a></strong>
                        <pre class="CppCode">
#ifndef GACUI_DEMO_FILE_SYSTEM_INFORMATION
#define GACUI_DEMO_FILE_SYSTEM_INFORMATION

#include "..\..\Public\Source\GacUI.h"
#include &lt;ShlObj.h&gt;

using namespace vl;
using namespace vl::collections;

/***********************************************************************
File System Operations
***********************************************************************/

extern WString GetWindowsDirectory();
extern void SearchDirectoriesAndFiles(const WString& path, List&lt;WString&gt;& directories, List&lt;WString&gt;& files);
extern Ptr&lt;GuiImageData&gt; GetFileIcon(const WString& fullPath, UINT uFlags);
extern WString GetFileDisplayName(const WString& fullPath);
extern WString GetFileTypeName(const WString& fullPath);
extern FILETIME GetFileLastWriteTime(const WString& fullPath);
extern LARGE_INTEGER GetFileSize(const WString& fullPath);
extern WString FileTimeToString(const FILETIME& filetime);
extern WString FileSizeToString(LARGE_INTEGER filesize);

/***********************************************************************
FileProperties
***********************************************************************/

class FileProperties
{
private:
	Ptr&lt;GuiImageData&gt;	smallIcon;
	Ptr&lt;GuiImageData&gt;	bigIcon;
	WString				displayName;
	WString				typeName;
	FILETIME			lastWriteTime;
	LARGE_INTEGER		size;

	bool				loaded;
	WString				fullPath;

	void				Load();
public:
	FileProperties(const WString& _fullPath);

	Ptr&lt;GuiImageData&gt;	GetSmallIcon();
	Ptr&lt;GuiImageData&gt;	GetBigIcon();
	WString				GetDisplayName();
	WString				GetTypeName();
	FILETIME			GetLastWriteTime();
	LARGE_INTEGER		GetSize();
};

#endif
                        </pre>
                        <strong><a name="FILE_CPP">FileSystemInformation.cpp</a></strong>
                        <pre class="CppCode">
#include "FileSystemInformation.h"

/***********************************************************************
File System Operations
***********************************************************************/

WString GetWindowsDirectory()
{
	wchar_t folderPath[MAX_PATH]={0};
	HRESULT hr=SHGetFolderPath(NULL, CSIDL_WINDOWS, NULL, 0, folderPath);
	if(FAILED(hr)) return L"";
	return folderPath;
}

void SearchDirectoriesAndFiles(const WString& path, List&lt;WString&gt;& directories, List&lt;WString&gt;& files)
{
	// Use FindFirstFile, FindNextFile and FindClose to enumerate all directories and files
	WIN32_FIND_DATA findData;
	HANDLE findHandle=INVALID_HANDLE_VALUE;

	while(true)
	{
		if(findHandle==INVALID_HANDLE_VALUE)
		{
			WString searchPath=path+L"\\*";
			findHandle=FindFirstFile(searchPath.Buffer(), &findData);
			if(findHandle==INVALID_HANDLE_VALUE)
			{
				break;
			}
		}
		else
		{
			BOOL result=FindNextFile(findHandle, &findData);
			if(result==0)
			{
				FindClose(findHandle);
				break;
			}
		}

		if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			if(wcscmp(findData.cFileName, L".")!=0 && wcscmp(findData.cFileName, L"..")!=0)
			{
				directories.Add(findData.cFileName);
			}
		}
		else
		{
			files.Add(findData.cFileName);
		}
	}

	Func&lt;vint(WString a, WString b)&gt; comparer=[](WString a, WString b){return _wcsicmp(a.Buffer(), b.Buffer());};
	CopyFrom(directories.Wrap(), directories.Wrap()>>OrderBy(comparer));
	CopyFrom(files.Wrap(), files.Wrap()>>OrderBy(comparer));
}

Ptr&lt;GuiImageData&gt; GetFileIcon(const WString& fullPath, UINT uFlags)
{
	// Use SHGetFileInfo to get the correct icons for the specified directory or file.
	SHFILEINFO info;
	DWORD result=SHGetFileInfo(fullPath.Buffer(), 0, &info, sizeof(SHFILEINFO), uFlags);
	Ptr&lt;GuiImageData&gt; imageData;
	if(result)
	{
		Ptr&lt;INativeImage&gt; image=windows::CreateImageFromHICON(info.hIcon);
		if(image)
		{
			imageData=new GuiImageData(image, 0);
		}
		DestroyIcon(info.hIcon);
	}
	return imageData;
}

WString GetFileDisplayName(const WString& fullPath)
{
	SHFILEINFO info;
	DWORD result=SHGetFileInfo(fullPath.Buffer(), 0, &info, sizeof(SHFILEINFO), SHGFI_DISPLAYNAME);
	return result?info.szDisplayName:L"";
}

WString GetFileTypeName(const WString& fullPath)
{
	SHFILEINFO info;
	DWORD result=SHGetFileInfo(fullPath.Buffer(), 0, &info, sizeof(SHFILEINFO), SHGFI_TYPENAME);
	return result?info.szTypeName:L"";
}

FILETIME GetFileLastWriteTime(const WString& fullPath)
{
	// Get file attributes.
	WIN32_FILE_ATTRIBUTE_DATA info;
	BOOL result=GetFileAttributesEx(fullPath.Buffer(), GetFileExInfoStandard, &info);

	// Get the localized string for the file last write date.
	FILETIME localFileTime;
	FileTimeToLocalFileTime(&info.ftLastWriteTime, &localFileTime);

	return localFileTime;
}

LARGE_INTEGER GetFileSize(const WString& fullPath)
{
	// Get file attributes.
	WIN32_FILE_ATTRIBUTE_DATA info;
	BOOL result=GetFileAttributesEx(fullPath.Buffer(), GetFileExInfoStandard, &info);

	// Get the string for file size
	LARGE_INTEGER li;
	li.HighPart=info.nFileSizeHigh;
	li.LowPart=info.nFileSizeLow;

	return li;
}

WString FileTimeToString(const FILETIME& filetime)
{
	SYSTEMTIME localSystemTime;
	FileTimeToSystemTime(&filetime, &localSystemTime);

	// Get the correct locale
	wchar_t localeName[LOCALE_NAME_MAX_LENGTH]={0};
	GetSystemDefaultLocaleName(localeName, sizeof(localeName)/sizeof(*localeName));

	// Get the localized date string
	wchar_t dateString[100]={0};
	GetDateFormatEx(localeName, DATE_SHORTDATE, &localSystemTime, NULL, dateString, sizeof(dateString)/sizeof(*dateString), NULL);

	// Get the localized time string
	wchar_t timeString[100]={0};
	GetTimeFormatEx(localeName, TIME_FORCE24HOURFORMAT | TIME_NOSECONDS, &localSystemTime, NULL, timeString, sizeof(timeString)/sizeof(*timeString));

	return dateString+WString(L" ")+timeString;
}

WString FileSizeToString(LARGE_INTEGER filesize)
{
	WString unit;
	double size=0;
	if(filesize.QuadPart>=1024*1024*1024)
	{
		unit=L" GB";
		size=(double)filesize.QuadPart/(1024*1024*1024);
	}
	else if(filesize.QuadPart>=1024*1024)
	{
		unit=L" MB";
		size=(double)filesize.QuadPart/(1024*1024);
	}
	else if(filesize.QuadPart>=1024)
	{
		unit=L" KB";
		size=(double)filesize.QuadPart/1024;
	}
	else
	{
		unit=L" Bytes";
		size=(double)filesize.QuadPart;
	}

	WString sizeString=ftow(size);
	const wchar_t* reading=sizeString.Buffer();
	const wchar_t* point=wcschr(sizeString.Buffer(), L'.');
	if(point)
	{
		const wchar_t* max=reading+sizeString.Length();
		point+=4;
		if(point>max) point=max;
		sizeString=sizeString.Left(point-reading);
	}

	return sizeString+unit;
}

/***********************************************************************
FileProperties
***********************************************************************/

void FileProperties::Load()
{
	if(!loaded)
	{
		loaded=true;
		smallIcon=GetFileIcon(fullPath, SHGFI_SMALLICON | SHGFI_ICON);
		bigIcon=GetFileIcon(fullPath, SHGFI_LARGEICON | SHGFI_ICON);
		displayName=GetFileDisplayName(fullPath);
		typeName=GetFileTypeName(fullPath);
		lastWriteTime=GetFileLastWriteTime(fullPath);
		size=GetFileSize(fullPath);
	}
	}

FileProperties::FileProperties(const WString& _fullPath)
	:loaded(false)
	,fullPath(_fullPath)
{
}

Ptr&lt;GuiImageData&gt; FileProperties::GetSmallIcon()
{
	Load();
	return smallIcon;
}

Ptr&lt;GuiImageData&gt; FileProperties::GetBigIcon()
{
	Load();
	return bigIcon;
}

WString FileProperties::GetDisplayName()
{
	Load();
	return displayName;
}

WString FileProperties::GetTypeName()
{
	Load();
	return typeName;
}

FILETIME FileProperties::GetLastWriteTime()
{
	Load();
	return lastWriteTime;
}

LARGE_INTEGER FileProperties::GetSize()
{
	Load();
	return size;
}
                        </pre>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
</table>
</body>
</html>