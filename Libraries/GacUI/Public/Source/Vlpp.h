/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: 陈梓瀚(vczh)
***********************************************************************/

/***********************************************************************
BASIC.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Basic

Classes:
	NotCopyable									：不可复制对象
	Error										：内部错误，检查到了不可出现的变量、参数或状态错误
	Object										：对象基类

Macros:
	CHECK_ERROR(CONDITION,DESCRIPTION)			：检查内部错误
***********************************************************************/

#ifndef VCZH_BASIC
#define VCZH_BASIC

namespace vl
{

/***********************************************************************
32位/64位兼容
***********************************************************************/

#ifdef _WIN64
#define VCZH_64
#endif

#ifdef VCZH_64
	typedef __int64					vint;
	typedef signed __int64			vsint;
	typedef unsigned __int64		vuint;
#else
	typedef __int32					vint;
	typedef signed __int32			vsint;
	typedef unsigned __int32		vuint;
#endif

typedef signed __int64	pos_t;

#ifdef VCZH_64
#define ITOA_S		_i64toa_s
#define ITOW_S		_i64tow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#else
#define ITOA_S		_itoa_s
#define ITOW_S		_itow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#endif

#ifndef _MSC_VER
#define override
#endif

#define VCZH_NO_OLD_OS

/***********************************************************************
基础
***********************************************************************/

	class NotCopyable
	{
	private:
		NotCopyable(const NotCopyable&);
		NotCopyable& operator=(const NotCopyable&);
	public:
		NotCopyable();
	};

	class Error
	{
	private:
		wchar_t*			description;
	public:
		Error(wchar_t* _description);

		wchar_t*			Description()const;
	};

#ifdef _DEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION) do{if(!(CONDITION))throw Error(DESCRIPTION);}while(0)
#endif
#ifdef NDEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION)
#endif

#define CHECK_FAIL(DESCRIPTION) do{throw Error(DESCRIPTION);}while(0)

	class Object
	{
	public:
		virtual ~Object();
	};

	template<typename T>
	class ObjectBox : public Object
	{
	private:
		T					object;
	public:
		ObjectBox(const T& _object)
		{
			object=_object;
		}

		const T& Unbox()
		{
			return object;
		}
	};

	template<typename T, size_t minSize>
	union BinaryRetriver
	{
		T t;
		char binary[sizeof(T)>minSize?sizeof(T):minSize];
	};

/***********************************************************************
配置
***********************************************************************/

	template<typename T>
	struct KeyType
	{
	public:
		typedef T Type;
	};

	template<typename T>
	struct POD
	{
		static const bool Result=false;
	};

	template<>struct POD<bool>{static const bool Result=true;};
	template<>struct POD<unsigned __int8>{static const bool Result=true;};
	template<>struct POD<signed __int8>{static const bool Result=true;};
	template<>struct POD<unsigned __int16>{static const bool Result=true;};
	template<>struct POD<signed __int16>{static const bool Result=true;};
	template<>struct POD<unsigned __int32>{static const bool Result=true;};
	template<>struct POD<signed __int32>{static const bool Result=true;};
	template<>struct POD<unsigned __int64>{static const bool Result=true;};
	template<>struct POD<signed __int64>{static const bool Result=true;};
	template<>struct POD<char>{static const bool Result=true;};
	template<>struct POD<wchar_t>{static const bool Result=true;};
	template<typename T>struct POD<T*>{static const bool Result=true;};
	template<typename T>struct POD<T&>{static const bool Result=true;};
	template<typename T, typename C>struct POD<T C::*>{static const bool Result=true;};
	template<typename T, vint _Size>struct POD<T[_Size]>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<volatile T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const volatile T>{static const bool Result=POD<T>::Result;};

/***********************************************************************
时间
***********************************************************************/

	struct DateTime
	{
		vint				year;
		vint				month;
		vint				dayOfWeek;
		vint				day;
		vint				hour;
		vint				minute;
		vint				second;
		vint				milliseconds;

		unsigned __int64	totalMilliseconds;
		unsigned __int64	filetime;

		static DateTime		LocalTime();
		static DateTime		UtcTime();

		DateTime			ToLocalTime();
		DateTime			ToUtcTime();
	};

/***********************************************************************
接口
***********************************************************************/

	class Interface : private NotCopyable
	{
	public:
		virtual ~Interface();
	};
}

#endif

/***********************************************************************
COLLECTIONS\PAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Pair

Classes:
	Pair<K, V>							：二元组
***********************************************************************/

#ifndef VCZH_COLLECTIONS_PAIR
#define VCZH_COLLECTIONS_PAIR


namespace vl
{
	namespace collections
	{
		template<typename K, typename V>
		class Pair
		{
		public:
			K				key;
			V				value;

			Pair()
			{
			}

			Pair(const K& _key, const V& _value)
			{
				key=_key;
				value=_value;
			}

			Pair(const Pair<K, V>& pair)
			{
				key=pair.key;
				value=pair.value;
			}

			vint CompareTo(const Pair<K, V>& pair)const
			{
				if(key<pair.key)
				{
					return -1;
				}
				else if(key>pair.key)
				{
					return 1;
				}
				else if(value<pair.value)
				{
					return -1;
				}
				else if(value>pair.value)
				{
					return 1;
				}
				else
				{
					return 0;
				}
			}

			bool operator==(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)==0;
			}

			bool operator!=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)!=0;
			}

			bool operator<(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<0;
			}

			bool operator<=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<=0;
			}

			bool operator>(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>0;
			}

			bool operator>=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>=0;
			}
		};
	}

	template<typename K, typename V>
	struct POD<collections::Pair<K, V>>
	{
		static const bool Result=POD<K>::Result && POD<V>::Result;
	};
}

#endif

/***********************************************************************
COLLECTIONS\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Interfaces

Interfaces:
	IEnumerator<T>									：枚举器
	IEnumerable<T>									：可枚举对象
	IReadonlyList<T>								：只读列表
	IArray<T>										：数组
	ICollection<T>									：集合
	IList<T>										：列表
	IReadonlyDictionary<K,V>						：只读映射
	IDictionary<K,V>								：映射
	IReadonlyGroup<K,V>								：只读多重映射
	IGroup<K,V>										：多重映射
***********************************************************************/

#ifndef VCZH_COLLECTIONS_INTERFACES
#define VCZH_COLLECTIONS_INTERFACES


namespace vl
{
	namespace collections
	{

/***********************************************************************
接口
***********************************************************************/

		template<typename T>
		class IEnumerator : public virtual Interface
		{
		public:
			virtual IEnumerator<T>*						Clone()const=0;
			virtual const T&							Current()const=0;
			virtual vint								Index()const=0;
			virtual bool								Next()=0;
			virtual bool								Available()const=0;
			virtual void								Reset()=0;
		};

		template<typename T>
		class IEnumerable : public virtual Interface
		{
		public:
			virtual IEnumerator<T>*						CreateEnumerator()const=0;
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class IReadonlyList : public virtual IEnumerable<T>
		{
		public:
			virtual bool								Contains(const K& item)const=0;
			virtual vint								Count()const=0;
			virtual const T&							Get(vint index)const=0;
			virtual const T&							operator[](vint index)const=0;
			virtual vint								IndexOf(const K& item)const=0;
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class IArray : public virtual IReadonlyList<T, K>
		{
		public:
			virtual void								Set(vint index, const T& item)=0;
			virtual void								Resize(vint size)=0;
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class ICollection : public virtual IReadonlyList<T, K>
		{
		public:
			virtual vint								Add(const T& item)=0;
			virtual bool								Remove(const K& item)=0;
			virtual bool								RemoveAt(vint index)=0;
			virtual bool								RemoveRange(vint index, vint count)=0;
			virtual bool								Clear()=0;
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class IList : public virtual ICollection<T, K>
		{
		public:
			virtual vint								Insert(vint index, const T& item)=0;
			virtual bool								Set(vint index, const T& item)=0;
		};

		template<typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class IReadonlyDictionary : public virtual IEnumerable<Pair<KT, VT>>
		{
		public:
			virtual const IReadonlyList<KT, KK>&		Keys()const=0;
			virtual const IReadonlyList<VT, VK>&		Values()const=0;
			virtual vint								Count()const=0;
			virtual const VT&							Get(const KK& key)const=0;
			virtual const VT&							operator[](const KK& key)const=0;
		};

		template<typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class IDictionary : public virtual IReadonlyDictionary<KT, VT, KK, VK>
		{
		public:
			virtual bool								Set(const KK& key, const VT& value)=0;
			virtual bool								Add(const KT& key, const VT& value)=0;
			virtual bool								Remove(const KK& key)=0;
			virtual bool								Clear()=0;
		};

		template<typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class IReadonlyGroup : public virtual IEnumerable<Pair<KT, VT>>
		{
		public:
			virtual const IReadonlyList<KT, KK>&		Keys()const=0;
			virtual vint								Count()const=0;
			virtual const IReadonlyList<VT, VK>&		Get(const KK& key)const=0;
			virtual const IReadonlyList<VT, VK>&		GetByIndex(vint index)const=0;
			virtual const IReadonlyList<VT, VK>&		operator[](const KK& key)const=0;
			virtual bool								Contains(const KK& key)const=0;
			virtual bool								Contains(const KK& key, const VK& value)const=0;
		};

		template<typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class IGroup: public virtual IReadonlyGroup<KT, VT, KK, VK>
		{
		public:
			virtual bool								Add(const KT& key, const VT& value)=0;
			virtual bool								Remove(const KK& key)=0;
			virtual bool								Remove(const KK& key, const VK& value)=0;
			virtual bool								Clear()=0;
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONCOPYFROM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONCOPYFROM
#define VCZH_COLLECTIONS_OPERATIONCOPYFROM


namespace vl
{
	namespace collections
	{

/***********************************************************************
容器复制
***********************************************************************/

		template<typename T, typename K>
		void CopyFrom(IArray<T, K>& dst, const IReadonlyList<T, K>& src, bool append=false)
		{
			vint start=0;
			if(append)
			{
				start=dst.Count();
				dst.Resize(start+src.Count());
			}
			else
			{
				dst.Resize(src.Count());
			}
			vint srcCount=src.Count();
			for(vint i=0;i<srcCount;i++)
			{
				dst.Set(start+i, src[i]);
			}
		}

		template<typename T, typename K>
		void CopyFrom(ICollection<T, K>& dst, const IReadonlyList<T, K>& src, bool append=false)
		{
			if(!append)
			{
				dst.Clear();
			}
			vint srcCount=src.Count();
			for(vint i=0;i<srcCount;i++)
			{
				dst.Add(src[i]);
			}
		}

		template<typename KT, typename VT, typename KK, typename VK>
		void CopyFrom(IDictionary<KT, VT, KK, VK>& dst, const IReadonlyList<Pair<KT, VT>>& src, bool append=false)
		{
			if(!append)
			{
				dst.Clear();
			}
			vint srcCount=src.Count();
			for(vint i=0;i<srcCount;i++)
			{
				const Pair<KT, VT>& pair=src[i];
				dst.Set(pair.key, pair.value);
			}
		}

		template<typename KT, typename VT, typename KK, typename VK>
		void CopyFrom(IGroup<KT, VT, KK, VK>& dst, const IReadonlyList<Pair<KT, VT>>& src, bool append=false)
		{
			if(!append)
			{
				dst.Clear();
			}
			vint srcCount=src.Count();
			for(vint i=0;i<srcCount;i++)
			{
				const Pair<KT, VT>& pair=src[i];
				dst.Add(pair.key, pair.value);
			}
		}

		template<typename T, typename K>
		void CopyFrom(IArray<T, K>& dst, const IEnumerable<T>& src, bool append=false)
		{
			IEnumerator<T>* enumerator=src.CreateEnumerator();
			try
			{
				vint count=0;
				while(enumerator->Available())
				{
					count++;
					enumerator->Next();
				}
				enumerator->Reset();
				vint start=0;
				if(append)
				{
					start=dst.Count();
					dst.Resize(start+count);
				}
				else
				{
					dst.Resize(count);
				}
				while(enumerator->Available())
				{
					dst.Set(start+enumerator->Index(), enumerator->Current());
					enumerator->Next();
				}
				delete enumerator;
			}
			catch(...)
			{
				delete enumerator;
				throw;
			}
		}

		template<typename T, typename K>
		void CopyFrom(ICollection<T, K>& dst, const IEnumerable<T>& src, bool append=false)
		{
			IEnumerator<T>* enumerator=src.CreateEnumerator();
			try
			{
				if(!append)
				{
					dst.Clear();
				}
				while(enumerator->Available())
				{
					dst.Add(enumerator->Current());
					enumerator->Next();
				}
				delete enumerator;
			}
			catch(...)
			{
				delete enumerator;
				throw;
			}
		}

		template<typename KT, typename VT, typename KK, typename VK>
		void CopyFrom(IDictionary<KT, VT, KK, VK>& dst, const IEnumerable<Pair<KT, VT>>& src, bool append=false)
		{
			IEnumerator<Pair<KT, VT>>* enumerator=src.CreateEnumerator();
			try
			{
				if(!append)
				{
					dst.Clear();
				}
				while(enumerator->Available())
				{
					const Pair<KT, VT>& pair=enumerator->Current();
					dst.Set(pair.key, pair.value);
					enumerator->Next();
				}
				delete enumerator;
			}
			catch(...)
			{
				delete enumerator;
				throw;
			}
		}

		template<typename KT, typename VT, typename KK, typename VK>
		void CopyFrom(IGroup<KT, VT, KK, VK>& dst, const IEnumerable<Pair<KT, VT>>& src, bool append=false)
		{
			IEnumerator<Pair<KT, VT>>* enumerator=src.CreateEnumerator();
			try
			{
				if(!append)
				{
					dst.Clear();
				}
				while(enumerator->Available())
				{
					const Pair<KT, VT>& pair=enumerator->Current();
					dst.Add(pair.key, pair.value);
					enumerator->Next();
				}
				delete enumerator;
			}
			catch(...)
			{
				delete enumerator;
				throw;
			}
		}

		template<typename T, typename K, typename I>
		void CopyFrom(IArray<T, K>& dst, I begin, vint length, bool append=false)
		{
			vint start=0;
			if(append)
			{
				start=dst.Count();
				dst.Resize(start+length);
			}
			else
			{
				dst.Resize(length);
			}

			for(vint i=0;i<length;i++)
			{
				dst.Set(start+i, *begin++);
			}
		}

		template<typename T, typename K, typename I>
		void CopyFrom(ICollection<T, K>& dst, I begin, vint length, bool append=false)
		{
			if(!append)
			{
				dst.Clear();
			}

			for(vint i=0;i<length;i++)
			{
				dst.Add(*begin++);
			}
		}

		template<typename T, typename K, typename I>
		void CopyFrom(IArray<T, K>& dst, I begin, I end, bool append=false)
		{
			vint length=0;
			I current=begin;
			while(current!=end)
			{
				length++;
				current++;
			}
			CopyFrom(dst, begin, length, append);
		}

		template<typename T, typename K, typename I>
		void CopyFrom(ICollection<T, K>& dst, I begin, I end, bool append=false)
		{
			if(!append)
			{
				dst.Clear();
			}

			while(begin!=end)
			{
				dst.Add(*begin++);
			}
		}
	}
}

#endif

/***********************************************************************
POINTER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Smart Pointer

Classes:
	Ptr<T>							：智能指针
***********************************************************************/

#ifndef VCZH_POINTER
#define VCZH_POINTER


namespace vl
{
	template<typename T>
	class Ptr
	{
		 template<typename X>
		 friend class Ptr;
	protected:
		vint*				counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				(*counter)++;
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(--(*counter)==0)
				{
					delete counter;
					delete reference;
					counter=0;
					reference=0;
				}
			}
		}

		vint* Counter()const
		{
			return counter;
		}

		Ptr(vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		Ptr()
		{
			counter=0;
			reference=0;
		}

		Ptr(T* pointer)
		{
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		Ptr(const Ptr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		template<typename C>
		Ptr(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		~Ptr()
		{
			Dec();
		}

		template<typename C>
		Ptr<C> Cast()const
		{
			C* converted=dynamic_cast<C*>(reference);
			return Ptr<C>((converted?counter:0), converted);
		}

		Ptr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		Ptr<T>& operator=(const Ptr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		template<typename C>
		Ptr<T>& operator=(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			Dec();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const Ptr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const Ptr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const Ptr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const Ptr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const Ptr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const Ptr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

	template<typename T>
	class ComPtr
	{
	protected:
		vint*				counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				(*counter)++;
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(--(*counter)==0)
				{
					delete counter;
					reference->Release();
					counter=0;
					reference=0;
				}
			}
		}

		vint* Counter()const
		{
			return counter;
		}

		ComPtr(vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		ComPtr()
		{
			counter=0;
			reference=0;
		}

		ComPtr(T* pointer)
		{
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		ComPtr(const ComPtr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		~ComPtr()
		{
			Dec();
		}

		ComPtr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		ComPtr<T>& operator=(const ComPtr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const ComPtr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const ComPtr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const ComPtr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const ComPtr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const ComPtr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const ComPtr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

	template<typename T>
	struct KeyType<Ptr<T>>
	{
		typedef T* Type;
	};

	template<typename T>
	struct POD<Ptr<T>>
	{
		static const bool Result=false;
	};

	template<typename T>
	struct KeyType<ComPtr<T>>
	{
		typedef T* Type;
	};

	template<typename T>
	struct POD<ComPtr<T>>
	{
		static const bool Result=false;
	};
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONENUMERABLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONENUMERABLE
#define VCZH_COLLECTIONS_OPERATIONENUMERABLE


namespace vl
{
	namespace collections
	{

		template<typename T>
		class Enumerable;

/***********************************************************************
空迭代器
***********************************************************************/

		template<typename T>
		class EmptyEnumerable : public Object, public IEnumerable<T>
		{
			friend class Enumerable<T>;
		private:
			class Enumerator : public Object, public IEnumerator<T>
			{
				IEnumerator<T>* Clone()const
				{
					return new Enumerator;
				}

				const T& Current()const
				{
					return *(T*)0;
				}

				vint Index()const
				{
					return -1;
				}

				bool Next()
				{
					return false;
				}

				bool Available()const
				{
					return false;
				}

				void Reset()
				{
				}
			};
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator;
			}
		};

/***********************************************************************
算法串联
***********************************************************************/

		template<typename T, typename R>
		class EnumerableProcessor : public Object
		{
		public:
			virtual R operator()(const IEnumerable<T>& enumerable)const=0;
		};

		template<typename T, typename R>
		R operator>>(const IEnumerable<T>& enumerable, const EnumerableProcessor<T, R>& processor)
		{
			return processor(enumerable);
		}

		template<template<typename T> class R>
		class SequenceEnumerableProcessor : public Object
		{
		public:
			template<typename T>
			struct ResultTypeRetriver
			{
				typedef R<T> ResultType;
			};
		};

		class AggregateEnumerableProcessor : public Object
		{
		public:
			template<typename T>
			struct ResultTypeRetriver
			{
				typedef T ResultType;
			};
		};

		class FreeEnumerableProcessor : public Object
		{
		};

		template<typename T, typename P>
		typename P::template ResultTypeRetriver<T>::ResultType operator>>(const IEnumerable<T>& enumerable, const P& processor)
		{
			return processor(enumerable);
		}

/***********************************************************************
迭代器存储
***********************************************************************/

		template<typename T, vint I=0>
		class EnumerableStore : public virtual Object
		{
			friend class Enumerable<T>;
		private:
			IEnumerator<T>*			enumerator;
		protected:
			IEnumerator<T>* CopyEnumerator()const
			{
				return enumerator->Clone();
			}
		public:
			EnumerableStore(const IEnumerable<T>& enumerable)
			{
				enumerator=enumerable.CreateEnumerator();
			}

			EnumerableStore(const EnumerableStore<T>& store)
			{
				enumerator=store->CopyEnumerator();
			}

			~EnumerableStore()
			{
				delete enumerator;
			}

			EnumerableStore<T>& operator=(const EnumerableStore<T>& store)
			{
				delete enumerator;
				enumerator=store->CopyEnumerator();
				return *this;
			}
		};

/***********************************************************************
迭代器副本
***********************************************************************/

		template<typename T>
		class Enumerable : public Object, public IEnumerable<T>
		{
		protected:
			Ptr<EnumerableStore<T>>		store;
		public:
			Enumerable()
			{
			}

			Enumerable(const Enumerable<T>& enumerable)
			{
				store=enumerable.store;
			}

			Enumerable(const IEnumerable<T>& enumerable)
			{
				store=new EnumerableStore<T>(enumerable);
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return store?store->CopyEnumerator():new EmptyEnumerable<T>::Enumerator();
			}
		};

/***********************************************************************
迭代器比较
***********************************************************************/

		template<typename T, typename U>
		vint CompareEnumerable(const IEnumerable<T>& a, const IEnumerable<U>& b)
		{
			Ptr<IEnumerator<T>> ator=a.CreateEnumerator();
			Ptr<IEnumerator<U>> btor=b.CreateEnumerator();
			while(ator->Available() && btor->Available())
			{
				const T& ac=ator->Current();
				const U& bc=btor->Current();
				if(ac<bc)
				{
					return -1;
				}
				else if(ac>bc)
				{
					return 1;
				}
				ator->Next();
				btor->Next();
			}
			if(ator->Available())
			{
				return 1;
			}
			else if(btor->Available())
			{
				return -1;
			}
			else
			{
				return 0;
			}
		}
	}
}

#endif

/***********************************************************************
FUNCTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Function

Classes:
	Func<function-type>									：函数对象

Functions:
	Curry :: (A->B) -> A -> B							：参数拆分
	Combine :: (A->B) -> (A->C) -> (B->C->D) -> (A->D)	：函数组合
	
本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/
#ifndef VCZH_FUNCTION
#define VCZH_FUNCTION
#include <memory.h>
namespace vl
{
	template<typename T>
	class Func
	{
	};
 
/***********************************************************************
vl::Func<R()>
***********************************************************************/
	template<typename R >
	class Func<R()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)();
		public:
			StaticInvoker(R(*_function)())
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)();
			struct Content
			{
				C*			sender;
				R(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke()
			{
				return (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType();
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R()>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()()const
		{
			return invoker->Invoke();
		}
		bool operator==(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void()>
***********************************************************************/
	template< >
	class Func<void()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)();
		public:
			StaticInvoker(void(*_function)())
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)();
			struct Content
			{
				C*			sender;
				void(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke()
			{
				  (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType();
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void()>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()()const
		{
			  invoker->Invoke();
		}
		bool operator==(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0)>
***********************************************************************/
	template<typename R,typename T0>
	class Func<R(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0);
		public:
			StaticInvoker(R(*_function)(T0))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0)const
		{
			return invoker->Invoke(p0);
		}
		bool operator==(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0)>
***********************************************************************/
	template< typename T0>
	class Func<void(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0);
		public:
			StaticInvoker(void(*_function)(T0))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0)const
		{
			  invoker->Invoke(p0);
		}
		bool operator==(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1)>
***********************************************************************/
	template<typename R,typename T0,typename T1>
	class Func<R(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1);
		public:
			StaticInvoker(R(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1)const
		{
			return invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1)>
***********************************************************************/
	template< typename T0,typename T1>
	class Func<void(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1);
		public:
			StaticInvoker(void(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1)const
		{
			  invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2>
	class Func<R(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2)const
		{
			return invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2)>
***********************************************************************/
	template< typename T0,typename T1,typename T2>
	class Func<void(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2)const
		{
			  invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3>
	class Func<R(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			return invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3>
	class Func<void(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			  invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<R(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<void(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<R(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<void(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<R(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<void(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
	namespace function_binding
	{
		template<typename T>
		struct Binding
		{
		};
		 
		template<typename T>
		struct CR{typedef const T& Type;};
		template<typename T>
		struct CR<T&>{typedef T& Type;};
		template<typename T>
		struct CR<const T>{typedef const T& Type;};
		template<typename T>
		struct CR<const T&>{typedef const T& Type;};
		 
		template<typename T>
		struct RCR{typedef T Type;};
		template<typename T>
		struct RCR<T&>{typedef T& Type;};
		template<typename T>
		struct RCR<const T>{typedef T Type;};
		template<typename T>
		struct RCR<const T&>{typedef T Type;};
		
 
/***********************************************************************
vl::function_binding::Binding<R(T0)>
***********************************************************************/
		template<typename R,typename T0>
		struct Binding<R(T0)>
		{
			typedef R FunctionType(T0);
			typedef R CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()()const
				{
					return target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0)>
***********************************************************************/
		template< typename T0>
		struct Binding<void(T0)>
		{
			typedef void FunctionType(T0);
			typedef void CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()()const
				{
					  target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1)>
***********************************************************************/
		template<typename R,typename T0,typename T1>
		struct Binding<R(T0,T1)>
		{
			typedef R FunctionType(T0,T1);
			typedef R CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1)const
				{
					return target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1)>
***********************************************************************/
		template< typename T0,typename T1>
		struct Binding<void(T0,T1)>
		{
			typedef void FunctionType(T0,T1);
			typedef void CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1)const
				{
					  target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2>
		struct Binding<R(T0,T1,T2)>
		{
			typedef R FunctionType(T0,T1,T2);
			typedef R CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2)const
				{
					return target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2)>
***********************************************************************/
		template< typename T0,typename T1,typename T2>
		struct Binding<void(T0,T1,T2)>
		{
			typedef void FunctionType(T0,T1,T2);
			typedef void CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2)const
				{
					  target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3>
		struct Binding<R(T0,T1,T2,T3)>
		{
			typedef R FunctionType(T0,T1,T2,T3);
			typedef R CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3)const
				{
					return target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3>
		struct Binding<void(T0,T1,T2,T3)>
		{
			typedef void FunctionType(T0,T1,T2,T3);
			typedef void CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3)const
				{
					  target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<R(T0,T1,T2,T3,T4)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4);
			typedef R CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					return target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<void(T0,T1,T2,T3,T4)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4);
			typedef void CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					  target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<R(T0,T1,T2,T3,T4,T5)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5);
			typedef R CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					return target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<void(T0,T1,T2,T3,T4,T5)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5);
			typedef void CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					  target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
	}
 
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(T* function)
	{
		return typename function_binding::Binding<T>::Currier(function);
	}
 
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(const Func<T>& function)
	{
		return typename function_binding::Binding<T>::Currier(function);
	}
 
	namespace function_combining
	{
		template<typename A, typename B, typename C>
		class Combining
		{
		};
 
/***********************************************************************
vl::function_combining::Combining<R1(), R2(), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R >
		class Combining<R1(), R2(), R(R1,R2)> : public Object
		{
		protected:
			Func<R1()>			function1;
			Func<R2()>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType();
			typedef R2 SecondFunctionType();
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType();
			Combining(const Func<R1()>& _function1, const Func<R2()>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()()const
			{
				return converter(function1(), function2());
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0), R2(T0), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0>
		class Combining<R1(T0), R2(T0), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0)>			function1;
			Func<R2(T0)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0);
			typedef R2 SecondFunctionType(T0);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0);
			Combining(const Func<R1(T0)>& _function1, const Func<R2(T0)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0)const
			{
				return converter(function1(p0), function2(p0));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1>
		class Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1)>			function1;
			Func<R2(T0,T1)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1);
			typedef R2 SecondFunctionType(T0,T1);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1);
			Combining(const Func<R1(T0,T1)>& _function1, const Func<R2(T0,T1)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1)const
			{
				return converter(function1(p0,p1), function2(p0,p1));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2>
		class Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2)>			function1;
			Func<R2(T0,T1,T2)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2);
			typedef R2 SecondFunctionType(T0,T1,T2);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2);
			Combining(const Func<R1(T0,T1,T2)>& _function1, const Func<R2(T0,T1,T2)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2)const
			{
				return converter(function1(p0,p1,p2), function2(p0,p1,p2));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3>
		class Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3)>			function1;
			Func<R2(T0,T1,T2,T3)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3);
			typedef R2 SecondFunctionType(T0,T1,T2,T3);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3);
			Combining(const Func<R1(T0,T1,T2,T3)>& _function1, const Func<R2(T0,T1,T2,T3)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
			{
				return converter(function1(p0,p1,p2,p3), function2(p0,p1,p2,p3));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		class Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4)>			function1;
			Func<R2(T0,T1,T2,T3,T4)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4);
			Combining(const Func<R1(T0,T1,T2,T3,T4)>& _function1, const Func<R2(T0,T1,T2,T3,T4)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
			{
				return converter(function1(p0,p1,p2,p3,p4), function2(p0,p1,p2,p3,p4));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		class Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5), function2(p0,p1,p2,p3,p4,p5));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6), function2(p0,p1,p2,p3,p4,p5,p6));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7), function2(p0,p1,p2,p3,p4,p5,p6,p7));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9));
			}
		};
	}
	template<typename F1, typename F2, typename C>
	Func<typename function_combining::Combining<F1, F2, C>::FinalFunctionType>
	Combine(Func<C> converter, Func<F1> function1, Func<F2> function2)
	{
		return function_combining::Combining<F1, F2, C>(function1, function2, converter);
	}
	template<typename T>
	Func<Func<T>(Func<T>,Func<T>)> Combiner(const Func<typename Func<T>::ResultType(typename Func<T>::ResultType,typename Func<T>::ResultType)>& converter)
	{
		typedef typename Func<T>::ResultType R;
		return Curry<Func<T>(Func<R(R,R)>,Func<T>,Func<T>)>(Combine)(converter);
	}
}
#endif

/***********************************************************************
COLLECTIONS\OPERATIONSELECT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSELECT
#define VCZH_COLLECTIONS_OPERATIONSELECT


namespace vl
{
	namespace collections
	{

/***********************************************************************
Select
***********************************************************************/

		template<typename T, typename K>
		class SelectEnumerable : public EnumerableStore<T>, public virtual IEnumerable<K>
		{
		private:
			class Enumerator : public virtual IEnumerator<K>
			{
			protected:
				IEnumerator<T>*		enumerator;
				Func<K(T)>			selector;
				K					current;
			public:
				Enumerator(IEnumerator<T>* _enumerator, const Func<K(T)>& _selector)
					:enumerator(_enumerator)
					,selector(_selector)
				{
					if(enumerator->Available())
					{
						current=selector(enumerator->Current());
					}
				}

				~Enumerator()
				{
					delete enumerator;
				}

				IEnumerator<K>* Clone()const
				{
					return new Enumerator(enumerator->Clone(), selector);
				}

				const K& Current()const
				{
					return current;
				}

				vint Index()const
				{
					return enumerator->Index();
				}

				bool Next()
				{
					if(enumerator->Next())
					{
						current=selector(enumerator->Current());
						return true;
					}
					else
					{
						return false;
					}
				}

				bool Available()const
				{
					return enumerator->Available();
				}

				void Reset()
				{
					enumerator->Reset();
				}
			};
		protected:
			Func<K(T)>				selector;
		public:
			SelectEnumerable(const IEnumerable<T>& enumerable, const Func<K(T)>& _selector)
				:EnumerableStore<T>(enumerable)
				,selector(_selector)
			{
			}

			IEnumerator<K>* CreateEnumerator()const
			{
				return new Enumerator(CopyEnumerator(), selector);
			}
		};

		template<typename T, typename K>
		class SelectProcessor : public EnumerableProcessor<T, SelectEnumerable<T, K>>
		{
		protected:
			Func<K(T)>				selector;
		public:
			SelectProcessor(const Func<K(T)>& _selector)
				:selector(_selector)
			{
			}

			SelectEnumerable<T, K> operator()(const IEnumerable<T>& enumerable)const
			{
				return SelectEnumerable<T, K>(enumerable, selector);
			}
		};

		template<typename T, typename K>
		SelectProcessor<T, K> Select(const Func<K(T)>& selector)
		{
			return SelectProcessor<T, K>(selector);
		}

		template<typename T, typename K>
		SelectProcessor<T, K> Select(K(*selector)(T))
		{
			return SelectProcessor<T, K>(selector);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONWHERE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONWHERE
#define VCZH_COLLECTIONS_OPERATIONWHERE


namespace vl
{
	namespace collections
	{

/***********************************************************************
Where
***********************************************************************/

		template<typename T>
		class WhereEnumerable : public EnumerableStore<T>, public virtual IEnumerable<T>
		{
		private:
			class Enumerator : public virtual IEnumerator<T>
			{
			protected:
				IEnumerator<T>*		enumerator;
				Func<bool(T)>		selector;
				vint					index;

				void GoNearest()
				{
					while(enumerator->Available())
					{
						if(selector(enumerator->Current()))
						{
							break;
						}
						else
						{
							enumerator->Next();
						}
					}
				}
			public:
				Enumerator(IEnumerator<T>* _enumerator, const Func<bool(T)>& _selector, vint _index=0)
					:enumerator(_enumerator)
					,selector(_selector)
					,index(_index)
				{
					GoNearest();
				}

				~Enumerator()
				{
					delete enumerator;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(enumerator->Clone(), selector, index);
				}

				const T& Current()const
				{
					return enumerator->Current();
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					enumerator->Next();
					GoNearest();
					return Available();
				}

				bool Available()const
				{
					return enumerator->Available();
				}

				void Reset()
				{
					enumerator->Reset();
					GoNearest();
				}
			};
		protected:
			Func<bool(T)>			selector;
		public:
			WhereEnumerable(const IEnumerable<T>& enumerable, const Func<bool(T)>& _selector)
				:EnumerableStore<T>(enumerable)
				,selector(_selector)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(CopyEnumerator(), selector);
			}
		};

		template<typename T>
		class WhereProcessor : public EnumerableProcessor<T, WhereEnumerable<T>>
		{
		protected:
			Func<bool(T)>			selector;
		public:
			WhereProcessor(const Func<bool(T)>& _selector)
				:selector(_selector)
			{
			}

			WhereEnumerable<T> operator()(const IEnumerable<T>& enumerable)const
			{
				return WhereEnumerable<T>(enumerable, selector);
			}
		};

		template<typename T>
		WhereProcessor<T> Where(const Func<bool(T)>& selector)
		{
			return WhereProcessor<T>(selector);
		}

		template<typename T>
		WhereProcessor<T> Where(bool(*selector)(T))
		{
			return WhereProcessor<T>(selector);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\LISTWRAPPERS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::List Wrappers

Classes:
	ReadonlyListEnumerator<T>
	ReadonlyListConverter<T>
	ReadonlyListWrapper<T>
	ArrayWrapper<T>
	CollectionWrapper<T>
	ListWrapper<T>
***********************************************************************/

#ifndef VCZH_COLLECTIONS_LISTWRAPPERS
#define VCZH_COLLECTIONS_LISTWRAPPERS


namespace vl
{
	namespace collections
	{

/***********************************************************************
代理
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class ReadonlyListEnumerator : public Object, public virtual IEnumerator<T>
		{
		private:
			const IReadonlyList<T, K>*			container;
			vint									index;
		public:
			ReadonlyListEnumerator(const IReadonlyList<T, K>* _container, vint _index)
			{
				container=_container;
				index=_index;
			}

			ReadonlyListEnumerator<T>* Clone()const
			{
				return new ReadonlyListEnumerator<T, K>(container, index);
			}

			const T& Current()const
			{
				return container->Get(index);
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				index++;
				return Available();
			}

			bool Available()const
			{
				return index>=0 && index<container->Count();
			}

			void Reset()
			{
				index=0;
			}
		};

		template<typename C, typename T, typename K=typename KeyType<T>::Type>
		class ReadonlyListWrapper : public Object, public virtual IReadonlyList<T, K>
		{
		private:
			C*									container;
		public:
			ReadonlyListWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return container->Contains(item);
			}

			vint Count()const
			{
				return container->Count();
			}

			const T& Get(vint index)const
			{
				return container->Get(index);
			}

			const T& operator[](vint index)const
			{
				return container->operator[](index);
			}

			vint IndexOf(const K& item)const
			{
				return container->IndexOf(item);
			}
		};

		template<typename C, typename T, typename K=typename KeyType<T>::Type>
		class ArrayWrapper : public Object, public virtual IArray<T, K>
		{
		private:
			C*									container;
		public:
			ArrayWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return container->Contains(item);
			}

			vint Count()const
			{
				return container->Count();
			}

			const T& Get(vint index)const
			{
				return container->Get(index);
			}

			const T& operator[](vint index)const
			{
				return container->operator[](index);
			}

			vint IndexOf(const K& item)const
			{
				return container->IndexOf(item);
			}

			void Set(vint index, const T& item)
			{
				container->Set(index, item);
			}

			void Resize(vint size)
			{
				container->Resize(size);
			}
		};

		template<typename C, typename T, typename K=KeyType<T>::Type>
		class CollectionWrapper : public Object, public virtual ICollection<T, K>
		{
		private:
			C*									container;
		public:
			CollectionWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return container->Contains(item);
			}

			vint Count()const
			{
				return container->Count();
			}

			const T& Get(vint index)const
			{
				return container->Get(index);
			}

			const T& operator[](vint index)const
			{
				return container->operator[](index);
			}

			vint IndexOf(const K& item)const
			{
				return container->IndexOf(item);
			}

			vint Add(const T& item)
			{
				return container->Add(item);
			}

			bool Remove(const K& item)
			{
				return container->Remove(item);
			}

			bool RemoveAt(vint index)
			{
				return container->RemoveAt(index);
			}

			bool RemoveRange(vint index, vint count)
			{
				return container->RemoveRange(index, count);
			}

			bool Clear()
			{
				return container->Clear();
			}
		};

		template<typename C, typename T, typename K=KeyType<T>::Type>
		class ListWrapper : public Object, public virtual IList<T, K>
		{
		private:
			C*									container;
		public:
			ListWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return container->Contains(item);
			}

			vint Count()const
			{
				return container->Count();
			}

			const T& Get(vint index)const
			{
				return container->Get(index);
			}

			const T& operator[](vint index)const
			{
				return container->operator[](index);
			}

			vint IndexOf(const K& item)const
			{
				return container->IndexOf(item);
			}

			vint Add(const T& item)
			{
				return container->Add(item);
			}

			bool Remove(const K& item)
			{
				return container->Remove(item);
			}

			bool RemoveAt(vint index)
			{
				return container->RemoveAt(index);
			}

			bool RemoveRange(vint index, vint count)
			{
				return container->RemoveRange(index, count);
			}

			bool Clear()
			{
				return container->Clear();
			}

			vint Insert(vint index, const T& item)
			{
				return container->Insert(index, item);
			}

			bool Set(vint index, const T& item)
			{
				return container->Set(index, item);
			}
		};

/***********************************************************************
类型转换代理
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class ReadonlyListImplBase : public virtual IReadonlyList<T, K>
		{
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			const T& operator[](vint index)const
			{
				return Get(index);
			}

			vint IndexOf(const K& item)const
			{
				vint count=Count();
				for(vint i=0;i<count;i++)
				{
					if(Get(i)==item)
					{
						return i;
					}
				}
				return -1;
			}
		};

		template<typename TS, typename TD, typename KS=typename KeyType<TS>::Type, typename KD=typename KeyType<TD>::Type>
		class ReadonlyListConverterBase : protected ReadonlyListImplBase<TD, KD>
		{
		private:
			IReadonlyList<TS, KS>*				container;

		protected:
			ReadonlyListConverterBase()
				:container(0)
			{
			}

			vint Count()const
			{
				return container->Count();
			}

			const TD& Get(vint index)const
			{
				return Convert(container->Get(index));
			}

			void SetContainer(IReadonlyList<TS, KS>* _container)
			{
				container=_container;
			}

			virtual const TD& Convert(const TS& value)const;
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\LIST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::List

Classes:
	ListStore<T,PODType>				：列表存储复制算法
	ListBase<T,K>						：列表基类
	Array<T,K>							：数组
	List<T,K>							：列表
	SortedList<T,K>						：有序列表
***********************************************************************/

#ifndef VCZH_COLLECTIONS_LIST
#define VCZH_COLLECTIONS_LIST

#include <string.h>

namespace vl
{
	namespace collections
	{

/***********************************************************************
储存结构
***********************************************************************/

		template<typename T, bool PODType>
		class ListStore abstract : public Object
		{
		};
		
		template<typename T>
		class ListStore<T,false> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(dest<source)
				{
					for(vint i=0;i<count;i++)
					{
						dest[i]=source[i];
					}
				}
				else if(dest>source)
				{
					for(vint i=count-1;i>=0;i--)
					{
						dest[i]=source[i];
					}
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
				for(vint i=0;i<count;i++)
				{
					dest[i]=T();
				}
			}
		public:
		};
		
		template<typename T>
		class ListStore<T,true> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(count)
				{
					memmove(dest, source, sizeof(T)*count);
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
			}
		public:
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class ListBase abstract : public ListStore<T,POD<T>::Result>
		{
		protected:
			vint						count;
			vint						capacity;
			T*						buffer;
			bool					lessMemoryMode;

			vint CalculateCapacity(vint expected)
			{
				vint result=capacity;
				while(result<expected)
				{
					result=result*5/4+1;
				}
				return result;
			}

			void MakeRoom(vint index, vint _count)
			{
				vint newCount=count+_count;
				if(newCount>capacity)
				{
					vint newCapacity=CalculateCapacity(newCount);
					T* newBuffer=new T[newCapacity];
					CopyObjects(newBuffer, buffer, index);
					CopyObjects(newBuffer+index+_count, buffer+index, count-index);
					delete[] buffer;
					capacity=newCapacity;
					buffer=newBuffer;
				}
				else
				{
					CopyObjects(buffer+index+_count, buffer+index, count-index);
				}
				count=newCount;
			}

			void ReleaseUnnecessaryBuffer(vint previousCount)
			{
				if(buffer && count<previousCount)
				{
					ClearObjects(&buffer[count], previousCount-count);
				}
				if(lessMemoryMode && count<=capacity/2)
				{
					vint newCapacity=capacity*5/8;
					if(count<newCapacity)
					{
						T* newBuffer=new T[newCapacity];
						CopyObjects(newBuffer, buffer, count);
						delete[] buffer;
						capacity=newCapacity;
						buffer=newBuffer;
					}
				}
			}
		public:
			ListBase()
			{
				count=0;
				capacity=0;
				buffer=0;
				lessMemoryMode=true;
			}

			~ListBase()
			{
				delete[] buffer;
			}

			void SetLessMemoryMode(bool mode)
			{
				lessMemoryMode=mode;
			}

			vint Count()const
			{
				return count;
			}

			const T& Get(vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::Get(vint)#参数越界。");
				return buffer[index];
			}

			const T& operator[](vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			bool RemoveAt(vint index)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::RemoveAt(vint)#参数index越界。");
				CopyObjects(buffer+index,buffer+index+1,count-index-1);
				count--;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool RemoveRange(vint index, vint _count)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<=count, L"ListBase<T, K>::RemoveRange(vint, vint)#参数index越界。");
				CHECK_ERROR(index+_count>=0 && index+_count<=count, L"ListBase<T,K>::RemoveRange(vint, vint)#参数_count越界。");
				CopyObjects(buffer+index, buffer+index+_count, count-index-_count);
				count-=_count;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool Clear()
			{
				vint previousCount=count;
				count=0;
				if(lessMemoryMode)
				{
					capacity=0;
					delete[] buffer;
					buffer=0;
				}
				else
				{
					ReleaseUnnecessaryBuffer(previousCount);
				}
				return true;
			}
		};

/***********************************************************************
列表对象
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class Array : public ListStore<T, POD<T>::Result>, private NotCopyable
		{
		protected:
			vint								count;
			T*								buffer;
			mutable ArrayWrapper<Array<T, K>, T, K>		wrapper;

			void Create(vint size)
			{
				if(size>0)
				{
					count=size;
					buffer=new T[size];
				}
				else
				{
					count=0;
					buffer=0;
				}
			}

			void Destroy()
			{
				count=0;
				delete[] buffer;
				buffer=0;
			}
		public:
			Array(vint size=0)
			{
				wrapper.SetContainer(this);
				Create(size);
			}

			Array(const T* _buffer, vint size)
			{
				wrapper.SetContainer(this);
				Create(size);
				CopyObjects(buffer, _buffer, size);
			}

			~Array()
			{
				Destroy();
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint Count()const
			{
				return count;
			}

			const T& Get(vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::Get(vint)#参数越界。");
				return buffer[index];
			}

			const T& operator[](vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			void Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
			}

			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			void Resize(vint size)
			{
				vint oldCount=count;
				T* oldBuffer=buffer;
				Create(size);
				CopyObjects(buffer, oldBuffer, (count<oldCount?count:oldCount));
				delete[] oldBuffer;
			}

			IArray<T, K>& Wrap()const
			{
				return wrapper;
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class List : public ListBase<T, K>, private NotCopyable
		{
		protected:
			mutable ListWrapper<List<T, K>, T, K>	wrapper;
		public:
			List()
			{
				wrapper.SetContainer(this);
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			vint Add(const T& item)
			{
				MakeRoom(count, 1);
				buffer[count-1]=item;
				return count-1;
			}

			vint Insert(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<=count, L"List<T, K>::Insert(vint, const T&)#参数index越界。");
				MakeRoom(index,1);
				buffer[index]=item;
				return index;
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
				return true;
			}

			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			IList<T, K>& Wrap()const
			{
				return wrapper;
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class SortedList : public ListBase<T, K>, private NotCopyable
		{
		protected:
			mutable CollectionWrapper<SortedList<T, K>, T, K>	wrapper;
		public:
			SortedList()
			{
				wrapper.SetContainer(this);
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			template<typename Key>
			vint IndexOf(const Key& item)const
			{
				vint start=0;
				vint end=count-1;
				while(start<=end)
				{
					vint index=(start+end)/2;
					if(buffer[index]==item)
					{
						return index;
					}
					else if(buffer[index]>item)
					{
						end=index-1;
					}
					else
					{
						start=index+1;
					}
				}
				return -1;
			}

			vint IndexOf(const K& item)const
			{
				return IndexOf<K>(item);
			}

			vint Add(const T& item)
			{
				if(count==0)
				{
					MakeRoom(0, 1);
					buffer[0]=item;
					return 0;
				}
				else
				{
					vint start=0;
					vint end=count-1;
					vint index=-1;
					while(start<=end)
					{
						index=(start+end)/2;
						if(buffer[index]==item)
						{
							goto SORTED_LIST_INSERT;
						}
						else if(buffer[index]>item)
						{
							end=index-1;
						}
						else
						{
							start=index+1;
						}
					}
					CHECK_ERROR(index>=0 && index<count, L"SortedList<T, K>::Add(const T&)#内部错误，变量index越界");
					if(buffer[index]<item)
					{
						index++;
					}
SORTED_LIST_INSERT:
					MakeRoom(index, 1);
					buffer[index]=item;
					return index;
				}
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			ICollection<T, K>& Wrap()const
			{
				return wrapper;
			}
		};

/***********************************************************************
容器复制模板
***********************************************************************/

		template<typename A, typename B>
		void CopyToCollection(A& dst, const B& src, bool append=false)
		{
			if(!append)dst.Clear();
			vint count=src.Count();
			for(vint i=0;i<count;i++)
			{
				dst.Add(src.Get(i));
			}
		}

		template<typename A, typename B>
		void CopyToArray(A& dst, const B& src, bool append=false)
		{
			vint start=0;
			vint count=src.Count();
			if(append)
			{
				start=dst.Count();
				dst.Resize(start+count);
			}
			else
			{
				dst.Resize(count);
			}
			for(vint i=0;i<count;i++)
			{
				dst[start+i]=src.Get(i);
			}
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONORDERBY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONORDERBY
#define VCZH_COLLECTIONS_OPERATIONORDERBY


namespace vl
{
	namespace collections
	{

/***********************************************************************
OrderBy Quick Sort
***********************************************************************/

		template<typename T>
		void Sort(T* items, vint length, const Func<vint(T, T)>& orderer)
		{
			if(length==0) return;
			vint pivot=0;
			vint left=0;
			vint right=0;
			bool flag=false;

			while(left+right+1!=length)
			{
				vint& mine=(flag?left:right);
				vint& theirs=(flag?right:left);
				vint candidate=(flag?left:length-right-1);
				vint factor=(flag?-1:1);

				if(orderer(items[pivot], items[candidate])*factor<=0)
				{
					mine++;
				}
				else
				{
					theirs++;
					T temp=items[pivot];
					items[pivot]=items[candidate];
					items[candidate]=temp;
					pivot=candidate;
					flag=!flag;
				}
			}

			Sort(items, left, orderer);
			Sort(items+left+1, right, orderer);
		}

/***********************************************************************
OrderBy
***********************************************************************/

		template<typename T>
		class OrderByEnumerable : public virtual IEnumerable<T>
		{
		protected:
			List<T>					values;
		public:
			OrderByEnumerable(const IEnumerable<T>& enumerable, const Func<vint(T, T)>& orderer)
			{
				CopyFrom(values.Wrap(), enumerable);
				if(values.Count()>0)
				{
					Sort(&values[0], values.Count(), orderer);
				}
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return values.Wrap().CreateEnumerator();
			}
		};

		template<typename T>
		class OrderByProcessor : public EnumerableProcessor<T, OrderByEnumerable<T>>
		{
		protected:
			Func<vint(T, T)>		orderer;
		public:
			OrderByProcessor(const Func<vint(T, T)>& _orderer)
				:orderer(_orderer)
			{
			}

			OrderByEnumerable<T> operator()(const IEnumerable<T>& enumerable)const
			{
				return OrderByEnumerable<T>(enumerable, orderer);
			}
		};

		template<typename T>
		OrderByProcessor<T> OrderBy(const Func<vint(T, T)>& orderer)
		{
			return OrderByProcessor<T>(orderer);
		}

		template<typename T>
		OrderByProcessor<T> OrderBy(vint(*orderer)(T, T))
		{
			return OrderByProcessor<T>(orderer);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONFOREACH.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

扩展：
	实现一个函数重载IteratorType CreateForEachIterator(const CollectionType& collection);
	CollectionType是所需要的容器类型
	IteratorType继承自ForEachIterator<T>
	必须写在vl::collections命名空间里
***********************************************************************/

#ifndef VCZH_COLLECTIONS_FOREACH
#define VCZH_COLLECTIONS_FOREACH

namespace vl
{
	namespace collections
	{

/***********************************************************************
ForEach基础设施
***********************************************************************/

		template<typename T>
		class ForEachIterator : public Object
		{
		public:
			virtual bool				Available(T& variable)const=0;
			virtual void				Next()const=0;

			operator bool()const
			{
				return true;
			}
		};

/***********************************************************************
IEnumerable<T>支持
***********************************************************************/

		template<typename T>
		class EnumerableForEachIterator : public ForEachIterator<T>
		{
		protected:
			Ptr<IEnumerator<T>>			iterator;
		public:
			EnumerableForEachIterator(const IEnumerable<T>& enumerable)
				:iterator(enumerable.CreateEnumerator())
			{
			}

			EnumerableForEachIterator(const EnumerableForEachIterator<T>& enumerableIterator)
				:iterator(enumerableIterator.iterator)
			{
			}

			bool Available(T& variable)const
			{
				if(iterator->Available())
				{
					variable=iterator->Current();
					return true;
				}
				else
				{
					return false;
				}
			}

			void Next()const
			{
				iterator->Next();
			}
		};

		template<typename T>
		EnumerableForEachIterator<T> CreateForEachIterator(const IEnumerable<T>& enumerable)
		{
			return enumerable;
		}

/***********************************************************************
ForEach宏
***********************************************************************/

#define SCOPE_VARIABLE(TYPE, VARIABLE, VALUE)\
		if(bool __scope_variable_flag__=true)\
			for(TYPE VARIABLE = VALUE;__scope_variable_flag__;__scope_variable_flag__=false)

#define FOREACH(TYPE, VARIABLE, COLLECTION)\
		SCOPE_VARIABLE(const ForEachIterator<TYPE>&, __foreach_iterator__, CreateForEachIterator(COLLECTION))\
		for(TYPE VARIABLE;__foreach_iterator__.Available(VARIABLE);__foreach_iterator__.Next())

#define FOREACH_INDEXER(TYPE, VARIABLE, INDEXER, COLLECTION)\
		SCOPE_VARIABLE(const ForEachIterator<TYPE>&, __foreach_iterator__, CreateForEachIterator(COLLECTION))\
		SCOPE_VARIABLE(vint, INDEXER, 0)\
		for(TYPE VARIABLE;__foreach_iterator__.Available(VARIABLE);__foreach_iterator__.Next(),INDEXER++)
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONAGGREGATE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONAGGREGATE
#define VCZH_COLLECTIONS_OPERATIONAGGREGATE


namespace vl
{
	namespace collections
	{

/***********************************************************************
Aggregate
***********************************************************************/

		template<typename T>
		class AggregateProcessor : public EnumerableProcessor<T, T>
		{
		protected:
			Func<T(T,T)>				selector;
			T							initial;
			bool						hasInitial;
		public:
			AggregateProcessor(const Func<T(T,T)>& _selector)
				:selector(_selector)
				,hasInitial(false)
			{
			}

			AggregateProcessor(const Func<T(T,T)>& _selector, const T& _initial)
				:selector(_selector)
				,initial(_initial)
				,hasInitial(true)
			{
			}

			T operator()(const IEnumerable<T>& enumerable)const
			{
				T result;
				IEnumerator<T>* enumerator=enumerable.CreateEnumerator();
				try
				{
					if(hasInitial)
					{
						result=initial;
					}
					else if(enumerator->Available())
					{
						result=enumerator->Current();
						enumerator->Next();
					}
					else
					{
						throw Error(L"AggregateProcessor<T>::operator(const IEnumerable<T>&)#容器为空并且没有初始值，Aggregate操作失败。");
					}
					while(enumerator->Available())
					{
						result=selector(result, enumerator->Current());
						enumerator->Next();
					}
					delete enumerator;
				}
				catch(...)
				{
					delete enumerator;
					throw;
				}
				return result;
			}
		};

		template<typename T>
		AggregateProcessor<T> Aggregate(const Func<T(T,T)>& selector)
		{
			return AggregateProcessor<T>(selector);
		}

		template<typename T>
		AggregateProcessor<T> Aggregate(T(*selector)(T,T))
		{
			return AggregateProcessor<T>(selector);
		}

		template<typename T>
		AggregateProcessor<T> Aggregate(const Func<T(T,T)>& selector, const T& initial)
		{
			return AggregateProcessor<T>(selector, initial);
		}

		template<typename T>
		AggregateProcessor<T> Aggregate(T(*selector)(T,T), const T& initial)
		{
			return AggregateProcessor<T>(selector, initial);
		}

/***********************************************************************
All
***********************************************************************/

		template<typename T>
		class AllProcessor : public EnumerableProcessor<T, bool>
		{
		protected:
			Func<bool(T)>				selector;

			static bool Op(bool a, bool b)
			{
				return a && b;
			}
		public:
			AllProcessor(const Func<bool(T)>& _selector)
				:selector(_selector)
			{
			}

			bool operator()(const IEnumerable<T>& enumerable)const
			{
				return enumerable>>Select(selector)>>Aggregate(Op, true);
			}
		};

		template<typename T>
		AllProcessor<T> All(const Func<bool(T)>& selector)
		{
			return AllProcessor<T>(selector);
		}

		template<typename T>
		AllProcessor<T> All(bool(*selector)(T))
		{
			return AllProcessor<T>(selector);
		}

/***********************************************************************
Any
***********************************************************************/

		template<typename T>
		class AnyProcessor : public EnumerableProcessor<T, bool>
		{
		protected:
			Func<bool(T)>				selector;

			static bool Op(bool a, bool b)
			{
				return a || b;
			}
		public:
			AnyProcessor(const Func<bool(T)>& _selector)
				:selector(_selector)
			{
			}

			bool operator()(const IEnumerable<T>& enumerable)const
			{
				return enumerable>>Select(selector)>>Aggregate(Op, false);
			}
		};

		template<typename T>
		AnyProcessor<T> Any(const Func<bool(T)>& selector)
		{
			return AnyProcessor<T>(selector);
		}

		template<typename T>
		AnyProcessor<T> Any(bool(*selector)(T))
		{
			return AnyProcessor<T>(selector);
		}

/***********************************************************************
Max
***********************************************************************/

		class MaxProcessor : public AggregateEnumerableProcessor
		{
		protected:
			template<typename T>
			static T Op(T a, T b)
			{
				return a>b?a:b;
			}
		public:
			MaxProcessor()
			{
			}

			template<typename T>
			T operator()(const IEnumerable<T>& enumerable)const
			{
				return enumerable>>Aggregate(Op<T>);
			}
		};

		extern MaxProcessor Max();

/***********************************************************************
Min
***********************************************************************/

		class MinProcessor : public AggregateEnumerableProcessor
		{
		protected:
			template<typename T>
			static T Op(T a, T b)
			{
				return a<b?a:b;
			}
		public:
			MinProcessor()
			{
			}

			template<typename T>
			T operator()(const IEnumerable<T>& enumerable)const
			{
				return enumerable>>Aggregate(Op<T>);
			}
		};

		extern MinProcessor Min();

/***********************************************************************
First
***********************************************************************/

		class FirstProcessor : public FreeEnumerableProcessor
		{
		public:
			template<typename T>
			struct ResultTypeRetriver
			{
				typedef T ResultType;
			};

			FirstProcessor()
			{
			}

			template<typename T>
			T operator()(const IEnumerable<T>& enumerable)const
			{
				FOREACH(T, x, enumerable)
				{
					return x;
				}
				return T();
			}
		};

		extern FirstProcessor First();

/***********************************************************************
Count
***********************************************************************/

		class CountProcessor : public FreeEnumerableProcessor
		{
		public:
			template<typename T>
			struct ResultTypeRetriver
			{
				typedef vint ResultType;
			};

			CountProcessor()
			{
			}

			template<typename T>
			vint operator()(const IEnumerable<T>& enumerable)const
			{
				vint count=0;
				FOREACH(T, x, enumerable)
				{
					count++;
				}
				return count;
			}
		};

		extern CountProcessor Count();

/***********************************************************************
IsEmpty
***********************************************************************/

		class IsEmptyProcessor : public FreeEnumerableProcessor
		{
		public:
			template<typename T>
			struct ResultTypeRetriver
			{
				typedef bool ResultType;
			};

			IsEmptyProcessor()
			{
			}

			template<typename T>
			bool operator()(const IEnumerable<T>& enumerable)const
			{
				FOREACH(T, x, enumerable)
				{
					return false;
				}
				return true;
			}
		};

		extern IsEmptyProcessor IsEmpty();
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONCONCAT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONCONCAT
#define VCZH_COLLECTIONS_OPERATIONCONCAT


namespace vl
{
	namespace collections
	{

/***********************************************************************
Concat
***********************************************************************/

		template<typename T>
		class ConcatEnumerable : public EnumerableStore<T, 1>, public EnumerableStore<T, 2>, public virtual IEnumerable<T>
		{
		protected:
			class Enumerator : public virtual IEnumerator<T>
			{
			protected:
				IEnumerator<T>*					enumerator1;
				IEnumerator<T>*					enumerator2;
				vint							index;
				bool							turned;
			public:
				Enumerator(IEnumerator<T>* _enumerator1, IEnumerator<T>* _enumerator2, vint _index=0, bool _turned=false)
					:enumerator1(_enumerator1)
					,enumerator2(_enumerator2)
					,index(_index)
					,turned(_turned)
				{
					if(turned==false && !enumerator1->Available())
					{
						turned=true;
					}
				}

				~Enumerator()
				{
					delete enumerator1;
					delete enumerator2;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(enumerator1->Clone(), enumerator2->Clone(), index, turned);
				}

				const T& Current()const
				{
					if(enumerator1->Available())
					{
						return enumerator1->Current();
					}
					else
					{
						return enumerator2->Current();
					}
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					if(enumerator1->Next())
					{
						return true;
					}
					else if(turned==false)
					{
						turned=true;
						return enumerator2->Available();
					}
					else
					{
						return enumerator2->Next();
					}
				}

				bool Available()const
				{
					return enumerator1->Available() || enumerator2->Available();
				}

				void Reset()
				{
					enumerator1->Reset();
					enumerator2->Reset();
					index=0;
				}
			};
		public:
			ConcatEnumerable(const IEnumerable<T>& enumerable1, const IEnumerable<T>& enumerable2)
				:EnumerableStore<T, 1>(enumerable1)
				,EnumerableStore<T, 2>(enumerable2)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(EnumerableStore<T, 1>::CopyEnumerator(), EnumerableStore<T, 2>::CopyEnumerator());
			}
		};

		template<typename T>
		class ConcatProcessor : public EnumerableProcessor<T, ConcatEnumerable<T>>
		{
		protected:
			const IEnumerable<T>&				second;
		public:
			ConcatProcessor(const IEnumerable<T>& _second)
				:second(_second)
			{
			}

			ConcatEnumerable<T> operator()(const IEnumerable<T>& first)const
			{
				return ConcatEnumerable<T>(first, second);
			}
		};

		template<typename T>
		ConcatProcessor<T> Concat(const IEnumerable<T>& second)
		{
			return ConcatProcessor<T>(second);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSEQUENCE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSEQUENCE
#define VCZH_COLLECTIONS_OPERATIONSEQUENCE


namespace vl
{
	namespace collections
	{

/***********************************************************************
Take
***********************************************************************/

		template<typename T>
		class TakeEnumerable : public EnumerableStore<T>, public virtual IEnumerable<T>
		{
		private:
			class Enumerator : public virtual IEnumerator<T>
			{
			protected:
				IEnumerator<T>*		enumerator;
				vint					count;
			public:
				Enumerator(IEnumerator<T>* _enumerator, vint _count)
					:enumerator(_enumerator)
					,count(_count)
				{
				}

				~Enumerator()
				{
					delete enumerator;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(enumerator->Clone(), count);
				}

				const T& Current()const
				{
					return enumerator->Current();
				}

				vint Index()const
				{
					return enumerator->Index();
				}

				bool Next()
				{
					if(enumerator->Index()==count-1)
					{
						enumerator->Next();
						return false;
					}
					else if(enumerator->Index()>=count)
					{
						return false;
					}
					else
					{
						return enumerator->Next();
					}
				}

				bool Available()const
				{
					return enumerator->Available() && enumerator->Index()<count;
				}

				void Reset()
				{
					enumerator->Reset();
				}
			};
		protected:
			vint					count;
		public:
			TakeEnumerable(const IEnumerable<T>& enumerable, vint _count)
				:EnumerableStore<T>(enumerable)
				,count(_count)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(CopyEnumerator(), count);
			}
		};

		class TakeProcessor : public SequenceEnumerableProcessor<TakeEnumerable>
		{
		protected:
			vint					count;
		public:
			TakeProcessor(vint _count)
				:count(_count)
			{
			}

			template<typename T>
			TakeEnumerable<T> operator()(const IEnumerable<T>& enumerable)const
			{
				return TakeEnumerable<T>(enumerable, count);
			}
		};

		extern TakeProcessor Take(vint count);

/***********************************************************************
Skip
***********************************************************************/

		template<typename T>
		class SkipEnumerable : public EnumerableStore<T>, public virtual IEnumerable<T>
		{
		private:
			class Enumerator : public virtual IEnumerator<T>
			{
			protected:
				IEnumerator<T>*		enumerator;
				vint					count;
			public:
				Enumerator(IEnumerator<T>* _enumerator, vint _count)
					:enumerator(_enumerator)
					,count(_count)
				{
					for(vint i=0;i<count;i++)
					{
						enumerator->Next();
					}
				}

				~Enumerator()
				{
					delete enumerator;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(enumerator->Clone(), count);
				}

				const T& Current()const
				{
					return enumerator->Current();
				}

				vint Index()const
				{
					return enumerator->Index()-count;
				}

				bool Next()
				{
					return enumerator->Next();
				}

				bool Available()const
				{
					return enumerator->Available();
				}

				void Reset()
				{
					enumerator->Reset();
					for(vint i=0;i<count;i++)
					{
						enumerator->Next();
					}
				}
			};
		protected:
			vint					count;
		public:
			SkipEnumerable(const IEnumerable<T>& enumerable, vint _count)
				:EnumerableStore<T>(enumerable)
				,count(_count)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(CopyEnumerator(), count);
			}
		};

		class SkipProcessor : public SequenceEnumerableProcessor<SkipEnumerable>
		{
		protected:
			vint					count;
		public:
			SkipProcessor(vint _count)
				:count(_count)
			{
			}

			template<typename T>
			SkipEnumerable<T> operator()(const IEnumerable<T>& enumerable)const
			{
				return SkipEnumerable<T>(enumerable, count);
			}
		};

		extern SkipProcessor Skip(vint count);

/***********************************************************************
Repeat
***********************************************************************/

		template<typename T>
		class RepeatEnumerable : public EnumerableStore<T>, public virtual IEnumerable<T>
		{
		private:
			class Enumerator : public virtual IEnumerator<T>
			{
			protected:
				IEnumerator<T>*		enumerator;
				vint					count;
				vint					index;
				vint					repeatedCount;
			public:
				Enumerator(IEnumerator<T>* _enumerator, vint _count, vint _index=0, vint _repeatedCount=0)
					:enumerator(_enumerator)
					,count(_count)
					,index(_index)
					,repeatedCount(_repeatedCount)
				{
				}

				~Enumerator()
				{
					delete enumerator;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(enumerator->Clone(), count, index, repeatedCount);
				}

				const T& Current()const
				{
					return enumerator->Current();
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					if(repeatedCount>=count)
					{
						return false;
					}
					else if(enumerator->Next())
					{
						index++;
						return true;
					}
					else
					{
						repeatedCount++;
						if(repeatedCount<count)
						{
							index++;
							enumerator->Reset();
							return enumerator->Available();
						}
						else
						{
							return false;
						}
					}
				}

				bool Available()const
				{
					return enumerator->Available() && repeatedCount<count;
				}

				void Reset()
				{
					enumerator->Reset();
					index=0;
					repeatedCount=0;
				}
			};
		protected:
			vint					count;
		public:
			RepeatEnumerable(const IEnumerable<T>& enumerable, vint _count)
				:EnumerableStore<T>(enumerable)
				,count(_count)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(CopyEnumerator(), count);
			}
		};

		class RepeatProcessor : public SequenceEnumerableProcessor<RepeatEnumerable>
		{
		protected:
			vint					count;
		public:
			RepeatProcessor(vint _count)
				:count(_count)
			{
			}

			template<typename T>
			RepeatEnumerable<T> operator()(const IEnumerable<T>& enumerable)const
			{
				return RepeatEnumerable<T>(enumerable, count);
			}
		};

		extern RepeatProcessor Repeat(vint count);

/***********************************************************************
Distinct
***********************************************************************/

		template<typename T>
		class DistinctEnumerable : public EnumerableStore<T>, public virtual IEnumerable<T>
		{
		private:
			class Enumerator : public virtual IEnumerator<T>
			{
			protected:
				IEnumerator<T>*		enumerator;
				SortedList<T>		distinct;
				T					lastValue;

				void GoNearest()
				{
					while(enumerator->Available())
					{
						const T& current=enumerator->Current();
						if(!distinct.Contains(current))
						{
							lastValue=current;
							distinct.Add(current);
							break;
						}
						enumerator->Next();
					}
				}
			public:
				Enumerator(IEnumerator<T>* _enumerator)
					:enumerator(_enumerator)
				{
					GoNearest();
				}

				Enumerator(const Enumerator& _enumerator)
				{
					enumerator=_enumerator.enumerator->Clone();
					CopyFrom(distinct.Wrap(), _enumerator.distinct.Wrap());
				}

				~Enumerator()
				{
					delete enumerator;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(*this);
				}

				const T& Current()const
				{
					return lastValue;
				}

				vint Index()const
				{
					return distinct.Count()-1;
				}

				bool Next()
				{
					enumerator->Next();
					GoNearest();
					return Available();
				}

				bool Available()const
				{
					return enumerator->Available();
				}

				void Reset()
				{
					enumerator->Reset();
					distinct.Clear();
					GoNearest();
				}
			};
		public:
			DistinctEnumerable(const IEnumerable<T>& enumerable)
				:EnumerableStore<T>(enumerable)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(CopyEnumerator());
			}
		};

		class DistinctProcessor : public SequenceEnumerableProcessor<DistinctEnumerable>
		{
		public:
			DistinctProcessor()
			{
			}

			template<typename T>
			DistinctEnumerable<T> operator()(const IEnumerable<T>& enumerable)const
			{
				return DistinctEnumerable<T>(enumerable);
			}
		};

		extern DistinctProcessor Distinct();

/***********************************************************************
Reverse
***********************************************************************/

		template<typename T>
		class ReverseEnumerable : public Object, public virtual IEnumerable<T>
		{
		private:
			class Enumerator : public virtual IEnumerator<T>
			{
			protected:
				List<T>					cache;
				vint						index;
			public:
				Enumerator(const IEnumerable<T>& enumerable)
					:index(0)
				{
					CopyFrom(cache.Wrap(), enumerable);
				}

				Enumerator(const Enumerator& _enumerator)
				{
					CopyFrom(cache.Wrap(), _enumerator.cache.Wrap());
					index=_enumerator.index;
				}

				~Enumerator()
				{
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(*this);
				}

				const T& Current()const
				{
					return cache.Get(cache.Count()-1-index);
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					return Available();
				}

				bool Available()const
				{
					return index<cache.Count();
				}

				void Reset()
				{
					index=0;
				}
			};
		protected:
			const IEnumerable<T>&		enumerable;
		public:
			ReverseEnumerable(const IEnumerable<T>& _enumerable)
				:enumerable(_enumerable)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(enumerable);
			}
		};

		class ReverseProcessor : public SequenceEnumerableProcessor<ReverseEnumerable>
		{
		public:
			ReverseProcessor()
			{
			}

			template<typename T>
			ReverseEnumerable<T> operator()(const IEnumerable<T>& enumerable)const
			{
				return ReverseEnumerable<T>(enumerable);
			}
		};

		extern ReverseProcessor Reverse();

/***********************************************************************
FromIterator
***********************************************************************/

		template<typename T, typename I>
		class FromIteratorEnumerable : public Object, public IEnumerable<T>
		{
			friend class Enumerable<T>;
		private:
			class Enumerator : public Object, public IEnumerator<T>
			{
			private:
				I				begin;
				I				end;
				I				current;
				vint			index;

			public:
				Enumerator(I _begin, I _end, I _current, vint _index)
					:begin(_begin)
					,end(_end)
					,current(_current)
					,index(_index)
				{
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(begin, end, current, index);
				}

				const T& Current()const
				{
					return *current;
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					if(current==end)
					{
						return false;
					}
					current++;
					if(current==end)
					{
						return false;
					}
					else
					{
						index++;
						return true;
					}
				}

				bool Available()const
				{
					return current!=end;
				}

				void Reset()
				{
					current=begin;
					index=0;
				}
			};
		private:
			I					begin;
			I					end;
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(begin, end, begin, 0);
			}

			FromIteratorEnumerable(I _begin, I _end)
				:begin(_begin)
				,end(_end)
			{
			}
		};

		template<typename T>
		class FromIterator
		{
		public:
			template<typename I>
			static FromIteratorEnumerable<T, I> Wrap(I begin, I end)
			{
				return FromIteratorEnumerable<T, I>(begin, end);
			}
		};

		template<typename T>
		FromIteratorEnumerable<T, T*> FromPointer(T* begin, T* end)
		{
			return FromIteratorEnumerable<T, T*>(begin, end);
		}

		template<typename T, int size>
		FromIteratorEnumerable<T, T*> FromArray(T (&items)[size])
		{
			return FromIteratorEnumerable<T, T*>(&items[0], &items[size]);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSET.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSET
#define VCZH_COLLECTIONS_OPERATIONSET


namespace vl
{
	namespace collections
	{

/***********************************************************************
Intersect/Except
***********************************************************************/

		template<typename T, bool Intersect>
		class IntersectExceptEnumerable : public EnumerableStore<T>, public virtual IEnumerable<T>
		{
		protected:
			class Enumerator : public virtual IEnumerator<T>
			{
			protected:
				IEnumerator<T>*			enumerator;
				SortedList<T>			reference;
				vint						index;

				void GoNearest()
				{
					while(enumerator->Available())
					{
						if(reference.Contains(enumerator->Current())==Intersect)
						{
							break;
						}
						else
						{
							enumerator->Next();
						}
					}
				}
			public:
				Enumerator(IEnumerator<T>* _enumerator, const IEnumerable<T>& _reference)
					:enumerator(_enumerator)
					,index(0)
				{
					CopyFrom(reference.Wrap(), _reference);
					GoNearest();
				}

				Enumerator(const Enumerator& _enumerator)
				{
					enumerator=_enumerator.enumerator->Clone();
					CopyFrom(reference.Wrap(), _enumerator.reference.Wrap());
					index=_enumerator.index;
				}

				~Enumerator()
				{
					delete enumerator;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(*this);
				}

				const T& Current()const
				{
					return enumerator->Current();
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					enumerator->Next();
					GoNearest();
					return Available();
				}

				bool Available()const
				{
					return enumerator->Available();
				}

				void Reset()
				{
					enumerator->Reset();
					index=0;
					GoNearest();
				}
			};
		protected:
			const IEnumerable<T>&				reference;
		public:
			IntersectExceptEnumerable(const IEnumerable<T>& enumerable, const IEnumerable<T>& _reference)
				:EnumerableStore<T>(enumerable)
				,reference(_reference)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(CopyEnumerator(), reference);
			}
		};

		template<typename T, bool Intersect>
		class IntersectExceptProcessor : public EnumerableProcessor<T, IntersectExceptEnumerable<T, Intersect>>
		{
		protected:
			const IEnumerable<T>&				second;
		public:
			IntersectExceptProcessor(const IEnumerable<T>& _second)
				:second(_second)
			{
			}

			IntersectExceptEnumerable<T, Intersect> operator()(const IEnumerable<T>& first)const
			{
				return IntersectExceptEnumerable<T, Intersect>(first, second);
			}
		};

		template<typename T>
		IntersectExceptProcessor<T, true> Intersect(const IEnumerable<T>& second)
		{
			return IntersectExceptProcessor<T, true>(second);
		}

		template<typename T>
		IntersectExceptProcessor<T, false> Except(const IEnumerable<T>& second)
		{
			return IntersectExceptProcessor<T, false>(second);
		}

/***********************************************************************
Union
***********************************************************************/

		template<typename T>
		class UnionProcessor : public EnumerableProcessor<T, DistinctEnumerable<T>>
		{
		protected:
			const IEnumerable<T>&				second;
		public:
			UnionProcessor(const IEnumerable<T>& _second)
				:second(_second)
			{
			}

			DistinctEnumerable<T> operator()(const IEnumerable<T>& first)const
			{
				return first>>Concat(second)>>Distinct();
			}
		};

		template<typename T>
		UnionProcessor<T> Union(const IEnumerable<T>& second)
		{
			return UnionProcessor<T>(second);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONPAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONPAIR
#define VCZH_COLLECTIONS_OPERATIONPAIR


namespace vl
{
	namespace collections
	{

/***********************************************************************
Pairwise
***********************************************************************/

		template<typename S, typename T>
		class PairwiseEnumerable : public EnumerableStore<S, 1>, public EnumerableStore<T, 2>, public virtual IEnumerable<Pair<S, T>>
		{
		protected:
			class Enumerator : public virtual IEnumerator<Pair<S, T>>
			{
			protected:
				IEnumerator<S>*					enumerator1;
				IEnumerator<T>*					enumerator2;
				Pair<S, T>						current;
			public:
				Enumerator(IEnumerator<S>* _enumerator1, IEnumerator<T>* _enumerator2, vint _index=0, bool _turned=false)
					:enumerator1(_enumerator1)
					,enumerator2(_enumerator2)
				{
					if(Available())
					{
						current=Pair<S, T>(enumerator1->Current(), enumerator2->Current());
					}
				}

				~Enumerator()
				{
					delete enumerator1;
					delete enumerator2;
				}

				IEnumerator<Pair<S, T>>* Clone()const
				{
					return new Enumerator(enumerator1->Clone(), enumerator2->Clone());
				}

				const Pair<S, T>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					return enumerator1->Index();
				}

				bool Next()
				{
					if(enumerator1->Next() && enumerator2->Next())
					{
						current=Pair<S, T>(enumerator1->Current(), enumerator2->Current());
						return true;
					}
					else
					{
						return false;
					}
				}

				bool Available()const
				{
					return enumerator1->Available() && enumerator2->Available();
				}

				void Reset()
				{
					enumerator1->Reset();
					enumerator2->Reset();
					if(Available())
					{
						current=Pair<S, T>(enumerator1->Current(), enumerator2->Current());
					}
				}
			};
		public:
			PairwiseEnumerable(const IEnumerable<S>& enumerable1, const IEnumerable<T>& enumerable2)
				:EnumerableStore<S, 1>(enumerable1)
				,EnumerableStore<T, 2>(enumerable2)
			{
			}

			IEnumerator<Pair<S, T>>* CreateEnumerator()const
			{
				return new Enumerator(EnumerableStore<S, 1>::CopyEnumerator(), EnumerableStore<T, 2>::CopyEnumerator());
			}
		};

		template<typename T>
		class PairwiseProcessor : public FreeEnumerableProcessor
		{
		protected:
			const IEnumerable<T>&				second;
		public:
			template<typename S>
			struct ResultTypeRetriver
			{
				typedef PairwiseEnumerable<S, T> ResultType;
			};

			PairwiseProcessor(const IEnumerable<T>& _second)
				:second(_second)
			{
			}

			template<typename S>
			PairwiseEnumerable<S, T> operator()(const IEnumerable<S>& first)const
			{
				return PairwiseEnumerable<S, T>(first, second);
			}
		};

		template<typename T>
		PairwiseProcessor<T> Pairwise(const IEnumerable<T>& second)
		{
			return PairwiseProcessor<T>(second);
		}
	}
}

#endif

/***********************************************************************
STRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::String

Classes:
	AString										：Mbcs字符串
	WString										：Utf-16字符串
***********************************************************************/

#ifndef VCZH_STRING
#define VCZH_STRING


namespace vl
{
	template<typename T>
	class ObjectString : public Object
	{
	private:
		static const T	zero=0;

		mutable T*					buffer;
		mutable vint*				reference;
		mutable vint				start;
		mutable vint				length;
		mutable vint				realLength;

		static vint CalculateLength(const T* buffer)
		{
			vint result=0;
			while(*buffer++)result++;
			return result;
		}

		static vint Compare(const T* bufA, const ObjectString<T>& strB)
		{
			const T* bufB=strB.buffer+strB.start;
			const T* bufAOld=bufA;
			vint length=strB.length;
			while(length-- && *bufA)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return CalculateLength(bufAOld)-strB.length;
		}

	public:

		static vint Compare(const ObjectString<T>& strA, const ObjectString<T>& strB)
		{
			const T* bufA=strA.buffer+strA.start;
			const T* bufB=strB.buffer+strB.start;
			vint length=strA.length<strB.length?strA.length:strB.length;
			while(length--)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return strA.length-strB.length;
		}

	private:

		void Inc()const
		{
			if(reference)
			{
				(*reference)++;
			}
		}

		void Dec()const
		{
			if(reference)
			{
				if(--(*reference)==0)
				{
					delete[] buffer;
					delete reference;
				}
			}
		}

		ObjectString(const ObjectString<T>& string, vint _start, vint _length)
		{
			if(_length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=string.buffer;
				reference=string.reference;
				start=string.start+_start;
				length=_length;
				realLength=string.realLength;
				Inc();
			}
		}

		ObjectString(const ObjectString<T>& dest, const ObjectString<T>& source, vint index, vint count)
		{
			if(index==0 && count==dest.length && source.length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				reference=new vint(1);
				start=0;
				length=dest.length-count+source.length;
				realLength=length;
				buffer=new T[length+1];
				memcpy(buffer, dest.buffer+dest.start, sizeof(T)*index);
				memcpy(buffer+index, source.buffer+source.start, sizeof(T)*source.length);
				memcpy(buffer+index+source.length, (dest.buffer+dest.start+index+count), sizeof(T)*(dest.length-index-count));
				buffer[length]=0;
			}
		}
	public:
		static ObjectString<T>	Empty;

		ObjectString()
		{
			buffer=(T*)&zero;
			reference=0;
			start=0;
			length=0;
			realLength=0;
		}

		ObjectString(const T& _char)
		{
			reference=new vint(1);
			start=0;
			length=1;
			buffer=new T[2];
			buffer[0]=_char;
			buffer[1]=0;
			realLength=length;
		}

		ObjectString(const T* _buffer, vint _length)
		{
			if(_length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=new T[_length+1];
				memcpy(buffer, _buffer, _length*sizeof(T));
				buffer[_length]=0;
				reference=new vint(1);
				start=0;
				length=_length;
				realLength=_length;
			}
		}

		ObjectString(const T* _buffer, bool copy = true)
		{
			CHECK_ERROR(_buffer!=0, L"ObjectString<T>::ObjectString(const T*, bool)#不能用空指针构造字符串。");
			if(copy)
			{
				reference=new vint(1);
				start=0;
				length=CalculateLength(_buffer);
				buffer=new T[length+1];
				memcpy(buffer, _buffer, sizeof(T)*(length+1));
				realLength=length;
			}
			else
			{
				buffer=(T*)_buffer;
				reference=0;
				start=0;
				length=CalculateLength(_buffer);
				realLength=length;
			}
		}

		ObjectString(const ObjectString<T>& string)
		{
			buffer=string.buffer;
			reference=string.reference;
			start=string.start;
			length=string.length;
			realLength=string.realLength;
			Inc();
		}

		~ObjectString()
		{
			Dec();
		}

		const T* Buffer()const
		{
			if(start+length!=realLength)
			{
				T* newBuffer=new T[length+1];
				memcpy(newBuffer, buffer+start, sizeof(T)*length);
				newBuffer[length]=0;
				Dec();
				buffer=newBuffer;
				reference=new vint(1);
				start=0;
				realLength=length;
			}
			return buffer+start;
		}

		ObjectString<T>& operator=(const ObjectString<T>& string)
		{
			if(this!=&string)
			{
				Dec();
				buffer=string.buffer;
				reference=string.reference;
				start=string.start;
				length=string.length;
				realLength=string.realLength;
				Inc();
			}
			return *this;
		}

		ObjectString<T>& operator+=(const ObjectString<T>& string)
		{
			return *this=*this+string;
		}

		ObjectString<T> operator+(const ObjectString<T>& string)const
		{
			return ObjectString<T>(*this, string, length, 0);
		}

		bool operator==(const ObjectString<T>& string)const
		{
			return Compare(*this, string)==0;
		}

		bool operator!=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)!=0;
		}

		bool operator>(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>0;
		}

		bool operator>=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>=0;
		}

		bool operator<(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<0;
		}

		bool operator<=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<=0;
		}

		bool operator==(const T* buffer)const
		{
			return Compare(buffer, *this)==0;
		}

		bool operator!=(const T* buffer)const
		{
			return Compare(buffer, *this)!=0;
		}

		bool operator>(const T* buffer)const
		{
			return Compare(buffer, *this)<0;
		}

		bool operator>=(const T* buffer)const
		{
			return Compare(buffer, *this)<=0;
		}

		bool operator<(const T* buffer)const
		{
			return Compare(buffer, *this)>0;
		}

		bool operator<=(const T* buffer)const
		{
			return Compare(buffer, *this)>=0;
		}

		T operator[](vint index)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString:<T>:operator[](vint)#参数index越界。");
			return buffer[start+index];
		}

		vint Length()const
		{
			return length;
		}

		vint IndexOf(T c)const
		{
			const T* reading=buffer+start;
			for(vint i=0;i<length;i++)
			{
				if(reading[i]==c)
					return i;
			}
			return -1;
		}

		ObjectString<T> Left(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Left(vint)#参数count越界。");
			return ObjectString<T>(*this, 0, count);
		}

		ObjectString<T> Right(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Right(vint)#参数count越界。");
			return ObjectString<T>(*this, length-count, count);
		}

		ObjectString<T> Sub(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Sub(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Sub(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, index, count);
		}

		ObjectString<T> Remove(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Remove(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Remove(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, ObjectString<T>(), index, count);
		}

		ObjectString<T> Insert(vint index, const ObjectString<T>& string)const
		{
			CHECK_ERROR(index>=0 && index<=length, L"ObjectString<T>::Insert(vint)#参数count越界。");
			return ObjectString<T>(*this, string, index, 0);
		}

		friend bool operator<(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<0;
		}

		friend bool operator<=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<=0;
		}

		friend bool operator>(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>0;
		}

		friend bool operator>=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>=0;
		}

		friend bool operator==(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)==0;
		}

		friend bool operator!=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)!=0;
		}

		friend ObjectString<T> operator+(const T* left, const ObjectString<T>& right)
		{
			return WString(left, false)+right;
		}
	};

	template<typename T>
	ObjectString<T> ObjectString<T>::Empty=ObjectString<T>();

	typedef ObjectString<char>		AString;
	typedef ObjectString<wchar_t>	WString;

	extern vint					atoi(const AString& string);
	extern vint					wtoi(const WString& string);
	extern __int64				atoi64(const AString& string);
	extern __int64				wtoi64(const WString& string);
	extern vuint			atou(const AString& string);
	extern vuint			wtou(const WString& string);
	extern unsigned __int64		atou64(const AString& string);
	extern unsigned __int64		wtou64(const WString& string);
	extern double				atof(const AString& string);
	extern double				wtof(const WString& string);
	extern AString				itoa(vint number);
	extern WString				itow(vint number);
	extern AString				i64toa(__int64 number);
	extern WString				i64tow(__int64 number);
	extern AString				utoa(vuint number);
	extern WString				utow(vuint number);
	extern AString				u64toa(unsigned __int64 number);
	extern WString				u64tow(unsigned __int64 number);
	extern AString				ftoa(double number);
	extern WString				ftow(double number);
	extern vint					_wtoa(const wchar_t* w, char* a, vint chars);
	extern AString				wtoa(const WString& string);
	extern vint					_atow(const char* a, wchar_t* w, vint chars);
	extern WString				atow(const AString& string);
	extern AString				alower(const AString& string);
	extern WString				wlower(const WString& string);
	extern AString				aupper(const AString& string);
	extern WString				wupper(const WString& string);
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSTRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSTRING
#define VCZH_COLLECTIONS_OPERATIONSTRING


namespace vl
{
	namespace collections
	{
		template<typename T, typename K>
		void CopyFrom(IArray<T, K>& dst, const ObjectString<T>& src, bool append=false)
		{
			vint start=0;
			if(append)
			{
				start=dst.Count();
				dst.Resize(start+src.Length());
			}
			else
			{
				dst.Resize(src.Length());
			}
			for(vint i=0;i<src.Length();i++)
			{
				dst.Set(start+i, src[i]);
			}
		}

		template<typename T, typename K>
		void CopyFrom(ICollection<T, K>& dst, const ObjectString<T>& src, bool append=false)
		{
			if(!append)
			{
				dst.Clear();
			}
			for(vint i=0;i<src.Length();i++)
			{
				dst.Add(src[i]);
			}
		}

		template<typename T, typename K>
		void CopyFrom(ObjectString<T>& dst, const IReadonlyList<T, K>& src, bool append=false)
		{
			T* buffer=new T[src.Count()+1];
			try
			{
				for(vint i=0;i<src.Count();i++)
				{
					buffer[i]=src[i];
				}
				buffer[src.Count()]=0;
				if(append)
				{
					dst+=buffer;
				}
				else
				{
					dst=buffer;
				}
				delete[] buffer;
			}
			catch(...)
			{
				delete[] buffer;
				throw;
			}
		}

		template<typename T>
		void CopyFrom(ObjectString<T>& dst, const IEnumerable<T>& src, bool append=false)
		{
			IEnumerator<T>* enumerator=src.CreateEnumerator();
			try
			{
				vint count=0;
				while(enumerator->Available())
				{
					count++;
					enumerator->Next();
				}
				enumerator->Reset();
				T* buffer=new T[count+1];
				try
				{
					while(enumerator->Available())
					{
						buffer[enumerator->Index()]=enumerator->Current();
						enumerator->Next();
					}
					buffer[count]=0;
					if(append)
					{
						dst+=buffer;
					}
					else
					{
						dst=buffer;
					}
					delete[] buffer;
				}
				catch(...)
				{
					delete[] buffer;
					throw;
				}
				delete enumerator;
			}
			catch(...)
			{
				delete enumerator;
				throw;
			}
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

Functions:
	CopyFrom(TargetContainer, SourceContainer)
	[T] >>	Select(T->K) => [K]
	[T] >>	Where(T->bool) => [T]
	[T] >>	OrderBy(T->T->int) => [T]
	[T] >>	Aggregate(T->T->T) => T
	[T] >>	Aggregate(T->T->T, T) => T
	[T] >>	All(T->bool) => bool
	[T] >>	Any(T->bool) => bool
	[T] >>	Max() => T
	[T] >>	Min() => T
	[T] >>	First() => T
	[T] >>	Count() => vint
	[T] >>	IsEmpty() => bool
	[T] >>	Concat([T]) => [T]
	[T] >>	Repeat(vint) => [T]
	[T] >>	Take(vint) => [T]
	[T] >>	Skip(vint) => [T]
	[T] >>	Distinct() => [T]
	[T] >>	Reverse() => [T]
			FromIterator<T>::Wrap(begin, end) => [T]
			FromPointer<T>(begin, end) => [T]
			FromArray<T[]>(array) => [T]
	[T] >>	Intersect([T]) => [T]
	[T] >>	Union([T]) => [T]
	[T] >>	Except([T]) => [T]
	[T] >>	Pairwise([K]) => [(T,K)]

FOREACH(X, a, XList.Wrap())
FOREACH_INDEXER(X, a, index, XList.Wrap())
***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATION
#define VCZH_COLLECTIONS_OPERATION


#endif

/***********************************************************************
CONSOLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
UI::Console

***********************************************************************/

#ifndef VCZH_CONSOLE
#define VCZH_CONSOLE


namespace vl
{
	namespace console
	{
		class Console abstract
		{
		public:
			static void Write(const WString& string);
			static void WriteLine(const WString& string);
			static WString Read();
			static void SetColor(bool red, bool green, bool blue, bool light);
			static void SetTitle(const WString& string);
		};
	}
}

#endif

/***********************************************************************
EXCEPTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Exception

Classes:
	Exception									：异常
	ArgumentException							：预料的的参数错误
***********************************************************************/

#ifndef VCZH_EXCEPTION
#define VCZH_EXCEPTION


namespace vl
{
	class Exception : public Object
	{
	protected:
		WString						message;

	public:
		Exception(const WString& _message=WString::Empty);

		const WString&				Message()const;
	};

	class ArgumentException : public Exception
	{
	protected:
		WString						function;
		WString						name;

	public:
		ArgumentException(const WString& _message=WString::Empty, const WString& _function=WString::Empty, const WString& _name=WString::Empty);

		const WString&				GetFunction()const;
		const WString&				GetName()const;
	};

	class ParsingException : public Exception
	{
	protected:
		vint							position;
		WString						expression;

	public:
		ParsingException(const WString& _message, const WString& _expression, vint _position);

		const WString&				GetExpression()const;
		vint							GetPosition()const;
	};
}

#endif

/***********************************************************************
COLLECTIONS\DICTIONARYWRAPPERS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Dictionary Wrappers

Classes:
	ReadonlyDictionaryWrapper<V,K>
	DictionaryWrapper<V,K>
	ReadonlyGroupWrapper<V,K>
	GroupWrapper<V,K>
***********************************************************************/

#ifndef VCZH_COLLECTIONS_DICTIONARYWRAPPERS
#define VCZH_COLLECTIONS_DICTIONARYWRAPPERS


namespace vl
{
	namespace collections
	{

/***********************************************************************
代理
***********************************************************************/

		template<typename C, typename KT, typename VT, typename KK, typename VK>
		class DictionaryWrapper;
		
		template<typename C, typename KT, typename VT, typename KK, typename VK>
		class GroupWrapper;

		template<typename C, typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class ReadonlyDictionaryWrapper : public Object, public virtual IReadonlyDictionary<KT, VT, KK, VK>
		{
			friend class DictionaryWrapper<C, KT, VT, KK, VK>;
		private:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const IReadonlyDictionary<KT, VT, KK, VK>*	container;
				vint											index;
				Pair<KT, VT>								current;

				void UpdateCurrent()
				{
					if(index<container->Count())
					{
						current.key=container->Keys()[index];
						current.value=container->Values()[index];
					}
				}
			public:
				Enumerator(const IReadonlyDictionary* _container, vint _index=0)
				{
					container=_container;
					index=_index;
					UpdateCurrent();
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, index);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					UpdateCurrent();
					return Available();
				}

				bool Available()const
				{
					return index>=0 && index<container->Count();
				}

				void Reset()
				{
					index=0;
					UpdateCurrent();
				}
			};

			C*						container;
		public:
			ReadonlyDictionaryWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return container->Keys();
			}

			const IReadonlyList<VT, VK>& Values()const
			{
				return container->Values();
			}

			vint Count()const
			{
				return container->Count();
			}

			const VT& Get(const KK& key)const
			{
				return container->Get(key);
			}

			const VT& operator[](const KK& key)const
			{
				return container->operator[](key);
			}
		};

		template<typename C, typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class DictionaryWrapper : public Object, public virtual IDictionary<KT, VT, KK, VK>
		{
		private:
			C*						container;
		public:
			DictionaryWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new ReadonlyDictionaryWrapper<C, KT, VT, KK, VK>::Enumerator(this);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return container->Keys();
			}

			const IReadonlyList<VT, VK>& Values()const
			{
				return container->Values();
			}

			vint Count()const
			{
				return container->Count();
			}

			const VT& Get(const KK& key)const
			{
				return container->Get(key);
			}

			const VT& operator[](const KK& key)const
			{
				return container->operator[](key);
			}

			bool Set(const KK& key, const VT& value)
			{
				return container->Set(key, value);
			}

			bool Add(const KT& key, const VT& value)
			{
				return container->Add(key, value);
			}

			bool Remove(const KK& key)
			{
				return container->Remove(key);
			}

			bool Clear()
			{
				return container->Clear();
			}
		};

		template<typename C, typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class ReadonlyGroupWrapper : public Object, public virtual IReadonlyGroup<KT, VT, KK, VK>
		{
			friend class GroupWrapper<C, KT, VT, KK, VK>;
		private:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const IReadonlyGroup<KT, VT, KK, VK>*		container;
				vint											keyIndex;
				vint											valueIndex;
				Pair<KT, VT>								current;

				void UpdateCurrent()
				{
					if(keyIndex<container->Count())
					{
						const IReadonlyList<VT, VK>& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							current.key=container->Keys()[keyIndex];
							current.value=values[valueIndex];
						}
					}
				}
			public:
				Enumerator(const IReadonlyGroup* _container, vint _keyIndex=0, vint _valueIndex=0)
				{
					container=_container;
					keyIndex=_keyIndex;
					valueIndex=_valueIndex;
					UpdateCurrent();
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, keyIndex, valueIndex);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					if(Available())
					{
						vint index=0;
						for(vint i=0;i<keyIndex;i++)
						{
							index+=container->GetByIndex(i).Count();
						}
						return index+valueIndex;
					}
					else
					{
						return -1;
					}
				}

				bool Next()
				{
					if(keyIndex<container->Count())
					{
						const IReadonlyList<VT, VK>& values=container->GetByIndex(keyIndex);
						valueIndex++;
						if(valueIndex<values.Count())
						{
							UpdateCurrent();
							return true;
						}
						else
						{
							keyIndex++;
							valueIndex=0;
							UpdateCurrent();
							return keyIndex<container->Count();
						}
					}
					else
					{
						return false;
					}
				}

				bool Available()const
				{
					if(keyIndex<container->Count())
					{
						const IReadonlyList<VT, VK>& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							return true;
						}
					}
					return false;
				}

				void Reset()
				{
					keyIndex=0;
					valueIndex=0;
					UpdateCurrent();
				}
			};

			C*									container;
		public:
			ReadonlyGroupWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return container->Keys();
			}

			vint Count()const
			{
				return container->Count();
			}

			const IReadonlyList<VT, VK>& Get(const KK& key)const
			{
				return container->Get(key);
			}

			const IReadonlyList<VT, VK>& GetByIndex(vint index)const
			{
				return container->GetByIndex(index);
			}

			const IReadonlyList<VT, VK>& operator[](const KK& key)const
			{
				return container->operator[](key);
			}

			bool Contains(const KK& key)const
			{
				return container->Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				return container->Contains(key, value);
			}
		};

		template<typename C, typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class GroupWrapper : public Object, public virtual IGroup<KT, VT, KK, VK>
		{
		private:
			C*									container;
		public:
			GroupWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new ReadonlyGroupWrapper<C, KT, VT, KK, VK>::Enumerator(this);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return container->Keys();
			}

			vint Count()const
			{
				return container->Count();
			}

			const IReadonlyList<VT, VK>& Get(const KK& key)const
			{
				return container->Get(key);
			}

			const IReadonlyList<VT, VK>& GetByIndex(vint index)const
			{
				return container->GetByIndex(index);
			}

			const IReadonlyList<VT, VK>& operator[](const KK& key)const
			{
				return container->operator[](key);
			}

			bool Contains(const KK& key)const
			{
				return container->Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				return container->Contains(key, value);
			}

			bool Add(const KT& key, const VT& value)
			{
				return container->Add(key, value);
			}

			bool Remove(const KK& key)
			{
				return container->Remove(key);
			}

			bool Remove(const KK& key, const VK& value)
			{
				return container->Remove(key, value);
			}

			bool Clear()
			{
				return container->Clear();
			}
		};

/***********************************************************************
类型转换代理
***********************************************************************/
	}
}

#endif

/***********************************************************************
COLLECTIONS\DICTIONARY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Dictionary

Classes:
	Dictionary<KT, VT, KK, VK>					：映射
	Group<KT, VT, KK, VK>						：多重映射
***********************************************************************/

#ifndef VCZH_COLLECTIONS_DICTIONARY
#define VCZH_COLLECTIONS_DICTIONARY


namespace vl
{
	namespace collections
	{
		template<
			typename KT,
			typename VT,
			typename ValueContainer=List<VT, typename KeyType<VT>::Type>,
			typename KK=typename KeyType<KT>::Type, 
			typename VK=typename KeyType<VT>::Type
		>
		class Dictionary : public Object, private NotCopyable
		{
		protected:
			SortedList<KT, KK>					keys;
			ValueContainer						values;
			mutable DictionaryWrapper<Dictionary<KT, VT, ValueContainer, KK, VK>, KT, VT, KK, VK>	wrapper;
		public:
			Dictionary()
			{
				wrapper.SetContainer(this);
			}

			void SetLessMemoryMode(bool mode)
			{
				keys.SetLessMemoryMode(mode);
				values.SetLessMemoryMode(mode);
			}

			template<typename T>
			void CopyKeysToCollection(T& dst, bool append=false)const
			{
				CopyToCollection(dst, keys, append);
			}

			template<typename T>
			void CopyKeysToArray(T& dst, bool append=false)const
			{
				CopyToArray(dst, keys, append);
			}

			template<typename T>
			void CopyValuesToCollection(T& dst, bool append=false)const
			{
				CopyToCollection(dst, values, append);
			}

			template<typename T>
			void CopyValuesToArray(T& dst, bool append=false)const
			{
				CopyToArray(dst, values, append);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return keys.Wrap();
			}

			const IReadonlyList<VT, VK>& Values()const
			{
				return values.Wrap();
			}

			vint Count()const
			{
				return keys.Count();
			}

			const VT& Get(const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			const VT& operator[](const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			bool Set(const KK& key, const VT& value)
			{
				vint index=keys.IndexOf(key);
				if(index==-1)
				{
					index=keys.Add(key);
					values.Insert(index, value);
				}
				else
				{
					values[index]=value;
				}
				return true;
			}

			bool Add(const KT& key, const VT& value)
			{
				CHECK_ERROR(!keys.Contains(key), L"Dictionary<KT, KK, ValueContainer, VT, VK>::Add(const KT&, const VT&)#key已存在。");
				vint index=keys.Add(key);
				values.Insert(index, value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					values.RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				keys.Clear();
				values.Clear();
				return true;
			}

			IDictionary<KT, VT, KK, VK>& Wrap()const
			{
				return wrapper;
			}
		};

		template<
			typename KT,
			typename VT,
			typename ValueContainer=List<VT, typename KeyType<VT>::Type>,
			typename KK=typename KeyType<KT>::Type,
			typename VK=typename KeyType<VT>::Type
		>
		class Group : public Object, private NotCopyable
		{
		protected:
			SortedList<KT, KK>				keys;
			List<ValueContainer*>			values;
			mutable GroupWrapper<Group<KT, VT, ValueContainer, KK, VK>, KT, VT, KK, VK>	wrapper;
		public:
			Group()
			{
				wrapper.SetContainer(this);
			}

			~Group()
			{
				Clear();
			}

			template<typename T>
			void CopyKeysToCollection(T& dst, bool append=false)const
			{
				CopyToCollection(dst, keys, append);
			}

			template<typename T>
			void CopyKeysToArray(T& dst, bool append=false)const
			{
				CopyToArray(dst, keys, append);
			}

			template<typename T>
			void CopyValuesToCollection(vint index, T& dst, bool append=false)const
			{
				CopyToCollection(dst, *(values.Get(index)), append);
			}

			template<typename T>
			void CopyValuesToArray(vint index, T& dst, bool append=false)const
			{
				CopyToArray(dst, *(values.Get(index)), append);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return keys.Wrap();
			}

			vint Count()const
			{
				return keys.Count();
			}

			const IReadonlyList<VT, VK>& Get(const KK& key)const
			{
				return values.Get(keys.IndexOf(key))->Wrap();
			}

			const IReadonlyList<VT, VK>& GetByIndex(vint index)const
			{
				return values.Get(index)->Wrap();
			}

			const IReadonlyList<VT, VK>& operator[](const KK& key)const
			{
				return values.Get(keys.IndexOf(key))->Wrap();
			}

			bool Contains(const KK& key)const
			{
				return keys.Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					return values.Get(index)->Contains(value);
				}
				else
				{
					return false;
				}
			}

			bool Add(const KT& key, const VT& value)
			{
				ValueContainer* target=0;
				vint index=keys.IndexOf(key);
				if(index==-1)
				{
					target=new ValueContainer;
					values.Insert(keys.Add(key), target);
				}
				else
				{
					target=values[index];
				}
				target->Add(value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					List<VT, VK>* target=values[index];
					values.RemoveAt(index);
					delete target;
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Remove(const KK& key, const VK& value)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					List<VT, VK>* target=values[index];
					target->Remove(value);
					if(target->Count()==0)
					{
						keys.RemoveAt(index);
						values.RemoveAt(index);
						delete target;
					}
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				for(vint i=0;i<values.Count();i++)
				{
					delete values[i];
				}
				keys.Clear();
				values.Clear();
				return true;
			}

			IGroup<KT, VT, KK, VK>& Wrap()const
			{
				return wrapper;
			}
		};
	}
}

#endif

/***********************************************************************
HTTPUTILITY.H
***********************************************************************/
#ifndef VCZH_HTTPUTILITY
#define VCZH_HTTPUTILITY


namespace vl
{

/***********************************************************************
HTTP Utility
***********************************************************************/

	class HttpRequest
	{
		typedef collections::Array<char>					BodyBuffer;
		typedef collections::List<WString>					StringList;
		typedef collections::Dictionary<WString, WString>	HeaderMap;
	public:
		WString				server;
		vint				port;
		WString				query;
		bool				secure;
		WString				username;
		WString				password;
		WString				method;
		WString				cookie;
		BodyBuffer			body;
		WString				contentType;
		StringList			acceptTypes;
		HeaderMap			extraHeaders;

		HttpRequest();
		bool				SetHost(const WString& inputQuery);
		void				SetBodyUtf8(const WString& bodyString);
	};

	class HttpResponse
	{
		typedef collections::Array<char>		BodyBuffer;
	public:
		vint				statusCode;
		BodyBuffer			body;
		WString				cookie;

		HttpResponse();
		WString				GetBodyUtf8();
	};

	extern bool				HttpQuery(const HttpRequest& request, HttpResponse& response);
	extern WString			UrlEncodeQuery(const WString& query);
}

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

XML Representation for Code Generation:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTOR
#define VCZH_REFLECTION_GUITYPEDESCRIPTOR


namespace vl
{
	namespace reflection
	{

/***********************************************************************
Attribute
***********************************************************************/

		namespace description
		{
			class ITypeDescriptor;
		}

		class DescriptableObject
		{
			template<typename T>
			friend class Description;

			friend class DescriptableValue;
		protected:
			size_t									objectSize;
			description::ITypeDescriptor**			typeDescriptor;
		public:
			DescriptableObject();
			virtual ~DescriptableObject();

			description::ITypeDescriptor*			GetTypeDescriptor();
		};

		class IDescriptable : public virtual Interface, public virtual DescriptableObject
		{
		public:
			~IDescriptable(){}
		};
		
		template<typename T>
		class Description : public virtual DescriptableObject
		{
		protected:
			static description::ITypeDescriptor*		associatedTypeDescriptor;
		public:
			Description()
			{
				if(objectSize<sizeof(T))
				{
					objectSize=sizeof(T);
					typeDescriptor=&associatedTypeDescriptor;
				}
			}

			static description::ITypeDescriptor* GetAssociatedTypeDescriptor()
			{
				return associatedTypeDescriptor;
			}

			static void SetAssociatedTypeDescroptor(description::ITypeDescriptor* typeDescroptor)
			{
				if(!associatedTypeDescriptor)
				{
					associatedTypeDescriptor=typeDescroptor;
				}
			}
		};

		template<typename T>
		description::ITypeDescriptor* Description<T>::associatedTypeDescriptor=0;

/***********************************************************************
Value
***********************************************************************/

		namespace description
		{
			class Value : public Object
			{
			public:
				enum ValueType
				{
					Null,
					DescriptableObjectRef,
					DescriptableObjectPtr,
					Text,
				};
			protected:
				ValueType						valueType;
				DescriptableObject*				descriptableObjectRef;
				Ptr<DescriptableObject>			descriptableObjectPtr;
				WString							text;
				ITypeDescriptor*				typeDescriptor;
			public:
				Value();
				Value(DescriptableObject* value);
				Value(Ptr<DescriptableObject> value);
				Value(const WString& value, ITypeDescriptor* associatedTypeDescriptor);
				Value(const Value& value);

				Value&							operator=(const Value& value);

				ValueType						GetValueType()const;
				DescriptableObject*				GetDescriptableObjectRef()const;
				Ptr<DescriptableObject>			GetDescriptableObjectPtr()const;
				const WString&					GetText()const;
				ITypeDescriptor*				GetTypeDescriptor()const;
			};

			class IValueSerializer : public Interface
			{
			public:
				virtual WString					GetName()=0;
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual bool					Validate(const WString& text)=0;
				virtual bool					Parse(const WString& input, Value& output)=0;
			};

			template<typename T>
			class ITypedValueSerializer : public IValueSerializer
			{
				virtual bool					Serialize(const T& input, Value& output)=0;
				virtual bool					Deserialize(const Value& input, T& output)=0;
			};

/***********************************************************************
ITypeDescriptor (basic)
***********************************************************************/

			class IMemberInfo : public virtual Interface
			{
			public:
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual const WString&			GetName()=0;
			};

			class IValueInfo : public virtual Interface
			{
			public:
				virtual ITypeDescriptor*		GetValueTypeDescriptor()=0;
				virtual bool					CanBeNull()=0;
			};

/***********************************************************************
ITypeDescriptor (event)
***********************************************************************/

			class IEventInfo;

			class IEventHandler : public Interface
			{
			public:
				virtual IEventInfo*				GetOwnerEvent()=0;
				virtual Value					GetOwnerObject()=0;
				virtual bool					IsAttached()=0;
				virtual bool					Detach()=0;
				virtual void					Invoke(const Value& thisObject, Value& arguments)=0;
			};

			class IEventInfo : public IMemberInfo
			{
			public:
				virtual Ptr<IEventHandler>		Attach(const Value& thisObject, const Func<void(const Value&, Value&)>& handler)=0;
				virtual void					Invoke(const Value& thisObject, Value& arguments)=0;
			};

/***********************************************************************
ITypeDescriptor (property)
***********************************************************************/

			class IPropertyInfo : public IMemberInfo, public IValueInfo
			{
			public:
				virtual bool					IsReadable()=0;
				virtual bool					IsWritable()=0;
				virtual IEventInfo*				GetValueChangedEvent()=0;
				virtual Value					GetValue(const Value& thisObject)=0;
				virtual void					SetValue(const Value& thisObject, Value newValue)=0;
			};

/***********************************************************************
ITypeDescriptor (method)
***********************************************************************/

			class IMethodInfo;
			class IMethodGroupInfo;

			class IParameterInfo : public IMemberInfo, public IValueInfo
			{
			public:
				virtual IMethodInfo*			GetOwnerMethod()=0;
				virtual bool					CanOutput()=0;
			};

			class IMethodInfo : public IMemberInfo
			{
			public:
				virtual IMethodGroupInfo*		GetOwnerMethodGroup()=0;
				virtual vint					GetParameterCount()=0;
				virtual IParameterInfo*			GetParameter(vint index)=0;
				virtual IValueInfo*				GetReturn()=0;
				virtual Value					Invoke(const Value& thisObject, collections::IArray<Value>& arguments)=0;
			};

			class IMethodGroupInfo : public IMemberInfo
			{
			public:
				virtual vint					GetMethodCount()=0;
				virtual IMethodInfo*			GetMethod(vint index)=0;
			};

/***********************************************************************
ITypeDescriptor
***********************************************************************/

			class ITypeDescriptor : public Interface
			{
			public:
				virtual const WString&			GetTypeName()=0;
				virtual IValueSerializer*		GetValueSerializer()=0;
				virtual vint					GetBaseTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetBaseTypeDescriptor(vint index)=0;

				virtual vint					GetPropertyCount()=0;
				virtual IPropertyInfo*			GetProperty(vint index)=0;
				virtual bool					IsPropertyExists(const WString& name, bool inheritable)=0;
				virtual IPropertyInfo*			GetPropertyByName(const WString& name, bool inheritable)=0;

				virtual vint					GetEventCount()=0;
				virtual IEventInfo*				GetEvent(vint index)=0;
				virtual bool					IsEventExists(const WString& name, bool inheritable)=0;
				virtual IEventInfo*				GetEventByName(const WString& name, bool inheritable)=0;

				virtual vint					GetMethodGroupCount()=0;
				virtual IMethodGroupInfo*		GetMethodGroup(vint index)=0;
				virtual bool					IsMethodGroupExists(const WString& name, bool inheritable)=0;
				virtual IMethodGroupInfo*		GetMethodGroupByName(const WString& name, bool inheritable)=0;
				virtual IMethodGroupInfo*		GetConstructorGroup()=0;
			};

/***********************************************************************
ITypeManager
***********************************************************************/

			class ITypeManager;

			class ITypeLoader : public Interface
			{
			public:
				virtual void					Load(ITypeManager* manager)=0;
				virtual void					Unload(ITypeManager* manager)=0;
			};

			class ITypeManager : public Interface
			{
			public:
				virtual vint					GetValueSerializerCount()=0;
				virtual IValueSerializer*		GetValueSerializer(vint index)=0;
				virtual IValueSerializer*		GetValueSerializer(const WString& name)=0;
				virtual bool					SetValueSerializer(const WString& name, Ptr<IValueSerializer> valueSerializer)=0;
				
				virtual vint					GetTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetTypeDescriptor(vint index)=0;
				virtual ITypeDescriptor*		GetTypeDescriptor(const WString& name)=0;
				virtual bool					SetTypeDescriptor(const WString& name, Ptr<ITypeDescriptor> typeDescriptor)=0;

				virtual bool					AddTypeLoader(Ptr<ITypeLoader> typeLoader)=0;
				virtual bool					RemoveTypeLoader(Ptr<ITypeLoader> typeLoader)=0;
				virtual bool					Load()=0;
				virtual bool					Unload()=0;
				virtual bool					Reload()=0;
				virtual bool					IsLoaded()=0;
			};

			extern ITypeManager*				GetGlobalTypeManager();
			extern bool							DestroyGlobalTypeManager();
			extern IValueSerializer*			GetValueSerializer(const WString& name);
			extern ITypeDescriptor*				GetTypeDescriptor(const WString& name);

/***********************************************************************
Exceptions
***********************************************************************/

			class TypeDescriptorException : public Exception
			{
			public:
				TypeDescriptorException(const WString& message)
					:Exception(message)
				{
				}
			};

			class PropertyIsNotReadableException : public TypeDescriptorException
			{
			public:
				PropertyIsNotReadableException(IPropertyInfo* propertyInfo)
					:TypeDescriptorException(L"Cannot read value from a property \""+propertyInfo->GetName()+L"\" that is not readable in type \""+propertyInfo->GetOwnerTypeDescriptor()->GetTypeName()+L"\"/")
				{
				}
			};

			class PropertyIsNotWritableException : public TypeDescriptorException
			{
			public:
				PropertyIsNotWritableException(IPropertyInfo* propertyInfo)
					:TypeDescriptorException(L"Cannot write value to a property \""+propertyInfo->GetName()+L"\" that is not writable in type \""+propertyInfo->GetOwnerTypeDescriptor()->GetTypeName()+L"\"/")
				{
				}
			};
		}
	}
}

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTORBUILDER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

Classes:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER
#define VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER


namespace vl
{
	namespace reflection
	{
		namespace description
		{

/***********************************************************************
Exceptions
***********************************************************************/

			class TypeDescriptorBuilderException : public Exception
			{
			public:
				TypeDescriptorBuilderException(const WString& message)
					:Exception(message)
				{
				}
			};

			class PropertyAlreadyExistsException : public TypeDescriptorBuilderException
			{
			public:
				PropertyAlreadyExistsException(ITypeDescriptor* typeDescriptor, const WString& propertyName)
					:TypeDescriptorBuilderException(L"Property \""+propertyName+L"\" already exists in type \""+typeDescriptor->GetTypeName()+L"\".")
				{
				}
			};

			class EventAlreadyExistsException : public TypeDescriptorBuilderException
			{
			public:
				EventAlreadyExistsException(ITypeDescriptor* typeDescriptor, const WString& eventName)
					:TypeDescriptorBuilderException(L"Event \""+eventName+L"\" already exists in type \""+typeDescriptor->GetTypeName()+L"\".")
				{
				}
			};

			class ParameterAlreadyExistsException : public TypeDescriptorBuilderException
			{
			public:
				ParameterAlreadyExistsException(IMethodInfo* method,  const WString& parameterName)
					:TypeDescriptorBuilderException(L"Parameter \""+parameterName+L"\" already exists in method \""+method->GetName()+L"\" in type \""+method->GetOwnerTypeDescriptor()->GetTypeName()+L"\".")
				{
				}
			};

/***********************************************************************
GeneralTypeDescriptor
***********************************************************************/

			class GeneralTypeDescriptor : public Object, public ITypeDescriptor
			{
			public:
				class PropertyGroup
				{
					friend class GeneralTypeDescriptor;
				protected:
					bool														loaded;
					Func<void(PropertyGroup*)>									loaderProcedure;
					ITypeDescriptor*											ownerTypeDescriptor;
					
					WString														typeName;
					IValueSerializer*											valueSerializer;
					collections::List<ITypeDescriptor*>							baseTypeDescriptors;
					collections::Dictionary<WString, Ptr<IPropertyInfo>>		properties;
					collections::Dictionary<WString, Ptr<IEventInfo>>			events;
					collections::Dictionary<WString, Ptr<IMethodGroupInfo>>		methodGroups;
					Ptr<IMethodGroupInfo>										contructorGroup;

				public:
					PropertyGroup();
					~PropertyGroup();

					void						Prepare();

					//----------------------------------------------------

					class MethodBuilder
					{
					protected:
						PropertyGroup&			propertyGroup;
						Ptr<IMethodGroupInfo>	buildingMethodGroup;
						Ptr<IMethodInfo>		buildingMethod;
					public:
						MethodBuilder(PropertyGroup& _propertyGroup, const WString& _name);

						MethodBuilder&			Parameter(
													const WString&									_name,
													ITypeDescriptor*								_type,
													bool											_nullable,
													bool											_canOutput
													);
						MethodBuilder&			Return(
													ITypeDescriptor*								_type,
													bool											_nullable
													);
						MethodBuilder&			Invoker(
													const Func<Value(const Value&, collections::IArray<Value>&)>&	_invoker
													);
						PropertyGroup&			Done();
					};

					//----------------------------------------------------

					class EventBuilder
					{
					protected:
						PropertyGroup&			propertyGroup;
						Ptr<IEventInfo>			buildingEvent;
					public:
						EventBuilder(PropertyGroup& _propertyGroup, const WString& _name);

						EventBuilder&			Attacher(
													const Func<void(DescriptableObject*, IEventHandler*)>&	_attacher
													);
						EventBuilder&			Detacher(
													const Func<void(DescriptableObject*, IEventHandler*)>&	_detacher
													);
						EventBuilder&			Invoker(
													const Func<Value(const Value&, Value&)>&		_invoker
													);
						PropertyGroup&			Done();
					};

					//----------------------------------------------------

					PropertyGroup&				TypeName(
													const WString&									_typeName
													);
					PropertyGroup&				Property(
													const WString&									_name,
													ITypeDescriptor*								_type,
													bool											_nullable,
													const Func<Value(const Value&)>&				_getter,
													const Func<void(const Value&, const Value&)>&	_setter,
													const WString&									_valueChangedEventName
													);
					MethodBuilder				Method(
													const WString&									_name
													);
					EventBuilder				Event(
													const WString&									_name
													);
				};
			protected:
				PropertyGroup				propertyGroup;

			public:
				GeneralTypeDescriptor(const Func<void(PropertyGroup*)>& loaderProcedure);
				~GeneralTypeDescriptor();

				PropertyGroup&				Operations();

				const WString&				GetTypeName()override;
				IValueSerializer*			GetValueSerializer()override;
				vint						GetBaseTypeDescriptorCount()override;
				ITypeDescriptor*			GetBaseTypeDescriptor(vint index)override;

				vint						GetPropertyCount()override;
				IPropertyInfo*				GetProperty(vint index)override;
				bool						IsPropertyExists(const WString& name, bool inheritable)override;
				IPropertyInfo*				GetPropertyByName(const WString& name, bool inheritable)override;

				vint						GetEventCount()override;
				IEventInfo*					GetEvent(vint index)override;
				bool						IsEventExists(const WString& name, bool inheritable)override;
				IEventInfo*					GetEventByName(const WString& name, bool inheritable)override;

				vint						GetMethodGroupCount()override;
				IMethodGroupInfo*			GetMethodGroup(vint index)override;
				bool						IsMethodGroupExists(const WString& name, bool inheritable)override;
				IMethodGroupInfo*			GetMethodGroupByName(const WString& name, bool inheritable)override;
				IMethodGroupInfo*			GetConstructorGroup()override;
			};
		}
	}
}

#endif

/***********************************************************************
REGEX\REGEX.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::Regular Expression

Classes:
	RegexString						：字符串匹配结果
	RegexMatch						：匹配结果
	Regex							：正则表达式引擎
	RegexToken						：词法记号
	RegexTokens						：词法记号表
	RegexLexer						：词法分析器
***********************************************************************/

#ifndef VCZH_REGEX_REGEX
#define VCZH_REGEX_REGEX


namespace vl
{
	namespace regex_internal
	{
		class PureResult;
		class PureInterpretor;
		class RichResult;
		class RichInterpretor;
	}

	namespace regex
	{

/***********************************************************************
正则表达式引擎数据结构
***********************************************************************/

		class RegexString : public Object
		{
		protected:
			WString										value;
			vint										start;
			vint										length;

		public:
			RegexString(vint _start=0);
			RegexString(const WString& _string, vint _start, vint _length);

			vint										Start()const;
			vint										Length()const;
			const WString&								Value()const;
			bool										operator==(const RegexString& string)const;
		};

		class RegexMatch : public Object, private NotCopyable
		{
			friend class Regex;
		public:
			typedef Ptr<RegexMatch>										Ref;
			typedef collections::List<Ref>								List;
			typedef collections::IReadonlyList<RegexString>				CaptureList;
			typedef collections::IReadonlyGroup<WString, RegexString>	CaptureGroup;
		protected:
			collections::List<RegexString>				captures;
			collections::Group<WString, RegexString>	groups;
			bool										success;
			RegexString									result;

			RegexMatch(const WString& _string, regex_internal::PureResult* _result);
			RegexMatch(const WString& _string, regex_internal::RichResult* _result, regex_internal::RichInterpretor* _rich);
			RegexMatch(const RegexString& _result);
		public:
			
			bool										Success()const;
			const RegexString&							Result()const;
			const CaptureList&							Captures()const;
			const CaptureGroup&							Groups()const;
		};

/***********************************************************************
正则表达式引擎
***********************************************************************/

		class Regex : public Object, private NotCopyable
		{
		protected:
			regex_internal::PureInterpretor*			pure;
			regex_internal::RichInterpretor*			rich;

			void										Process(const WString& text, bool keepEmpty, bool keepSuccess, bool keepFail, RegexMatch::List& matches)const;
		public:
			Regex(const WString& code, bool preferPure=true);
			~Regex();

			bool										IsPureMatch()const;
			bool										IsPureTest()const;

			RegexMatch::Ref								MatchHead(const WString& text)const;
			RegexMatch::Ref								Match(const WString& text)const;
			bool										TestHead(const WString& text)const;
			bool										Test(const WString& text)const;
			void										Search(const WString& text, RegexMatch::List& matches)const;
			void										Split(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const;
			void										Cut(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const;
		};

/***********************************************************************
正则表达式词法分析器
***********************************************************************/

		class RegexToken
		{
		public:
			vint										start;
			vint										length;
			vint										token;
			const wchar_t*								reading;
			vint										codeIndex;

			vint										rowStart;
			vint										columnStart;
			vint										rowEnd;
			vint										columnEnd;

			bool										operator==(const RegexToken& _token)const;
			bool										operator==(const wchar_t* _token)const;
		};

		class RegexTokens : public Object, public collections::IEnumerable<RegexToken>
		{
			friend class RegexLexer;
		protected:
			regex_internal::PureInterpretor*			pure;
			const collections::Array<vint>&				stateTokens;
			WString										code;
			vint										codeIndex;
			
			RegexTokens(regex_internal::PureInterpretor* _pure, const collections::Array<vint>& _stateTokens, const WString& _code, vint _codeIndex);
		public:

			collections::IEnumerator<RegexToken>*		CreateEnumerator()const;
			void										ReadToEnd(collections::List<RegexToken>& tokens, bool(*discard)(vint)=0)const;
		};

		class RegexLexerWalker : public Object
		{
			friend class RegexLexer;
		protected:
			regex_internal::PureInterpretor*			pure;
			const collections::Array<vint>&				stateTokens;
			
			RegexLexerWalker(regex_internal::PureInterpretor* _pure, const collections::Array<vint>& _stateTokens);
		public:
			RegexLexerWalker(const RegexLexerWalker& walker);
			~RegexLexerWalker();

			vint										GetStartState()const;
			vint										GetRelatedToken(vint state)const;
			void										Walk(wchar_t input, vint& state, vint& token, bool& finalState, bool& previousTokenStop)const;
			vint										Walk(wchar_t input, vint state)const;
		};

		class RegexLexerColorizer : public Object
		{
			friend class RegexLexer;
		public:
			typedef void(*TokenProc)(void* argument, vint start, vint length, vint token);

		protected:
			RegexLexerWalker							walker;
			vint										currentState;

			RegexLexerColorizer(const RegexLexerWalker& _walker);
		public:
			RegexLexerColorizer(const RegexLexerColorizer& colorizer);
			~RegexLexerColorizer();

			void										Reset(vint state);
			void										Pass(wchar_t input);
			vint										GetStartState()const;
			vint										GetCurrentState()const;
			void										Colorize(const wchar_t* input, vint length, TokenProc tokenProc, void* tokenProcArgument);
		};

		class RegexLexer : public Object, private NotCopyable
		{
		protected:
			regex_internal::PureInterpretor*			pure;
			collections::Array<vint>					ids;
			collections::Array<vint>					stateTokens;
		public:
			RegexLexer(const collections::IEnumerable<WString>& tokens);
			~RegexLexer();

			RegexTokens									Parse(const WString& code, vint codeIndex=-1)const;
			RegexLexerWalker							Walk()const;
			RegexLexerColorizer							Colorize()const;
		};
	}
}

#endif

/***********************************************************************
REGEX\REGEXDATA.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::Basic Data Structure

Classes:
***********************************************************************/

#ifndef VCZH_REGEX_REGEXDATA
#define VCZH_REGEX_REGEXDATA


namespace vl
{
	namespace regex_internal
	{
		using namespace vl::collections;

/***********************************************************************
基础数据结构
***********************************************************************/

		class CharRange
		{
		public:
			typedef SortedList<CharRange>			List;

			wchar_t					begin;
			wchar_t					end;

			CharRange();
			CharRange(wchar_t _begin, wchar_t _end);

			bool					operator<(CharRange item)const;
			bool					operator<=(CharRange item)const;
			bool					operator>(CharRange item)const;
			bool					operator>=(CharRange item)const;
			bool					operator==(CharRange item)const;
			bool					operator!=(CharRange item)const;

			bool					operator<(wchar_t item)const;
			bool					operator<=(wchar_t item)const;
			bool					operator>(wchar_t item)const;
			bool					operator>=(wchar_t item)const;
			bool					operator==(wchar_t item)const;
			bool					operator!=(wchar_t item)const;
		};
	}

	template<>
	struct POD<regex_internal::CharRange>
	{
		static const bool Result=true;
	};
}

#endif

/***********************************************************************
REGEX\REGEXAUTOMATON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexAutomaton

Classes:
	State						：状态
	Transition					：转换
	Automaton					：状态机

Functions:
	EpsilonNfaToNfa				：去Epsilon
	NfaToDfa					：NFA转DFA
***********************************************************************/

#ifndef VCZH_REGEX_REGEXAUTOMATON
#define VCZH_REGEX_REGEXAUTOMATON


namespace vl
{
	namespace regex_internal
	{
		class State;
		class Transition;

		class Transition
		{
		public:
			enum Type
			{
				Chars,				//range为字符范围
				Epsilon,
				BeginString,
				EndString,
				Nop,				//无动作（不可消除epsilon，用来控制优先级）
				Capture,			//capture为捕获频道
				Match,				//capture为捕获频道，index为匹配的位置，-1代表匹配频道下面的所有项目
				Positive,			//正向匹配
				Negative,			//反向匹配
				NegativeFail,		//反向匹配失败
				End					//Capture, Position, Negative
			};

			State*					source;
			State*					target;
			CharRange				range;
			Type					type;
			vint						capture;
			vint						index;
		};

		class State
		{
		public:
			List<Transition*>		transitions;
			List<Transition*>		inputs;
			bool					finalState;
			void*					userData;
		};

		class Automaton
		{
		public:
			typedef Ptr<Automaton>		Ref;

			List<Ptr<State>>		states;
			List<Ptr<Transition>>	transitions;
			List<WString>			captureNames;
			State*					startState;

			Automaton();

			State*					NewState();
			Transition*				NewTransition(State* start, State* end);
			Transition*				NewChars(State* start, State* end, CharRange range);
			Transition*				NewEpsilon(State* start, State* end);
			Transition*				NewBeginString(State* start, State* end);
			Transition*				NewEndString(State* start, State* end);
			Transition*				NewNop(State* start, State* end);
			Transition*				NewCapture(State* start, State* end, vint capture);
			Transition*				NewMatch(State* start, State* end, vint capture, vint index=-1);
			Transition*				NewPositive(State* start, State* end);
			Transition*				NewNegative(State* start, State* end);
			Transition*				NewNegativeFail(State* start, State* end);
			Transition*				NewEnd(State* start, State* end);
		};

		extern bool					PureEpsilonChecker(Transition* transition);
		extern bool					RichEpsilonChecker(Transition* transition);
		extern bool					AreEqual(Transition* transA, Transition* transB);
		extern Automaton::Ref		EpsilonNfaToNfa(Automaton::Ref source, bool(*epsilonChecker)(Transition*), Dictionary<State*, State*>& nfaStateMap);
		extern Automaton::Ref		NfaToDfa(Automaton::Ref source, Group<State*, State*>& dfaStateMap);
	}
}

#endif

/***********************************************************************
REGEX\REGEXEXPRESSION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexExpression

Classes:
	Expression						：表达式基类					|
	CharSetExpression				：字符集表达式				| a, [a-b], [^a-b0_9], \.rnt\/()+*?{}[]<>^$!=SsDdLlWw, [\rnt-[]\/^$]
	LoopExpression					：循环表达式					| a{3}, a{3,}, a{1,3}, a+, a*, a?, LOOP?
	SequenceExpression				：顺序表达式					| ab
	AlternateExpression				：选择表达式					| a|b
	BeginExpression					：【非纯】字符串起始表达式	| ^
	EndExpression					：【非纯】字符串末尾表达式	| $
	CaptureExpression				：【非纯】捕获表达式			| (<name>expr), (?expr)
	MatchExpression					：【非纯】匹配表达式			| (<$name>), (<$name;i>), (<$i>)
	PositiveExpression				：【非纯】正向预查表达式		| (=expr)
	NegativeExpression				：【非纯】反向预查表达式		| (!expr)
	UsingExpression					：引用表达式					| (<#name1>expr)...(<&name1>)...

	RegexExpression					：正则表达式

Functions:
	ParseRegexExpression			：将字符串分析为RegexExpression对象，如果语法有问题则抛异常
***********************************************************************/

#ifndef VCZH_REGEX_REGEXEXPRESSION
#define VCZH_REGEX_REGEXEXPRESSION


namespace vl
{
	namespace regex_internal
	{
		class IRegexExpressionAlgorithm;

/***********************************************************************
正则表达式表达式树
***********************************************************************/

		class Expression : public Object, private NotCopyable
		{
		public:
			typedef Ptr<Expression>								Ref;
			typedef Dictionary<WString, Expression::Ref>		Map;

			virtual void				Apply(IRegexExpressionAlgorithm& algorithm)=0;
			bool						IsEqual(Expression* expression);
			bool						HasNoExtension();
			bool						CanTreatAsPure();
			void						NormalizeCharSet(CharRange::List& subsets);
			void						CollectCharSet(CharRange::List& subsets);
			void						ApplyCharSet(CharRange::List& subsets);
			Automaton::Ref				GenerateEpsilonNfa();
		};

		class CharSetExpression : public Expression
		{
		public:
			CharRange::List				ranges;
			bool						reverse;

			bool						AddRangeWithConflict(CharRange range);
			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class LoopExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//被循环表达式
			vint							min;			//下限
			vint							max;			//上限，-1代表无限
			bool						preferLong;		//长匹配优先

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class SequenceExpression : public Expression
		{
		public:
			Expression::Ref				left;			//左表达式
			Expression::Ref				right;			//右表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class AlternateExpression : public Expression
		{
		public:
			Expression::Ref				left;			//左表达式
			Expression::Ref				right;			//右表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class BeginExpression: public Expression
		{
		public:

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class EndExpression : public Expression
		{
		public:

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class CaptureExpression : public Expression
		{
		public:
			WString						name;			//捕获名，空代表缺省捕获
			Expression::Ref				expression;		//被捕获表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class MatchExpression : public Expression
		{
		public:
			WString						name;			//捕获名，空代表缺省捕获
			vint							index;			//捕获序号，-1代表非空捕获的所有项

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class PositiveExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//正向匹配表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class NegativeExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//反向匹配表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class UsingExpression : public Expression
		{
		public:
			WString						name;			//引用名

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class RegexExpression : public Object, private NotCopyable
		{
		public:
			typedef Ptr<RegexExpression>						Ref;

			Expression::Map				definitions;	//命名子表达式
			Expression::Ref				expression;		//主表达式

			Expression::Ref				Merge();
		};

/***********************************************************************
算法基类
***********************************************************************/

		class IRegexExpressionAlgorithm : public Interface
		{
		public:
			virtual void				Visit(CharSetExpression* expression)=0;
			virtual void				Visit(LoopExpression* expression)=0;
			virtual void				Visit(SequenceExpression* expression)=0;
			virtual void				Visit(AlternateExpression* expression)=0;
			virtual void				Visit(BeginExpression* expression)=0;
			virtual void				Visit(EndExpression* expression)=0;
			virtual void				Visit(CaptureExpression* expression)=0;
			virtual void				Visit(MatchExpression* expression)=0;
			virtual void				Visit(PositiveExpression* expression)=0;
			virtual void				Visit(NegativeExpression* expression)=0;
			virtual void				Visit(UsingExpression* expression)=0;
		};

		template<typename ReturnType, typename ParameterType=void*>
		class RegexExpressionAlgorithm : public Object, public IRegexExpressionAlgorithm
		{
		private:
			ReturnType					returnValue;
			void*						parameterValue;
		public:

			ReturnType Invoke(Expression* expression, ParameterType parameter)
			{
				parameterValue=(void*)&parameter;
				expression->Apply(*this);
				return returnValue;
			}

			ReturnType Invoke(Expression::Ref expression, ParameterType parameter)
			{
				parameterValue=(void*)&parameter;
				expression->Apply(*this);
				return returnValue;
			}

			virtual ReturnType			Apply(CharSetExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(LoopExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(SequenceExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(AlternateExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(BeginExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(EndExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(CaptureExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(MatchExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(PositiveExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(NegativeExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(UsingExpression* expression, ParameterType parameter)=0;
		public:
			void Visit(CharSetExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(LoopExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(SequenceExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(AlternateExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(BeginExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(EndExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(CaptureExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(MatchExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(PositiveExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(NegativeExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(UsingExpression* expression)
			{
				returnValue=Apply(expression, *((ParameterType*)parameterValue));
			}
		};

		template<typename ParameterType>
		class RegexExpressionAlgorithm<void, ParameterType> : public Object, public IRegexExpressionAlgorithm
		{
		private:
			void*						parameterValue;
		public:

			void Invoke(Expression* expression, ParameterType parameter)
			{
				parameterValue=(void*)&parameter;
				expression->Apply(*this);
			}

			void Invoke(Expression::Ref expression, ParameterType parameter)
			{
				parameterValue=(void*)&parameter;
				expression->Apply(*this);
			}

			virtual void				Apply(CharSetExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(LoopExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(SequenceExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(AlternateExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(BeginExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(EndExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(CaptureExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(MatchExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(PositiveExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(NegativeExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(UsingExpression* expression, ParameterType parameter)=0;
		public:
			void Visit(CharSetExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(LoopExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(SequenceExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(AlternateExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(BeginExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(EndExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(CaptureExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(MatchExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(PositiveExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(NegativeExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}

			void Visit(UsingExpression* expression)
			{
				Apply(expression, *((ParameterType*)parameterValue));
			}
		};

/***********************************************************************
辅助函数
***********************************************************************/

		extern Ptr<LoopExpression>		ParseLoop(const wchar_t*& input);
		extern Ptr<Expression>			ParseCharSet(const wchar_t*& input);
		extern Ptr<Expression>			ParseFunction(const wchar_t*& input);
		extern Ptr<Expression>			ParseUnit(const wchar_t*& input);
		extern Ptr<Expression>			ParseJoin(const wchar_t*& input);
		extern Ptr<Expression>			ParseAlt(const wchar_t*& input);
		extern Ptr<Expression>			ParseExpression(const wchar_t*& input);
		extern RegexExpression::Ref		ParseRegexExpression(const WString& code);
	}
}

#endif

/***********************************************************************
REGEX\REGEXPURE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexInterpretor

Classes:
	PureInterpretor					：正则表达式纯模拟器
***********************************************************************/

#ifndef VCZH_REGEX_REGEXPURE
#define VCZH_REGEX_REGEXPURE


namespace vl
{
	namespace regex_internal
	{
		class PureResult
		{
		public:
			vint				start;
			vint				length;
			vint				finalState;
		};

		class PureInterpretor : public Object
		{
		protected:
			vint				charMap[1<<(8*sizeof(wchar_t))];	// char -> char set index
			vint**				transition;							// (state * char set index) -> state*
			bool*				finalState;							// state -> bool
			vint*				relatedFinalState;					// sate -> (finalState or -1)
			vint				stateCount;
			vint				charSetCount;
			vint				startState;
		public:
			PureInterpretor(Automaton::Ref dfa, CharRange::List& subsets);
			~PureInterpretor();

			bool				MatchHead(const wchar_t* input, const wchar_t* start, PureResult& result);
			bool				Match(const wchar_t* input, const wchar_t* start, PureResult& result);

			vint				GetStartState();
			vint				Transit(wchar_t input, vint state);
			bool				IsFinalState(vint state);

			void				PrepareForRelatedFinalStateTable();
			vint				GetRelatedFinalState(vint state);
		};
	}
}

#endif

/***********************************************************************
REGEX\REGEXRICH.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexInterpretor

Classes:
	RichInterpretor					：正则表达式完全模拟器
***********************************************************************/

#ifndef VCZH_REGEX_REGEXRICH
#define VCZH_REGEX_REGEXRICH


namespace vl
{
	namespace regex_internal
	{
		class CaptureRecord
		{
		public:
			vint								capture;
			vint								start;
			vint								length;

			bool							operator==(const CaptureRecord& record)const;
		};
	}

	template<>
	struct POD<regex_internal::CaptureRecord>
	{
		static const bool Result=true;
	};

	namespace regex_internal
	{
		class RichResult
		{
		public:
			vint							start;
			vint							length;
			List<CaptureRecord>			captures;
		};

		class RichInterpretor : public Object
		{
		public:
		protected:
			class UserData
			{
			public:
				bool						NeedKeepState;
			};

			Automaton::Ref					dfa;
			UserData*						datas;
		public:
			RichInterpretor(Automaton::Ref _dfa);
			~RichInterpretor();

			bool							MatchHead(const wchar_t* input, const wchar_t* start, RichResult& result);
			bool							Match(const wchar_t* input, const wchar_t* start, RichResult& result);
			const IReadonlyList<WString>&	CaptureNames();
		};
	};
}

#endif

/***********************************************************************
REGEX\REGEXWRITER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexWriter

Classes:
***********************************************************************/

#ifndef VCZH_REGEX_REGEXWRITER
#define VCZH_REGEX_REGEXWRITER


namespace vl
{
	namespace regex
	{
		class RegexNode : public Object
		{
		public:
			vl::regex_internal::Expression::Ref		expression;

			RegexNode(vl::regex_internal::Expression::Ref _expression);

			RegexNode					Some()const;
			RegexNode					Any()const;
			RegexNode					Opt()const;
			RegexNode					Loop(vint min, vint max)const;
			RegexNode					AtLeast(vint min)const;
			RegexNode					operator+(const RegexNode& node)const;
			RegexNode					operator|(const RegexNode& node)const;
			RegexNode					operator+()const;
			RegexNode					operator-()const;
			RegexNode					operator!()const;
			RegexNode					operator%(const RegexNode& node)const;
		};

		extern RegexNode				rCapture(const WString& name, const RegexNode& node);
		extern RegexNode				rUsing(const WString& name);
		extern RegexNode				rMatch(const WString& name, vint index=-1);
		extern RegexNode				rMatch(vint index);
		extern RegexNode				rBegin();
		extern RegexNode				rEnd();
		extern RegexNode				rC(wchar_t a, wchar_t b=L'\0');
		extern RegexNode				r_d();
		extern RegexNode				r_l();
		extern RegexNode				r_w();
		extern RegexNode				rAnyChar();
	}
}

#endif

/***********************************************************************
STREAM\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::Interfaces

Interfaces:
	IStream							：流
***********************************************************************/

#ifndef VCZH_STREAM_INTERFACES
#define VCZH_STREAM_INTERFACES


namespace vl
{
	namespace stream
	{
		class IStream : public virtual Interface
		{
		public:
			virtual bool					CanRead()const=0;
			virtual bool					CanWrite()const=0;
			virtual bool					CanSeek()const=0;
			virtual bool					CanPeek()const=0;
			virtual bool					IsLimited()const=0;
			virtual bool					IsAvailable()const=0;
			virtual void					Close()=0;
			virtual pos_t					Position()const=0;
			virtual pos_t					Size()const=0;
			virtual void					Seek(pos_t _size)=0;
			virtual void					SeekFromBegin(pos_t _size)=0;
			virtual void					SeekFromEnd(pos_t _size)=0;
			virtual vint					Read(void* _buffer, vint _size)=0;
			virtual vint					Write(void* _buffer, vint _size)=0;
			virtual vint					Peek(void* _buffer, vint _size)=0;
		};

		class IEncoder : public Interface
		{
		public:
			virtual void					Setup(IStream* _stream)=0;
			virtual	void					Close()=0;
			virtual vint					Write(void* _buffer, vint _size)=0;
		};

		class IDecoder : public Interface
		{
		public:
			virtual void					Setup(IStream* _stream)=0;
			virtual	void					Close()=0;
			virtual vint					Read(void* _buffer, vint _size)=0;
		};
	}
}

#endif

/***********************************************************************
STREAM\ACCESSOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::Accessor

Classes:
	TextReader						：字符串阅读器
	TextWriter						：字符串书写器
	StreamReader					：流阅读器
	StreamWriter					：流书写器
	EncoderStream					：编码流
	DecoderStream					：解码流
***********************************************************************/

#ifndef VCZH_STREAM_ACCESSOR
#define VCZH_STREAM_ACCESSOR


namespace vl
{
	namespace stream
	{

/***********************************************************************
流控制器
***********************************************************************/

		class TextReader : public Object, private NotCopyable
		{
		public:
			virtual bool				IsEnd()=0;
			virtual wchar_t				ReadChar()=0;
			virtual WString				ReadString(vint length);
			virtual WString				ReadLine();
			virtual WString				ReadToEnd();
		};

		class TextWriter : public Object, private NotCopyable
		{
		public:
			virtual void				WriteChar(wchar_t c)=0;
			virtual void				WriteString(const wchar_t* string, vint charCount);
			virtual void				WriteString(const wchar_t* string);
			virtual void				WriteString(const WString& string);
			virtual void				WriteLine(const wchar_t* string, vint charCount);
			virtual void				WriteLine(const wchar_t* string);
			virtual void				WriteLine(const WString& string);
		};

		class StringReader : public TextReader
		{
		protected:
			WString						string;
			vint						current;
			bool						lastCallIsReadLine;

			void						PrepareIfLastCallIsReadLine();
		public:
			StringReader(const WString& _string);

			bool						IsEnd();
			wchar_t						ReadChar();
			WString						ReadString(vint length);
			WString						ReadLine();
			WString						ReadToEnd();
		};

		class StreamReader : public TextReader
		{
		protected:
			IStream*					stream;
		public:
			StreamReader(IStream& _stream);

			bool						IsEnd();
			wchar_t						ReadChar();
		};

		class StreamWriter : public TextWriter
		{
		protected:
			IStream*					stream;
		public:
			StreamWriter(IStream& _stream);
			using TextWriter::WriteString;

			void						WriteChar(wchar_t c);
			void						WriteString(const wchar_t* string, vint charCount);
		};

/***********************************************************************
编码解码
***********************************************************************/

		class EncoderStream : public virtual IStream
		{
		protected:
			IStream*					stream;
			IEncoder*					encoder;
			pos_t						position;

		public:
			EncoderStream(IStream& _stream, IEncoder& _encoder);
			~EncoderStream();

			bool						CanRead()const;
			bool						CanWrite()const;
			bool						CanSeek()const;
			bool						CanPeek()const;
			bool						IsLimited()const;
			bool						IsAvailable()const;
			void						Close();
			pos_t						Position()const;
			pos_t						Size()const;
			void						Seek(pos_t _size);
			void						SeekFromBegin(pos_t _size);
			void						SeekFromEnd(pos_t _size);
			vint							Read(void* _buffer, vint _size);
			vint							Write(void* _buffer, vint _size);
			vint							Peek(void* _buffer, vint _size);
		};

		class DecoderStream : public virtual IStream
		{
		protected:
			IStream*					stream;
			IDecoder*					decoder;
			pos_t						position;

		public:
			DecoderStream(IStream& _stream, IDecoder& _decoder);
			~DecoderStream();

			bool						CanRead()const;
			bool						CanWrite()const;
			bool						CanSeek()const;
			bool						CanPeek()const;
			bool						IsLimited()const;
			bool						IsAvailable()const;
			void						Close();
			pos_t						Position()const;
			pos_t						Size()const;
			void						Seek(pos_t _size);
			void						SeekFromBegin(pos_t _size);
			void						SeekFromEnd(pos_t _size);
			vint							Read(void* _buffer, vint _size);
			vint							Write(void* _buffer, vint _size);
			vint							Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\BROADCASTSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::BroadcastStream

Interfaces:
	BroadcastStream					：广播流
***********************************************************************/

#ifndef VCZH_STREAM_BROADCASTSTREAM
#define VCZH_STREAM_BROADCASTSTREAM


namespace vl
{
	namespace stream
	{
		class BroadcastStream : public Object, public virtual IStream
		{
			typedef collections::IList<IStream*>	_ListInterface;
			typedef collections::List<IStream*>		_List;
		protected:
			bool					closed;
			pos_t					position;
			_List					streams;
		public:
			BroadcastStream();
			~BroadcastStream();

			_ListInterface&			Targets();
			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\CACHESTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::CacheStream

Interfaces:
	CacheStream						：缓冲流
***********************************************************************/

#ifndef VCZH_STREAM_CACHESTREAM
#define VCZH_STREAM_CACHESTREAM


namespace vl
{
	namespace stream
	{
		class CacheStream : public Object, public virtual IStream
		{
		protected:
			IStream*				target;
			vint					block;
			pos_t					start;
			pos_t					position;

			char*					buffer;
			vint					dirtyStart;
			vint					dirtyLength;
			vint					availableLength;
			pos_t					operatedSize;

			void					Flush();
			void					Load(pos_t _position);
			vint					InternalRead(void* _buffer, vint _size);
			vint					InternalWrite(void* _buffer, vint _size);
		public:
			CacheStream(IStream& _target, vint _block=65536);
			~CacheStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint					Read(void* _buffer, vint _size);
			vint					Write(void* _buffer, vint _size);
			vint					Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\CHARFORMAT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::CharFormat

Classes:
	CharEncoder									：字符串编码器基类
	CharDecoder									：字符串解码器基类
	MbcsEncoder									：Mbcs编码器
	MbcsDecoder									：Mbcs解码器
	Utf16Encoder								：Utf16编码器
	Utf16Decoder								：Utf16解码器
	Utf16BEEncoder								：Utf16 Big Endian编码器
	Utf16BEDecoder								：Utf16 Big Endian解码器
	Utf8Encoder									：Utf8编码器
	Utf8Decoder									：Utf8解码器
	BomEncoder									：BOM相关编码器
	BomDecoder									：BOM相关解码器
***********************************************************************/

#ifndef VCZH_STREAM_CHARFORMAT
#define VCZH_STREAM_CHARFORMAT


namespace vl
{
	namespace stream
	{

		/*编码资料
		UCS-4和UTF-8的对应关系:
		U-00000000 - U-0000007F:  0xxxxxxx
		U-00000080 - U-000007FF:  110xxxxx 10xxxxxx
		U-00000800 - U-0000FFFF:  1110xxxx 10xxxxxx 10xxxxxx
		U-00010000 - U-001FFFFF:  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
		U-00200000 - U-03FFFFFF:  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
		U-04000000 - U-7FFFFFFF:  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
		BOM:
		FFFE	=Unicode			(vceUtf16)
		FEFF	=Unicode Big Endian	(vceUtf16_be)
		EFBBBF	=UTF-8				(vceUtf8)
		other	=MBCS(GBK)			(vceMbcs)
		*/

/***********************************************************************
字符串编码解码基类
***********************************************************************/

		class CharEncoder : public Object, public IEncoder
		{
		protected:
			IStream*						stream;
			unsigned char					cache;
			bool							cacheAvailable;

			virtual vint						WriteString(wchar_t* _buffer, vint chars)=0;
		public:
			CharEncoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint								Write(void* _buffer, vint _size);
		};

		class CharDecoder : public Object, public IDecoder
		{
		protected:
			IStream*						stream;
			unsigned char					cache;
			bool							cacheAvailable;

			virtual vint						ReadString(wchar_t* _buffer, vint chars)=0;
		public:
			CharDecoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint								Read(void* _buffer, vint _size);
		};

/***********************************************************************
Mbcs
***********************************************************************/

		class MbcsEncoder : public CharEncoder
		{
		protected:
			vint								WriteString(wchar_t* _buffer, vint chars);
		};

		class MbcsDecoder : public CharDecoder
		{
		protected:
			vint								ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-16
***********************************************************************/

		class Utf16Encoder : public CharEncoder
		{
		protected:
			vint								WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf16Decoder : public CharDecoder
		{
		protected:
			vint								ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-16-be
***********************************************************************/

		class Utf16BEEncoder : public CharEncoder
		{
		protected:
			vint								WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf16BEDecoder : public CharDecoder
		{
		protected:
			vint								ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-8
***********************************************************************/

		class Utf8Encoder : public CharEncoder
		{
		protected:
			vint								WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf8Decoder : public CharDecoder
		{
		protected:
			vint								ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Bom
***********************************************************************/

		class BomEncoder : public Object, public IEncoder
		{
		public:
			enum Encoding
			{
				Mbcs,
				Utf8,
				Utf16,
				Utf16BE
			};
		protected:
			Encoding						encoding;
			IEncoder*						encoder;
		public:
			BomEncoder(Encoding _encoding);
			~BomEncoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint								Write(void* _buffer, vint _size);
		};

		class BomDecoder : public Object, public IDecoder
		{
		private:
			class BomStream : public Object, public IStream
			{
			protected:
				IStream*					stream;
				char						bom[3];
				vint							bomLength;
				vint							bomPosition;
			public:
				BomStream(IStream* _stream, char* _bom, vint _bomLength);

				bool						CanRead()const;
				bool						CanWrite()const;
				bool						CanSeek()const;
				bool						CanPeek()const;
				bool						IsLimited()const;
				bool						IsAvailable()const;
				void						Close();
				pos_t						Position()const;
				pos_t						Size()const;
				void						Seek(pos_t _size);
				void						SeekFromBegin(pos_t _size);
				void						SeekFromEnd(pos_t _size);
				vint							Read(void* _buffer, vint _size);
				vint							Write(void* _buffer, vint _size);
				vint							Peek(void* _buffer, vint _size);
			};
		protected:
			IDecoder*						decoder;
			IStream*						stream;

		public:
			BomDecoder();
			~BomDecoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint								Read(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\FILESTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::FileStream

Interfaces:
	FileStream						：文件流
***********************************************************************/

#ifndef VCZH_STREAM_FILESTREAM
#define VCZH_STREAM_FILESTREAM

#include <stdio.h>

namespace vl
{
	namespace stream
	{
		class FileStream : public Object, public virtual IStream
		{
		public:
			enum AccessRight
			{
				ReadOnly,
				WriteOnly,
				ReadWrite
			};
		protected:
			AccessRight				accessRight;
			FILE*					file;
		public:
			FileStream(const WString& fileName, AccessRight _accessRight);
			~FileStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\MEMORYSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::MemoryStream

Interfaces:
	MemoryStream					：内存流
***********************************************************************/

#ifndef VCZH_STREAM_MEMORYSTREAM
#define VCZH_STREAM_MEMORYSTREAM


namespace vl
{
	namespace stream
	{
		class MemoryStream : public Object, public virtual IStream
		{
		protected:
			vint					block;
			char*					buffer;
			vint					size;
			vint					position;
			vint					capacity;

			void					PrepareSpace(vint totalSpace);
		public:
			MemoryStream(vint _block=65536);
			~MemoryStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint					Read(void* _buffer, vint _size);
			vint					Write(void* _buffer, vint _size);
			vint					Peek(void* _buffer, vint _size);
			void*					GetInternalBuffer();
		};
	}
}

#endif

/***********************************************************************
STREAM\MEMORYWRAPPERSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::MemoryWrapperStream

Interfaces:
	MemoryWrapperStream				：内存代理流
***********************************************************************/

#ifndef VCZH_STREAM_MEMORYWRAPPERSTREAM
#define VCZH_STREAM_MEMORYWRAPPERSTREAM


namespace vl
{
	namespace stream
	{
		class MemoryWrapperStream : public Object, public virtual IStream
		{
		protected:
			char*					buffer;
			vint						size;
			vint						position;
		public:
			MemoryWrapperStream(void* _buffer, vint _size);
			~MemoryWrapperStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\RECORDERSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::RecorderStream

Interfaces:
	RecorderStream					：备份流
***********************************************************************/

#ifndef VCZH_STREAM_RECORDERSTREAM
#define VCZH_STREAM_RECORDERSTREAM


namespace vl
{
	namespace stream
	{
		class RecorderStream : public Object, public virtual IStream
		{
		protected:
			IStream*				in;
			IStream*				out;
		public:
			RecorderStream(IStream& _in, IStream& _out);
			~RecorderStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
THREADING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Threading

Classes:
	Thread										：线程
	CriticalSection
	Mutex
	Semaphore
	EventObject
***********************************************************************/

#ifndef VCZH_THREADING
#define VCZH_THREADING


namespace vl
{

/***********************************************************************
内核模式对象
***********************************************************************/

	namespace threading_internal
	{
		struct WaitableData;
		struct ThreadData;
		struct MutexData;
		struct SemaphoreData;
		struct EventData;

		struct CriticalSectionData;
		struct ReaderWriterLockData;
		struct ConditionVariableData;
	}

	class WaitableObject : public Object, public NotCopyable
	{
	private:
		threading_internal::WaitableData*			waitableData;
	protected:

		WaitableObject();
		void										SetData(threading_internal::WaitableData* data);
	public:

		bool										IsCreated();
		bool										Wait();
		bool										WaitForTime(vint ms);
		
		static bool									WaitAll(WaitableObject** objects, vint count);
		static bool									WaitAllForTime(WaitableObject** objects, vint count, vint ms);
		static vint									WaitAny(WaitableObject** objects, vint count, bool* abandoned);
		static vint									WaitAnyForTime(WaitableObject** objects, vint count, vint ms, bool* abandoned);
	};

	class Thread : public WaitableObject
	{
		friend void InternalThreadProc(Thread* thread);
	public:
		enum ThreadState
		{
			NotStarted,
			Running,
			Paused,
			Stopped
		};

		typedef void(*ThreadProcedure)(Thread*, void*);
	private:
		threading_internal::ThreadData*				internalData;
		volatile ThreadState						threadState;

	protected:

		virtual void								Run()=0;
	public:
		Thread();
		~Thread();

		static Thread*								CreateAndStart(ThreadProcedure procedure, void* argument=0, bool deleteAfterStopped=true);
		static void									Sleep(vint ms);
		static vint									GetCPUCount();
		static vint									GetCurrentThreadId();

		bool										Start();
		bool										Pause();
		bool										Resume();
		bool										Stop();
		ThreadState									GetState();
		void										SetCPU(vint index);
	};

	class Mutex : public WaitableObject
	{
	private:
		threading_internal::MutexData*				internalData;
	public:
		Mutex();
		~Mutex();

		bool										Create(bool owned=false, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Release();
	};

	class Semaphore : public WaitableObject
	{
	private:
		threading_internal::SemaphoreData*			internalData;
	public:
		Semaphore();
		~Semaphore();

		bool										Create(vint initialCount, vint maxCount, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Release();
		vint										Release(vint count);
	};

	class EventObject : public WaitableObject
	{
	private:
		threading_internal::EventData*				internalData;
	public:
		EventObject();
		~EventObject();

		bool										CreateAutoUnsignal(bool signaled, const WString& name=L"");
		bool										CreateManualUnsignal(bool signaled, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Signal();
		bool										Unsignal();
	};

/***********************************************************************
线程池
***********************************************************************/

	class ThreadPoolLite : public Object
	{
	private:
		ThreadPoolLite();
		~ThreadPoolLite();
	public:
		static bool									Queue(void(*proc)(void*), void* argument);
		static bool									Queue(const Func<void()>& proc);

		template<typename T>
		static void QueueLambda(const T& proc)
		{
			Queue(Func<void()>(proc));
		}
	};

/***********************************************************************
进程内对象
***********************************************************************/

	class CriticalSection : public Object, public NotCopyable
	{
	private:
#ifdef VCZH_NO_OLD_OS
		friend class ConditionVariable;
#endif
		threading_internal::CriticalSectionData*	internalData;
	public:
		CriticalSection();
		~CriticalSection();

		bool										TryEnter();
		void										Enter();
		void										Leave();

	public:
		class Scope : public Object, public NotCopyable
		{
		private:
			CriticalSection*						criticalSection;
		public:
			Scope(CriticalSection& _criticalSection);
			~Scope();
		};
	};

#ifdef VCZH_NO_OLD_OS

	class ReaderWriterLock : public Object, public NotCopyable
	{
	private:
		friend class ConditionVariable;
		threading_internal::ReaderWriterLockData*	internalData;
	public:
		ReaderWriterLock();
		~ReaderWriterLock();

		bool										TryEnterReader();
		void										EnterReader();
		void										LeaveReader();
		bool										TryEnterWriter();
		void										EnterWriter();
		void										LeaveWriter();
	public:
		class ReaderScope : public Object, public NotCopyable
		{
		private:
			ReaderWriterLock*						lock;
		public:
			ReaderScope(ReaderWriterLock& _lock);
			~ReaderScope();
		};
		
		class WriterScope : public Object, public NotCopyable
		{
		private:
			ReaderWriterLock*						lock;
		public:
			WriterScope(ReaderWriterLock& _lock);
			~WriterScope();
		};
	};

	class ConditionVariable : public Object, public NotCopyable
	{
	private:
		threading_internal::ConditionVariableData*	internalData;
	public:
		ConditionVariable();
		~ConditionVariable();

		bool										SleepWith(CriticalSection& cs);
		bool										SleepWithForTime(CriticalSection& cs, vint ms);
		bool										SleepWithReader(ReaderWriterLock& lock);
		bool										SleepWithReaderForTime(ReaderWriterLock& lock, vint ms);
		bool										SleepWithWriter(ReaderWriterLock& lock);
		bool										SleepWithWriterForTime(ReaderWriterLock& lock, vint ms);
		void										WakeOnePending();
		void										WakeAllPendings();
	};
#endif

/***********************************************************************
用户模式对象
***********************************************************************/

	typedef long LockedInt;

	class SpinLock : public Object, public NotCopyable
	{
	protected:
		volatile LockedInt							token;
	public:
		SpinLock();
		~SpinLock();

		bool										TryEnter();
		void										Enter();
		void										Leave();

	public:
		class Scope : public Object, public NotCopyable
		{
		private:
			SpinLock*								spinLock;
		public:
			Scope(SpinLock& _spinLock);
			~Scope();
		};
	};
}

#endif
