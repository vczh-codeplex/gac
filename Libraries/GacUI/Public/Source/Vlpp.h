/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: 陈梓瀚(vczh)
***********************************************************************/

/***********************************************************************
BASIC.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Basic

Classes:
	NotCopyable									：不可复制对象
	Error										：内部错误，检查到了不可出现的变量、参数或状态错误
	Object										：对象基类

Macros:
	CHECK_ERROR(CONDITION,DESCRIPTION)			：检查内部错误
***********************************************************************/

#ifndef VCZH_BASIC
#define VCZH_BASIC

namespace vl
{

/***********************************************************************
32位/64位兼容
***********************************************************************/

#ifdef _WIN64
#define VCZH_64
#endif

#ifdef VCZH_64
	typedef __int64					vint;
	typedef signed __int64			vsint;
	typedef unsigned __int64		vuint;
#else
	typedef __int32					vint;
	typedef signed __int32			vsint;
	typedef unsigned __int32		vuint;
#endif

typedef signed __int64	pos_t;

#ifdef VCZH_64
#define ITOA_S		_i64toa_s
#define ITOW_S		_i64tow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#else
#define ITOA_S		_itoa_s
#define ITOW_S		_itow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#endif

#ifndef _MSC_VER
#define override
#define abstract
#endif

#define VCZH_NO_OLD_OS

/***********************************************************************
基础
***********************************************************************/

	class NotCopyable
	{
	private:
		NotCopyable(const NotCopyable&);
		NotCopyable& operator=(const NotCopyable&);
	public:
		NotCopyable();
	};

	class Error
	{
	private:
		wchar_t*			description;
	public:
		Error(wchar_t* _description);

		wchar_t*			Description()const;
	};

#ifdef _DEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION) do{if(!(CONDITION))throw Error(DESCRIPTION);}while(0)
#endif
#ifdef NDEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION)
#endif

#define CHECK_FAIL(DESCRIPTION) do{throw Error(DESCRIPTION);}while(0)

	class Object
	{
	public:
		virtual ~Object();
	};

	template<typename T>
	class ObjectBox : public Object
	{
	private:
		T					object;
	public:
		ObjectBox(const T& _object)
		{
			object=_object;
		}

		const T& Unbox()
		{
			return object;
		}
	};

	template<typename T, size_t minSize>
	union BinaryRetriver
	{
		T t;
		char binary[sizeof(T)>minSize?sizeof(T):minSize];
	};

/***********************************************************************
配置
***********************************************************************/

	template<typename T>
	struct KeyType
	{
	public:
		typedef T Type;
	};

	template<typename T>
	struct POD
	{
		static const bool Result=false;
	};

	template<>struct POD<bool>{static const bool Result=true;};
	template<>struct POD<unsigned __int8>{static const bool Result=true;};
	template<>struct POD<signed __int8>{static const bool Result=true;};
	template<>struct POD<unsigned __int16>{static const bool Result=true;};
	template<>struct POD<signed __int16>{static const bool Result=true;};
	template<>struct POD<unsigned __int32>{static const bool Result=true;};
	template<>struct POD<signed __int32>{static const bool Result=true;};
	template<>struct POD<unsigned __int64>{static const bool Result=true;};
	template<>struct POD<signed __int64>{static const bool Result=true;};
	template<>struct POD<char>{static const bool Result=true;};
	template<>struct POD<wchar_t>{static const bool Result=true;};
	template<typename T>struct POD<T*>{static const bool Result=true;};
	template<typename T>struct POD<T&>{static const bool Result=true;};
	template<typename T, typename C>struct POD<T C::*>{static const bool Result=true;};
	template<typename T, vint _Size>struct POD<T[_Size]>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<volatile T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const volatile T>{static const bool Result=POD<T>::Result;};

/***********************************************************************
时间
***********************************************************************/

	struct DateTime
	{
		vint				year;
		vint				month;
		vint				dayOfWeek;
		vint				day;
		vint				hour;
		vint				minute;
		vint				second;
		vint				milliseconds;

		unsigned __int64	totalMilliseconds;
		unsigned __int64	filetime;

		static DateTime		LocalTime();
		static DateTime		UtcTime();

		DateTime			ToLocalTime();
		DateTime			ToUtcTime();
	};

/***********************************************************************
接口
***********************************************************************/

	class Interface : private NotCopyable
	{
	public:
		virtual ~Interface();
	};
}

#endif

/***********************************************************************
STRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::String

Classes:
	AString										：Mbcs字符串
	WString										：Utf-16字符串
***********************************************************************/

#ifndef VCZH_STRING
#define VCZH_STRING

#include <memory.h>

namespace vl
{
	template<typename T>
	class ObjectString : public Object
	{
	private:
		static const T	zero=0;

		mutable T*					buffer;
		mutable vint*				reference;
		mutable vint				start;
		mutable vint				length;
		mutable vint				realLength;

		static vint CalculateLength(const T* buffer)
		{
			vint result=0;
			while(*buffer++)result++;
			return result;
		}

		static vint Compare(const T* bufA, const ObjectString<T>& strB)
		{
			const T* bufB=strB.buffer+strB.start;
			const T* bufAOld=bufA;
			vint length=strB.length;
			while(length-- && *bufA)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return CalculateLength(bufAOld)-strB.length;
		}

	public:

		static vint Compare(const ObjectString<T>& strA, const ObjectString<T>& strB)
		{
			const T* bufA=strA.buffer+strA.start;
			const T* bufB=strB.buffer+strB.start;
			vint length=strA.length<strB.length?strA.length:strB.length;
			while(length--)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return strA.length-strB.length;
		}

	private:

		void Inc()const
		{
			if(reference)
			{
				(*reference)++;
			}
		}

		void Dec()const
		{
			if(reference)
			{
				if(--(*reference)==0)
				{
					delete[] buffer;
					delete reference;
				}
			}
		}

		ObjectString(const ObjectString<T>& string, vint _start, vint _length)
		{
			if(_length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=string.buffer;
				reference=string.reference;
				start=string.start+_start;
				length=_length;
				realLength=string.realLength;
				Inc();
			}
		}

		ObjectString(const ObjectString<T>& dest, const ObjectString<T>& source, vint index, vint count)
		{
			if(index==0 && count==dest.length && source.length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				reference=new vint(1);
				start=0;
				length=dest.length-count+source.length;
				realLength=length;
				buffer=new T[length+1];
				memcpy(buffer, dest.buffer+dest.start, sizeof(T)*index);
				memcpy(buffer+index, source.buffer+source.start, sizeof(T)*source.length);
				memcpy(buffer+index+source.length, (dest.buffer+dest.start+index+count), sizeof(T)*(dest.length-index-count));
				buffer[length]=0;
			}
		}
	public:
		static ObjectString<T>	Empty;

		ObjectString()
		{
			buffer=(T*)&zero;
			reference=0;
			start=0;
			length=0;
			realLength=0;
		}

		ObjectString(const T& _char)
		{
			reference=new vint(1);
			start=0;
			length=1;
			buffer=new T[2];
			buffer[0]=_char;
			buffer[1]=0;
			realLength=length;
		}

		ObjectString(const T* _buffer, vint _length)
		{
			if(_length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=new T[_length+1];
				memcpy(buffer, _buffer, _length*sizeof(T));
				buffer[_length]=0;
				reference=new vint(1);
				start=0;
				length=_length;
				realLength=_length;
			}
		}

		ObjectString(const T* _buffer, bool copy = true)
		{
			CHECK_ERROR(_buffer!=0, L"ObjectString<T>::ObjectString(const T*, bool)#不能用空指针构造字符串。");
			if(copy)
			{
				reference=new vint(1);
				start=0;
				length=CalculateLength(_buffer);
				buffer=new T[length+1];
				memcpy(buffer, _buffer, sizeof(T)*(length+1));
				realLength=length;
			}
			else
			{
				buffer=(T*)_buffer;
				reference=0;
				start=0;
				length=CalculateLength(_buffer);
				realLength=length;
			}
		}

		ObjectString(const ObjectString<T>& string)
		{
			buffer=string.buffer;
			reference=string.reference;
			start=string.start;
			length=string.length;
			realLength=string.realLength;
			Inc();
		}

		~ObjectString()
		{
			Dec();
		}

		const T* Buffer()const
		{
			if(start+length!=realLength)
			{
				T* newBuffer=new T[length+1];
				memcpy(newBuffer, buffer+start, sizeof(T)*length);
				newBuffer[length]=0;
				Dec();
				buffer=newBuffer;
				reference=new vint(1);
				start=0;
				realLength=length;
			}
			return buffer+start;
		}

		ObjectString<T>& operator=(const ObjectString<T>& string)
		{
			if(this!=&string)
			{
				Dec();
				buffer=string.buffer;
				reference=string.reference;
				start=string.start;
				length=string.length;
				realLength=string.realLength;
				Inc();
			}
			return *this;
		}

		ObjectString<T>& operator+=(const ObjectString<T>& string)
		{
			return *this=*this+string;
		}

		ObjectString<T> operator+(const ObjectString<T>& string)const
		{
			return ObjectString<T>(*this, string, length, 0);
		}

		bool operator==(const ObjectString<T>& string)const
		{
			return Compare(*this, string)==0;
		}

		bool operator!=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)!=0;
		}

		bool operator>(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>0;
		}

		bool operator>=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>=0;
		}

		bool operator<(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<0;
		}

		bool operator<=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<=0;
		}

		bool operator==(const T* buffer)const
		{
			return Compare(buffer, *this)==0;
		}

		bool operator!=(const T* buffer)const
		{
			return Compare(buffer, *this)!=0;
		}

		bool operator>(const T* buffer)const
		{
			return Compare(buffer, *this)<0;
		}

		bool operator>=(const T* buffer)const
		{
			return Compare(buffer, *this)<=0;
		}

		bool operator<(const T* buffer)const
		{
			return Compare(buffer, *this)>0;
		}

		bool operator<=(const T* buffer)const
		{
			return Compare(buffer, *this)>=0;
		}

		T operator[](vint index)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString:<T>:operator[](vint)#参数index越界。");
			return buffer[start+index];
		}

		vint Length()const
		{
			return length;
		}

		vint IndexOf(T c)const
		{
			const T* reading=buffer+start;
			for(vint i=0;i<length;i++)
			{
				if(reading[i]==c)
					return i;
			}
			return -1;
		}

		ObjectString<T> Left(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Left(vint)#参数count越界。");
			return ObjectString<T>(*this, 0, count);
		}

		ObjectString<T> Right(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Right(vint)#参数count越界。");
			return ObjectString<T>(*this, length-count, count);
		}

		ObjectString<T> Sub(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Sub(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Sub(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, index, count);
		}

		ObjectString<T> Remove(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Remove(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Remove(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, ObjectString<T>(), index, count);
		}

		ObjectString<T> Insert(vint index, const ObjectString<T>& string)const
		{
			CHECK_ERROR(index>=0 && index<=length, L"ObjectString<T>::Insert(vint)#参数count越界。");
			return ObjectString<T>(*this, string, index, 0);
		}

		friend bool operator<(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<0;
		}

		friend bool operator<=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<=0;
		}

		friend bool operator>(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>0;
		}

		friend bool operator>=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>=0;
		}

		friend bool operator==(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)==0;
		}

		friend bool operator!=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)!=0;
		}

		friend ObjectString<T> operator+(const T* left, const ObjectString<T>& right)
		{
			return WString(left, false)+right;
		}
	};

	template<typename T>
	ObjectString<T> ObjectString<T>::Empty=ObjectString<T>();

	typedef ObjectString<char>		AString;
	typedef ObjectString<wchar_t>	WString;

	extern vint					atoi(const AString& string);
	extern vint					wtoi(const WString& string);
	extern __int64				atoi64(const AString& string);
	extern __int64				wtoi64(const WString& string);
	extern vuint				atou(const AString& string);
	extern vuint				wtou(const WString& string);
	extern unsigned __int64		atou64(const AString& string);
	extern unsigned __int64		wtou64(const WString& string);
	extern double				atof(const AString& string);
	extern double				wtof(const WString& string);
	extern AString				itoa(vint number);
	extern WString				itow(vint number);
	extern AString				i64toa(__int64 number);
	extern WString				i64tow(__int64 number);
	extern AString				utoa(vuint number);
	extern WString				utow(vuint number);
	extern AString				u64toa(unsigned __int64 number);
	extern WString				u64tow(unsigned __int64 number);
	extern AString				ftoa(double number);
	extern WString				ftow(double number);
	extern vint					_wtoa(const wchar_t* w, char* a, vint chars);
	extern AString				wtoa(const WString& string);
	extern vint					_atow(const char* a, wchar_t* w, vint chars);
	extern WString				atow(const AString& string);
	extern AString				alower(const AString& string);
	extern WString				wlower(const WString& string);
	extern AString				aupper(const AString& string);
	extern WString				wupper(const WString& string);
}

#endif

/***********************************************************************
CONSOLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
UI::Console

***********************************************************************/

#ifndef VCZH_CONSOLE
#define VCZH_CONSOLE


namespace vl
{
	namespace console
	{
		class Console abstract
		{
		public:
			static void Write(const wchar_t* string, vint length);
			static void Write(const wchar_t* string);
			static void Write(const WString& string);
			static void WriteLine(const WString& string);
			static WString Read();
			static void SetColor(bool red, bool green, bool blue, bool light);
			static void SetTitle(const WString& string);
		};
	}
}

#endif

/***********************************************************************
EXCEPTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Exception

Classes:
	Exception									：异常
	ArgumentException							：预料的的参数错误
***********************************************************************/

#ifndef VCZH_EXCEPTION
#define VCZH_EXCEPTION


namespace vl
{
	class Exception : public Object
	{
	protected:
		WString						message;

	public:
		Exception(const WString& _message=WString::Empty);

		const WString&				Message()const;
	};

	class ArgumentException : public Exception
	{
	protected:
		WString						function;
		WString						name;

	public:
		ArgumentException(const WString& _message=WString::Empty, const WString& _function=WString::Empty, const WString& _name=WString::Empty);

		const WString&				GetFunction()const;
		const WString&				GetName()const;
	};

	class ParsingException : public Exception
	{
	protected:
		vint							position;
		WString						expression;

	public:
		ParsingException(const WString& _message, const WString& _expression, vint _position);

		const WString&				GetExpression()const;
		vint							GetPosition()const;
	};
}

#endif

/***********************************************************************
COLLECTIONS\PAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Pair

Classes:
	Pair<K, V>							：二元组
***********************************************************************/

#ifndef VCZH_COLLECTIONS_PAIR
#define VCZH_COLLECTIONS_PAIR


namespace vl
{
	namespace collections
	{
		template<typename K, typename V>
		class Pair
		{
		public:
			K				key;
			V				value;

			Pair()
			{
			}

			Pair(const K& _key, const V& _value)
			{
				key=_key;
				value=_value;
			}

			Pair(const Pair<K, V>& pair)
			{
				key=pair.key;
				value=pair.value;
			}

			vint CompareTo(const Pair<K, V>& pair)const
			{
				if(key<pair.key)
				{
					return -1;
				}
				else if(key>pair.key)
				{
					return 1;
				}
				else if(value<pair.value)
				{
					return -1;
				}
				else if(value>pair.value)
				{
					return 1;
				}
				else
				{
					return 0;
				}
			}

			bool operator==(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)==0;
			}

			bool operator!=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)!=0;
			}

			bool operator<(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<0;
			}

			bool operator<=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<=0;
			}

			bool operator>(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>0;
			}

			bool operator>=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>=0;
			}
		};
	}

	template<typename K, typename V>
	struct POD<collections::Pair<K, V>>
	{
		static const bool Result=POD<K>::Result && POD<V>::Result;
	};
}

#endif

/***********************************************************************
COLLECTIONS\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Interfaces

Interfaces:
	IEnumerator<T>									：枚举器
	IEnumerable<T>									：可枚举对象
***********************************************************************/

#ifndef VCZH_COLLECTIONS_INTERFACES
#define VCZH_COLLECTIONS_INTERFACES


namespace vl
{
	namespace collections
	{

/***********************************************************************
接口
***********************************************************************/

		template<typename T>
		class IEnumerator : public virtual Interface
		{
		public:
			virtual IEnumerator<T>*						Clone()const=0;
			virtual const T&							Current()const=0;
			virtual vint								Index()const=0;
			virtual bool								Next()=0;
			virtual void								Reset()=0;
		};

		template<typename T>
		class IEnumerable : public virtual Interface
		{
		public:
			typedef T									ElementType;

			virtual IEnumerator<T>*						CreateEnumerator()const=0;
		};

/***********************************************************************
随机存取
***********************************************************************/

		namespace randomaccess_internal
		{
			template<typename T>
			struct RandomAccessable
			{
				static const bool							CanRead = false;
				static const bool							CanResize = false;
			};

			template<typename T>
			struct RandomAccess
			{
				static vint GetCount(const T& t)
				{
					return t.Count();
				}

				static const typename T::ElementType& GetValue(const T& t, vint index)
				{
					return t.Get(index);
				}

				static void SetCount(T& t, vint count)
				{
					t.Resize(count);
				}

				static void SetValue(T& t, vint index, const typename T::ElementType& value)
				{
					t.Set(index, value);
				}

				static void AppendValue(T& t, const typename T::ElementType& value)
				{
					t.Add(value);
				}
			};
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\LIST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::List

Classes:
	ListStore<T,PODType>				：列表存储复制算法
	ListBase<T,K>						：列表基类
	Array<T,K>							：数组
	List<T,K>							：列表
	SortedList<T,K>						：有序列表
***********************************************************************/

#ifndef VCZH_COLLECTIONS_LIST
#define VCZH_COLLECTIONS_LIST

#include <string.h>

namespace vl
{
	namespace collections
	{

/***********************************************************************
储存结构
***********************************************************************/

		template<typename T, bool PODType>
		class ListStore abstract : public Object
		{
		};
		
		template<typename T>
		class ListStore<T, false> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(dest<source)
				{
					for(vint i=0;i<count;i++)
					{
						dest[i]=source[i];
					}
				}
				else if(dest>source)
				{
					for(vint i=count-1;i>=0;i--)
					{
						dest[i]=source[i];
					}
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
				for(vint i=0;i<count;i++)
				{
					dest[i]=T();
				}
			}
		public:
		};
		
		template<typename T>
		class ListStore<T, true> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(count)
				{
					memmove(dest, source, sizeof(T)*count);
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
			}
		public:
		};
		
		template<typename T>
		class ArrayBase abstract : public ListStore<T,POD<T>::Result>, public virtual IEnumerable<T>
		{
		protected:
			class Enumerator : public Object, public virtual IEnumerator<T>
			{
			private:
				const ArrayBase<T>*				container;
				vint							index;

			public:
				Enumerator(const ArrayBase<T>* _container, vint _index=-1)
				{
					container=_container;
					index=_index;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(container, index);
				}

				const T& Current()const
				{
					return container->Get(index);
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					return index>=0 && index<container->Count();
				}

				void Reset()
				{
					index=-1;
				}
			};
			
			T*						buffer;
			vint					count;
		public:
			ArrayBase()
				:buffer(0)
				,count(0)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			vint Count()const
			{
				return count;
			}

			const T& Get(vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ArrayBase<T, K>::Get(vint)#参数越界。");
				return buffer[index];
			}

			const T& operator[](vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ArrayBase<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class ListBase abstract : public ArrayBase<T>
		{
		protected:
			vint					capacity;
			bool					lessMemoryMode;

			vint CalculateCapacity(vint expected)
			{
				vint result=capacity;
				while(result<expected)
				{
					result=result*5/4+1;
				}
				return result;
			}

			void MakeRoom(vint index, vint _count)
			{
				vint newCount=count+_count;
				if(newCount>capacity)
				{
					vint newCapacity=CalculateCapacity(newCount);
					T* newBuffer=new T[newCapacity];
					CopyObjects(newBuffer, buffer, index);
					CopyObjects(newBuffer+index+_count, buffer+index, count-index);
					delete[] buffer;
					capacity=newCapacity;
					buffer=newBuffer;
				}
				else
				{
					CopyObjects(buffer+index+_count, buffer+index, count-index);
				}
				count=newCount;
			}

			void ReleaseUnnecessaryBuffer(vint previousCount)
			{
				if(buffer && count<previousCount)
				{
					ClearObjects(&buffer[count], previousCount-count);
				}
				if(lessMemoryMode && count<=capacity/2)
				{
					vint newCapacity=capacity*5/8;
					if(count<newCapacity)
					{
						T* newBuffer=new T[newCapacity];
						CopyObjects(newBuffer, buffer, count);
						delete[] buffer;
						capacity=newCapacity;
						buffer=newBuffer;
					}
				}
			}
		public:
			ListBase()
			{
				count=0;
				capacity=0;
				buffer=0;
				lessMemoryMode=true;
			}

			~ListBase()
			{
				delete[] buffer;
			}

			void SetLessMemoryMode(bool mode)
			{
				lessMemoryMode=mode;
			}

			bool RemoveAt(vint index)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::RemoveAt(vint)#参数index越界。");
				CopyObjects(buffer+index,buffer+index+1,count-index-1);
				count--;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool RemoveRange(vint index, vint _count)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<=count, L"ListBase<T, K>::RemoveRange(vint, vint)#参数index越界。");
				CHECK_ERROR(index+_count>=0 && index+_count<=count, L"ListBase<T,K>::RemoveRange(vint, vint)#参数_count越界。");
				CopyObjects(buffer+index, buffer+index+_count, count-index-_count);
				count-=_count;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool Clear()
			{
				vint previousCount=count;
				count=0;
				if(lessMemoryMode)
				{
					capacity=0;
					delete[] buffer;
					buffer=0;
				}
				else
				{
					ReleaseUnnecessaryBuffer(previousCount);
				}
				return true;
			}
		};

/***********************************************************************
列表对象
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class Array : public ArrayBase<T>
		{
		protected:
			void Create(vint size)
			{
				if(size>0)
				{
					count=size;
					buffer=new T[size];
				}
				else
				{
					count=0;
					buffer=0;
				}
			}

			void Destroy()
			{
				count=0;
				delete[] buffer;
				buffer=0;
			}
		public:
			Array(vint size=0)
			{
				Create(size);
			}

			Array(const T* _buffer, vint size)
			{
				Create(size);
				CopyObjects(buffer, _buffer, size);
			}

			~Array()
			{
				Destroy();
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			void Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
			}

			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			void Resize(vint size)
			{
				vint oldCount=count;
				T* oldBuffer=buffer;
				Create(size);
				CopyObjects(buffer, oldBuffer, (count<oldCount?count:oldCount));
				delete[] oldBuffer;
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class List : public ListBase<T, K>
		{
		public:
			List()
			{
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			vint Add(const T& item)
			{
				MakeRoom(count, 1);
				buffer[count-1]=item;
				return count-1;
			}

			vint Insert(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<=count, L"List<T, K>::Insert(vint, const T&)#参数index越界。");
				MakeRoom(index,1);
				buffer[index]=item;
				return index;
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
				return true;
			}

			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class SortedList : public ListBase<T, K>
		{
		public:
			SortedList()
			{
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			template<typename Key>
			vint IndexOf(const Key& item)const
			{
				vint start=0;
				vint end=count-1;
				while(start<=end)
				{
					vint index=(start+end)/2;
					if(buffer[index]==item)
					{
						return index;
					}
					else if(buffer[index]>item)
					{
						end=index-1;
					}
					else
					{
						start=index+1;
					}
				}
				return -1;
			}

			vint IndexOf(const K& item)const
			{
				return IndexOf<K>(item);
			}

			vint Add(const T& item)
			{
				if(count==0)
				{
					MakeRoom(0, 1);
					buffer[0]=item;
					return 0;
				}
				else
				{
					vint start=0;
					vint end=count-1;
					vint index=-1;
					while(start<=end)
					{
						index=(start+end)/2;
						if(buffer[index]==item)
						{
							goto SORTED_LIST_INSERT;
						}
						else if(buffer[index]>item)
						{
							end=index-1;
						}
						else
						{
							start=index+1;
						}
					}
					CHECK_ERROR(index>=0 && index<count, L"SortedList<T, K>::Add(const T&)#内部错误，变量index越界");
					if(buffer[index]<item)
					{
						index++;
					}
SORTED_LIST_INSERT:
					MakeRoom(index, 1);
					buffer[index]=item;
					return index;
				}
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}
		};

/***********************************************************************
随机访问
***********************************************************************/

		namespace randomaccess_internal
		{
			template<typename T, typename K>
			struct RandomAccessable<Array<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = true;
			};

			template<typename T, typename K>
			struct RandomAccessable<List<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};

			template<typename T, typename K>
			struct RandomAccessable<SortedList<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\DICTIONARY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Dictionary

Classes:
	Dictionary<KT, VT, KK, VK>					：映射
	Group<KT, VT, KK, VK>						：多重映射
***********************************************************************/

#ifndef VCZH_COLLECTIONS_DICTIONARY
#define VCZH_COLLECTIONS_DICTIONARY


namespace vl
{
	namespace collections
	{
		template<
			typename KT,
			typename VT,
			typename KK=typename KeyType<KT>::Type, 
			typename VK=typename KeyType<VT>::Type
		>
		class Dictionary : public Object, public virtual IEnumerable<Pair<KT, VT>>
		{
			typedef SortedList<KT, KK>			KeyContainer;
			typedef List<VT, VK>				ValueContainer;
		protected:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const Dictionary<KT, VT, KK, VK>*	container;
				vint								index;
				Pair<KT, VT>						current;

				void UpdateCurrent()
				{
					if(index<container->Count())
					{
						current.key=container->Keys().Get(index);
						current.value=container->Values().Get(index);
					}
				}
			public:
				Enumerator(const Dictionary<KT, VT, KK, VK>* _container, vint _index=-1)
				{
					container=_container;
					index=_index;
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, index);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					UpdateCurrent();
					return index>=0 && index<container->Count();
				}

				void Reset()
				{
					index=-1;
					UpdateCurrent();
				}
			};

			KeyContainer						keys;
			ValueContainer						values;
		public:
			Dictionary()
			{
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			void SetLessMemoryMode(bool mode)
			{
				keys.SetLessMemoryMode(mode);
				values.SetLessMemoryMode(mode);
			}

			const KeyContainer& Keys()const
			{
				return keys;
			}

			const ValueContainer& Values()const
			{
				return values;
			}

			vint Count()const
			{
				return keys.Count();
			}

			const VT& Get(const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			const VT& operator[](const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			bool Set(const KK& key, const VT& value)
			{
				vint index=keys.IndexOf(key);
				if(index==-1)
				{
					index=keys.Add(key);
					values.Insert(index, value);
				}
				else
				{
					values[index]=value;
				}
				return true;
			}

			bool Add(const Pair<KT, VT>& value)
			{
				return Add(value.key, value.value);
			}

			bool Add(const KT& key, const VT& value)
			{
				CHECK_ERROR(!keys.Contains(key), L"Dictionary<KT, KK, ValueContainer, VT, VK>::Add(const KT&, const VT&)#key已存在。");
				vint index=keys.Add(key);
				values.Insert(index, value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					values.RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				keys.Clear();
				values.Clear();
				return true;
			}
		};

		template<
			typename KT,
			typename VT,
			typename KK=typename KeyType<KT>::Type,
			typename VK=typename KeyType<VT>::Type
		>
		class Group : public Object, public virtual IEnumerable<Pair<KT, VT>>
		{
			typedef SortedList<KT, KK>		KeyContainer;
			typedef List<VT, VK>			ValueContainer;
		protected:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const Group<KT, VT, KK, VK>*		container;
				vint								keyIndex;
				vint								valueIndex;
				Pair<KT, VT>						current;

				void UpdateCurrent()
				{
					if(keyIndex<container->Count())
					{
						const ValueContainer& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							current.key=container->Keys().Get(keyIndex);
							current.value=values.Get(valueIndex);
						}
					}
				}
			public:
				Enumerator(const Group<KT, VT, KK, VK>* _container, vint _keyIndex=-1, vint _valueIndex=-1)
				{
					container=_container;
					keyIndex=_keyIndex;
					valueIndex=_valueIndex;
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, keyIndex, valueIndex);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					if(0<=keyIndex && keyIndex<container->Count())
					{
						vint index=0;
						for(vint i=0;i<keyIndex;i++)
						{
							index+=container->GetByIndex(i).Count();
						}
						return index+valueIndex;
					}
					else
					{
						return -1;
					}
				}

				bool Next()
				{
					if(keyIndex==-1)
					{
						keyIndex=0;
					}
					while(keyIndex<container->Count())
					{
						valueIndex++;
						const ValueContainer& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							UpdateCurrent();
							return true;
						}
						else
						{
							keyIndex++;
							valueIndex=-1;
						}
					}
					return false;
				}

				void Reset()
				{
					keyIndex=-1;
					valueIndex=-1;
					UpdateCurrent();
				}
			};

			KeyContainer					keys;
			List<ValueContainer*>			values;
		public:
			Group()
			{
			}

			~Group()
			{
				Clear();
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			const KeyContainer& Keys()const
			{
				return keys;
			}

			vint Count()const
			{
				return keys.Count();
			}

			const ValueContainer& Get(const KK& key)const
			{
				return *values.Get(keys.IndexOf(key));
			}

			const ValueContainer& GetByIndex(vint index)const
			{
				return *values.Get(index);
			}

			const ValueContainer& operator[](const KK& key)const
			{
				return *values.Get(keys.IndexOf(key));
			}

			bool Contains(const KK& key)const
			{
				return keys.Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					return values.Get(index)->Contains(value);
				}
				else
				{
					return false;
				}
			}

			bool Add(const Pair<KT, VT>& value)
			{
				return Add(value.key, value.value);
			}

			bool Add(const KT& key, const VT& value)
			{
				ValueContainer* target=0;
				vint index=keys.IndexOf(key);
				if(index==-1)
				{
					target=new ValueContainer;
					values.Insert(keys.Add(key), target);
				}
				else
				{
					target=values[index];
				}
				target->Add(value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					List<VT, VK>* target=values[index];
					values.RemoveAt(index);
					delete target;
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Remove(const KK& key, const VK& value)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					List<VT, VK>* target=values[index];
					target->Remove(value);
					if(target->Count()==0)
					{
						keys.RemoveAt(index);
						values.RemoveAt(index);
						delete target;
					}
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				for(vint i=0;i<values.Count();i++)
				{
					delete values[i];
				}
				keys.Clear();
				values.Clear();
				return true;
			}
		};

/***********************************************************************
随机访问
***********************************************************************/
		namespace randomaccess_internal
		{
			template<typename KT, typename VT, typename KK, typename VK>
			struct RandomAccessable<Dictionary<KT, VT, KK, VK>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		
			template<typename KT, typename VT, typename KK, typename VK>
			struct RandomAccess<Dictionary<KT, VT, KK, VK>>
			{
				static vint GetCount(const Dictionary<KT, VT, KK, VK>& t)
				{
					return t.Count();
				}

				static Pair<KT, VT> GetValue(const Dictionary<KT, VT, KK, VK>& t, vint index)
				{
					return Pair<KT, VT>(t.Keys().Get(index), t.Values().Get(index));
				}

				static void AppendValue(Dictionary<KT, VT, KK, VK>& t, const Pair<KT, VT>& value)
				{
					t.Set(value.key, value.value);
				}
			};
		}
	}
}

#endif

/***********************************************************************
HTTPUTILITY.H
***********************************************************************/
#ifndef VCZH_HTTPUTILITY
#define VCZH_HTTPUTILITY


namespace vl
{

/***********************************************************************
HTTP Utility
***********************************************************************/

	class HttpRequest
	{
		typedef collections::Array<char>					BodyBuffer;
		typedef collections::List<WString>					StringList;
		typedef collections::Dictionary<WString, WString>	HeaderMap;
	public:
		WString				server;
		vint				port;
		WString				query;
		bool				secure;
		WString				username;
		WString				password;
		WString				method;
		WString				cookie;
		BodyBuffer			body;
		WString				contentType;
		StringList			acceptTypes;
		HeaderMap			extraHeaders;

		HttpRequest();
		bool				SetHost(const WString& inputQuery);
		void				SetBodyUtf8(const WString& bodyString);
	};

	class HttpResponse
	{
		typedef collections::Array<char>		BodyBuffer;
	public:
		vint				statusCode;
		BodyBuffer			body;
		WString				cookie;

		HttpResponse();
		WString				GetBodyUtf8();
	};

	extern bool				HttpQuery(const HttpRequest& request, HttpResponse& response);
	extern WString			UrlEncodeQuery(const WString& query);
}

#endif

/***********************************************************************
POINTER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Smart Pointer

Classes:
	Ptr<T>							：智能指针
***********************************************************************/

#ifndef VCZH_POINTER
#define VCZH_POINTER


namespace vl
{
	template<typename T>
	class Ptr
	{
		 template<typename X>
		 friend class Ptr;
	protected:
		vint*				counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				(*counter)++;
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(--(*counter)==0)
				{
					delete counter;
					delete reference;
					counter=0;
					reference=0;
				}
			}
		}

		vint* Counter()const
		{
			return counter;
		}

		Ptr(vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		Ptr()
		{
			counter=0;
			reference=0;
		}

		Ptr(T* pointer)
		{
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		Ptr(const Ptr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		template<typename C>
		Ptr(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		~Ptr()
		{
			Dec();
		}

		template<typename C>
		Ptr<C> Cast()const
		{
			C* converted=dynamic_cast<C*>(reference);
			return Ptr<C>((converted?counter:0), converted);
		}

		Ptr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		Ptr<T>& operator=(const Ptr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		template<typename C>
		Ptr<T>& operator=(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			Dec();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const Ptr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const Ptr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const Ptr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const Ptr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const Ptr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const Ptr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

	template<typename T>
	class ComPtr
	{
	protected:
		vint*				counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				(*counter)++;
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(--(*counter)==0)
				{
					delete counter;
					reference->Release();
					counter=0;
					reference=0;
				}
			}
		}

		vint* Counter()const
		{
			return counter;
		}

		ComPtr(vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		ComPtr()
		{
			counter=0;
			reference=0;
		}

		ComPtr(T* pointer)
		{
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		ComPtr(const ComPtr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		~ComPtr()
		{
			Dec();
		}

		ComPtr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		ComPtr<T>& operator=(const ComPtr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const ComPtr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const ComPtr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const ComPtr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const ComPtr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const ComPtr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const ComPtr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

	template<typename T>
	struct KeyType<Ptr<T>>
	{
		typedef T* Type;
	};

	template<typename T>
	struct POD<Ptr<T>>
	{
		static const bool Result=false;
	};

	template<typename T>
	struct KeyType<ComPtr<T>>
	{
		typedef T* Type;
	};

	template<typename T>
	struct POD<ComPtr<T>>
	{
		static const bool Result=false;
	};
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONFOREACH.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

扩展：
	实现一个函数重载IteratorType CreateForEachIterator(const CollectionType& collection);
	CollectionType是所需要的容器类型
	IteratorType继承自ForEachIterator<T>
	必须写在vl::collections命名空间里
***********************************************************************/

#ifndef VCZH_COLLECTIONS_FOREACH
#define VCZH_COLLECTIONS_FOREACH

namespace vl
{
	namespace collections
	{

/***********************************************************************
ForEach基础设施
***********************************************************************/

		template<typename T>
		class ForEachIterator : public Object
		{
		public:
			virtual bool				Next(T& variable)const=0;

			operator bool()const
			{
				return true;
			}
		};

/***********************************************************************
IEnumerable<T>支持
***********************************************************************/

		template<typename T>
		class EnumerableForEachIterator : public ForEachIterator<T>
		{
		protected:
			Ptr<IEnumerator<T>>			enumerator;
		public:
			EnumerableForEachIterator(const IEnumerable<T>& enumerable)
				:enumerator(enumerable.CreateEnumerator())
			{
			}

			EnumerableForEachIterator(const EnumerableForEachIterator<T>& enumerableIterator)
				:enumerator(enumerableIterator.iterator)
			{
			}

			bool Next(T& variable)const
			{
				if(enumerator->Next())
				{
					variable=enumerator->Current();
					return true;
				}
				else
				{
					return false;
				}
			}
		};

		template<typename T>
		EnumerableForEachIterator<T> CreateForEachIterator(const IEnumerable<T>& enumerable)
		{
			return enumerable;
		}

/***********************************************************************
ForEach宏
***********************************************************************/

#define SCOPE_VARIABLE(TYPE, VARIABLE, VALUE)\
		if(bool __scope_variable_flag__=true)\
			for(TYPE VARIABLE = VALUE;__scope_variable_flag__;__scope_variable_flag__=false)

#define FOREACH(TYPE, VARIABLE, COLLECTION)\
		SCOPE_VARIABLE(const ForEachIterator<TYPE>&, __foreach_iterator__, CreateForEachIterator(COLLECTION))\
		for(TYPE VARIABLE;__foreach_iterator__.Next(VARIABLE);)

#define FOREACH_INDEXER(TYPE, VARIABLE, INDEXER, COLLECTION)\
		SCOPE_VARIABLE(const ForEachIterator<TYPE>&, __foreach_iterator__, CreateForEachIterator(COLLECTION))\
		SCOPE_VARIABLE(vint, INDEXER, 0)\
		for(TYPE VARIABLE;__foreach_iterator__.Next(VARIABLE);INDEXER++)
	}
}

#endif

/***********************************************************************
LOCALE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Locale

Interfaces:
***********************************************************************/

#ifndef VCZH_LOCALE
#define VCZH_LOCALE


namespace vl
{
	class Locale : public Object
	{
	protected:
		WString						localeName;

	public:
		Locale(const WString& _localeName=WString::Empty);
		~Locale();

		static Locale				Invariant();
		static Locale				SystemDefault();
		static Locale				UserDefault();
		static void					Enumerate(collections::List<Locale>& locales);

		const WString&				GetName()const;

		void						GetShortDateFormats(collections::List<WString>& formats);
		void						GetLongDateFormats(collections::List<WString>& formats);
		void						GetYearMonthDateFormats(collections::List<WString>& formats);
		void						GetLongTimeFormats(collections::List<WString>& formats);
		void						GetShortTimeFormats(collections::List<WString>& formats);
		WString						FormatDate(const WString& format, DateTime date);
		WString						FormatTime(const WString& format, DateTime time);
		WString						FormatNumber(const WString& number);
		WString						FormatCurrency(const WString& currency);

		WString						ToFullWidth(const WString& str);
		WString						ToHalfWidth(const WString& str);
		WString						ToHiragana(const WString& str);
		WString						ToKatagana(const WString& str);
		WString						ToLower(const WString& str);
		WString						ToUpper(const WString& str);
		WString						ToLinguisticLower(const WString& str);
		WString						ToLinguisticUpper(const WString& str);
		WString						ToSimplifiedChinese(const WString& str);
		WString						ToTraditionalChinese(const WString& str);
		WString						ToTileCase(const WString& str);

		enum Normalization
		{
			None=0,
			IgnoreCase=1,
			IgnoreCaseLinguistic=2,
			IgnoreKanaType=4,
			IgnoreNonSpace=8,
			IgnoreSymbol=16,
			IgnoreWidth=32,
			DigitsAsNumbers=64,
			StringSoft=128,
		};
		vint									Compare(const WString& s1, const WString& s2, Normalization normalization);
		vint									CompareOrdinal(const WString& s1, const WString& s2);
		vint									CompareOrdinalIgnoreCase(const WString& s1, const WString& s2);
		collections::Pair<vint, vint>			FindFirst(const WString& text, const WString& find, Normalization normalization);
		collections::Pair<vint, vint>			FindLast(const WString& text, const WString& find, Normalization normalization);
		bool									StartsWith(const WString& text, const WString& find, Normalization normalization);
		bool									EndsWidth(const WString& text, const WString& find, Normalization normalization);
	};
}

#endif

/***********************************************************************
REGEX\REGEX.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::Regular Expression

Classes:
	RegexString						：字符串匹配结果
	RegexMatch						：匹配结果
	Regex							：正则表达式引擎
	RegexToken						：词法记号
	RegexTokens						：词法记号表
	RegexLexer						：词法分析器
***********************************************************************/

#ifndef VCZH_REGEX_REGEX
#define VCZH_REGEX_REGEX


namespace vl
{
	namespace regex_internal
	{
		class PureResult;
		class PureInterpretor;
		class RichResult;
		class RichInterpretor;
	}

	namespace regex
	{

/***********************************************************************
正则表达式引擎数据结构
***********************************************************************/

		class RegexString : public Object
		{
		protected:
			WString										value;
			vint										start;
			vint										length;

		public:
			RegexString(vint _start=0);
			RegexString(const WString& _string, vint _start, vint _length);

			vint										Start()const;
			vint										Length()const;
			const WString&								Value()const;
			bool										operator==(const RegexString& string)const;
		};

		class RegexMatch : public Object, private NotCopyable
		{
			friend class Regex;
		public:
			typedef Ptr<RegexMatch>										Ref;
			typedef collections::List<Ref>								List;
			typedef collections::List<RegexString>						CaptureList;
			typedef collections::Group<WString, RegexString>			CaptureGroup;
		protected:
			collections::List<RegexString>				captures;
			collections::Group<WString, RegexString>	groups;
			bool										success;
			RegexString									result;

			RegexMatch(const WString& _string, regex_internal::PureResult* _result);
			RegexMatch(const WString& _string, regex_internal::RichResult* _result, regex_internal::RichInterpretor* _rich);
			RegexMatch(const RegexString& _result);
		public:
			
			bool										Success()const;
			const RegexString&							Result()const;
			const CaptureList&							Captures()const;
			const CaptureGroup&							Groups()const;
		};

/***********************************************************************
正则表达式引擎
***********************************************************************/

		class Regex : public Object, private NotCopyable
		{
		protected:
			regex_internal::PureInterpretor*			pure;
			regex_internal::RichInterpretor*			rich;

			void										Process(const WString& text, bool keepEmpty, bool keepSuccess, bool keepFail, RegexMatch::List& matches)const;
		public:
			Regex(const WString& code, bool preferPure=true);
			~Regex();

			bool										IsPureMatch()const;
			bool										IsPureTest()const;

			RegexMatch::Ref								MatchHead(const WString& text)const;
			RegexMatch::Ref								Match(const WString& text)const;
			bool										TestHead(const WString& text)const;
			bool										Test(const WString& text)const;
			void										Search(const WString& text, RegexMatch::List& matches)const;
			void										Split(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const;
			void										Cut(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const;
		};

/***********************************************************************
正则表达式词法分析器
***********************************************************************/

		class RegexToken
		{
		public:
			vint										start;
			vint										length;
			vint										token;
			const wchar_t*								reading;
			vint										codeIndex;

			vint										rowStart;
			vint										columnStart;
			vint										rowEnd;
			vint										columnEnd;

			bool										operator==(const RegexToken& _token)const;
			bool										operator==(const wchar_t* _token)const;
		};

		class RegexTokens : public Object, public collections::IEnumerable<RegexToken>
		{
			friend class RegexLexer;
		protected:
			regex_internal::PureInterpretor*			pure;
			const collections::Array<vint>&				stateTokens;
			WString										code;
			vint										codeIndex;
			
			RegexTokens(regex_internal::PureInterpretor* _pure, const collections::Array<vint>& _stateTokens, const WString& _code, vint _codeIndex);
		public:

			collections::IEnumerator<RegexToken>*		CreateEnumerator()const;
			void										ReadToEnd(collections::List<RegexToken>& tokens, bool(*discard)(vint)=0)const;
		};

		class RegexLexerWalker : public Object
		{
			friend class RegexLexer;
		protected:
			regex_internal::PureInterpretor*			pure;
			const collections::Array<vint>&				stateTokens;
			
			RegexLexerWalker(regex_internal::PureInterpretor* _pure, const collections::Array<vint>& _stateTokens);
		public:
			RegexLexerWalker(const RegexLexerWalker& walker);
			~RegexLexerWalker();

			vint										GetStartState()const;
			vint										GetRelatedToken(vint state)const;
			void										Walk(wchar_t input, vint& state, vint& token, bool& finalState, bool& previousTokenStop)const;
			vint										Walk(wchar_t input, vint state)const;
		};

		class RegexLexerColorizer : public Object
		{
			friend class RegexLexer;
		public:
			typedef void(*TokenProc)(void* argument, vint start, vint length, vint token);

		protected:
			RegexLexerWalker							walker;
			vint										currentState;

			RegexLexerColorizer(const RegexLexerWalker& _walker);
		public:
			RegexLexerColorizer(const RegexLexerColorizer& colorizer);
			~RegexLexerColorizer();

			void										Reset(vint state);
			void										Pass(wchar_t input);
			vint										GetStartState()const;
			vint										GetCurrentState()const;
			void										Colorize(const wchar_t* input, vint length, TokenProc tokenProc, void* tokenProcArgument);
		};

		class RegexLexer : public Object, private NotCopyable
		{
		protected:
			regex_internal::PureInterpretor*			pure;
			collections::Array<vint>					ids;
			collections::Array<vint>					stateTokens;
		public:
			RegexLexer(const collections::IEnumerable<WString>& tokens);
			~RegexLexer();

			RegexTokens									Parse(const WString& code, vint codeIndex=-1)const;
			RegexLexerWalker							Walk()const;
			RegexLexerColorizer							Colorize()const;
		};
	}
}

#endif

/***********************************************************************
STREAM\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::Interfaces

Interfaces:
	IStream							：流
***********************************************************************/

#ifndef VCZH_STREAM_INTERFACES
#define VCZH_STREAM_INTERFACES


namespace vl
{
	namespace stream
	{
		class IStream : public virtual Interface
		{
		public:
			virtual bool					CanRead()const=0;
			virtual bool					CanWrite()const=0;
			virtual bool					CanSeek()const=0;
			virtual bool					CanPeek()const=0;
			virtual bool					IsLimited()const=0;
			virtual bool					IsAvailable()const=0;
			virtual void					Close()=0;
			virtual pos_t					Position()const=0;
			virtual pos_t					Size()const=0;
			virtual void					Seek(pos_t _size)=0;
			virtual void					SeekFromBegin(pos_t _size)=0;
			virtual void					SeekFromEnd(pos_t _size)=0;
			virtual vint					Read(void* _buffer, vint _size)=0;
			virtual vint					Write(void* _buffer, vint _size)=0;
			virtual vint					Peek(void* _buffer, vint _size)=0;
		};

		class IEncoder : public Interface
		{
		public:
			virtual void					Setup(IStream* _stream)=0;
			virtual	void					Close()=0;
			virtual vint					Write(void* _buffer, vint _size)=0;
		};

		class IDecoder : public Interface
		{
		public:
			virtual void					Setup(IStream* _stream)=0;
			virtual	void					Close()=0;
			virtual vint					Read(void* _buffer, vint _size)=0;
		};
	}
}

#endif

/***********************************************************************
STREAM\ACCESSOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::Accessor

Classes:
	TextReader						：字符串阅读器
	TextWriter						：字符串书写器
	StreamReader					：流阅读器
	StreamWriter					：流书写器
	EncoderStream					：编码流
	DecoderStream					：解码流
***********************************************************************/

#ifndef VCZH_STREAM_ACCESSOR
#define VCZH_STREAM_ACCESSOR


namespace vl
{
	namespace stream
	{

/***********************************************************************
流控制器
***********************************************************************/

		class TextReader : public Object, private NotCopyable
		{
		public:
			virtual bool				IsEnd()=0;
			virtual wchar_t				ReadChar()=0;
			virtual WString				ReadString(vint length);
			virtual WString				ReadLine();
			virtual WString				ReadToEnd();
		};

		class TextWriter : public Object, private NotCopyable
		{
		public:
			virtual void				WriteChar(wchar_t c)=0;
			virtual void				WriteString(const wchar_t* string, vint charCount);
			virtual void				WriteString(const wchar_t* string);
			virtual void				WriteString(const WString& string);
			virtual void				WriteLine(const wchar_t* string, vint charCount);
			virtual void				WriteLine(const wchar_t* string);
			virtual void				WriteLine(const WString& string);

			virtual void				WriteMonospacedEnglishTable(collections::Array<WString>& tableByRow, vint rows, vint columns);
		};

		class StringReader : public TextReader
		{
		protected:
			WString						string;
			vint						current;
			bool						lastCallIsReadLine;

			void						PrepareIfLastCallIsReadLine();
		public:
			StringReader(const WString& _string);

			bool						IsEnd();
			wchar_t						ReadChar();
			WString						ReadString(vint length);
			WString						ReadLine();
			WString						ReadToEnd();
		};

		class StreamReader : public TextReader
		{
		protected:
			IStream*					stream;
		public:
			StreamReader(IStream& _stream);

			bool						IsEnd();
			wchar_t						ReadChar();
		};

		class StreamWriter : public TextWriter
		{
		protected:
			IStream*					stream;
		public:
			StreamWriter(IStream& _stream);
			using TextWriter::WriteString;

			void						WriteChar(wchar_t c);
			void						WriteString(const wchar_t* string, vint charCount);
		};

/***********************************************************************
编码解码
***********************************************************************/

		class EncoderStream : public virtual IStream
		{
		protected:
			IStream*					stream;
			IEncoder*					encoder;
			pos_t						position;

		public:
			EncoderStream(IStream& _stream, IEncoder& _encoder);
			~EncoderStream();

			bool						CanRead()const;
			bool						CanWrite()const;
			bool						CanSeek()const;
			bool						CanPeek()const;
			bool						IsLimited()const;
			bool						IsAvailable()const;
			void						Close();
			pos_t						Position()const;
			pos_t						Size()const;
			void						Seek(pos_t _size);
			void						SeekFromBegin(pos_t _size);
			void						SeekFromEnd(pos_t _size);
			vint							Read(void* _buffer, vint _size);
			vint							Write(void* _buffer, vint _size);
			vint							Peek(void* _buffer, vint _size);
		};

		class DecoderStream : public virtual IStream
		{
		protected:
			IStream*					stream;
			IDecoder*					decoder;
			pos_t						position;

		public:
			DecoderStream(IStream& _stream, IDecoder& _decoder);
			~DecoderStream();

			bool						CanRead()const;
			bool						CanWrite()const;
			bool						CanSeek()const;
			bool						CanPeek()const;
			bool						IsLimited()const;
			bool						IsAvailable()const;
			void						Close();
			pos_t						Position()const;
			pos_t						Size()const;
			void						Seek(pos_t _size);
			void						SeekFromBegin(pos_t _size);
			void						SeekFromEnd(pos_t _size);
			vint							Read(void* _buffer, vint _size);
			vint							Write(void* _buffer, vint _size);
			vint							Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
PARSING\PARSINGTREE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Parsing Tree

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGTREE
#define VCZH_PARSING_PARSINGTREE


namespace vl
{
	namespace parsing
	{

/***********************************************************************
位置信息
***********************************************************************/

		struct ParsingTextPos
		{
			static const int	UnknownValue=-2;
			vint				index;
			vint				row;
			vint				column;

			ParsingTextPos()
				:index(UnknownValue)
				,row(UnknownValue)
				,column(UnknownValue)
			{
			}

			ParsingTextPos(vint _index)
				:index(_index)
				,row(UnknownValue)
				,column(UnknownValue)
			{
			}

			ParsingTextPos(vint _row, vint _column)
				:index(UnknownValue)
				,row(_row)
				,column(_column)
			{
			}

			ParsingTextPos(vint _index, vint _row, vint _column)
				:index(_index)
				,row(_row)
				,column(_column)
			{
			}

			static vint Compare(const ParsingTextPos& a, const ParsingTextPos& b)
			{
				if(a.index!=UnknownValue && b.index!=UnknownValue)
				{
					return a.index-b.index;
				}
				else if(a.row!=UnknownValue && a.column!=UnknownValue && b.row!=UnknownValue && b.column!=UnknownValue)
				{
					if(a.row==b.row)
					{
						return a.column-b.column;
					}
					else
					{
						return a.row-b.row;
					}
				}
				else
				{
					return 0;
				}
			}

			bool operator==(const ParsingTextPos& pos)const{return Compare(*this, pos)==0;}
			bool operator!=(const ParsingTextPos& pos)const{return Compare(*this, pos)!=0;}
			bool operator<(const ParsingTextPos& pos)const{return Compare(*this, pos)<0;}
			bool operator<=(const ParsingTextPos& pos)const{return Compare(*this, pos)<=0;}
			bool operator>(const ParsingTextPos& pos)const{return Compare(*this, pos)>0;}
			bool operator>=(const ParsingTextPos& pos)const{return Compare(*this, pos)>=0;}
		};

		struct ParsingTextRange
		{
			ParsingTextPos	start;
			ParsingTextPos	end;

			ParsingTextRange()
			{
				end.index=-1;
				end.column=-1;
			}

			ParsingTextRange(const ParsingTextPos& _start, const ParsingTextPos& _end)
				:start(_start)
				,end(_end)
			{
			}

			ParsingTextRange(const regex::RegexToken* startToken, const regex::RegexToken* endToken)
			{
				start.index=startToken->start;
				start.row=startToken->rowStart;
				start.column=startToken->columnStart;
				end.index=endToken->start+endToken->length-1;
				end.row=endToken->rowEnd;
				end.column=endToken->columnEnd;
			}

			bool operator==(const ParsingTextRange& range)const{return start==range.start && end==range.end;}
			bool operator!=(const ParsingTextRange& range)const{return start!=range.start || end!=range.end;}
			bool Contains(const ParsingTextPos& pos)const{return start<=pos && pos<=end;}
			bool Contains(const ParsingTextRange& range)const{return start<=range.start && range.end<=end;}
		};

/***********************************************************************
通用语法树
***********************************************************************/

		class ParsingTreeNode;
		class ParsingTreeToken;
		class ParsingTreeObject;
		class ParsingTreeArray;

		class ParsingTreeNode : public Object
		{
		public:
			class IVisitor : public Interface
			{
			public:
				virtual void			Visit(ParsingTreeToken* node)=0;
				virtual void			Visit(ParsingTreeObject* node)=0;
				virtual void			Visit(ParsingTreeArray* node)=0;
			};

			class TraversalVisitor : public Object, public IVisitor
			{
			public:
				enum TraverseDirection
				{
					ByTextPosition,
					ByStorePosition
				};
			protected:
				TraverseDirection		direction;
			public:
				TraversalVisitor(TraverseDirection _direction);

				virtual void			BeforeVisit(ParsingTreeToken* node);
				virtual void			AfterVisit(ParsingTreeToken* node);
				virtual void			BeforeVisit(ParsingTreeObject* node);
				virtual void			AfterVisit(ParsingTreeObject* node);
				virtual void			BeforeVisit(ParsingTreeArray* node);
				virtual void			AfterVisit(ParsingTreeArray* node);

				virtual void			Visit(ParsingTreeToken* node)override;
				virtual void			Visit(ParsingTreeObject* node)override;
				virtual void			Visit(ParsingTreeArray* node)override;
			};
		protected:
			typedef collections::List<Ptr<ParsingTreeNode>>				NodeList;

			ParsingTextRange			codeRange;
			ParsingTreeNode*			parent;
			NodeList					cachedOrderedSubNodes;

			virtual const NodeList&		GetSubNodesInternal()=0;
			bool						BeforeAddChild(Ptr<ParsingTreeNode> node);
			void						AfterAddChild(Ptr<ParsingTreeNode> node);
			bool						BeforeRemoveChild(Ptr<ParsingTreeNode> node);
			void						AfterRemoveChild(Ptr<ParsingTreeNode> node);
		public:
			ParsingTreeNode(const ParsingTextRange& _codeRange);
			~ParsingTreeNode();

			virtual void				Accept(IVisitor* visitor)=0;
			ParsingTextRange			GetCodeRange();
			void						SetCodeRange(const ParsingTextRange& range);

			void						InitializeQueryCache();
			void						ClearQueryCache();
			ParsingTreeNode*			GetParent();
			const NodeList&				GetSubNodes();

			ParsingTreeNode*			FindSubNode(const ParsingTextPos& position);
			ParsingTreeNode*			FindSubNode(const ParsingTextRange& range);
			ParsingTreeNode*			FindDeepestNode(const ParsingTextPos& position);
			ParsingTreeNode*			FindDeepestNode(const ParsingTextRange& range);
		};

		class ParsingTreeToken : public ParsingTreeNode
		{
		protected:
			WString						value;
			vint						tokenIndex;

			const NodeList&				GetSubNodesInternal()override;
		public:
			ParsingTreeToken(const WString& _value, vint _tokenIndex=-1, const ParsingTextRange& _codeRange=ParsingTextRange());
			~ParsingTreeToken();

			void						Accept(IVisitor* visitor)override;
			vint						GetTokenIndex();
			void						SetTokenIndex(vint _tokenIndex);
			const WString&				GetValue();
			void						SetValue(const WString& _value);
		};

		class ParsingTreeObject : public ParsingTreeNode
		{
		protected:
			typedef collections::Dictionary<WString, Ptr<ParsingTreeNode>>				NodeMap;
			typedef collections::SortedList<WString>									NameList;

			WString						type;
			NodeMap						members;

			const NodeList&			GetSubNodesInternal()override;
		public:
			ParsingTreeObject(const WString& _type=L"", const ParsingTextRange& _codeRange=ParsingTextRange());
			~ParsingTreeObject();

			void						Accept(IVisitor* visitor)override;
			const WString&				GetType();
			void						SetType(const WString& _type);
			NodeMap&					GetMembers();
			Ptr<ParsingTreeNode>		GetMember(const WString& name);
			bool						SetMember(const WString& name, Ptr<ParsingTreeNode> node);
			bool						RemoveMember(const WString& name);
			const NameList&				GetMemberNames();
		};

		class ParsingTreeArray : public ParsingTreeNode
		{
		protected:
			typedef collections::List<Ptr<ParsingTreeNode>>								NodeArray;

			WString						elementType;
			NodeArray					items;

			const NodeList&				GetSubNodesInternal()override;
		public:
			ParsingTreeArray(const WString& _elementType=L"", const ParsingTextRange& _codeRange=ParsingTextRange());
			~ParsingTreeArray();

			void						Accept(IVisitor* visitor)override;
			const WString&				GetElementType();
			void						SetElementType(const WString& _elementType);
			NodeArray&					GetItems();
			Ptr<ParsingTreeNode>		GetItem(vint index);
			bool						SetItem(vint index, Ptr<ParsingTreeNode> node);
			bool						AddItem(Ptr<ParsingTreeNode> node);
			bool						InsertItem(vint index, Ptr<ParsingTreeNode> node);
			bool						RemoveItem(vint index);
			bool						RemoveItem(Ptr<ParsingTreeNode> node);
			vint						IndexOfItem(Ptr<ParsingTreeNode> node);
			bool						ContainsItem(Ptr<ParsingTreeNode> node);
			vint						Count();
			bool						Clear();
		};

/***********************************************************************
辅助函数
***********************************************************************/

		extern void						Log(Ptr<ParsingTreeNode> node, const WString& originalInput, stream::TextWriter& writer, const WString& prefix=L"");

/***********************************************************************
语法树基础设施
***********************************************************************/

		class ParsingTreeCustomBase : public Object
		{
		public:
			ParsingTextRange			codeRange;
		};

		class ParsingToken : public ParsingTreeCustomBase
		{
		public:
			vint						tokenIndex;
			WString						value;

			ParsingToken():tokenIndex(-1){}
		};

		class ParsingError : public Object
		{
		public:
			ParsingTextRange			codeRange;
			const regex::RegexToken*	token;
			ParsingTreeCustomBase*		parsingTree;
			WString						errorMessage;

			ParsingError();
			ParsingError(const WString& _errorMessage);
			ParsingError(const regex::RegexToken* _token, const WString& _errorMessage);
			ParsingError(ParsingTreeCustomBase* _parsingTree, const WString& _errorMessage);
			~ParsingError();
		};

/***********************************************************************
语法树构造
***********************************************************************/

		class ParsingTreeConverter : public Object
		{
		public:
			typedef collections::List<regex::RegexToken>	TokenList;

			virtual Ptr<ParsingTreeCustomBase>				ConvertClass(Ptr<ParsingTreeObject> obj, const TokenList& tokens)=0;

			bool SetMember(ParsingToken& member, Ptr<ParsingTreeNode> node, const TokenList& tokens)
			{
				Ptr<ParsingTreeToken> token=node.Cast<ParsingTreeToken>();
				if(token)
				{
					member.tokenIndex=token->GetTokenIndex();
					member.value=token->GetValue();
					member.codeRange=token->GetCodeRange();
					return true;
				}
				return false;
			}

			template<typename T>
			bool SetMember(collections::List<T>& member, Ptr<ParsingTreeNode> node, const TokenList& tokens)
			{
				Ptr<ParsingTreeArray> arr=node.Cast<ParsingTreeArray>();
				if(arr)
				{
					member.Clear();
					vint count=arr->Count();
					for(vint i=0;i<count;i++)
					{
						T t;
						SetMember(t, arr->GetItem(i), tokens);
						member.Add(t);
					}
					return true;
				}
				return false;
			}

			template<typename T>
			bool SetMember(Ptr<T>& member, Ptr<ParsingTreeNode> node, const TokenList& tokens)
			{
				Ptr<ParsingTreeObject> obj=node.Cast<ParsingTreeObject>();
				if(obj)
				{
					Ptr<ParsingTreeCustomBase> tree=ConvertClass(obj, tokens);
					if(tree)
					{
						tree->codeRange=node->GetCodeRange();
						member=tree.Cast<T>();
						return member;
					}
				}
				return false;
			}
		};
	}
}

#endif

/***********************************************************************
PARSING\PARSINGTABLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Table

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGTABLE
#define VCZH_PARSING_PARSINGTABLE


namespace vl
{
	namespace parsing
	{
		namespace tabling
		{

/***********************************************************************
跳转表
***********************************************************************/

			class ParsingTable : public Object
			{
			public:
				static const vint							TokenBegin=0;
				static const vint							TokenFinish=1;
				static const vint							TryReduce=2;
				static const vint							UserTokenStart=3;

				class TokenInfo
				{
				public:
					WString									name;
					WString									regex;
					vint									regexTokenIndex;

					TokenInfo():regexTokenIndex(-1){}

					TokenInfo(const WString& _name, const WString& _regex)
						:name(_name)
						,regex(_regex)
						,regexTokenIndex(-1)
					{
					}
				};

				class StateInfo
				{
				public:
					WString									ruleName;
					WString									stateName;
					WString									stateExpression;

					StateInfo(){}

					StateInfo(const WString& _ruleName, const WString& _stateName, const WString& _stateExpression)
						:ruleName(_ruleName)
						,stateName(_stateName)
						,stateExpression(_stateExpression)
					{
					}
				};

				class RuleInfo
				{
				public:
					WString									name;
					WString									type;
					vint									rootStartState;

					RuleInfo(){}

					RuleInfo(const WString& _name, const WString& _type, vint _rootStartState)
						:name(_name)
						,type(_type)
						,rootStartState(_rootStartState)
					{
					}
				};

				class Instruction
				{
				public:
					enum InstructionType
					{
						Create,
						Assign,
						Item,
						Using,
						Setter,
						Shift,
						Reduce,
						LeftRecursiveReduce,
					};

					InstructionType							instructionType;
					vint									stateParameter;
					WString									nameParameter;
					WString									value;

					Instruction()
						:instructionType(Create)
						,stateParameter(0)
					{
					}

					Instruction(InstructionType _instructionType, vint _stateParameter, const WString& _nameParameter, const WString& _value)
						:instructionType(_instructionType)
						,stateParameter(_stateParameter)
						,nameParameter(_nameParameter)
						,value(_value)
					{
					}
				};

				class TransitionItem
				{
				public:
					vint									token;
					vint									targetState;
					collections::List<vint>					stackPattern;
					collections::List<Instruction>			instructions;

					enum OrderResult
					{
						CorrectOrder,
						WrongOrder,
						SameOrder,
						UnknownOrder,
					};

					TransitionItem(){}

					TransitionItem(vint _token, vint _targetState)
						:token(_token)
						,targetState(_targetState)
					{
					}

					static OrderResult						CheckOrder(Ptr<TransitionItem> t1, Ptr<TransitionItem> t2, bool forceGivingOrder);
					static vint								Compare(Ptr<TransitionItem> t1, Ptr<TransitionItem> t2);
				};

				class TransitionBag
				{
				public:
					collections::List<Ptr<TransitionItem>>	transitionItems;
				};

			protected:
				Ptr<regex::RegexLexer>						lexer;
				collections::Array<Ptr<TransitionBag>>		transitionBags;
				vint										tokenCount;
				vint										stateCount;
				collections::Array<TokenInfo>				tokenInfos;
				collections::Array<TokenInfo>				discardTokenInfos;
				collections::Array<StateInfo>				stateInfos;
				collections::Array<RuleInfo>				ruleInfos;

			public:
				ParsingTable(vint _tokenCount, vint _discardTokenCount, vint _stateCount, vint _ruleCount);
				~ParsingTable();

				vint										GetTokenCount();
				const TokenInfo&							GetTokenInfo(vint token);
				void										SetTokenInfo(vint token, const TokenInfo& info);

				vint										GetDiscardTokenCount();
				const TokenInfo&							GetDiscardTokenInfo(vint token);
				void										SetDiscardTokenInfo(vint token, const TokenInfo& info);

				vint										GetStateCount();
				const StateInfo&							GetStateInfo(vint state);
				void										SetStateInfo(vint state, const StateInfo& info);

				vint										GetRuleCount();
				const RuleInfo&								GetRuleInfo(vint rule);
				void										SetRuleInfo(vint rule, const RuleInfo& info);

				const regex::RegexLexer&					GetLexer();
				Ptr<TransitionBag>							GetTransitionBag(vint state, vint token);
				void										SetTransitionBag(vint state, vint token, Ptr<TransitionBag> bag);
				void										Initialize();
				bool										IsInputToken(vint regexTokenIndex);
				vint										GetTableTokenIndex(vint regexTokenIndex);
				vint										GetTableDiscardTokenIndex(vint regexTokenIndex);
			};

/***********************************************************************
辅助函数
***********************************************************************/

			extern void										Log(Ptr<ParsingTable> table, stream::TextWriter& writer);
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSINGSTATE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::State

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGSTATE
#define VCZH_PARSING_PARSINGSTATE


namespace vl
{
	namespace parsing
	{
		namespace tabling
		{

/***********************************************************************
语法分析器
***********************************************************************/

			class ParsingState : public Object
			{
			public:
				struct ShiftReduceRange
				{
					regex::RegexToken*							shiftToken;
					regex::RegexToken*							reduceToken;

					ShiftReduceRange()
						:shiftToken(0)
						,reduceToken(0)
					{
					}
				};

				struct TransitionResult
				{
					vint										tableTokenIndex;
					vint										tableStateSource;
					vint										tableStateTarget;
					vint										tokenIndexInStream;
					regex::RegexToken*							token;
					ParsingTable::TransitionItem*				transition;
					Ptr<collections::List<ShiftReduceRange>>	shiftReduceRanges;

					TransitionResult()
						:tableTokenIndex(-1)
						,tableStateSource(-1)
						,tableStateTarget(-1)
						,tokenIndexInStream(-1)
						,token(0)
						,transition(0)
					{
					}

					operator bool()const
					{
						return transition!=0;
					}

					void AddShiftReduceRange(regex::RegexToken* shiftToken, regex::RegexToken* reduceToken)
					{
						ShiftReduceRange range;
						range.shiftToken=shiftToken;
						range.reduceToken=reduceToken;
						if(!shiftReduceRanges)
						{
							shiftReduceRanges=new collections::List<ShiftReduceRange>();
						}
						shiftReduceRanges->Add(range);
					}
				};

				struct Future
				{
					vint									currentState;
					vint									reduceStateCount;
					collections::List<vint>					shiftStates;
					vint									selectedToken;
					Future*									previous;
					Future*									next;

					Future()
						:currentState(-1)
						,reduceStateCount(0)
						,selectedToken(-1)
						,previous(0)
						,next(0)
					{
					}
				};
			private:
				WString										input;
				Ptr<ParsingTable>							table;
				collections::List<regex::RegexToken>		tokens;

				collections::List<vint>						stateStack;
				vint										currentState;
				vint										currentToken;
				vint										tokenSequenceIndex;
				
				collections::List<regex::RegexToken*>		shiftTokenStack;
				regex::RegexToken*							shiftToken;
				regex::RegexToken*							reduceToken;
			public:
				ParsingState(const WString& _input, Ptr<ParsingTable> _table, vint codeIndex=-1);
				~ParsingState();

				const WString&								GetInput();
				Ptr<ParsingTable>							GetTable();
				const collections::List<regex::RegexToken>&	GetTokens();
				regex::RegexToken*							GetToken(vint index);

				vint										Reset(const WString& rule);
				vint										GetCurrentToken();
				const collections::List<vint>&				GetStateStack();
				vint										GetCurrentState();

				ParsingTable::TransitionItem*				MatchToken(vint tableTokenIndex);
				ParsingTable::TransitionItem*				MatchTokenInFuture(vint tableTokenIndex, Future* future);
				TransitionResult							ReadToken(vint tableTokenIndex, regex::RegexToken* regexToken);
				TransitionResult							ReadToken();
				bool										ReadTokenInFuture(vint tableTokenIndex, Future* previous, Future* now);
			};

/***********************************************************************
语法树生成器
***********************************************************************/

			class ParsingTreeBuilder : public Object
			{
			protected:
				Ptr<ParsingTreeNode>						createdObject;
				Ptr<ParsingTreeObject>						operationTarget;
				collections::List<Ptr<ParsingTreeObject>>	nodeStack;
			public:
				ParsingTreeBuilder();
				~ParsingTreeBuilder();

				void										Reset();
				bool										Run(const ParsingState::TransitionResult& result);
				Ptr<ParsingTreeObject>						GetNode();
			};
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Parser

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSING
#define VCZH_PARSING_PARSING


namespace vl
{
	namespace parsing
	{
		namespace tabling
		{

/***********************************************************************
语法分析器通用策略
***********************************************************************/

			class ParsingGeneralParser : public Object
			{
			protected:
				Ptr<ParsingTable>							table;

				virtual void								OnReset();
				virtual ParsingState::TransitionResult		OnErrorRecover(ParsingState& state, const regex::RegexToken* currentToken, collections::List<Ptr<ParsingError>>& errors)=0;
			public:
				ParsingGeneralParser(Ptr<ParsingTable> _table);
				~ParsingGeneralParser();
				
				Ptr<ParsingTreeNode>						Parse(ParsingState& state, collections::List<Ptr<ParsingError>>& errors);
				Ptr<ParsingTreeNode>						Parse(const WString& input, const WString& rule, collections::List<Ptr<ParsingError>>& errors);
			};

/***********************************************************************
语法分析器策略
***********************************************************************/

			class ParsingStrictParser : public ParsingGeneralParser
			{
			protected:

				ParsingState::TransitionResult				OnErrorRecover(ParsingState& state, const regex::RegexToken* currentToken, collections::List<Ptr<ParsingError>>& errors)override;
			public:
				ParsingStrictParser(Ptr<ParsingTable> _table=0);
				~ParsingStrictParser();
			};

			class ParsingAutoRecoverParser : public ParsingGeneralParser
			{
			protected:
				collections::Array<ParsingState::Future>	recoverFutures;
				vint										recoveringFutureIndex;

				ParsingState::TransitionResult				OnErrorRecover(ParsingState& state, const regex::RegexToken* currentToken, collections::List<Ptr<ParsingError>>& errors)override;
			public:
				ParsingAutoRecoverParser(Ptr<ParsingTable> _table=0);
				~ParsingAutoRecoverParser();
			};

/***********************************************************************
辅助函数
***********************************************************************/

			extern Ptr<ParsingStrictParser>					CreateBootstrapStrictParser();
			extern Ptr<ParsingAutoRecoverParser>			CreateBootstrapAutoRecoverParser();
		}
	}
}

#endif

/***********************************************************************
PARSING\JSON\PARSINGJSON_PARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parser::ParsingJson_Parser

本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/

#ifndef VCZH_PARSING_JSON_PARSINGJSON_PARSER
#define VCZH_PARSING_JSON_PARSINGJSON_PARSER


namespace vl
{
	namespace parsing
	{
		namespace json
		{
			struct JsonParserTokenIndex abstract
			{
				static const vl::vint TRUE = 0;
				static const vl::vint FALSE = 1;
				static const vl::vint NULLVALUE = 2;
				static const vl::vint OBJOPEN = 3;
				static const vl::vint OBJCLOSE = 4;
				static const vl::vint ARROPEN = 5;
				static const vl::vint ARRCLOSE = 6;
				static const vl::vint COMMA = 7;
				static const vl::vint COLON = 8;
				static const vl::vint NUMBER = 9;
				static const vl::vint STRING = 10;
				static const vl::vint SPACE = 11;
			};
			class JsonNode;
			class JsonLiteral;
			class JsonString;
			class JsonNumber;
			class JsonArray;
			class JsonObjectField;
			class JsonObject;

			class JsonNode abstract : public vl::parsing::ParsingTreeCustomBase
			{
			public:
				class IVisitor : public vl::Interface
				{
				public:
					virtual void Visit(JsonLiteral* node)=0;
					virtual void Visit(JsonString* node)=0;
					virtual void Visit(JsonNumber* node)=0;
					virtual void Visit(JsonArray* node)=0;
					virtual void Visit(JsonObjectField* node)=0;
					virtual void Visit(JsonObject* node)=0;
				};

				virtual void Accept(JsonNode::IVisitor* visitor)=0;

			};

			class JsonLiteral : public JsonNode
			{
			public:
				struct JsonValue abstract
				{
					enum Type
					{
						True,
						False,
						Null,
					};
				};

				JsonValue::Type value;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonLiteral> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonString : public JsonNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonString> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonNumber : public JsonNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonNumber> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonArray : public JsonNode
			{
			public:
				vl::collections::List<vl::Ptr<JsonNode>> items;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonArray> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonObjectField : public JsonNode
			{
			public:
				vl::parsing::ParsingToken name;
				vl::Ptr<JsonNode> value;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonObjectField> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class JsonObject : public JsonNode
			{
			public:
				vl::collections::List<vl::Ptr<JsonObjectField>> fields;

				void Accept(JsonNode::IVisitor* visitor)override;

				static vl::Ptr<JsonObject> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> JsonConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern vl::Ptr<vl::parsing::tabling::ParsingTable> JsonLoadTable();

			extern vl::Ptr<JsonNode> JsonParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);
		}
	}
}
#endif

/***********************************************************************
PARSING\JSON\PARSINGJSON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parser::ParsingJson_Parser

***********************************************************************/

#ifndef VCZH_PARSING_JSON_PARSINGJSON
#define VCZH_PARSING_JSON_PARSINGJSON


namespace vl
{
	namespace parsing
	{
		namespace json
		{
			extern void						JsonEscapeString(const WString& text, stream::TextWriter& writer);
			extern void						JsonUnescapeString(const WString& text, stream::TextWriter& writer);
			extern void						JsonPrint(Ptr<JsonNode> node, stream::TextWriter& writer);
			extern WString					JsonToString(Ptr<JsonNode> node);
		}
	}
}

#endif

/***********************************************************************
STREAM\MEMORYSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::MemoryStream

Interfaces:
	MemoryStream					：内存流
***********************************************************************/

#ifndef VCZH_STREAM_MEMORYSTREAM
#define VCZH_STREAM_MEMORYSTREAM


namespace vl
{
	namespace stream
	{
		class MemoryStream : public Object, public virtual IStream
		{
		protected:
			vint					block;
			char*					buffer;
			vint					size;
			vint					position;
			vint					capacity;

			void					PrepareSpace(vint totalSpace);
		public:
			MemoryStream(vint _block=65536);
			~MemoryStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint					Read(void* _buffer, vint _size);
			vint					Write(void* _buffer, vint _size);
			vint					Peek(void* _buffer, vint _size);
			void*					GetInternalBuffer();
		};
	}
}

#endif

/***********************************************************************
PARSING\PARSINGDEFINITIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Definitions

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGDEFINITIONS
#define VCZH_PARSING_PARSINGDEFINITIONS


namespace vl
{
	namespace parsing
	{
		namespace definitions
		{

/***********************************************************************
类型结构
***********************************************************************/

			class ParsingDefinitionPrimitiveType;
			class ParsingDefinitionTokenType;
			class ParsingDefinitionSubType;
			class ParsingDefinitionArrayType;

			class ParsingDefinitionType : public ParsingTreeCustomBase
			{
			public:
				class IVisitor : public Interface
				{
				public:
					virtual void								Visit(ParsingDefinitionPrimitiveType* node)=0;
					virtual void								Visit(ParsingDefinitionTokenType* node)=0;
					virtual void								Visit(ParsingDefinitionSubType* node)=0;
					virtual void								Visit(ParsingDefinitionArrayType* node)=0;
				};

				virtual void									Accept(IVisitor* visitor)=0;
			};

			class ParsingDefinitionPrimitiveType : public ParsingDefinitionType
			{
			public:
				WString											name;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionTokenType : public ParsingDefinitionType
			{
			public:

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionSubType : public ParsingDefinitionType
			{
			public:
				Ptr<ParsingDefinitionType>						parentType;
				WString											subTypeName;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionArrayType : public ParsingDefinitionType
			{
			public:
				Ptr<ParsingDefinitionType>						elementType;

				void											Accept(IVisitor* visitor)override;
			};

/***********************************************************************
数据结构
***********************************************************************/

			class ParsingDefinitionClassMemberDefinition;
			class ParsingDefinitionClassDefinition;
			class ParsingDefinitionEnumMemberDefinition;
			class ParsingDefinitionEnumDefinition;

			class ParsingDefinitionTypeDefinition : public ParsingTreeCustomBase
			{
			public:
				class IVisitor : public Interface
				{
				public:
					virtual void								Visit(ParsingDefinitionClassMemberDefinition* node)=0;
					virtual void								Visit(ParsingDefinitionClassDefinition* node)=0;
					virtual void								Visit(ParsingDefinitionEnumMemberDefinition* node)=0;
					virtual void								Visit(ParsingDefinitionEnumDefinition* node)=0;
				};

				virtual void									Accept(IVisitor* visitor)=0;
			public:
				WString											name;
			};

			class ParsingDefinitionClassMemberDefinition : public ParsingDefinitionTypeDefinition
			{
			public:
				Ptr<ParsingDefinitionType>						type;
				WString											unescapingFunction;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionClassDefinition : public ParsingDefinitionTypeDefinition
			{
			public:
				typedef collections::List<Ptr<ParsingDefinitionClassMemberDefinition>>	MemberList;
				typedef collections::List<Ptr<ParsingDefinitionTypeDefinition>>			TypeList;

				Ptr<ParsingDefinitionType>						parentType;
				MemberList										members;
				TypeList										subTypes;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionEnumMemberDefinition : public ParsingDefinitionTypeDefinition
			{
			public:

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionEnumDefinition : public ParsingDefinitionTypeDefinition
			{
			public:
				typedef collections::List<Ptr<ParsingDefinitionEnumMemberDefinition>>	MemberList;

				MemberList										members;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionPrimitiveGrammar;
			class ParsingDefinitionTextGrammar;
			class ParsingDefinitionSequenceGrammar;
			class ParsingDefinitionAlternativeGrammar;
			class ParsingDefinitionLoopGrammar;
			class ParsingDefinitionOptionalGrammar;
			class ParsingDefinitionCreateGrammar;
			class ParsingDefinitionAssignGrammar;
			class ParsingDefinitionUseGrammar;
			class ParsingDefinitionSetterGrammar;

			class ParsingDefinitionGrammar : public ParsingTreeCustomBase
			{
			public:
				class IVisitor : public Interface
				{
				public:
					virtual void								Visit(ParsingDefinitionPrimitiveGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionTextGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionSequenceGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionAlternativeGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionLoopGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionOptionalGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionCreateGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionAssignGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionUseGrammar* node)=0;
					virtual void								Visit(ParsingDefinitionSetterGrammar* node)=0;
				};

				virtual void									Accept(IVisitor* visitor)=0;
			};

/***********************************************************************
文法规则
***********************************************************************/

			class ParsingDefinitionPrimitiveGrammar : public ParsingDefinitionGrammar
			{
			public:
				WString											name;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionTextGrammar : public ParsingDefinitionGrammar
			{
			public:
				WString											text;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionSequenceGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					first;
				Ptr<ParsingDefinitionGrammar>					second;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionAlternativeGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					first;
				Ptr<ParsingDefinitionGrammar>					second;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionLoopGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionOptionalGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionCreateGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;
				Ptr<ParsingDefinitionType>						type;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionAssignGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;
				WString											memberName;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionUseGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;

				void											Accept(IVisitor* visitor)override;
			};

			class ParsingDefinitionSetterGrammar : public ParsingDefinitionGrammar
			{
			public:
				Ptr<ParsingDefinitionGrammar>					grammar;
				WString											memberName;
				WString											value;

				void											Accept(IVisitor* visitor)override;
			};

/***********************************************************************
文法结构
***********************************************************************/

			class ParsingDefinitionTokenDefinition : public ParsingTreeCustomBase
			{
			public:
				WString											name;
				WString											regex;
				bool											discard;
			};

			class ParsingDefinitionRuleDefinition : public ParsingTreeCustomBase
			{
			public:
				WString															name;
				Ptr<ParsingDefinitionType>										type;
				collections::List<Ptr<ParsingDefinitionGrammar>>				grammars;
			};

			class ParsingDefinition : public ParsingTreeCustomBase
			{
			public:
				collections::List<Ptr<ParsingDefinitionTypeDefinition>>			types;
				collections::List<Ptr<ParsingDefinitionTokenDefinition>>		tokens;
				collections::List<Ptr<ParsingDefinitionRuleDefinition>>			rules;
			};

/***********************************************************************
构造器（类型）
***********************************************************************/

			class ParsingDefinitionTypeWriter : public Object
			{
				friend ParsingDefinitionTypeWriter				Type(const WString& name);
				friend ParsingDefinitionTypeWriter				TokenType();
			protected:
				Ptr<ParsingDefinitionType>						type;

				ParsingDefinitionTypeWriter(Ptr<ParsingDefinitionType> internalType);
				ParsingDefinitionTypeWriter(const WString& name);
			public:
				ParsingDefinitionTypeWriter(const ParsingDefinitionTypeWriter& typeWriter);

				ParsingDefinitionTypeWriter						Sub(const WString& subTypeName)const;
				ParsingDefinitionTypeWriter						Array()const;
				Ptr<ParsingDefinitionType>						Type()const;
			};

			extern ParsingDefinitionTypeWriter					Type(const WString& name);
			extern ParsingDefinitionTypeWriter					TokenType();

/***********************************************************************
构造器（类型定义）
***********************************************************************/

			class ParsingDefinitionTypeDefinitionWriter : public Object
			{
			public:
				virtual Ptr<ParsingDefinitionTypeDefinition>	Definition()const=0;
			};

			class ParsingDefinitionClassDefinitionWriter : public ParsingDefinitionTypeDefinitionWriter
			{
			protected:
				Ptr<ParsingDefinitionClassDefinition>			definition;

			public:
				ParsingDefinitionClassDefinitionWriter(const WString& name);
				ParsingDefinitionClassDefinitionWriter(const WString& name, const ParsingDefinitionTypeWriter& parentType);

				ParsingDefinitionClassDefinitionWriter&			Member(const WString& name, const ParsingDefinitionTypeWriter& type, const WString& unescapingFunction=L"");
				ParsingDefinitionClassDefinitionWriter&			SubType(const ParsingDefinitionTypeDefinitionWriter& type);

				Ptr<ParsingDefinitionTypeDefinition>			Definition()const override;
			};
			
			extern ParsingDefinitionClassDefinitionWriter		Class(const WString& name);
			extern ParsingDefinitionClassDefinitionWriter		Class(const WString& name, const ParsingDefinitionTypeWriter& parentType);

			class ParsingDefinitionEnumDefinitionWriter : public ParsingDefinitionTypeDefinitionWriter
			{
			protected:
				Ptr<ParsingDefinitionEnumDefinition>			definition;

			public:
				ParsingDefinitionEnumDefinitionWriter(const WString& name);

				ParsingDefinitionEnumDefinitionWriter&			Member(const WString& name);

				Ptr<ParsingDefinitionTypeDefinition>			Definition()const override;
			};

			extern ParsingDefinitionEnumDefinitionWriter		Enum(const WString& name);

/***********************************************************************
构造器（文法规则）
***********************************************************************/

			class ParsingDefinitionGrammarWriter : public Object
			{
				friend ParsingDefinitionGrammarWriter			Rule(const WString& name);
				friend ParsingDefinitionGrammarWriter			Text(const WString& name);
				friend ParsingDefinitionGrammarWriter			Opt(const ParsingDefinitionGrammarWriter& writer);
			protected:
				Ptr<ParsingDefinitionGrammar>					grammar;

				ParsingDefinitionGrammarWriter(Ptr<ParsingDefinitionGrammar> internalGrammar);
			public:
				ParsingDefinitionGrammarWriter(const ParsingDefinitionGrammarWriter& grammarWriter);

				ParsingDefinitionGrammarWriter					operator+(const ParsingDefinitionGrammarWriter& next)const;
				ParsingDefinitionGrammarWriter					operator|(const ParsingDefinitionGrammarWriter& next)const;
				ParsingDefinitionGrammarWriter					operator*()const;
				ParsingDefinitionGrammarWriter					As(const ParsingDefinitionTypeWriter& type)const;
				ParsingDefinitionGrammarWriter					operator[](const WString& memberName)const;
				ParsingDefinitionGrammarWriter					operator!()const;
				ParsingDefinitionGrammarWriter					Set(const WString& memberName, const WString& value)const;

				Ptr<ParsingDefinitionGrammar>					Grammar()const;
			};

			extern ParsingDefinitionGrammarWriter				Rule(const WString& name);
			extern ParsingDefinitionGrammarWriter				Text(const WString& text);
			extern ParsingDefinitionGrammarWriter				Opt(const ParsingDefinitionGrammarWriter& writer);

/***********************************************************************
构造器（文法结构）
***********************************************************************/

			class ParsingDefinitionWriter;

			class ParsingDefinitionRuleDefinitionWriter : public Object
			{
			protected:
				Ptr<ParsingDefinitionRuleDefinition>			rule;
				ParsingDefinitionWriter&						owner;
			public:
				ParsingDefinitionRuleDefinitionWriter(ParsingDefinitionWriter& _owner, Ptr<ParsingDefinitionRuleDefinition> _rule);

				ParsingDefinitionRuleDefinitionWriter&			Imply(const ParsingDefinitionGrammarWriter& grammar);
				ParsingDefinitionWriter&						EndRule();
			};

			class ParsingDefinitionWriter : public Object
			{
			protected:
				Ptr<ParsingDefinition>							definition;

			public:
				ParsingDefinitionWriter();

				ParsingDefinitionWriter&						Type(const ParsingDefinitionTypeDefinitionWriter& type);
				ParsingDefinitionWriter&						Token(const WString& name, const WString& regex);
				ParsingDefinitionWriter&						Discard(const WString& name, const WString& regex);
				ParsingDefinitionRuleDefinitionWriter			Rule(const WString& name, const ParsingDefinitionTypeWriter& type);

				Ptr<ParsingDefinition>							Definition()const;
			};

/***********************************************************************
辅助函数
***********************************************************************/

			extern WString										TypeToString(ParsingDefinitionType* type);
			extern WString										GrammarToString(ParsingDefinitionGrammar* grammar);
			extern WString										GrammarStateToString(ParsingDefinitionGrammar* grammar, ParsingDefinitionGrammar* stateNode, bool beforeNode);
			extern ParsingDefinitionGrammar*					FindAppropriateGrammarState(ParsingDefinitionGrammar* grammar, ParsingDefinitionGrammar* stateNode, bool beforeNode);
			extern void											Log(Ptr<ParsingDefinition> definition, stream::TextWriter& writer);

/***********************************************************************
自举
***********************************************************************/
			
			extern Ptr<ParsingDefinition>						CreateParserDefinition();
			extern Ptr<ParsingDefinition>						DeserializeDefinition(Ptr<ParsingTreeNode> node);
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSINGANALYZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Analyzing

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGANALYZER
#define VCZH_PARSING_PARSINGANALYZER


namespace vl
{
	namespace parsing
	{
		namespace analyzing
		{

/***********************************************************************
符号表关联对象
***********************************************************************/

			class ParsingSymbol;

			struct DefinitionTypeScopePair
			{
				definitions::ParsingDefinitionType*		type;
				ParsingSymbol*							scope;

				DefinitionTypeScopePair()
				{
				}

				DefinitionTypeScopePair(definitions::ParsingDefinitionType* _type, ParsingSymbol* _scope)
					:type(_type)
					,scope(_scope)
				{
				}

				vint Compare(const DefinitionTypeScopePair& pair)
				{
					if(type<pair.type) return -1;
					if(type>pair.type) return 1;
					if(scope<pair.scope) return -1;
					if(scope>pair.scope) return 1;
					return 0;
				}

				bool operator==(const DefinitionTypeScopePair& pair){return Compare(pair)==0;}
				bool operator!=(const DefinitionTypeScopePair& pair){return Compare(pair)!=0;}
				bool operator>(const DefinitionTypeScopePair& pair){return Compare(pair)>0;}
				bool operator>=(const DefinitionTypeScopePair& pair){return Compare(pair)>=0;}
				bool operator<(const DefinitionTypeScopePair& pair){return Compare(pair)<0;}
				bool operator<=(const DefinitionTypeScopePair& pair){return Compare(pair)<=0;}
			};

/***********************************************************************
符号表
***********************************************************************/

			class ParsingSymbol : public Object
			{
				friend class ParsingSymbolManager;

				typedef collections::Dictionary<WString, ParsingSymbol*>		ParsingSymbolMap;
				typedef collections::List<ParsingSymbol*>						ParsingSymbolList;
			public:
				enum SymbolType
				{
					Global,
					EnumType,
					ClassType,		// descriptor == base type
					ArrayType,		// descriptor == element type
					TokenType,
					EnumItem,		// descriptor == parent
					ClassField,		// descriptor == field type
					TokenDef,		// descriptor == token type
					RuleDef,		// descriptor == rule type
				};

			protected:
				ParsingSymbolManager*			manager;
				SymbolType						type;
				WString							name;
				ParsingSymbol*					descriptorSymbol;
				WString							descriptorString;
				ParsingSymbol*					parentSymbol;
				ParsingSymbol*					arrayTypeSymbol;
				ParsingSymbolList				subSymbolList;
				ParsingSymbolMap				subSymbolMap;

				bool							AddSubSymbol(ParsingSymbol* subSymbol);

				ParsingSymbol(ParsingSymbolManager* _manager, SymbolType _type, const WString& _name, ParsingSymbol* _descriptorSymbol, const WString& _descriptorString);
			public:
				~ParsingSymbol();

				ParsingSymbolManager*			GetManager();
				SymbolType						GetType();
				const WString&					GetName();
				vint							GetSubSymbolCount();
				ParsingSymbol*					GetSubSymbol(vint index);
				ParsingSymbol*					GetSubSymbolByName(const WString& name);
				ParsingSymbol*					GetDescriptorSymbol();
				WString							GetDescriptorString();
				ParsingSymbol*					GetParentSymbol();
				bool							IsType();
				ParsingSymbol*					SearchClassSubSymbol(const WString& name);
				ParsingSymbol*					SearchCommonBaseClass(ParsingSymbol* classType);
			};

			class ParsingSymbolManager : public Object
			{

				typedef collections::List<Ptr<ParsingSymbol>>												ParsingSymbolList;
				typedef collections::Dictionary<DefinitionTypeScopePair, ParsingSymbol*>					DefinitionTypeSymbolMap;
				typedef collections::Dictionary<definitions::ParsingDefinitionGrammar*, ParsingSymbol*>		DefinitionGrammarSymbolMap;
			protected:
				ParsingSymbol*					globalSymbol;
				ParsingSymbol*					tokenTypeSymbol;
				ParsingSymbolList				createdSymbols;
				DefinitionTypeSymbolMap			definitionTypeSymbolCache;
				DefinitionGrammarSymbolMap		definitionGrammarSymbolCache;
				DefinitionGrammarSymbolMap		definitionGrammarTypeCache;

				ParsingSymbol*					TryAddSubSymbol(Ptr<ParsingSymbol> subSymbol, ParsingSymbol* parentSymbol);
			public:
				ParsingSymbolManager();
				~ParsingSymbolManager();

				ParsingSymbol*					GetGlobal();
				ParsingSymbol*					GetTokenType();
				ParsingSymbol*					GetArrayType(ParsingSymbol* elementType);

				ParsingSymbol*					AddClass(const WString& name, ParsingSymbol* baseType, ParsingSymbol* parentType=0);
				ParsingSymbol*					AddField(const WString& name, ParsingSymbol* classType, ParsingSymbol* fieldType);
				ParsingSymbol*					AddEnum(const WString& name, ParsingSymbol* parentType=0);
				ParsingSymbol*					AddEnumItem(const WString& name, ParsingSymbol* enumType);
				ParsingSymbol*					AddTokenDefinition(const WString& name, const WString& regex);
				ParsingSymbol*					AddRuleDefinition(const WString& name, ParsingSymbol* ruleType);

				ParsingSymbol*					CacheGetType(definitions::ParsingDefinitionType* type, ParsingSymbol* scope);
				bool							CacheSetType(definitions::ParsingDefinitionType* type, ParsingSymbol* scope, ParsingSymbol* symbol);
				ParsingSymbol*					CacheGetSymbol(definitions::ParsingDefinitionGrammar* grammar);
				bool							CacheSetSymbol(definitions::ParsingDefinitionGrammar* grammar, ParsingSymbol* symbol);
				ParsingSymbol*					CacheGetType(definitions::ParsingDefinitionGrammar* grammar);
				bool							CacheSetType(definitions::ParsingDefinitionGrammar* grammar, ParsingSymbol* type);
			};

/***********************************************************************
语义分析
***********************************************************************/

			extern WString						GetTypeFullName(ParsingSymbol* type);
			extern ParsingSymbol*				FindType(definitions::ParsingDefinitionType* type, ParsingSymbolManager* manager, ParsingSymbol* scope, collections::List<Ptr<ParsingError>>& errors);
			extern void							PrepareSymbols(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
			extern void							ValidateRuleStructure(Ptr<definitions::ParsingDefinition> definition, Ptr<definitions::ParsingDefinitionRuleDefinition> rule, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
			extern void							ResolveRuleSymbols(Ptr<definitions::ParsingDefinitionRuleDefinition> rule, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
			extern void							ResolveSymbols(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
			extern void							ValidateDefinition(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager, collections::List<Ptr<ParsingError>>& errors);
		}
	}
}

#endif

/***********************************************************************
PARSING\PARSINGAUTOMATON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parsing::Automaton

Classes:
***********************************************************************/

#ifndef VCZH_PARSING_PARSINGAUTOMATON
#define VCZH_PARSING_PARSINGAUTOMATON


namespace vl
{
	namespace parsing
	{
		namespace analyzing
		{

/***********************************************************************
状态机
***********************************************************************/

			class Action;
			class Transition;
			class State;

			class Action : public Object
			{
			public:
				enum ActionType
				{
					Create, // new source
					Assign, // source ::= <created symbol>
					Using,  // use <created symbol>
					Setter, // source ::= target
					Shift,
					Reduce,
					LeftRecursiveReduce,
				};

				ActionType											actionType;
				ParsingSymbol*										actionTarget;
				ParsingSymbol*										actionSource;

				// the following two fields record which rule symbol transition generate this shift/reduce action
				State*												shiftReduceSource;
				State*												shiftReduceTarget;

				Action();
				~Action();
			};

			class Transition : public Object
			{
			public:
				enum TransitionType
				{
					TokenBegin,		// token stream start
					TokenFinish,	// token stream end
					TryReduce,		// rule end
					Epsilon,		// an epsilon transition
					Symbol,			// a syntax symbol
				};

				enum StackOperationType
				{
					None,
					ShiftReduceCompacted,
					LeftRecursive,
				};

				State*												source;
				State*												target;
				collections::List<Ptr<Action>>						actions;
				
				TransitionType										transitionType;
				StackOperationType									stackOperationType;
				ParsingSymbol*										transitionSymbol;

				Transition();
				~Transition();

				static bool											IsEquivalent(Transition* t1, Transition* t2, bool careSourceAndTarget);
			};

			class State : public Object
			{
			public:
				enum StatePosition
				{
					BeforeNode,
					AfterNode,
				};

				collections::List<Transition*>						transitions;
				collections::List<Transition*>						inputs;
				bool												endState;

				ParsingSymbol*										ownerRuleSymbol;
				definitions::ParsingDefinitionRuleDefinition*		ownerRule;
				definitions::ParsingDefinitionGrammar*				grammarNode;
				definitions::ParsingDefinitionGrammar*				stateNode;
				StatePosition										statePosition;
				WString												stateName;
				WString												stateExpression;

				State();
				~State();
			};

			class RuleInfo : public Object
			{
			public:
				State*												rootRuleStartState;
				State*												rootRuleEndState;
				State*												startState;
				collections::List<State*>							endStates;
				int													stateNameCount;

				RuleInfo();
				~RuleInfo();
			};

			class Automaton : public Object
			{
				typedef collections::Dictionary<definitions::ParsingDefinitionRuleDefinition*, Ptr<RuleInfo>>		RuleInfoMap;
			public:
				ParsingSymbolManager*								symbolManager;
				collections::List<Ptr<Transition>>					transitions;
				collections::List<Ptr<State>>						states;
				RuleInfoMap											ruleInfos;

				Automaton(ParsingSymbolManager* _symbolManager);
				~Automaton();

				State*												RuleStartState(definitions::ParsingDefinitionRuleDefinition* ownerRule);
				State*												RootRuleStartState(definitions::ParsingDefinitionRuleDefinition* ownerRule);
				State*												RootRuleEndState(definitions::ParsingDefinitionRuleDefinition* ownerRule);
				State*												StartState(definitions::ParsingDefinitionRuleDefinition* ownerRule, definitions::ParsingDefinitionGrammar* grammarNode, definitions::ParsingDefinitionGrammar* stateNode);
				State*												EndState(definitions::ParsingDefinitionRuleDefinition* ownerRule, definitions::ParsingDefinitionGrammar* grammarNode, definitions::ParsingDefinitionGrammar* stateNode);
				State*												CopyState(State* oldState);

				Transition*											CreateTransition(State* start, State* end);
				Transition*											TokenBegin(State* start, State* end);
				Transition*											TokenFinish(State* start, State* end);
				Transition*											TryReduce(State* start, State* end);
				Transition*											Epsilon(State* start, State* end);
				Transition*											Symbol(State* start, State* end, ParsingSymbol* transitionSymbol);
				Transition*											CopyTransition(State* start, State* end, Transition* oldTransition);

				void												DeleteTransition(Transition* transition);
				void												DeleteState(State* state);
			};

/***********************************************************************
辅助函数
***********************************************************************/

			namespace closure_searching
			{
				struct ClosureItem
				{
					State*											state;			// target state of one path of a closure
					Ptr<collections::List<Transition*>>				transitions;	// path
					bool											cycle;			// true: invalid closure because there are cycles, and in the middle of the path there will be a transition that targets to the state field.

					ClosureItem()
						:state(0)
						,cycle(false)
					{
					}

					ClosureItem(State* _state, Ptr<collections::List<Transition*>> _transitions, bool _cycle)
						:state(_state)
						,transitions(_transitions)
						,cycle(_cycle)
					{
					}
				};

				enum ClosureSearchResult
				{
					Continue,
					Hit,
					Blocked,
				};

				extern void											SearchClosure(ClosureSearchResult(*closurePredicate)(Transition*), State* startState, collections::List<ClosureItem>& closure);
			}

			extern Ptr<Automaton>									CreateEpsilonPDA(Ptr<definitions::ParsingDefinition> definition, ParsingSymbolManager* manager);
			extern void												RemoveEpsilonTransitions(collections::Dictionary<State*, State*>& oldNewStateMap, collections::List<State*>& scanningStates, Ptr<Automaton> automaton);
			extern Ptr<Automaton>									CreateNondeterministicPDAFromEpsilonPDA(Ptr<Automaton> epsilonPDA);
			extern Ptr<Automaton>									CreateJointPDAFromNondeterministicPDA(Ptr<Automaton> nondeterministicPDA);
			extern void												CompactJointPDA(Ptr<Automaton> jointPDA);
			extern void												MarkLeftRecursiveInJointPDA(Ptr<Automaton> jointPDA, collections::List<Ptr<ParsingError>>& errors);

			extern WString											GetTypeNameForCreateInstruction(ParsingSymbol* type);
			extern Ptr<tabling::ParsingTable>						GenerateTable(Ptr<definitions::ParsingDefinition> definition, Ptr<Automaton> jointPDA, collections::List<Ptr<ParsingError>>& errors);
			extern Ptr<tabling::ParsingTable>						GenerateTable(Ptr<definitions::ParsingDefinition> definition, collections::List<Ptr<ParsingError>>& errors);
			extern void												Log(Ptr<Automaton> automaton, stream::TextWriter& writer);
		}
	}
}

#endif

/***********************************************************************
REGEX\REGEXDATA.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::Basic Data Structure

Classes:
***********************************************************************/

#ifndef VCZH_REGEX_REGEXDATA
#define VCZH_REGEX_REGEXDATA


namespace vl
{
	namespace regex_internal
	{
		using namespace vl::collections;

/***********************************************************************
基础数据结构
***********************************************************************/

		class CharRange
		{
		public:
			typedef SortedList<CharRange>			List;

			wchar_t					begin;
			wchar_t					end;

			CharRange();
			CharRange(wchar_t _begin, wchar_t _end);

			bool					operator<(CharRange item)const;
			bool					operator<=(CharRange item)const;
			bool					operator>(CharRange item)const;
			bool					operator>=(CharRange item)const;
			bool					operator==(CharRange item)const;
			bool					operator!=(CharRange item)const;

			bool					operator<(wchar_t item)const;
			bool					operator<=(wchar_t item)const;
			bool					operator>(wchar_t item)const;
			bool					operator>=(wchar_t item)const;
			bool					operator==(wchar_t item)const;
			bool					operator!=(wchar_t item)const;
		};
	}

	template<>
	struct POD<regex_internal::CharRange>
	{
		static const bool Result=true;
	};
}

#endif

/***********************************************************************
REGEX\REGEXAUTOMATON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexAutomaton

Classes:
	State						：状态
	Transition					：转换
	Automaton					：状态机

Functions:
	EpsilonNfaToNfa				：去Epsilon
	NfaToDfa					：NFA转DFA
***********************************************************************/

#ifndef VCZH_REGEX_REGEXAUTOMATON
#define VCZH_REGEX_REGEXAUTOMATON


namespace vl
{
	namespace regex_internal
	{
		class State;
		class Transition;

		class Transition
		{
		public:
			enum Type
			{
				Chars,				//range为字符范围
				Epsilon,
				BeginString,
				EndString,
				Nop,				//无动作（不可消除epsilon，用来控制优先级）
				Capture,			//capture为捕获频道
				Match,				//capture为捕获频道，index为匹配的位置，-1代表匹配频道下面的所有项目
				Positive,			//正向匹配
				Negative,			//反向匹配
				NegativeFail,		//反向匹配失败
				End					//Capture, Position, Negative
			};

			State*					source;
			State*					target;
			CharRange				range;
			Type					type;
			vint						capture;
			vint						index;
		};

		class State
		{
		public:
			List<Transition*>		transitions;
			List<Transition*>		inputs;
			bool					finalState;
			void*					userData;
		};

		class Automaton
		{
		public:
			typedef Ptr<Automaton>		Ref;

			List<Ptr<State>>		states;
			List<Ptr<Transition>>	transitions;
			List<WString>			captureNames;
			State*					startState;

			Automaton();

			State*					NewState();
			Transition*				NewTransition(State* start, State* end);
			Transition*				NewChars(State* start, State* end, CharRange range);
			Transition*				NewEpsilon(State* start, State* end);
			Transition*				NewBeginString(State* start, State* end);
			Transition*				NewEndString(State* start, State* end);
			Transition*				NewNop(State* start, State* end);
			Transition*				NewCapture(State* start, State* end, vint capture);
			Transition*				NewMatch(State* start, State* end, vint capture, vint index=-1);
			Transition*				NewPositive(State* start, State* end);
			Transition*				NewNegative(State* start, State* end);
			Transition*				NewNegativeFail(State* start, State* end);
			Transition*				NewEnd(State* start, State* end);
		};

		extern bool					PureEpsilonChecker(Transition* transition);
		extern bool					RichEpsilonChecker(Transition* transition);
		extern bool					AreEqual(Transition* transA, Transition* transB);
		extern Automaton::Ref		EpsilonNfaToNfa(Automaton::Ref source, bool(*epsilonChecker)(Transition*), Dictionary<State*, State*>& nfaStateMap);
		extern Automaton::Ref		NfaToDfa(Automaton::Ref source, Group<State*, State*>& dfaStateMap);
	}
}

#endif

/***********************************************************************
REGEX\REGEXEXPRESSION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexExpression

Classes:
	Expression						：表达式基类					|
	CharSetExpression				：字符集表达式				| a, [a-b], [^a-b0_9], \.rnt\/()+*?{}[]<>^$!=SsDdLlWw, [\rnt-[]\/^$]
	LoopExpression					：循环表达式					| a{3}, a{3,}, a{1,3}, a+, a*, a?, LOOP?
	SequenceExpression				：顺序表达式					| ab
	AlternateExpression				：选择表达式					| a|b
	BeginExpression					：【非纯】字符串起始表达式	| ^
	EndExpression					：【非纯】字符串末尾表达式	| $
	CaptureExpression				：【非纯】捕获表达式			| (<name>expr), (?expr)
	MatchExpression					：【非纯】匹配表达式			| (<$name>), (<$name;i>), (<$i>)
	PositiveExpression				：【非纯】正向预查表达式		| (=expr)
	NegativeExpression				：【非纯】反向预查表达式		| (!expr)
	UsingExpression					：引用表达式					| (<#name1>expr)...(<&name1>)...

	RegexExpression					：正则表达式

Functions:
	ParseRegexExpression			：将字符串分析为RegexExpression对象，如果语法有问题则抛异常
***********************************************************************/

#ifndef VCZH_REGEX_REGEXEXPRESSION
#define VCZH_REGEX_REGEXEXPRESSION


namespace vl
{
	namespace regex_internal
	{
		class IRegexExpressionAlgorithm;

/***********************************************************************
正则表达式表达式树
***********************************************************************/

		class Expression : public Object, private NotCopyable
		{
		public:
			typedef Ptr<Expression>								Ref;
			typedef Dictionary<WString, Expression::Ref>		Map;

			virtual void				Apply(IRegexExpressionAlgorithm& algorithm)=0;
			bool						IsEqual(Expression* expression);
			bool						HasNoExtension();
			bool						CanTreatAsPure();
			void						NormalizeCharSet(CharRange::List& subsets);
			void						CollectCharSet(CharRange::List& subsets);
			void						ApplyCharSet(CharRange::List& subsets);
			Automaton::Ref				GenerateEpsilonNfa();
		};

		class CharSetExpression : public Expression
		{
		public:
			CharRange::List				ranges;
			bool						reverse;

			bool						AddRangeWithConflict(CharRange range);
			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class LoopExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//被循环表达式
			vint							min;			//下限
			vint							max;			//上限，-1代表无限
			bool						preferLong;		//长匹配优先

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class SequenceExpression : public Expression
		{
		public:
			Expression::Ref				left;			//左表达式
			Expression::Ref				right;			//右表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class AlternateExpression : public Expression
		{
		public:
			Expression::Ref				left;			//左表达式
			Expression::Ref				right;			//右表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class BeginExpression: public Expression
		{
		public:

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class EndExpression : public Expression
		{
		public:

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class CaptureExpression : public Expression
		{
		public:
			WString						name;			//捕获名，空代表缺省捕获
			Expression::Ref				expression;		//被捕获表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class MatchExpression : public Expression
		{
		public:
			WString						name;			//捕获名，空代表缺省捕获
			vint							index;			//捕获序号，-1代表非空捕获的所有项

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class PositiveExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//正向匹配表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class NegativeExpression : public Expression
		{
		public:
			Expression::Ref				expression;		//反向匹配表达式

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class UsingExpression : public Expression
		{
		public:
			WString						name;			//引用名

			void						Apply(IRegexExpressionAlgorithm& algorithm);
		};

		class RegexExpression : public Object, private NotCopyable
		{
		public:
			typedef Ptr<RegexExpression>						Ref;

			Expression::Map				definitions;	//命名子表达式
			Expression::Ref				expression;		//主表达式

			Expression::Ref				Merge();
		};

/***********************************************************************
算法基类
***********************************************************************/

		class IRegexExpressionAlgorithm : public Interface
		{
		public:
			virtual void				Visit(CharSetExpression* expression)=0;
			virtual void				Visit(LoopExpression* expression)=0;
			virtual void				Visit(SequenceExpression* expression)=0;
			virtual void				Visit(AlternateExpression* expression)=0;
			virtual void				Visit(BeginExpression* expression)=0;
			virtual void				Visit(EndExpression* expression)=0;
			virtual void				Visit(CaptureExpression* expression)=0;
			virtual void				Visit(MatchExpression* expression)=0;
			virtual void				Visit(PositiveExpression* expression)=0;
			virtual void				Visit(NegativeExpression* expression)=0;
			virtual void				Visit(UsingExpression* expression)=0;
		};

		template<typename ReturnType, typename ParameterType=void*>
		class RegexExpressionAlgorithm : public Object, public IRegexExpressionAlgorithm
		{
		private:
			ReturnType					returnValue;
			ParameterType*				parameterValue;
		public:

			ReturnType Invoke(Expression* expression, ParameterType parameter)
			{
				parameterValue=&parameter;
				expression->Apply(*this);
				return returnValue;
			}

			ReturnType Invoke(Expression::Ref expression, ParameterType parameter)
			{
				parameterValue=&parameter;
				expression->Apply(*this);
				return returnValue;
			}

			virtual ReturnType			Apply(CharSetExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(LoopExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(SequenceExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(AlternateExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(BeginExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(EndExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(CaptureExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(MatchExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(PositiveExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(NegativeExpression* expression, ParameterType parameter)=0;
			virtual ReturnType			Apply(UsingExpression* expression, ParameterType parameter)=0;
		public:
			void Visit(CharSetExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(LoopExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(SequenceExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(AlternateExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(BeginExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(EndExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(CaptureExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(MatchExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(PositiveExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(NegativeExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}

			void Visit(UsingExpression* expression)
			{
				returnValue=Apply(expression, *parameterValue);
			}
		};

		template<typename ParameterType>
		class RegexExpressionAlgorithm<void, ParameterType> : public Object, public IRegexExpressionAlgorithm
		{
		private:
			ParameterType*				parameterValue;
		public:

			void Invoke(Expression* expression, ParameterType parameter)
			{
				parameterValue=&parameter;
				expression->Apply(*this);
			}

			void Invoke(Expression::Ref expression, ParameterType parameter)
			{
				parameterValue=&parameter;
				expression->Apply(*this);
			}

			virtual void				Apply(CharSetExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(LoopExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(SequenceExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(AlternateExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(BeginExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(EndExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(CaptureExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(MatchExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(PositiveExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(NegativeExpression* expression, ParameterType parameter)=0;
			virtual void				Apply(UsingExpression* expression, ParameterType parameter)=0;
		public:
			void Visit(CharSetExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(LoopExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(SequenceExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(AlternateExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(BeginExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(EndExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(CaptureExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(MatchExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(PositiveExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(NegativeExpression* expression)
			{
				Apply(expression, *parameterValue);
			}

			void Visit(UsingExpression* expression)
			{
				Apply(expression, *parameterValue);
			}
		};

/***********************************************************************
辅助函数
***********************************************************************/

		extern Ptr<LoopExpression>		ParseLoop(const wchar_t*& input);
		extern Ptr<Expression>			ParseCharSet(const wchar_t*& input);
		extern Ptr<Expression>			ParseFunction(const wchar_t*& input);
		extern Ptr<Expression>			ParseUnit(const wchar_t*& input);
		extern Ptr<Expression>			ParseJoin(const wchar_t*& input);
		extern Ptr<Expression>			ParseAlt(const wchar_t*& input);
		extern Ptr<Expression>			ParseExpression(const wchar_t*& input);
		extern RegexExpression::Ref		ParseRegexExpression(const WString& code);

		extern WString					EscapeTextForRegex(const WString& literalString);
		extern WString					UnescapeTextForRegex(const WString& escapedText);
		extern WString					NormalizeEscapedTextForRegex(const WString& escapedText);
		extern bool						IsRegexEscapedListeralString(const WString& regex);
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONCOPYFROM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONCOPYFROM
#define VCZH_COLLECTIONS_OPERATIONCOPYFROM


namespace vl
{
	namespace collections
	{

/***********************************************************************
容器复制
***********************************************************************/

		namespace copyfrom_internal
		{
			using namespace randomaccess_internal;

			template<typename Ds, typename Ss, bool DsRA, bool SsRA>
			struct CopyFromAlgorithm
			{
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, true, true>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					vint copyCount=RandomAccess<Ss>::GetCount(ss);
					vint index=(append?RandomAccess<Ds>::GetCount(ds):0);
					vint resizeCount=index+copyCount;
					RandomAccess<Ds>::SetCount(ds, resizeCount);
					for(vint i=0;i<copyCount;i++)
					{
						RandomAccess<Ds>::SetValue(ds, index+i, RandomAccess<Ss>::GetValue(ss, i));
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, false, true>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					if(!append)
					{
						ds.Clear();
					}
					vint copyCount=RandomAccess<Ss>::GetCount(ss);
					for(vint i=0;i<copyCount;i++)
					{
						RandomAccess<Ds>::AppendValue(ds, RandomAccess<Ss>::GetValue(ss, i));
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, true, false>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					Ptr<IEnumerator<typename Ss::ElementType>> enumerator;
					vint copyCount=0;

					enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						copyCount++;
					}

					vint index=(append?RandomAccess<Ds>::GetCount(ds):0);
					vint resizeCount=index+copyCount;
					RandomAccess<Ds>::SetCount(ds, resizeCount);

					enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						RandomAccess<Ds>::SetValue(ds, index++, enumerator->Current());
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, false, false>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					if(!append)
					{
						ds.Clear();
					}
					Ptr<IEnumerator<typename Ss::ElementType>> enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						RandomAccess<Ds>::AppendValue(ds, enumerator->Current());
					}
				}
			};

			template<typename T>
			struct Slice
			{
				const T*	items;
				vint		count;
			};
		}

		namespace randomaccess_internal
		{
			template<typename T>
			struct RandomAccessable<copyfrom_internal::Slice<T>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = true;
			};
		
			template<typename T>
			struct RandomAccess<copyfrom_internal::Slice<T>>
			{
				static vint GetCount(const copyfrom_internal::Slice<T>& t)
				{
					return t.count;
				}

				static const T& GetValue(const copyfrom_internal::Slice<T>& t, vint index)
				{
					return t.items[index];
				}
			};
		}

		template<typename Ds, typename Ss>
		void CopyFrom(Ds& ds, const Ss& ss, bool append=false)
		{
			copyfrom_internal::CopyFromAlgorithm<Ds, Ss, randomaccess_internal::RandomAccessable<Ds>::CanResize, randomaccess_internal::RandomAccessable<Ss>::CanRead>::Perform(ds, ss, append);
		}

		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const S* buffer, vint count, bool append=false)
		{
			copyfrom_internal::Slice<S> slice={buffer, count};
			CopyFrom(ds, slice, append);
		}

		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const S* begin, const S* end, bool append=false)
		{
			copyfrom_internal::Slice<S> slice={begin, end-begin};
			CopyFrom(ds, slice, append);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONENUMERABLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONENUMERABLE
#define VCZH_COLLECTIONS_OPERATIONENUMERABLE


namespace vl
{
	namespace collections
	{

		template<typename T>
		class Enumerable;

/***********************************************************************
空迭代器
***********************************************************************/

		template<typename T>
		class EmptyEnumerable : public Object, public IEnumerable<T>
		{
			friend class Enumerable<T>;
		private:
			class Enumerator : public Object, public IEnumerator<T>
			{
				IEnumerator<T>* Clone()const
				{
					return new Enumerator;
				}

				const T& Current()const
				{
					return *(T*)0;
				}

				vint Index()const
				{
					return -1;
				}

				bool Next()
				{
					return false;
				}

				void Reset()
				{
				}
			};
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator;
			}
		};

/***********************************************************************
自包含迭代器
***********************************************************************/

		template<typename T, typename TContainer>
		class ContainerEnumerator : public Object, public virtual IEnumerator<T>
		{
		private:
			Ptr<TContainer>					container;
			vint							index;

		public:
			ContainerEnumerator(Ptr<TContainer> _container, vint _index=-1)
			{
				container=_container;
				index=_index;
			}

			IEnumerator<T>* Clone()const
			{
				return new ContainerEnumerator(container, index);
			}

			const T& Current()const
			{
				return container->Get(index);
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				index++;
				return index>=0 && index<container->Count();
			}

			void Reset()
			{
				index=-1;
			}
		};

/***********************************************************************
迭代器比较
***********************************************************************/

		template<typename T, typename U>
		vint CompareEnumerable(const IEnumerable<T>& a, const IEnumerable<U>& b)
		{
			Ptr<IEnumerator<T>> ator=a.CreateEnumerator();
			Ptr<IEnumerator<U>> btor=b.CreateEnumerator();
			while()
			{
				bool a=ator->Next();
				bool b=btor->Next();
				if(a&&!b) return 1;
				if(!a&&b) return -1;
				if(!a&&!b) break;

				const T& ac=ator->Current();
				const U& bc=btor->Current();
				if(ac<bc)
				{
					return -1;
				}
				else if(ac>bc)
				{
					return 1;
				}
				ator->Next();
				btor->Next();
			}
			return 0;
		}
	}
}

#endif

/***********************************************************************
FUNCTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Function

Classes:
	Func<function-type>									：函数对象

Functions:
	Curry :: (A->B) -> A -> B							：参数拆分
	Combine :: (A->B) -> (A->C) -> (B->C->D) -> (A->D)	：函数组合
	
本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/
#ifndef VCZH_FUNCTION
#define VCZH_FUNCTION
namespace vl
{
	template<typename T>
	class Func
	{
	};
 
/***********************************************************************
vl::Func<R()>
***********************************************************************/
	template<typename R >
	class Func<R()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)();
		public:
			StaticInvoker(R(*_function)())
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)();
			struct Content
			{
				C*			sender;
				R(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke()
			{
				return (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType();
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R()>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()()const
		{
			return invoker->Invoke();
		}
		bool operator==(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void()>
***********************************************************************/
	template< >
	class Func<void()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)();
		public:
			StaticInvoker(void(*_function)())
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)();
			struct Content
			{
				C*			sender;
				void(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke()
			{
				  (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType();
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void()>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()()const
		{
			  invoker->Invoke();
		}
		bool operator==(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0)>
***********************************************************************/
	template<typename R,typename T0>
	class Func<R(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0);
		public:
			StaticInvoker(R(*_function)(T0))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0)const
		{
			return invoker->Invoke(p0);
		}
		bool operator==(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0)>
***********************************************************************/
	template< typename T0>
	class Func<void(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0);
		public:
			StaticInvoker(void(*_function)(T0))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0)const
		{
			  invoker->Invoke(p0);
		}
		bool operator==(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1)>
***********************************************************************/
	template<typename R,typename T0,typename T1>
	class Func<R(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1);
		public:
			StaticInvoker(R(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1)const
		{
			return invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1)>
***********************************************************************/
	template< typename T0,typename T1>
	class Func<void(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1);
		public:
			StaticInvoker(void(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1)const
		{
			  invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2>
	class Func<R(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2)const
		{
			return invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2)>
***********************************************************************/
	template< typename T0,typename T1,typename T2>
	class Func<void(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2)const
		{
			  invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3>
	class Func<R(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			return invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3>
	class Func<void(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			  invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<R(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<void(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<R(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<void(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<R(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<void(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
	namespace function_lambda
	{
		template<typename T>
		struct LambdaRetriveType
		{
			typedef vint Type;
			typedef vint ResultType;
		};
 
		template<typename T>
		struct FunctionObjectRetriveType
		{
			typedef typename LambdaRetriveType<decltype(&T::operator())>::Type Type;
			typedef typename LambdaRetriveType<decltype(&T::operator())>::ResultType ResultType;
		};
 
/***********************************************************************
vl::Func<R()>
***********************************************************************/
 
		template<typename TObject, typename R >
		struct LambdaRetriveType<R (__thiscall TObject::*)()const>
		{
			typedef Func<R()> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R >
		struct LambdaRetriveType<R (__thiscall TObject::*)()>
		{
			typedef Func<R()> Type;
			typedef R ResultType;
		};
 
		template<typename R >
		struct FunctionObjectRetriveType<R(*)()>
		{
			typedef Func<R()> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0)const>
		{
			typedef Func<R(T0)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0)>
		{
			typedef Func<R(T0)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0>
		struct FunctionObjectRetriveType<R(*)(T0)>
		{
			typedef Func<R(T0)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1)const>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1)>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1>
		struct FunctionObjectRetriveType<R(*)(T0,T1)>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2)const>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2)>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2)>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3)const>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3)>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3)>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4)>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4)>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R ResultType;
		};
 
 
		template<typename T>
		typename LambdaRetriveType<decltype(&T::operator())>::Type Lambda(T functionObject)
		{
			return functionObject;
		}
		template<typename T>
		typename FunctionObjectRetriveType<T>::Type ConvertToFunction(T functionObject)
		{
			return functionObject;
		}
#define LAMBDA vl::function_lambda::Lambda
#define FUNCTION vl::function_lambda::ConvertToFunction
#define FUNCTION_TYPE(T) typename vl::function_lambda::FunctionObjectRetriveType<T>::Type
#define FUNCTION_RESULT_TYPE(T) typename vl::function_lambda::FunctionObjectRetriveType<T>::ResultType
	}
	namespace function_binding
	{
		template<typename T>
		struct Binding
		{
		};
		 
		template<typename T>
		struct CR{typedef const T& Type;};
		template<typename T>
		struct CR<T&>{typedef T& Type;};
		template<typename T>
		struct CR<const T>{typedef const T& Type;};
		template<typename T>
		struct CR<const T&>{typedef const T& Type;};
		 
		template<typename T>
		struct RCR{typedef T Type;};
		template<typename T>
		struct RCR<T&>{typedef T& Type;};
		template<typename T>
		struct RCR<const T>{typedef T Type;};
		template<typename T>
		struct RCR<const T&>{typedef T Type;};
		
 
/***********************************************************************
vl::function_binding::Binding<R(T0)>
***********************************************************************/
		template<typename R,typename T0>
		struct Binding<R(T0)>
		{
			typedef R FunctionType(T0);
			typedef R CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()()const
				{
					return target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0)>
***********************************************************************/
		template< typename T0>
		struct Binding<void(T0)>
		{
			typedef void FunctionType(T0);
			typedef void CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()()const
				{
					  target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1)>
***********************************************************************/
		template<typename R,typename T0,typename T1>
		struct Binding<R(T0,T1)>
		{
			typedef R FunctionType(T0,T1);
			typedef R CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1)const
				{
					return target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1)>
***********************************************************************/
		template< typename T0,typename T1>
		struct Binding<void(T0,T1)>
		{
			typedef void FunctionType(T0,T1);
			typedef void CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1)const
				{
					  target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2>
		struct Binding<R(T0,T1,T2)>
		{
			typedef R FunctionType(T0,T1,T2);
			typedef R CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2)const
				{
					return target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2)>
***********************************************************************/
		template< typename T0,typename T1,typename T2>
		struct Binding<void(T0,T1,T2)>
		{
			typedef void FunctionType(T0,T1,T2);
			typedef void CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2)const
				{
					  target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3>
		struct Binding<R(T0,T1,T2,T3)>
		{
			typedef R FunctionType(T0,T1,T2,T3);
			typedef R CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3)const
				{
					return target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3>
		struct Binding<void(T0,T1,T2,T3)>
		{
			typedef void FunctionType(T0,T1,T2,T3);
			typedef void CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3)const
				{
					  target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<R(T0,T1,T2,T3,T4)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4);
			typedef R CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					return target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<void(T0,T1,T2,T3,T4)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4);
			typedef void CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					  target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<R(T0,T1,T2,T3,T4,T5)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5);
			typedef R CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					return target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<void(T0,T1,T2,T3,T4,T5)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5);
			typedef void CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					  target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
	}
 
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(T* function)
	{
		return typename function_binding::Binding<T>::Currier(function);
	}
 
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(const Func<T>& function)
	{
		return typename function_binding::Binding<T>::Currier(function);
	}
 
	namespace function_combining
	{
		template<typename A, typename B, typename C>
		class Combining
		{
		};
 
/***********************************************************************
vl::function_combining::Combining<R1(), R2(), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R >
		class Combining<R1(), R2(), R(R1,R2)> : public Object
		{
		protected:
			Func<R1()>			function1;
			Func<R2()>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType();
			typedef R2 SecondFunctionType();
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType();
			Combining(const Func<R1()>& _function1, const Func<R2()>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()()const
			{
				return converter(function1(), function2());
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0), R2(T0), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0>
		class Combining<R1(T0), R2(T0), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0)>			function1;
			Func<R2(T0)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0);
			typedef R2 SecondFunctionType(T0);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0);
			Combining(const Func<R1(T0)>& _function1, const Func<R2(T0)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0)const
			{
				return converter(function1(p0), function2(p0));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1>
		class Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1)>			function1;
			Func<R2(T0,T1)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1);
			typedef R2 SecondFunctionType(T0,T1);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1);
			Combining(const Func<R1(T0,T1)>& _function1, const Func<R2(T0,T1)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1)const
			{
				return converter(function1(p0,p1), function2(p0,p1));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2>
		class Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2)>			function1;
			Func<R2(T0,T1,T2)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2);
			typedef R2 SecondFunctionType(T0,T1,T2);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2);
			Combining(const Func<R1(T0,T1,T2)>& _function1, const Func<R2(T0,T1,T2)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2)const
			{
				return converter(function1(p0,p1,p2), function2(p0,p1,p2));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3>
		class Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3)>			function1;
			Func<R2(T0,T1,T2,T3)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3);
			typedef R2 SecondFunctionType(T0,T1,T2,T3);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3);
			Combining(const Func<R1(T0,T1,T2,T3)>& _function1, const Func<R2(T0,T1,T2,T3)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
			{
				return converter(function1(p0,p1,p2,p3), function2(p0,p1,p2,p3));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		class Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4)>			function1;
			Func<R2(T0,T1,T2,T3,T4)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4);
			Combining(const Func<R1(T0,T1,T2,T3,T4)>& _function1, const Func<R2(T0,T1,T2,T3,T4)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
			{
				return converter(function1(p0,p1,p2,p3,p4), function2(p0,p1,p2,p3,p4));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		class Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5), function2(p0,p1,p2,p3,p4,p5));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6), function2(p0,p1,p2,p3,p4,p5,p6));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7), function2(p0,p1,p2,p3,p4,p5,p6,p7));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9));
			}
		};
	}
	template<typename F1, typename F2, typename C>
	Func<typename function_combining::Combining<F1, F2, C>::FinalFunctionType>
	Combine(Func<C> converter, Func<F1> function1, Func<F2> function2)
	{
		return function_combining::Combining<F1, F2, C>(function1, function2, converter);
	}
	template<typename T>
	Func<Func<T>(Func<T>,Func<T>)> Combiner(const Func<typename Func<T>::ResultType(typename Func<T>::ResultType,typename Func<T>::ResultType)>& converter)
	{
		typedef typename Func<T>::ResultType R;
		return Curry<Func<T>(Func<R(R,R)>,Func<T>,Func<T>)>(Combine)(converter);
	}
}
#endif

/***********************************************************************
COLLECTIONS\OPERATIONSELECT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSELECT
#define VCZH_COLLECTIONS_OPERATIONSELECT


namespace vl
{
	namespace collections
	{

/***********************************************************************
Select
***********************************************************************/

		template<typename T, typename K>
		class SelectEnumerator : public virtual IEnumerator<K>
		{
		protected:
			IEnumerator<T>*		enumerator;
			Func<K(T)>			selector;
			K					current;
		public:
			SelectEnumerator(IEnumerator<T>* _enumerator, const Func<K(T)>& _selector)
				:enumerator(_enumerator)
				,selector(_selector)
			{
			}

			~SelectEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<K>* Clone()const
			{
				return new SelectEnumerator(enumerator->Clone(), selector);
			}

			const K& Current()const
			{
				return current;
			}

			vint Index()const
			{
				return enumerator->Index();
			}

			bool Next()
			{
				if(enumerator->Next())
				{
					current=selector(enumerator->Current());
					return true;
				}
				else
				{
					return false;
				}
			}

			void Reset()
			{
				enumerator->Reset();
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONWHERE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONWHERE
#define VCZH_COLLECTIONS_OPERATIONWHERE


namespace vl
{
	namespace collections
	{
/***********************************************************************
Where
***********************************************************************/

		template<typename T>
		class WhereEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			Func<bool(T)>			selector;
			vint					index;

		public:
			WhereEnumerator(IEnumerator<T>* _enumerator, const Func<bool(T)>& _selector, vint _index=-1)
				:enumerator(_enumerator)
				,selector(_selector)
				,index(_index)
			{
			}

			~WhereEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new WhereEnumerator(enumerator->Clone(), selector, index);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				while(enumerator->Next())
				{
					if(selector(enumerator->Current()))
					{
						index++;
						return true;
					}
				}
				return false;
			}

			void Reset()
			{
				enumerator->Reset();
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONCONCAT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONCONCAT
#define VCZH_COLLECTIONS_OPERATIONCONCAT


namespace vl
{
	namespace collections
	{

/***********************************************************************
Concat
***********************************************************************/

		template<typename T>
		class ConcatEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*					enumerator1;
			IEnumerator<T>*					enumerator2;
			vint							index;
			bool							turned;
		public:
			ConcatEnumerator(IEnumerator<T>* _enumerator1, IEnumerator<T>* _enumerator2, vint _index=-1, bool _turned=false)
				:enumerator1(_enumerator1)
				,enumerator2(_enumerator2)
				,index(_index)
				,turned(_turned)
			{
			}

			~ConcatEnumerator()
			{
				delete enumerator1;
				delete enumerator2;
			}

			IEnumerator<T>* Clone()const
			{
				return new ConcatEnumerator(enumerator1->Clone(), enumerator2->Clone(), index, turned);
			}

			const T& Current()const
			{
				if(turned)
				{
					return enumerator2->Current();
				}
				else
				{
					return enumerator1->Current();
				}
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				index++;
				if(turned)
				{
					return enumerator2->Next();
				}
				else
				{
					if(enumerator1->Next())
					{
						return true;
					}
					else
					{
						turned=true;
						return enumerator2->Next();
					}
				}
			}

			void Reset()
			{
				enumerator1->Reset();
				enumerator2->Reset();
				index=-1;
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSEQUENCE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSEQUENCE
#define VCZH_COLLECTIONS_OPERATIONSEQUENCE


namespace vl
{
	namespace collections
	{

/***********************************************************************
Take
***********************************************************************/

		template<typename T>
		class TakeEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
		public:
			TakeEnumerator(IEnumerator<T>* _enumerator, vint _count)
				:enumerator(_enumerator)
				,count(_count)
			{
			}

			~TakeEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new TakeEnumerator(enumerator->Clone(), count);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return enumerator->Index();
			}

			bool Next()
			{
				if(enumerator->Index()>=count-1) return false;
				return enumerator->Next();
			}

			void Reset()
			{
				enumerator->Reset();
			}
		};

/***********************************************************************
Skip
***********************************************************************/

		template<typename T>
		class SkipEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
		public:
			SkipEnumerator(IEnumerator<T>* _enumerator, vint _count, bool runSkip=true)
				:enumerator(_enumerator)
				,count(_count)
			{
				if(runSkip)
				{
					for(vint i=0;i<count;i++)
					{
						enumerator->Next();
					}
				}
			}

			~SkipEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new SkipEnumerator(enumerator->Clone(), count, false);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return enumerator->Index()-count;
			}

			bool Next()
			{
				return enumerator->Next();
			}

			void Reset()
			{
				enumerator->Reset();
				for(vint i=0;i<count;i++)
				{
					enumerator->Next();
				}
			}
		};

/***********************************************************************
Repeat
***********************************************************************/

		template<typename T>
		class RepeatEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
			vint					index;
			vint					repeatedCount;
		public:
			RepeatEnumerator(IEnumerator<T>* _enumerator, vint _count, vint _index=-1, vint _repeatedCount=0)
				:enumerator(_enumerator)
				,count(_count)
				,index(_index)
				,repeatedCount(_repeatedCount)
			{
			}

			~RepeatEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new RepeatEnumerator(enumerator->Clone(), count, index, repeatedCount);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				while(repeatedCount<count)
				{
					if(enumerator->Next())
					{
						index++;
						return true;
					}
					repeatedCount++;
					enumerator->Reset();
				}
				return false;
			}

			void Reset()
			{
				enumerator->Reset();
				index=-1;
				repeatedCount=0;
			}
		};

/***********************************************************************
Distinct
***********************************************************************/

		template<typename T>
		class DistinctEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*		enumerator;
			SortedList<T>		distinct;
			T					lastValue;

		public:
			DistinctEnumerator(IEnumerator<T>* _enumerator)
				:enumerator(_enumerator)
			{
			}

			DistinctEnumerator(const DistinctEnumerator& _enumerator)
			{
				enumerator=_enumerator.enumerator->Clone();
				CopyFrom(distinct, _enumerator.distinct);
			}

			~DistinctEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new DistinctEnumerator(*this);
			}

			const T& Current()const
			{
				return lastValue;
			}

			vint Index()const
			{
				return distinct.Count()-1;
			}

			bool Next()
			{
				while(enumerator->Next())
				{
					const T& current=enumerator->Current();
					if(!distinct.Contains(current))
					{
						lastValue=current;
						distinct.Add(current);
						return true;
					}
				}
				return false;
			}

			void Reset()
			{
				enumerator->Reset();
				distinct.Clear();
			}
		};

/***********************************************************************
Reverse
***********************************************************************/

		template<typename T>
		class ReverseEnumerator : public virtual IEnumerator<T>
		{
		protected:
			List<T>						cache;
			vint						index;
		public:
			ReverseEnumerator(const IEnumerable<T>& enumerable)
				:index(-1)
			{
				CopyFrom(cache, enumerable);
			}

			ReverseEnumerator(const ReverseEnumerator& _enumerator)
			{
				CopyFrom(cache, _enumerator.cache);
				index=_enumerator.index;
			}

			~ReverseEnumerator()
			{
			}

			IEnumerator<T>* Clone()const
			{
				return new ReverseEnumerator(*this);
			}

			const T& Current()const
			{
				return cache.Get(cache.Count()-1-index);
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				index++;
				return index<cache.Count();
			}

			void Reset()
			{
				index=0;
			}
		};

/***********************************************************************
FromIterator
***********************************************************************/

		template<typename T, typename I>
		class FromIteratorEnumerable : public Object, public IEnumerable<T>
		{
			friend class Enumerable<T>;
		private:
			class Enumerator : public Object, public IEnumerator<T>
			{
			private:
				I				begin;
				I				end;
				I				current;

			public:
				Enumerator(I _begin, I _end, I _current)
					:begin(_begin)
					,end(_end)
					,current(_current)
				{
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(begin, end, current);
				}

				const T& Current()const
				{
					return *current;
				}

				vint Index()const
				{
					return current-begin;
				}

				bool Next()
				{
					current++;
					return begin<=current && current<end;
				}

				void Reset()
				{
					current=begin-1;
				}
			};
		private:
			I					begin;
			I					end;
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(begin, end, begin-1);
			}

			FromIteratorEnumerable(I _begin, I _end)
				:begin(_begin)
				,end(_end)
			{
			}
		};

		template<typename T>
		class FromIterator
		{
		public:
			template<typename I>
			static FromIteratorEnumerable<T, I> Wrap(I begin, I end)
			{
				return FromIteratorEnumerable<T, I>(begin, end);
			}
		};

		template<typename T>
		FromIteratorEnumerable<T, T*> FromPointer(T* begin, T* end)
		{
			return FromIteratorEnumerable<T, T*>(begin, end);
		}

		template<typename T, int size>
		FromIteratorEnumerable<T, T*> FromArray(T (&items)[size])
		{
			return FromIteratorEnumerable<T, T*>(&items[0], &items[size]);
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSET.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSET
#define VCZH_COLLECTIONS_OPERATIONSET


namespace vl
{
	namespace collections
	{

/***********************************************************************
Intersect/Except
***********************************************************************/

		template<typename T, bool Intersect>
		class IntersectExceptEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*				enumerator;
			SortedList<T>				reference;
			vint						index;

		public:
			IntersectExceptEnumerator(IEnumerator<T>* _enumerator, const IEnumerable<T>& _reference)
				:enumerator(_enumerator)
				,index(-1)
			{
				CopyFrom(reference, _reference);
			}

			IntersectExceptEnumerator(const IntersectExceptEnumerator& _enumerator)
			{
				enumerator=_enumerator.enumerator->Clone();
				CopyFrom(reference, _enumerator.reference);
				index=_enumerator.index;
			}

			~IntersectExceptEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new IntersectExceptEnumerator(*this);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				while(enumerator->Next())
				{
					if(reference.Contains(enumerator->Current())==Intersect)
					{
						index++;
						return true;
					}
				}
				return false;
			}

			void Reset()
			{
				enumerator->Reset();
				index=0;
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONPAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONPAIR
#define VCZH_COLLECTIONS_OPERATIONPAIR


namespace vl
{
	namespace collections
	{

/***********************************************************************
Pairwise
***********************************************************************/

		template<typename S, typename T>
		class PairwiseEnumerator : public virtual IEnumerator<Pair<S, T>>
		{
		protected:
			IEnumerator<S>*					enumerator1;
			IEnumerator<T>*					enumerator2;
			Pair<S, T>						current;
		public:
			PairwiseEnumerator(IEnumerator<S>* _enumerator1, IEnumerator<T>* _enumerator2)
				:enumerator1(_enumerator1)
				,enumerator2(_enumerator2)
			{
			}

			~PairwiseEnumerator()
			{
				delete enumerator1;
				delete enumerator2;
			}

			IEnumerator<Pair<S, T>>* Clone()const
			{
				return new PairwiseEnumerator(enumerator1->Clone(), enumerator2->Clone());
			}

			const Pair<S, T>& Current()const
			{
				return current;
			}

			vint Index()const
			{
				return enumerator1->Index();
			}

			bool Next()
			{
				if(enumerator1->Next() && enumerator2->Next())
				{
					current=Pair<S, T>(enumerator1->Current(), enumerator2->Current());
					return true;
				}
				else
				{
					return false;
				}
			}

			void Reset()
			{
				enumerator1->Reset();
				enumerator2->Reset();
			}
		};
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATIONSTRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSTRING
#define VCZH_COLLECTIONS_OPERATIONSTRING


namespace vl
{
	namespace collections
	{
		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const ObjectString<S>& ss, bool append=false)
		{
			const S* buffer=ss.Buffer();
			vint count=ss.Length();
			CopyFrom(ds, buffer, count, append);
		}

		template<typename D, typename Ss>
		void CopyFrom(ObjectString<D>& ds, const Ss& ss, bool append=false)
		{
			Array<D> da(ds.Buffer(), ds.Length());
			CopyFrom(da, ss, append);
			if(da.Count()==0)
			{
				ds=ObjectString<D>();
			}
			else
			{
				ds=ObjectString<D>(&da[0], da.Count());
			}
		}
	}
}

#endif

/***********************************************************************
COLLECTIONS\OPERATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

Functions:
	CopyFrom(TargetContainer, SourceContainer)
	[T]		.Select(T->K) => [K]
	[T]		.SelectMany(T->[K]) => [K]
	[T]		.Where(T->bool) => [T]
	[Ptr<T>].Cast<K>() => [Ptr<K>]
	[Ptr<T>].FindType<K>() => [Ptr<K>]
	[T]		.OrderBy(T->T->int) => [T]

	[T]		.Aggregate(T->T->T) => T
	[T]		.Aggregate(T->T->T, T) => T
	[T]		.All(T->bool) => bool
	[T]		.Any(T->bool) => bool
	[T]		.Max() => T
	[T]		.Min() => T
	[T]		.First() => T
	[T]		.FirstOrDefault(T) => T
	[T]		.Last() => T
	[T]		.LastOrDefault(T) => T
	[T]		.Count() => vint
	[T]		.IsEmpty() => bool

	[T]		.Concat([T]) => [T]
	[T]		.Repeat(vint) => [T]
	[T]		.Take(vint) => [T]
	[T]		.Skip(vint) => [T]
	[T]		.Distinct() => [T]
	[T]		.Reverse() => [T]

	[T]		.Pairwise([K]) => [(T,K)]
	[T]		.Intersect([T]) => [T]
	[T]		.Union([T]) => [T]
	[T]		.Except([T]) => [T]

	From(begin, end) => [T]
	From(array) => [T]

	FOREACH(X, a, XList)
	FOREACH_INDEXER(X, a, index, XList)
***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATION
#define VCZH_COLLECTIONS_OPERATION


namespace vl
{
	namespace collections
	{

/***********************************************************************
OrderBy Quick Sort
***********************************************************************/

		template<typename T>
		void Sort(T* items, vint length, const Func<vint(T, T)>& orderer)
		{
			if(length==0) return;
			vint pivot=0;
			vint left=0;
			vint right=0;
			bool flag=false;

			while(left+right+1!=length)
			{
				vint& mine=(flag?left:right);
				vint& theirs=(flag?right:left);
				vint candidate=(flag?left:length-right-1);
				vint factor=(flag?-1:1);

				if(orderer(items[pivot], items[candidate])*factor<=0)
				{
					mine++;
				}
				else
				{
					theirs++;
					T temp=items[pivot];
					items[pivot]=items[candidate];
					items[candidate]=temp;
					pivot=candidate;
					flag=!flag;
				}
			}

			Sort(items, left, orderer);
			Sort(items+left+1, right, orderer);
		}

/***********************************************************************
LazyList
***********************************************************************/

		template<typename T>
		class LazyList : public Object, public IEnumerable<T>
		{
		protected:
			Ptr<IEnumerator<T>>			enumeratorPrototype;

			IEnumerator<T>* xs()const
			{
				return enumeratorPrototype->Clone();
			}
		public:
			LazyList(Ptr<IEnumerator<T>> enumerator)
				:enumeratorPrototype(enumerator)
			{
			}

			LazyList(const IEnumerable<T>& enumerable)
				:enumeratorPrototype(enumerable.CreateEnumerator())
			{
			}

			LazyList(const LazyList<T>& lazyList)
				:enumeratorPrototype(lazyList.enumeratorPrototype)
			{
			}

			template<typename TContainer>
			LazyList(Ptr<TContainer> container)
				:enumeratorPrototype(new ContainerEnumerator<T, TContainer>(container))
			{
			}
			
			LazyList()
				:enumeratorPrototype(EmptyEnumerable<T>().CreateEnumerator())
			{
			}

			LazyList<T>& operator=(const LazyList<T>& lazyList)
			{
				enumeratorPrototype=lazyList.enumeratorPrototype;
				return *this;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return enumeratorPrototype->Clone();
			}

			//-------------------------------------------------------

			template<typename F>
			LazyList<FUNCTION_RESULT_TYPE(F)> Select(F f)const
			{
				return new SelectEnumerator<T, FUNCTION_RESULT_TYPE(F)>(xs(), f);
			}

			template<typename F>
			auto SelectMany(F f)const -> LazyList<decltype(From(f(T())).First())>
			{
				typedef decltype(From(f(T())).First()) U;
				return Select(f).Aggregate(LazyList<U>(), [](const LazyList<U>& a, const IEnumerable<U>& b){return a.Concat(b);});
			}
			
			template<typename F>
			LazyList<T> Where(F f)const
			{
				return new WhereEnumerator<T>(xs(), f);
			}

			template<typename U>
			LazyList<Ptr<U>> Cast()const
			{
				Func<Ptr<U>(T)> f=[](T t)->Ptr<U>{return t.Cast<U>();};
				return new SelectEnumerator<T, Ptr<U>>(xs(), f);
			}

			template<typename U>
			LazyList<Ptr<U>> FindType()const
			{
				return Cast<U>().Where([](T t){return t;});
			}

			template<typename F>
			LazyList<T> OrderBy(F f)const
			{
				Ptr<List<T>> sorted=new List<T>;
				CopyFrom(*sorted.Obj(), *this);
				if(sorted->Count()>0)
				{
					Sort<T>(&sorted->operator[](0), sorted->Count(), f);
				}
				return new ContainerEnumerator<T, List<T>>(sorted);
			}

			//-------------------------------------------------------

			template<typename F>
			T Aggregate(F f)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::Aggregate(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				T result=enumerator->Current();
				while(enumerator->Next())
				{
					result=f(result, enumerator->Current());
				}
				return result;
			}

			template<typename I, typename F>
			I Aggregate(I init, F f)const
			{
				FOREACH(T, t, *this)
				{
					init=f(init, t);
				}
				return init;
			}

			template<typename F>
			bool All(F f)const
			{
				return Select(f).Aggregate(true, [](bool a, bool b){return a&&b;});
			}

			template<typename F>
			bool Any(F f)const
			{
				return Select(f).Aggregate(false, [](bool a, bool b){return a||b;});
			}

			T Max()const
			{
				return Aggregate([](T a, T b){return a>b?a:b;});
			}

			T Min()const
			{
				return Aggregate([](T a, T b){return a<b?a:b;});
			}

			T First()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::First(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				return enumerator->Current();
			}

			T First(T defaultValue)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					return defaultValue;
				}
				return enumerator->Current();
			}

			T Last()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::Last(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				else
				{
					T value=enumerator->Current();
					while(enumerator->Next())
					{
						value=enumerator->Current();
					}
					return value;
				}
			}

			T Last(T defaultValue)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				while(enumerator->Next())
				{
					defaultValue=enumerator->Current();
				}
				return defaultValue;
			}

			vint Count()const
			{
				vint result=0;
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				while(enumerator->Next())
				{
					result++;
				}
				return result;
			}

			bool IsEmpty()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				return enumerator->Next();
			}

			//-------------------------------------------------------

			LazyList<T> Concat(const IEnumerable<T>& remains)const
			{
				return new ConcatEnumerator<T>(xs(), remains.CreateEnumerator());
			}

			LazyList<T> Take(vint count)const
			{
				return new TakeEnumerator<T>(xs(), count);
			}

			LazyList<T> Skip(vint count)const
			{
				return new SkipEnumerator<T>(xs(), count);
			}

			LazyList<T> Repeat(vint count)const
			{
				return new RepeatEnumerator<T>(xs(), count);
			}

			LazyList<T> Distinct()const
			{
				return new DistinctEnumerator<T>(xs());
			}

			LazyList<T> Reverse()const
			{
				return new ReverseEnumerator<T>(*this);
			}

			//-------------------------------------------------------

			template<typename U>
			LazyList<Pair<T, U>> Pairwise(const IEnumerable<U>& remains)const
			{
				return new PairwiseEnumerator<T, U>(xs(), remains.CreateEnumerator());
			}

			LazyList<T> Intersect(const IEnumerable<T>& remains)const
			{
				return new IntersectExceptEnumerator<T, true>(xs(), remains);
			}

			LazyList<T> Except(const IEnumerable<T>& remains)const
			{
				return new IntersectExceptEnumerator<T, false>(xs(), remains);
			}

			LazyList<T> Union(const IEnumerable<T>& remains)const
			{
				return Concat(remains).Distinct();
			}
		};

		template<typename T>
		LazyList<T> From(const IEnumerable<T>& enumerable)
		{
			return enumerable;
		}

		template<typename T>
		LazyList<T> From(const T* begin, const T* end)
		{
			return FromPointer(begin, end);
		}

		template<typename T, int size>
		LazyList<T> From(T (&items)[size])
		{
			return FromArray(items);
		}

		template<typename T, int size>
		LazyList<T> From(const T (&items)[size])
		{
			return FromArray(items);
		}
	}
}

#endif

/***********************************************************************
PARSING\XML\PARSINGXML_PARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parser::ParsingXml_Parser

本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/

#ifndef VCZH_PARSING_XML_PARSINGXML_PARSER
#define VCZH_PARSING_XML_PARSINGXML_PARSER


namespace vl
{
	namespace parsing
	{
		namespace xml
		{
			struct XmlParserTokenIndex abstract
			{
				static const vl::vint INSTRUCTION_OPEN = 0;
				static const vl::vint INSTRUCTION_CLOSE = 1;
				static const vl::vint COMPLEX_ELEMENT_OPEN = 2;
				static const vl::vint SINGLE_ELEMENT_CLOSE = 3;
				static const vl::vint ELEMENT_OPEN = 4;
				static const vl::vint ELEMENT_CLOSE = 5;
				static const vl::vint EQUAL = 6;
				static const vl::vint NAME = 7;
				static const vl::vint ATTVALUE = 8;
				static const vl::vint COMMENT = 9;
				static const vl::vint CDATA = 10;
				static const vl::vint TEXT = 11;
				static const vl::vint SPACE = 12;
			};
			class XmlNode;
			class XmlText;
			class XmlCData;
			class XmlAttribute;
			class XmlComment;
			class XmlElement;
			class XmlInstruction;
			class XmlDocument;

			class XmlNode abstract : public vl::parsing::ParsingTreeCustomBase
			{
			public:
				class IVisitor : public vl::Interface
				{
				public:
					virtual void Visit(XmlText* node)=0;
					virtual void Visit(XmlCData* node)=0;
					virtual void Visit(XmlAttribute* node)=0;
					virtual void Visit(XmlComment* node)=0;
					virtual void Visit(XmlElement* node)=0;
					virtual void Visit(XmlInstruction* node)=0;
					virtual void Visit(XmlDocument* node)=0;
				};

				virtual void Accept(XmlNode::IVisitor* visitor)=0;

			};

			class XmlText : public XmlNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlText> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlCData : public XmlNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlCData> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlAttribute : public XmlNode
			{
			public:
				vl::parsing::ParsingToken name;
				vl::parsing::ParsingToken value;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlAttribute> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlComment : public XmlNode
			{
			public:
				vl::parsing::ParsingToken content;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlComment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlElement : public XmlNode
			{
			public:
				vl::parsing::ParsingToken name;
				vl::parsing::ParsingToken closingName;
				vl::collections::List<vl::Ptr<XmlAttribute>> attributes;
				vl::collections::List<vl::Ptr<XmlNode>> subNodes;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlElement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlInstruction : public XmlNode
			{
			public:
				vl::parsing::ParsingToken name;
				vl::collections::List<vl::Ptr<XmlAttribute>> attributes;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlInstruction> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			class XmlDocument : public XmlNode
			{
			public:
				vl::collections::List<vl::Ptr<XmlNode>> prologs;
				vl::Ptr<XmlElement> rootElement;

				void Accept(XmlNode::IVisitor* visitor)override;

				static vl::Ptr<XmlDocument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			};

			extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable();

			extern vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);
			extern vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table);
		}
	}
}
#endif

/***********************************************************************
PARSING\XML\PARSINGXML.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Parser::ParsingXml

***********************************************************************/

#ifndef VCZH_PARSING_XML_PARSINGXML
#define VCZH_PARSING_XML_PARSINGXML


namespace vl
{
	namespace parsing
	{
		namespace xml
		{
			extern WString							XmlEscapeValue(const WString& value);
			extern WString							XmlUnescapeValue(const WString& value);
			extern WString							XmlEscapeCData(const WString& value);
			extern WString							XmlUnescapeCData(const WString& value);
			extern WString							XmlEscapeComment(const WString& value);
			extern WString							XmlUnescapeComment(const WString& value);
			extern void								XmlPrint(Ptr<XmlNode> node, stream::TextWriter& writer);
			extern WString							XmlToString(Ptr<XmlNode> node);

			extern Ptr<XmlAttribute>							XmlGetAttribute(Ptr<XmlElement> element, const WString& name);
			extern Ptr<XmlElement>								XmlGetElement(Ptr<XmlElement> element, const WString& name);
			extern collections::LazyList<Ptr<XmlElement>>		XmlGetElements(Ptr<XmlElement> element);
			extern collections::LazyList<Ptr<XmlElement>>		XmlGetElements(Ptr<XmlElement> element, const WString& name);
			extern WString										XmlGetValue(Ptr<XmlElement> element);
		}
	}
}

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

XML Representation for Code Generation:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTOR
#define VCZH_REFLECTION_GUITYPEDESCRIPTOR


namespace vl
{
	namespace reflection
	{

/***********************************************************************
Attribute
***********************************************************************/

		namespace description
		{
			class ITypeDescriptor;
		}

		class DescriptableObject
		{
			template<typename T>
			friend class Description;

			friend class DescriptableValue;
		protected:
			size_t									objectSize;
			description::ITypeDescriptor**			typeDescriptor;
		public:
			DescriptableObject();
			virtual ~DescriptableObject();

			description::ITypeDescriptor*			GetTypeDescriptor();
		};

		class IDescriptable : public virtual Interface, public virtual DescriptableObject
		{
		public:
			~IDescriptable(){}
		};
		
		template<typename T>
		class Description : public virtual DescriptableObject
		{
		protected:
			static description::ITypeDescriptor*		associatedTypeDescriptor;
		public:
			Description()
			{
				if(objectSize<sizeof(T))
				{
					objectSize=sizeof(T);
					typeDescriptor=&associatedTypeDescriptor;
				}
			}

			static description::ITypeDescriptor* GetAssociatedTypeDescriptor()
			{
				return associatedTypeDescriptor;
			}

			static void SetAssociatedTypeDescroptor(description::ITypeDescriptor* typeDescroptor)
			{
				if(!associatedTypeDescriptor)
				{
					associatedTypeDescriptor=typeDescroptor;
				}
			}
		};

		template<typename T>
		description::ITypeDescriptor* Description<T>::associatedTypeDescriptor=0;

/***********************************************************************
Value
***********************************************************************/

		namespace description
		{
			class Value : public Object
			{
			public:
				enum ValueType
				{
					Null,
					DescriptableObjectRef,
					DescriptableObjectPtr,
					Text,
				};
			protected:
				ValueType						valueType;
				DescriptableObject*				descriptableObjectRef;
				Ptr<DescriptableObject>			descriptableObjectPtr;
				WString							text;
				ITypeDescriptor*				typeDescriptor;
			public:
				Value();
				Value(DescriptableObject* value);
				Value(Ptr<DescriptableObject> value);
				Value(const WString& value, ITypeDescriptor* associatedTypeDescriptor);
				Value(const Value& value);

				Value&							operator=(const Value& value);

				ValueType						GetValueType()const;
				DescriptableObject*				GetDescriptableObjectRef()const;
				Ptr<DescriptableObject>			GetDescriptableObjectPtr()const;
				const WString&					GetText()const;
				ITypeDescriptor*				GetTypeDescriptor()const;
			};

			class IValueSerializer : public Interface
			{
			public:
				virtual WString					GetName()=0;
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual bool					Validate(const WString& text)=0;
				virtual bool					Parse(const WString& input, Value& output)=0;
			};

			template<typename T>
			class ITypedValueSerializer : public IValueSerializer
			{
				virtual bool					Serialize(const T& input, Value& output)=0;
				virtual bool					Deserialize(const Value& input, T& output)=0;
			};

/***********************************************************************
ITypeDescriptor (basic)
***********************************************************************/

			class IMemberInfo : public virtual Interface
			{
			public:
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual const WString&			GetName()=0;
			};

			class IValueInfo : public virtual Interface
			{
			public:
				virtual ITypeDescriptor*		GetValueTypeDescriptor()=0;
				virtual bool					CanBeNull()=0;
			};

/***********************************************************************
ITypeDescriptor (event)
***********************************************************************/

			class IEventInfo;

			class IEventHandler : public Interface
			{
			public:
				virtual IEventInfo*				GetOwnerEvent()=0;
				virtual Value					GetOwnerObject()=0;
				virtual bool					IsAttached()=0;
				virtual bool					Detach()=0;
				virtual void					Invoke(const Value& thisObject, Value& arguments)=0;
			};

			class IEventInfo : public IMemberInfo
			{
			public:
				virtual Ptr<IEventHandler>		Attach(const Value& thisObject, const Func<void(const Value&, Value&)>& handler)=0;
				virtual void					Invoke(const Value& thisObject, Value& arguments)=0;
			};

/***********************************************************************
ITypeDescriptor (property)
***********************************************************************/

			class IPropertyInfo : public IMemberInfo, public IValueInfo
			{
			public:
				virtual bool					IsReadable()=0;
				virtual bool					IsWritable()=0;
				virtual IEventInfo*				GetValueChangedEvent()=0;
				virtual Value					GetValue(const Value& thisObject)=0;
				virtual void					SetValue(const Value& thisObject, Value newValue)=0;
			};

/***********************************************************************
ITypeDescriptor (method)
***********************************************************************/

			class IMethodInfo;
			class IMethodGroupInfo;

			class IParameterInfo : public IMemberInfo, public IValueInfo
			{
			public:
				virtual IMethodInfo*			GetOwnerMethod()=0;
				virtual bool					CanOutput()=0;
			};

			class IMethodInfo : public IMemberInfo
			{
			public:
				virtual IMethodGroupInfo*		GetOwnerMethodGroup()=0;
				virtual vint					GetParameterCount()=0;
				virtual IParameterInfo*			GetParameter(vint index)=0;
				virtual IValueInfo*				GetReturn()=0;
				virtual Value					Invoke(const Value& thisObject, collections::Array<Value>& arguments)=0;
			};

			class IMethodGroupInfo : public IMemberInfo
			{
			public:
				virtual vint					GetMethodCount()=0;
				virtual IMethodInfo*			GetMethod(vint index)=0;
			};

/***********************************************************************
ITypeDescriptor
***********************************************************************/

			class ITypeDescriptor : public Interface
			{
			public:
				virtual const WString&			GetTypeName()=0;
				virtual IValueSerializer*		GetValueSerializer()=0;
				virtual vint					GetBaseTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetBaseTypeDescriptor(vint index)=0;

				virtual vint					GetPropertyCount()=0;
				virtual IPropertyInfo*			GetProperty(vint index)=0;
				virtual bool					IsPropertyExists(const WString& name, bool inheritable)=0;
				virtual IPropertyInfo*			GetPropertyByName(const WString& name, bool inheritable)=0;

				virtual vint					GetEventCount()=0;
				virtual IEventInfo*				GetEvent(vint index)=0;
				virtual bool					IsEventExists(const WString& name, bool inheritable)=0;
				virtual IEventInfo*				GetEventByName(const WString& name, bool inheritable)=0;

				virtual vint					GetMethodGroupCount()=0;
				virtual IMethodGroupInfo*		GetMethodGroup(vint index)=0;
				virtual bool					IsMethodGroupExists(const WString& name, bool inheritable)=0;
				virtual IMethodGroupInfo*		GetMethodGroupByName(const WString& name, bool inheritable)=0;
				virtual IMethodGroupInfo*		GetConstructorGroup()=0;
			};

/***********************************************************************
ITypeManager
***********************************************************************/

			class ITypeManager;

			class ITypeLoader : public Interface
			{
			public:
				virtual void					Load(ITypeManager* manager)=0;
				virtual void					Unload(ITypeManager* manager)=0;
			};

			class ITypeManager : public Interface
			{
			public:
				virtual vint					GetValueSerializerCount()=0;
				virtual IValueSerializer*		GetValueSerializer(vint index)=0;
				virtual IValueSerializer*		GetValueSerializer(const WString& name)=0;
				virtual bool					SetValueSerializer(const WString& name, Ptr<IValueSerializer> valueSerializer)=0;
				
				virtual vint					GetTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetTypeDescriptor(vint index)=0;
				virtual ITypeDescriptor*		GetTypeDescriptor(const WString& name)=0;
				virtual bool					SetTypeDescriptor(const WString& name, Ptr<ITypeDescriptor> typeDescriptor)=0;

				virtual bool					AddTypeLoader(Ptr<ITypeLoader> typeLoader)=0;
				virtual bool					RemoveTypeLoader(Ptr<ITypeLoader> typeLoader)=0;
				virtual bool					Load()=0;
				virtual bool					Unload()=0;
				virtual bool					Reload()=0;
				virtual bool					IsLoaded()=0;
			};

			extern ITypeManager*				GetGlobalTypeManager();
			extern bool							DestroyGlobalTypeManager();
			extern IValueSerializer*			GetValueSerializer(const WString& name);
			extern ITypeDescriptor*				GetTypeDescriptor(const WString& name);

/***********************************************************************
Exceptions
***********************************************************************/

			class TypeDescriptorException : public Exception
			{
			public:
				TypeDescriptorException(const WString& message)
					:Exception(message)
				{
				}
			};

			class PropertyIsNotReadableException : public TypeDescriptorException
			{
			public:
				PropertyIsNotReadableException(IPropertyInfo* propertyInfo)
					:TypeDescriptorException(L"Cannot read value from a property \""+propertyInfo->GetName()+L"\" that is not readable in type \""+propertyInfo->GetOwnerTypeDescriptor()->GetTypeName()+L"\"/")
				{
				}
			};

			class PropertyIsNotWritableException : public TypeDescriptorException
			{
			public:
				PropertyIsNotWritableException(IPropertyInfo* propertyInfo)
					:TypeDescriptorException(L"Cannot write value to a property \""+propertyInfo->GetName()+L"\" that is not writable in type \""+propertyInfo->GetOwnerTypeDescriptor()->GetTypeName()+L"\"/")
				{
				}
			};
		}
	}
}

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTORBUILDER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

Classes:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER
#define VCZH_REFLECTION_GUITYPEDESCRIPTORBUILDER


namespace vl
{
	namespace reflection
	{
		namespace description
		{

/***********************************************************************
Exceptions
***********************************************************************/

			class TypeDescriptorBuilderException : public Exception
			{
			public:
				TypeDescriptorBuilderException(const WString& message)
					:Exception(message)
				{
				}
			};

			class PropertyAlreadyExistsException : public TypeDescriptorBuilderException
			{
			public:
				PropertyAlreadyExistsException(ITypeDescriptor* typeDescriptor, const WString& propertyName)
					:TypeDescriptorBuilderException(L"Property \""+propertyName+L"\" already exists in type \""+typeDescriptor->GetTypeName()+L"\".")
				{
				}
			};

			class EventAlreadyExistsException : public TypeDescriptorBuilderException
			{
			public:
				EventAlreadyExistsException(ITypeDescriptor* typeDescriptor, const WString& eventName)
					:TypeDescriptorBuilderException(L"Event \""+eventName+L"\" already exists in type \""+typeDescriptor->GetTypeName()+L"\".")
				{
				}
			};

			class ParameterAlreadyExistsException : public TypeDescriptorBuilderException
			{
			public:
				ParameterAlreadyExistsException(IMethodInfo* method,  const WString& parameterName)
					:TypeDescriptorBuilderException(L"Parameter \""+parameterName+L"\" already exists in method \""+method->GetName()+L"\" in type \""+method->GetOwnerTypeDescriptor()->GetTypeName()+L"\".")
				{
				}
			};

/***********************************************************************
GeneralTypeDescriptor
***********************************************************************/

			class GeneralTypeDescriptor : public Object, public ITypeDescriptor
			{
			public:
				class PropertyGroup
				{
					friend class GeneralTypeDescriptor;
				protected:
					bool														loaded;
					Func<void(PropertyGroup*)>									loaderProcedure;
					ITypeDescriptor*											ownerTypeDescriptor;
					
					WString														typeName;
					IValueSerializer*											valueSerializer;
					collections::List<ITypeDescriptor*>							baseTypeDescriptors;
					collections::Dictionary<WString, Ptr<IPropertyInfo>>		properties;
					collections::Dictionary<WString, Ptr<IEventInfo>>			events;
					collections::Dictionary<WString, Ptr<IMethodGroupInfo>>		methodGroups;
					Ptr<IMethodGroupInfo>										contructorGroup;

				public:
					PropertyGroup();
					~PropertyGroup();

					void						Prepare();

					//----------------------------------------------------

					class MethodBuilder
					{
					protected:
						PropertyGroup&			propertyGroup;
						Ptr<IMethodGroupInfo>	buildingMethodGroup;
						Ptr<IMethodInfo>		buildingMethod;
					public:
						MethodBuilder(PropertyGroup& _propertyGroup, const WString& _name);

						MethodBuilder&			Parameter(
													const WString&									_name,
													ITypeDescriptor*								_type,
													bool											_nullable,
													bool											_canOutput
													);
						MethodBuilder&			Return(
													ITypeDescriptor*								_type,
													bool											_nullable
													);
						MethodBuilder&			Invoker(
													const Func<Value(const Value&, collections::Array<Value>&)>&	_invoker
													);
						PropertyGroup&			Done();
					};

					//----------------------------------------------------

					class EventBuilder
					{
					protected:
						PropertyGroup&			propertyGroup;
						Ptr<IEventInfo>			buildingEvent;
					public:
						EventBuilder(PropertyGroup& _propertyGroup, const WString& _name);

						EventBuilder&			Attacher(
													const Func<void(DescriptableObject*, IEventHandler*)>&	_attacher
													);
						EventBuilder&			Detacher(
													const Func<void(DescriptableObject*, IEventHandler*)>&	_detacher
													);
						EventBuilder&			Invoker(
													const Func<Value(const Value&, Value&)>&		_invoker
													);
						PropertyGroup&			Done();
					};

					//----------------------------------------------------

					PropertyGroup&				TypeName(
													const WString&									_typeName
													);
					PropertyGroup&				Property(
													const WString&									_name,
													ITypeDescriptor*								_type,
													bool											_nullable,
													const Func<Value(const Value&)>&				_getter,
													const Func<void(const Value&, const Value&)>&	_setter,
													const WString&									_valueChangedEventName
													);
					MethodBuilder				Method(
													const WString&									_name
													);
					EventBuilder				Event(
													const WString&									_name
													);
				};
			protected:
				PropertyGroup				propertyGroup;

			public:
				GeneralTypeDescriptor(const Func<void(PropertyGroup*)>& loaderProcedure);
				~GeneralTypeDescriptor();

				PropertyGroup&				Operations();

				const WString&				GetTypeName()override;
				IValueSerializer*			GetValueSerializer()override;
				vint						GetBaseTypeDescriptorCount()override;
				ITypeDescriptor*			GetBaseTypeDescriptor(vint index)override;

				vint						GetPropertyCount()override;
				IPropertyInfo*				GetProperty(vint index)override;
				bool						IsPropertyExists(const WString& name, bool inheritable)override;
				IPropertyInfo*				GetPropertyByName(const WString& name, bool inheritable)override;

				vint						GetEventCount()override;
				IEventInfo*					GetEvent(vint index)override;
				bool						IsEventExists(const WString& name, bool inheritable)override;
				IEventInfo*					GetEventByName(const WString& name, bool inheritable)override;

				vint						GetMethodGroupCount()override;
				IMethodGroupInfo*			GetMethodGroup(vint index)override;
				bool						IsMethodGroupExists(const WString& name, bool inheritable)override;
				IMethodGroupInfo*			GetMethodGroupByName(const WString& name, bool inheritable)override;
				IMethodGroupInfo*			GetConstructorGroup()override;
			};
		}
	}
}

#endif

/***********************************************************************
REGEX\REGEXPURE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexInterpretor

Classes:
	PureInterpretor					：正则表达式纯模拟器
***********************************************************************/

#ifndef VCZH_REGEX_REGEXPURE
#define VCZH_REGEX_REGEXPURE


namespace vl
{
	namespace regex_internal
	{
		class PureResult
		{
		public:
			vint				start;
			vint				length;
			vint				finalState;
		};

		class PureInterpretor : public Object
		{
		protected:
			vint				charMap[1<<(8*sizeof(wchar_t))];	// char -> char set index
			vint**				transition;							// (state * char set index) -> state*
			bool*				finalState;							// state -> bool
			vint*				relatedFinalState;					// sate -> (finalState or -1)
			vint				stateCount;
			vint				charSetCount;
			vint				startState;
		public:
			PureInterpretor(Automaton::Ref dfa, CharRange::List& subsets);
			~PureInterpretor();

			bool				MatchHead(const wchar_t* input, const wchar_t* start, PureResult& result);
			bool				Match(const wchar_t* input, const wchar_t* start, PureResult& result);

			vint				GetStartState();
			vint				Transit(wchar_t input, vint state);
			bool				IsFinalState(vint state);

			void				PrepareForRelatedFinalStateTable();
			vint				GetRelatedFinalState(vint state);
		};
	}
}

#endif

/***********************************************************************
REGEX\REGEXRICH.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexInterpretor

Classes:
	RichInterpretor					：正则表达式完全模拟器
***********************************************************************/

#ifndef VCZH_REGEX_REGEXRICH
#define VCZH_REGEX_REGEXRICH


namespace vl
{
	namespace regex_internal
	{
		class CaptureRecord
		{
		public:
			vint								capture;
			vint								start;
			vint								length;

			bool							operator==(const CaptureRecord& record)const;
		};
	}

	template<>
	struct POD<regex_internal::CaptureRecord>
	{
		static const bool Result=true;
	};

	namespace regex_internal
	{
		class RichResult
		{
		public:
			vint							start;
			vint							length;
			List<CaptureRecord>			captures;
		};

		class RichInterpretor : public Object
		{
		public:
		protected:
			class UserData
			{
			public:
				bool						NeedKeepState;
			};

			Automaton::Ref					dfa;
			UserData*						datas;
		public:
			RichInterpretor(Automaton::Ref _dfa);
			~RichInterpretor();

			bool							MatchHead(const wchar_t* input, const wchar_t* start, RichResult& result);
			bool							Match(const wchar_t* input, const wchar_t* start, RichResult& result);
			const List<WString>&			CaptureNames();
		};
	};
}

#endif

/***********************************************************************
REGEX\REGEXWRITER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::RegexWriter

Classes:
***********************************************************************/

#ifndef VCZH_REGEX_REGEXWRITER
#define VCZH_REGEX_REGEXWRITER


namespace vl
{
	namespace regex
	{
		class RegexNode : public Object
		{
		public:
			vl::regex_internal::Expression::Ref		expression;

			RegexNode(vl::regex_internal::Expression::Ref _expression);

			RegexNode					Some()const;
			RegexNode					Any()const;
			RegexNode					Opt()const;
			RegexNode					Loop(vint min, vint max)const;
			RegexNode					AtLeast(vint min)const;
			RegexNode					operator+(const RegexNode& node)const;
			RegexNode					operator|(const RegexNode& node)const;
			RegexNode					operator+()const;
			RegexNode					operator-()const;
			RegexNode					operator!()const;
			RegexNode					operator%(const RegexNode& node)const;
		};

		extern RegexNode				rCapture(const WString& name, const RegexNode& node);
		extern RegexNode				rUsing(const WString& name);
		extern RegexNode				rMatch(const WString& name, vint index=-1);
		extern RegexNode				rMatch(vint index);
		extern RegexNode				rBegin();
		extern RegexNode				rEnd();
		extern RegexNode				rC(wchar_t a, wchar_t b=L'\0');
		extern RegexNode				r_d();
		extern RegexNode				r_l();
		extern RegexNode				r_w();
		extern RegexNode				rAnyChar();
	}
}

#endif

/***********************************************************************
STREAM\BROADCASTSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::BroadcastStream

Interfaces:
	BroadcastStream					：广播流
***********************************************************************/

#ifndef VCZH_STREAM_BROADCASTSTREAM
#define VCZH_STREAM_BROADCASTSTREAM


namespace vl
{
	namespace stream
	{
		class BroadcastStream : public Object, public virtual IStream
		{
			typedef collections::List<IStream*>		StreamList;
		protected:
			bool					closed;
			pos_t					position;
			StreamList				streams;
		public:
			BroadcastStream();
			~BroadcastStream();

			StreamList&				Targets();
			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\CACHESTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::CacheStream

Interfaces:
	CacheStream						：缓冲流
***********************************************************************/

#ifndef VCZH_STREAM_CACHESTREAM
#define VCZH_STREAM_CACHESTREAM


namespace vl
{
	namespace stream
	{
		class CacheStream : public Object, public virtual IStream
		{
		protected:
			IStream*				target;
			vint					block;
			pos_t					start;
			pos_t					position;

			char*					buffer;
			vint					dirtyStart;
			vint					dirtyLength;
			vint					availableLength;
			pos_t					operatedSize;

			void					Flush();
			void					Load(pos_t _position);
			vint					InternalRead(void* _buffer, vint _size);
			vint					InternalWrite(void* _buffer, vint _size);
		public:
			CacheStream(IStream& _target, vint _block=65536);
			~CacheStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint					Read(void* _buffer, vint _size);
			vint					Write(void* _buffer, vint _size);
			vint					Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\CHARFORMAT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::CharFormat

Classes:
	CharEncoder									：字符串编码器基类
	CharDecoder									：字符串解码器基类
	MbcsEncoder									：Mbcs编码器
	MbcsDecoder									：Mbcs解码器
	Utf16Encoder								：Utf16编码器
	Utf16Decoder								：Utf16解码器
	Utf16BEEncoder								：Utf16 Big Endian编码器
	Utf16BEDecoder								：Utf16 Big Endian解码器
	Utf8Encoder									：Utf8编码器
	Utf8Decoder									：Utf8解码器
	BomEncoder									：BOM相关编码器
	BomDecoder									：BOM相关解码器
***********************************************************************/

#ifndef VCZH_STREAM_CHARFORMAT
#define VCZH_STREAM_CHARFORMAT


namespace vl
{
	namespace stream
	{

		/*编码资料
		UCS-4和UTF-8的对应关系:
		U-00000000 - U-0000007F:  0xxxxxxx
		U-00000080 - U-000007FF:  110xxxxx 10xxxxxx
		U-00000800 - U-0000FFFF:  1110xxxx 10xxxxxx 10xxxxxx
		U-00010000 - U-001FFFFF:  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
		U-00200000 - U-03FFFFFF:  111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
		U-04000000 - U-7FFFFFFF:  1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
		BOM:
		FFFE	=Unicode			(vceUtf16)
		FEFF	=Unicode Big Endian	(vceUtf16_be)
		EFBBBF	=UTF-8				(vceUtf8)
		other	=MBCS(GBK)			(vceMbcs)
		*/

/***********************************************************************
字符串编码解码基类
***********************************************************************/

		class CharEncoder : public Object, public IEncoder
		{
		protected:
			IStream*						stream;
			unsigned char					cache;
			bool							cacheAvailable;

			virtual vint					WriteString(wchar_t* _buffer, vint chars)=0;
		public:
			CharEncoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint							Write(void* _buffer, vint _size);
		};

		class CharDecoder : public Object, public IDecoder
		{
		protected:
			IStream*						stream;
			unsigned char					cache;
			bool							cacheAvailable;

			virtual vint					ReadString(wchar_t* _buffer, vint chars)=0;
		public:
			CharDecoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint							Read(void* _buffer, vint _size);
		};

/***********************************************************************
Mbcs
***********************************************************************/

		class MbcsEncoder : public CharEncoder
		{
		protected:
			vint							WriteString(wchar_t* _buffer, vint chars);
		};

		class MbcsDecoder : public CharDecoder
		{
		protected:
			vint							ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-16
***********************************************************************/

		class Utf16Encoder : public CharEncoder
		{
		protected:
			vint							WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf16Decoder : public CharDecoder
		{
		protected:
			vint							ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-16-be
***********************************************************************/

		class Utf16BEEncoder : public CharEncoder
		{
		protected:
			vint							WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf16BEDecoder : public CharDecoder
		{
		protected:
			vint							ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Utf-8
***********************************************************************/

		class Utf8Encoder : public CharEncoder
		{
		protected:
			vint							WriteString(wchar_t* _buffer, vint chars);
		};

		class Utf8Decoder : public CharDecoder
		{
		protected:
			vint							ReadString(wchar_t* _buffer, vint chars);
		};

/***********************************************************************
Bom
***********************************************************************/

		class BomEncoder : public Object, public IEncoder
		{
		public:
			enum Encoding
			{
				Mbcs,
				Utf8,
				Utf16,
				Utf16BE
			};
		protected:
			Encoding						encoding;
			IEncoder*						encoder;
		public:
			BomEncoder(Encoding _encoding);
			~BomEncoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint								Write(void* _buffer, vint _size);
		};

		class BomDecoder : public Object, public IDecoder
		{
		private:
			class BomStream : public Object, public IStream
			{
			protected:
				IStream*					stream;
				char						bom[3];
				vint						bomLength;
				vint						bomPosition;
			public:
				BomStream(IStream* _stream, char* _bom, vint _bomLength);

				bool						CanRead()const;
				bool						CanWrite()const;
				bool						CanSeek()const;
				bool						CanPeek()const;
				bool						IsLimited()const;
				bool						IsAvailable()const;
				void						Close();
				pos_t						Position()const;
				pos_t						Size()const;
				void						Seek(pos_t _size);
				void						SeekFromBegin(pos_t _size);
				void						SeekFromEnd(pos_t _size);
				vint						Read(void* _buffer, vint _size);
				vint						Write(void* _buffer, vint _size);
				vint						Peek(void* _buffer, vint _size);
			};
		protected:
			IDecoder*						decoder;
			IStream*						stream;

		public:
			BomDecoder();
			~BomDecoder();

			void							Setup(IStream* _stream);
			void							Close();
			vint							Read(void* _buffer, vint _size);
		};

/***********************************************************************
Encoding Test
***********************************************************************/

		extern void							TestEncoding(unsigned char* buffer, vint size, BomEncoder::Encoding& encoding, bool& containsBom);
	}
}

#endif

/***********************************************************************
STREAM\FILESTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::FileStream

Interfaces:
	FileStream						：文件流
***********************************************************************/

#ifndef VCZH_STREAM_FILESTREAM
#define VCZH_STREAM_FILESTREAM

#include <stdio.h>

namespace vl
{
	namespace stream
	{
		class FileStream : public Object, public virtual IStream
		{
		public:
			enum AccessRight
			{
				ReadOnly,
				WriteOnly,
				ReadWrite
			};
		protected:
			AccessRight				accessRight;
			FILE*					file;
		public:
			FileStream(const WString& fileName, AccessRight _accessRight);
			~FileStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\MEMORYWRAPPERSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::MemoryWrapperStream

Interfaces:
	MemoryWrapperStream				：内存代理流
***********************************************************************/

#ifndef VCZH_STREAM_MEMORYWRAPPERSTREAM
#define VCZH_STREAM_MEMORYWRAPPERSTREAM


namespace vl
{
	namespace stream
	{
		class MemoryWrapperStream : public Object, public virtual IStream
		{
		protected:
			char*					buffer;
			vint						size;
			vint						position;
		public:
			MemoryWrapperStream(void* _buffer, vint _size);
			~MemoryWrapperStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
STREAM\RECORDERSTREAM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::RecorderStream

Interfaces:
	RecorderStream					：备份流
***********************************************************************/

#ifndef VCZH_STREAM_RECORDERSTREAM
#define VCZH_STREAM_RECORDERSTREAM


namespace vl
{
	namespace stream
	{
		class RecorderStream : public Object, public virtual IStream
		{
		protected:
			IStream*				in;
			IStream*				out;
		public:
			RecorderStream(IStream& _in, IStream& _out);
			~RecorderStream();

			bool					CanRead()const;
			bool					CanWrite()const;
			bool					CanSeek()const;
			bool					CanPeek()const;
			bool					IsLimited()const;
			bool					IsAvailable()const;
			void					Close();
			pos_t					Position()const;
			pos_t					Size()const;
			void					Seek(pos_t _size);
			void					SeekFromBegin(pos_t _size);
			void					SeekFromEnd(pos_t _size);
			vint						Read(void* _buffer, vint _size);
			vint						Write(void* _buffer, vint _size);
			vint						Peek(void* _buffer, vint _size);
		};
	}
}

#endif

/***********************************************************************
THREADING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Threading

Classes:
	Thread										：线程
	CriticalSection
	Mutex
	Semaphore
	EventObject
***********************************************************************/

#ifndef VCZH_THREADING
#define VCZH_THREADING


namespace vl
{

/***********************************************************************
内核模式对象
***********************************************************************/

	namespace threading_internal
	{
		struct WaitableData;
		struct ThreadData;
		struct MutexData;
		struct SemaphoreData;
		struct EventData;

		struct CriticalSectionData;
		struct ReaderWriterLockData;
		struct ConditionVariableData;
	}

	class WaitableObject : public Object, public NotCopyable
	{
	private:
		threading_internal::WaitableData*			waitableData;
	protected:

		WaitableObject();
		void										SetData(threading_internal::WaitableData* data);
	public:

		bool										IsCreated();
		bool										Wait();
		bool										WaitForTime(vint ms);
		
		static bool									WaitAll(WaitableObject** objects, vint count);
		static bool									WaitAllForTime(WaitableObject** objects, vint count, vint ms);
		static vint									WaitAny(WaitableObject** objects, vint count, bool* abandoned);
		static vint									WaitAnyForTime(WaitableObject** objects, vint count, vint ms, bool* abandoned);
	};

	class Thread : public WaitableObject
	{
		friend void InternalThreadProc(Thread* thread);
	public:
		enum ThreadState
		{
			NotStarted,
			Running,
			Paused,
			Stopped
		};

		typedef void(*ThreadProcedure)(Thread*, void*);
	private:
		threading_internal::ThreadData*				internalData;
		volatile ThreadState						threadState;

	protected:

		virtual void								Run()=0;
	public:
		Thread();
		~Thread();

		static Thread*								CreateAndStart(ThreadProcedure procedure, void* argument=0, bool deleteAfterStopped=true);
		static void									Sleep(vint ms);
		static vint									GetCPUCount();
		static vint									GetCurrentThreadId();

		bool										Start();
		bool										Pause();
		bool										Resume();
		bool										Stop();
		ThreadState									GetState();
		void										SetCPU(vint index);
	};

	class Mutex : public WaitableObject
	{
	private:
		threading_internal::MutexData*				internalData;
	public:
		Mutex();
		~Mutex();

		bool										Create(bool owned=false, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Release();
	};

	class Semaphore : public WaitableObject
	{
	private:
		threading_internal::SemaphoreData*			internalData;
	public:
		Semaphore();
		~Semaphore();

		bool										Create(vint initialCount, vint maxCount, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Release();
		vint										Release(vint count);
	};

	class EventObject : public WaitableObject
	{
	private:
		threading_internal::EventData*				internalData;
	public:
		EventObject();
		~EventObject();

		bool										CreateAutoUnsignal(bool signaled, const WString& name=L"");
		bool										CreateManualUnsignal(bool signaled, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Signal();
		bool										Unsignal();
	};

/***********************************************************************
线程池
***********************************************************************/

	class ThreadPoolLite : public Object
	{
	private:
		ThreadPoolLite();
		~ThreadPoolLite();
	public:
		static bool									Queue(void(*proc)(void*), void* argument);
		static bool									Queue(const Func<void()>& proc);

		template<typename T>
		static void QueueLambda(const T& proc)
		{
			Queue(Func<void()>(proc));
		}
	};

/***********************************************************************
进程内对象
***********************************************************************/

	class CriticalSection : public Object, public NotCopyable
	{
	private:
#ifdef VCZH_NO_OLD_OS
		friend class ConditionVariable;
#endif
		threading_internal::CriticalSectionData*	internalData;
	public:
		CriticalSection();
		~CriticalSection();

		bool										TryEnter();
		void										Enter();
		void										Leave();

	public:
		class Scope : public Object, public NotCopyable
		{
		private:
			CriticalSection*						criticalSection;
		public:
			Scope(CriticalSection& _criticalSection);
			~Scope();
		};
	};

#ifdef VCZH_NO_OLD_OS

	class ReaderWriterLock : public Object, public NotCopyable
	{
	private:
		friend class ConditionVariable;
		threading_internal::ReaderWriterLockData*	internalData;
	public:
		ReaderWriterLock();
		~ReaderWriterLock();

		bool										TryEnterReader();
		void										EnterReader();
		void										LeaveReader();
		bool										TryEnterWriter();
		void										EnterWriter();
		void										LeaveWriter();
	public:
		class ReaderScope : public Object, public NotCopyable
		{
		private:
			ReaderWriterLock*						lock;
		public:
			ReaderScope(ReaderWriterLock& _lock);
			~ReaderScope();
		};
		
		class WriterScope : public Object, public NotCopyable
		{
		private:
			ReaderWriterLock*						lock;
		public:
			WriterScope(ReaderWriterLock& _lock);
			~WriterScope();
		};
	};

	class ConditionVariable : public Object, public NotCopyable
	{
	private:
		threading_internal::ConditionVariableData*	internalData;
	public:
		ConditionVariable();
		~ConditionVariable();

		bool										SleepWith(CriticalSection& cs);
		bool										SleepWithForTime(CriticalSection& cs, vint ms);
		bool										SleepWithReader(ReaderWriterLock& lock);
		bool										SleepWithReaderForTime(ReaderWriterLock& lock, vint ms);
		bool										SleepWithWriter(ReaderWriterLock& lock);
		bool										SleepWithWriterForTime(ReaderWriterLock& lock, vint ms);
		void										WakeOnePending();
		void										WakeAllPendings();
	};
#endif

/***********************************************************************
用户模式对象
***********************************************************************/

	typedef long LockedInt;

	class SpinLock : public Object, public NotCopyable
	{
	protected:
		volatile LockedInt							token;
	public:
		SpinLock();
		~SpinLock();

		bool										TryEnter();
		void										Enter();
		void										Leave();

	public:
		class Scope : public Object, public NotCopyable
		{
		private:
			SpinLock*								spinLock;
		public:
			Scope(SpinLock& _spinLock);
			~Scope();
		};
	};
}

#endif
