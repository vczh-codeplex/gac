/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: 陈梓瀚(vczh)
***********************************************************************/
#include "GacUI.h"

/***********************************************************************
Controls\GuiApplication.cpp
***********************************************************************/

extern void GuiMain();

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace collections;
			using namespace compositions;

/***********************************************************************
GuiApplication
***********************************************************************/

			void GuiApplication::LeftButtonDown(Point position)
			{
				OnMouseDown(position);
			}

			void GuiApplication::LeftButtonUp(Point position)
			{
			}

			void GuiApplication::RightButtonDown(Point position)
			{
				OnMouseDown(position);
			}

			void GuiApplication::RightButtonUp(Point position)
			{
			}

			void GuiApplication::ClipboardUpdated()
			{
				for(vint i=0;i<windows.Count();i++)
				{
					GuiEventArgs arguments=windows[i]->GetNotifyEventArguments();
					windows[i]->ClipboardUpdated.Execute(arguments);
				}
			}

			GuiApplication::GuiApplication()
				:mainWindow(0)
			{
				GetCurrentController()->CallbackService()->InstallListener(this);
			}

			GuiApplication::~GuiApplication()
			{
				GetCurrentController()->CallbackService()->UninstallListener(this);
			}

			void GuiApplication::RegisterWindow(GuiWindow* window)
			{
				windows.Add(window);
			}

			void GuiApplication::UnregisterWindow(GuiWindow* window)
			{
				windows.Remove(window);
			}

			void GuiApplication::RegisterPopupOpened(GuiPopup* popup)
			{
				vint index=openingPopups.IndexOf(popup);
				if(index==-1)
				{
					openingPopups.Add(popup);
					if(openingPopups.Count()==1)
					{
						GetCurrentController()->InputService()->StartHookMouse();
					}
				}
			}

			void GuiApplication::RegisterPopupClosed(GuiPopup* popup)
			{
				if(openingPopups.Remove(popup))
				{
					if(openingPopups.Count()==0)
					{
						GetCurrentController()->InputService()->StopHookMouse();
					}
				}
			}

			void GuiApplication::OnMouseDown(Point location)
			{
				GuiWindow* window=GetWindow(location);
				for(vint i=0;i<windows.Count();i++)
				{
					if(windows[i]!=window)
					{
						windows[i]->MouseClickedOnOtherWindow(window);
					}
				}
			}

			void GuiApplication::Run(GuiWindow* _mainWindow)
			{
				if(!mainWindow)
				{
					mainWindow=_mainWindow;
					GetCurrentController()->WindowService()->Run(mainWindow->GetNativeWindow());
					mainWindow=0;
				}
			}

			const collections::List<GuiWindow*>& GuiApplication::GetWindows()
			{
				return windows;
			}

			GuiWindow* GuiApplication::GetWindow(Point location)
			{
				INativeWindow* nativeWindow=GetCurrentController()->WindowService()->GetWindow(location);
				if(nativeWindow)
				{
					for(vint i=0;i<windows.Count();i++)
					{
						GuiWindow* window=windows[i];
						if(window->GetNativeWindow()==nativeWindow)
						{
							return window;
						}
					}
				}
				return 0;
			}

			WString GuiApplication::GetExecutablePath()
			{
				return GetCurrentController()->GetExecutablePath();
			}

			WString GuiApplication::GetExecutableFolder()
			{
				WString path=GetExecutablePath();
				for(vint i=path.Length()-1;i>=0;i--)
				{
					if(path[i]==L'\\' || path[i]==L'/')
					{
						return path.Sub(0, i+1);
					}
				}
				return L"";
			}

			bool GuiApplication::IsInMainThread()
			{
				return GetCurrentController()->AsyncService()->IsInMainThread();
			}

			void GuiApplication::InvokeAsync(INativeAsyncService::AsyncTaskProc* proc, void* argument)
			{
				GetCurrentController()->AsyncService()->InvokeAsync(proc, argument);
			}

			void GuiApplication::InvokeInMainThread(INativeAsyncService::AsyncTaskProc* proc, void* argument)
			{
				GetCurrentController()->AsyncService()->InvokeInMainThread(proc, argument);
			}

			bool GuiApplication::InvokeInMainThreadAndWait(INativeAsyncService::AsyncTaskProc* proc, void* argument, vint milliseconds)
			{
				return GetCurrentController()->AsyncService()->InvokeInMainThreadAndWait(proc, argument, milliseconds);
			}

			void InvokeInMainThreadProc(void* argument)
			{
				Func<void()>* proc=(Func<void()>*)argument;
				(*proc)();
				delete proc;
			}

			void GuiApplication::InvokeAsync(const Func<void()>& proc)
			{
				InvokeAsync(&InvokeInMainThreadProc, new Func<void()>(proc));
			}

			void GuiApplication::InvokeInMainThread(const Func<void()>& proc)
			{
				InvokeInMainThread(&InvokeInMainThreadProc, new Func<void()>(proc));
			}

			bool GuiApplication::InvokeInMainThreadAndWait(const Func<void()>& proc, vint milliseconds)
			{
				return InvokeInMainThreadAndWait(&InvokeInMainThreadProc, new Func<void()>(proc));
			}

/***********************************************************************
Helpers
***********************************************************************/

			GuiApplication* application=0;

			GuiApplication* GetApplication()
			{
				return application;
			}

			void GuiApplicationInitialize()
			{
				Ptr<theme::ITheme> theme;
				{
					WString osVersion=GetCurrentController()->GetOSVersion();
					vint index=osVersion.IndexOf(L';');
					WString osMainVersion=osVersion.Sub(0, index);
					if(osMainVersion==L"Windows 8" || osMainVersion==L"Windows Server 2012")
					{
						theme=new win8::Win8Theme;
					}
					else
					{
						theme=new win7::Win7Theme;
					}
				}
				theme::SetCurrentTheme(theme.Obj());

				GetCurrentController()->InputService()->StartTimer();
				GuiApplication app;
				application=&app;

				GuiMain();
				theme::SetCurrentTheme(0);
				description::DestroyGlobalTypeManager();
			}
		}
	}
}

void GuiApplicationMain()
{
	vl::presentation::controls::GuiApplicationInitialize();
}

/***********************************************************************
Controls\GuiBasicControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace compositions;

/***********************************************************************
GuiControl::EmptyStyleController
***********************************************************************/

			GuiControl::EmptyStyleController::EmptyStyleController()
			{
				boundsComposition=new GuiBoundsComposition;
			}

			GuiControl::EmptyStyleController::~EmptyStyleController()
			{
			}

			compositions::GuiBoundsComposition* GuiControl::EmptyStyleController::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* GuiControl::EmptyStyleController::GetContainerComposition()
			{
				return boundsComposition;
			}

			void GuiControl::EmptyStyleController::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void GuiControl::EmptyStyleController::SetText(const WString& value)
			{
			}

			void GuiControl::EmptyStyleController::SetFont(const FontProperties& value)
			{
			}

			void GuiControl::EmptyStyleController::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
GuiControl
***********************************************************************/

			void GuiControl::OnChildInserted(GuiControl* control)
			{
				GuiControl* oldParent=control->parent;
				children.Add(control);
				control->parent=this;
				control->OnParentChanged(oldParent, control->parent);
				control->UpdateVisuallyEnabled();
			}

			void GuiControl::OnChildRemoved(GuiControl* control)
			{
				GuiControl* oldParent=control->parent;
				control->parent=0;
				children.Remove(control);
				control->OnParentChanged(oldParent, control->parent);
			}

			void GuiControl::OnParentChanged(GuiControl* oldParent, GuiControl* newParent)
			{
				OnParentLineChanged();
			}

			void GuiControl::OnParentLineChanged()
			{
				for(vint i=0;i<children.Count();i++)
				{
					children[i]->OnParentLineChanged();
				}
			}

			void GuiControl::OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)
			{
			}

			void GuiControl::OnBeforeReleaseGraphicsHost()
			{
				for(vint i=0;i<children.Count();i++)
				{
					children[i]->OnBeforeReleaseGraphicsHost();
				}
			}

			void GuiControl::UpdateVisuallyEnabled()
			{
				bool newValue=isEnabled && (parent==0?true:parent->GetVisuallyEnabled());
				if(isVisuallyEnabled!=newValue)
				{
					isVisuallyEnabled=newValue;
					styleController->SetVisuallyEnabled(isVisuallyEnabled);
					VisuallyEnabledChanged.Execute(GetNotifyEventArguments());

					for(vint i=0;i<children.Count();i++)
					{
						children[i]->UpdateVisuallyEnabled();
					}
				}
			}

			void GuiControl::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				if(focusableComposition!=value)
				{
					focusableComposition=value;
					styleController->SetFocusableComposition(focusableComposition);
				}
			}

			GuiControl::GuiControl(IStyleController* _styleController)
				:styleController(_styleController)
				,boundsComposition(_styleController->GetBoundsComposition())
				,focusableComposition(0)
				,eventReceiver(_styleController->GetBoundsComposition()->GetEventReceiver())
				,isEnabled(true)
				,isVisuallyEnabled(true)
				,isVisible(true)
				,parent(0)
			{
				boundsComposition->SetAssociatedControl(this);
				VisibleChanged.SetAssociatedComposition(boundsComposition);
				EnabledChanged.SetAssociatedComposition(boundsComposition);
				VisuallyEnabledChanged.SetAssociatedComposition(boundsComposition);
				TextChanged.SetAssociatedComposition(boundsComposition);
				FontChanged.SetAssociatedComposition(boundsComposition);

				font=GetCurrentController()->ResourceService()->GetDefaultFont();
				styleController->SetFont(font);
				styleController->SetText(text);
				styleController->SetVisuallyEnabled(isVisuallyEnabled);
			}

			GuiControl::~GuiControl()
			{
				if(parent || !styleController)
				{
					for(vint i=0;i<children.Count();i++)
					{
						delete children[i];
					}
				}
				else
				{
					for(vint i=children.Count()-1;i>=0;i--)
					{
						GuiControl* child=children[i];
						child->GetBoundsComposition()->GetParent()->RemoveChild(child->GetBoundsComposition());
						delete child;
					}
					delete boundsComposition;
				}
			}

			compositions::GuiEventArgs GuiControl::GetNotifyEventArguments()
			{
				return GuiEventArgs(boundsComposition);
			}

			GuiControl::IStyleController* GuiControl::GetStyleController()
			{
				return styleController.Obj();
			}

			compositions::GuiBoundsComposition* GuiControl::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* GuiControl::GetContainerComposition()
			{
				return styleController->GetContainerComposition();
			}

			compositions::GuiGraphicsComposition* GuiControl::GetFocusableComposition()
			{
				return focusableComposition;
			}

			compositions::GuiGraphicsEventReceiver* GuiControl::GetEventReceiver()
			{
				return eventReceiver;
			}

			GuiControl* GuiControl::GetParent()
			{
				return parent;
			}

			vint GuiControl::GetChildrenCount()
			{
				return children.Count();
			}

			GuiControl* GuiControl::GetChild(vint index)
			{
				return children[index];
			}

			bool GuiControl::AddChild(GuiControl* control)
			{
				return GetContainerComposition()->AddChild(control->GetBoundsComposition());
			}

			GuiControlHost* GuiControl::GetRelatedControlHost()
			{
				return parent?parent->GetRelatedControlHost():0;
			}

			bool GuiControl::GetVisuallyEnabled()
			{
				return isVisuallyEnabled;
			}

			bool GuiControl::GetEnabled()
			{
				return isEnabled;
			}

			void GuiControl::SetEnabled(bool value)
			{
				if(isEnabled!=value)
				{
					isEnabled=value;
					EnabledChanged.Execute(GetNotifyEventArguments());
					UpdateVisuallyEnabled();
				}
			}

			bool GuiControl::GetVisible()
			{
				return isVisible;
			}

			void GuiControl::SetVisible(bool value)
			{
				boundsComposition->SetVisible(value);
				if(isVisible!=value)
				{
					isVisible=value;
					VisibleChanged.Execute(GetNotifyEventArguments());
				}
			}

			const WString& GuiControl::GetText()
			{
				return text;
			}

			void GuiControl::SetText(const WString& value)
			{
				if(text!=value)
				{
					text=value;
					styleController->SetText(text);
					TextChanged.Execute(GetNotifyEventArguments());
				}
			}

			const FontProperties& GuiControl::GetFont()
			{
				return font;
			}

			void GuiControl::SetFont(const FontProperties& value)
			{
				if(font!=value)
				{
					font=value;
					styleController->SetFont(font);
					FontChanged.Execute(GetNotifyEventArguments());
				}
			}

			void GuiControl::SetFocus()
			{
				if(focusableComposition)
				{
					GuiGraphicsHost* host=focusableComposition->GetRelatedGraphicsHost();
					if(host)
					{
						host->SetFocus(focusableComposition);
					}
				}
			}

			Ptr<Object> GuiControl::GetTag()
			{
				return tag;
			}

			void GuiControl::SetTag(Ptr<Object> value)
			{
				tag=value;
			}

			IDescriptable* GuiControl::QueryService(const WString& identifier)
			{
				if(parent)
				{
					return parent->QueryService(identifier);
				}
				else
				{
					return 0;
				}
			}

/***********************************************************************
GuiComponent
***********************************************************************/
			
			GuiComponent::GuiComponent()
			{
			}

			GuiComponent::~GuiComponent()
			{
			}

/***********************************************************************
GuiImageData
***********************************************************************/

			GuiImageData::GuiImageData()
				:frameIndex(-1)
			{
			}

			GuiImageData::GuiImageData(Ptr<INativeImage> _image, vint _frameIndex)
				:image(_image)
				,frameIndex(_frameIndex)
			{
			}

			GuiImageData::~GuiImageData()
			{
			}

			Ptr<INativeImage> GuiImageData::GetImage()
			{
				return image;
			}

			vint GuiImageData::GetFrameIndex()
			{
				return frameIndex;
			}

/***********************************************************************
GuiLabel
***********************************************************************/

			GuiLabel::GuiLabel(IStyleController* _styleController)
				:GuiControl(_styleController)
				,styleController(_styleController)
			{
				textColor=styleController->GetDefaultTextColor();
				styleController->SetTextColor(textColor);
			}

			GuiLabel::~GuiLabel()
			{
			}

			Color GuiLabel::GetTextColor()
			{
				return textColor;
			}

			void GuiLabel::SetTextColor(Color value)
			{
				if(textColor!=value)
				{
					textColor=value;
					styleController->SetTextColor(textColor);
				}
			}

/***********************************************************************
GuiButton
***********************************************************************/

			void GuiButton::OnParentLineChanged()
			{
				GuiControl::OnParentLineChanged();
				if(GetRelatedControlHost()==0)
				{
					mousePressing=false;
					mouseHoving=false;
					UpdateControlState();
				}
			}

			void GuiButton::UpdateControlState()
			{
				ControlState newControlState=Normal;
				if(mousePressing)
				{
					if(mouseHoving)
					{
						newControlState=Pressed;
					}
					else
					{
						newControlState=Active;
					}
				}
				else
				{
					if(mouseHoving)
					{
						newControlState=Active;
					}
					else
					{
						newControlState=Normal;
					}
				}
				if(controlState!=newControlState)
				{
					controlState=newControlState;
					styleController->Transfer(controlState);
				}
			}

			void GuiButton::OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(arguments.eventSource==boundsComposition)
				{
					mousePressing=true;
					boundsComposition->GetRelatedGraphicsHost()->SetFocus(boundsComposition);
					UpdateControlState();
					if(!clickOnMouseUp && arguments.eventSource->GetAssociatedControl()==this)
					{
						Clicked.Execute(GetNotifyEventArguments());
					}
				}
			}

			void GuiButton::OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(arguments.eventSource==boundsComposition)
				{
					mousePressing=false;
					UpdateControlState();
				}
				if(GetVisuallyEnabled())
				{
					if(mouseHoving && clickOnMouseUp && arguments.eventSource->GetAssociatedControl()==this)
					{
						Clicked.Execute(GetNotifyEventArguments());
					}
				}
			}

			void GuiButton::OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(arguments.eventSource==boundsComposition)
				{
					mouseHoving=true;
					UpdateControlState();
				}
			}

			void GuiButton::OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(arguments.eventSource==boundsComposition)
				{
					mouseHoving=false;
					UpdateControlState();
				}
			}

			GuiButton::GuiButton(IStyleController* _styleController)
				:GuiControl(_styleController)
				,styleController(_styleController)
				,clickOnMouseUp(true)
				,mousePressing(false)
				,mouseHoving(false)
				,controlState(Normal)
			{
				Clicked.SetAssociatedComposition(boundsComposition);
				styleController->Transfer(Normal);
				styleController->SetFocusableComposition(boundsComposition);

				GetEventReceiver()->leftButtonDown.AttachMethod(this, &GuiButton::OnLeftButtonDown);
				GetEventReceiver()->leftButtonUp.AttachMethod(this, &GuiButton::OnLeftButtonUp);
				GetEventReceiver()->mouseEnter.AttachMethod(this, &GuiButton::OnMouseEnter);
				GetEventReceiver()->mouseLeave.AttachMethod(this, &GuiButton::OnMouseLeave);
			}

			GuiButton::~GuiButton()
			{
			}

			bool GuiButton::GetClickOnMouseUp()
			{
				return clickOnMouseUp;
			}

			void GuiButton::SetClickOnMouseUp(bool value)
			{
				clickOnMouseUp=value;
			}

/***********************************************************************
GuiSelectableButton::GroupController
***********************************************************************/

			GuiSelectableButton::GroupController::GroupController()
			{
			}

			GuiSelectableButton::GroupController::~GroupController()
			{
				for(vint i=buttons.Count()-1;i>=0;i--)
				{
					buttons[i]->SetGroupController(0);
				}
			}

			void GuiSelectableButton::GroupController::Attach(GuiSelectableButton* button)
			{
				if(!buttons.Contains(button))
				{
					buttons.Add(button);
				}
			}

			void GuiSelectableButton::GroupController::Detach(GuiSelectableButton* button)
			{
				buttons.Remove(button);
			}

/***********************************************************************
GuiSelectableButton::MutexGroupController
***********************************************************************/

			GuiSelectableButton::MutexGroupController::MutexGroupController()
				:suppress(false)
			{
			}

			GuiSelectableButton::MutexGroupController::~MutexGroupController()
			{
			}

			void GuiSelectableButton::MutexGroupController::OnSelectedChanged(GuiSelectableButton* button)
			{
				if(!suppress)
				{
					suppress=true;
					for(vint i=0;i<buttons.Count();i++)
					{
						buttons[i]->SetSelected(buttons[i]==button);
					}
					suppress=false;
				}
			}

/***********************************************************************
GuiSelectableButton
***********************************************************************/

			void GuiSelectableButton::OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(autoSelection)
				{
					SetSelected(!GetSelected());
				}
			}

			GuiSelectableButton::GuiSelectableButton(IStyleController* _styleController)
				:GuiButton(_styleController)
				,styleController(_styleController)
				,groupController(0)
				,autoSelection(true)
				,isSelected(false)
			{
				GroupControllerChanged.SetAssociatedComposition(boundsComposition);
				AutoSelectionChanged.SetAssociatedComposition(boundsComposition);
				SelectedChanged.SetAssociatedComposition(boundsComposition);

				Clicked.AttachMethod(this, &GuiSelectableButton::OnClicked);
				styleController->SetSelected(isSelected);
			}
			
			GuiSelectableButton::~GuiSelectableButton()
			{
				if(groupController)
				{
					groupController->Detach(this);
				}
			}

			GuiSelectableButton::GroupController* GuiSelectableButton::GetGroupController()
			{
				return groupController;
			}

			void GuiSelectableButton::SetGroupController(GroupController* value)
			{
				if(groupController)
				{
					groupController->Detach(this);
				}
				groupController=value;
				if(groupController)
				{
					groupController->Attach(this);
				}
				GroupControllerChanged.Execute(GetNotifyEventArguments());
			}

			bool GuiSelectableButton::GetAutoSelection()
			{
				return autoSelection;
			}

			void GuiSelectableButton::SetAutoSelection(bool value)
			{
				if(autoSelection!=value)
				{
					autoSelection=value;
					AutoSelectionChanged.Execute(GetNotifyEventArguments());
				}
			}

			bool GuiSelectableButton::GetSelected()
			{
				return isSelected;
			}

			void GuiSelectableButton::SetSelected(bool value)
			{
				if(isSelected!=value)
				{
					isSelected=value;
					styleController->SetSelected(isSelected);
					if(groupController)
					{
						groupController->OnSelectedChanged(this);
					}
					SelectedChanged.Execute(GetNotifyEventArguments());
				}
			}

/***********************************************************************
GuiScroll::CommandExecutor
***********************************************************************/

			GuiScroll::CommandExecutor::CommandExecutor(GuiScroll* _scroll)
				:scroll(_scroll)
			{
			}

			GuiScroll::CommandExecutor::~CommandExecutor()
			{
			}

			void GuiScroll::CommandExecutor::SmallDecrease()
			{
				scroll->SetPosition(scroll->GetPosition()-scroll->GetSmallMove());
			}

			void GuiScroll::CommandExecutor::SmallIncrease()
			{
				scroll->SetPosition(scroll->GetPosition()+scroll->GetSmallMove());
			}

			void GuiScroll::CommandExecutor::BigDecrease()
			{
				scroll->SetPosition(scroll->GetPosition()-scroll->GetBigMove());
			}

			void GuiScroll::CommandExecutor::BigIncrease()
			{
				scroll->SetPosition(scroll->GetPosition()+scroll->GetBigMove());
			}
			
			void GuiScroll::CommandExecutor::SetTotalSize(vint value)
			{
				scroll->SetTotalSize(value);
			}

			void GuiScroll::CommandExecutor::SetPageSize(vint value)
			{
				scroll->SetPageSize(value);
			}

			void GuiScroll::CommandExecutor::SetPosition(vint value)
			{
				scroll->SetPosition(value);
			}

/***********************************************************************
GuiScroll
***********************************************************************/

			GuiScroll::GuiScroll(IStyleController* _styleController)
				:GuiControl(_styleController)
				,styleController(_styleController)
				,totalSize(100)
				,pageSize(10)
				,position(0)
				,smallMove(1)
				,bigMove(10)
			{
				TotalSizeChanged.SetAssociatedComposition(boundsComposition);
				PageSizeChanged.SetAssociatedComposition(boundsComposition);
				PositionChanged.SetAssociatedComposition(boundsComposition);
				SmallMoveChanged.SetAssociatedComposition(boundsComposition);
				BigMoveChanged.SetAssociatedComposition(boundsComposition);

				commandExecutor=new CommandExecutor(this);
				styleController->SetCommandExecutor(commandExecutor.Obj());
				styleController->SetPageSize(pageSize);
				styleController->SetTotalSize(totalSize);
				styleController->SetPosition(position);
			}

			GuiScroll::~GuiScroll()
			{
			}

			vint GuiScroll::GetTotalSize()
			{
				return totalSize;
			}

			void GuiScroll::SetTotalSize(vint value)
			{
				if(totalSize!=value && 0<value)
				{
					totalSize=value;
					if(pageSize>totalSize)
					{
						SetPageSize(totalSize);
					}
					if(position>GetMaxPosition())
					{
						SetPosition(GetMaxPosition());
					}
					styleController->SetTotalSize(totalSize);
					TotalSizeChanged.Execute(GetNotifyEventArguments());
				}
			}

			vint GuiScroll::GetPageSize()
			{
				return pageSize;
			}

			void GuiScroll::SetPageSize(vint value)
			{
				if(pageSize!=value && 0<=value && value<=totalSize)
				{
					pageSize=value;
					if(position>GetMaxPosition())
					{
						SetPosition(GetMaxPosition());
					}
					styleController->SetPageSize(pageSize);
					PageSizeChanged.Execute(GetNotifyEventArguments());
				}
			}

			vint GuiScroll::GetPosition()
			{
				return position;
			}

			void GuiScroll::SetPosition(vint value)
			{
				vint min=GetMinPosition();
				vint max=GetMaxPosition();
				vint newPosition=
					value<min?min:
					value>max?max:
					value;
				if(position!=newPosition)
				{
					position=newPosition;
					styleController->SetPosition(position);
					PositionChanged.Execute(GetNotifyEventArguments());
				}
			}

			vint GuiScroll::GetSmallMove()
			{
				return smallMove;
			}

			void GuiScroll::SetSmallMove(vint value)
			{
				if(value>0 && smallMove!=value)
				{
					smallMove=value;
					SmallMoveChanged.Execute(GetNotifyEventArguments());
				}
			}

			vint GuiScroll::GetBigMove()
			{
				return bigMove;
			}

			void GuiScroll::SetBigMove(vint value)
			{
				if(value>0 && bigMove!=value)
				{
					bigMove=value;
					BigMoveChanged.Execute(GetNotifyEventArguments());
				}
			}

			vint GuiScroll::GetMinPosition()
			{
				return 0;
			}

			vint GuiScroll::GetMaxPosition()
			{
				return totalSize-pageSize;
			}
		}
	}
}

/***********************************************************************
Controls\GuiContainerControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace compositions;

		namespace controls
		{
/***********************************************************************
GuiTabPage
***********************************************************************/

			GuiTabPage::GuiTabPage()
				:container(0)
				,owner(0)
			{
			}

			GuiTabPage::~GuiTabPage()
			{
				if(!container->GetParent())
				{
					delete container;
				}
			}

			bool GuiTabPage::AssociateTab(GuiTab* _owner, GuiControl::IStyleController* _styleController)
			{
				if(owner)
				{
					return false;
				}
				else
				{
					if(!container)
					{
						container=new GuiControl(_styleController);
						TextChanged.SetAssociatedComposition(container->GetBoundsComposition());
						PageInstalled.SetAssociatedComposition(container->GetBoundsComposition());
						PageUninstalled.SetAssociatedComposition(container->GetBoundsComposition());
						PageContainerReady.SetAssociatedComposition(container->GetBoundsComposition());

						PageContainerReady.Execute(container->GetNotifyEventArguments());
					}
					owner=_owner;
					PageInstalled.Execute(container->GetNotifyEventArguments());
					return true;
				}
			}

			bool GuiTabPage::DeassociateTab(GuiTab* _owner)
			{
				if(owner && owner==_owner)
				{
					PageUninstalled.Execute(container->GetNotifyEventArguments());
					owner=0;
					return true;
				}
				else
				{
					return false;
				}
			}

			GuiControl* GuiTabPage::GetContainer()
			{
				return container;
			}

			GuiTab* GuiTabPage::GetOwnerTab()
			{
				return owner;
			}

			const WString& GuiTabPage::GetText()
			{
				return text;
			}

			void GuiTabPage::SetText(const WString& value)
			{
				if(text!=value)
				{
					text=value;
					if(owner)
					{
						owner->styleController->SetTabText(owner->tabPages.IndexOf(this), text);
					}
					if(container)
					{
						TextChanged.Execute(container->GetNotifyEventArguments());
					}
					else
					{
						GuiEventArgs arguments;
						TextChanged.Execute(arguments);
					}
				}
			}

			bool GuiTabPage::GetSelected()
			{
				return owner->GetSelectedPage()==this;
			}

/***********************************************************************
GuiTab
***********************************************************************/

			GuiTab::CommandExecutor::CommandExecutor(GuiTab* _tab)
				:tab(_tab)
			{
			}

			GuiTab::CommandExecutor::~CommandExecutor()
			{
			}

			void GuiTab::CommandExecutor::ShowTab(vint index)
			{
				tab->SetSelectedPage(tab->GetPages().Get(index));
			}

			GuiTab::GuiTab(IStyleController* _styleController)
				:GuiControl(_styleController)
				,styleController(_styleController)
				,selectedPage(0)
			{
				commandExecutor=new CommandExecutor(this);
				styleController->SetCommandExecutor(commandExecutor.Obj());
			}

			GuiTab::~GuiTab()
			{
				for(vint i=0;i<tabPages.Count();i++)
				{
					delete tabPages[i];
				}
			}

			GuiTabPage* GuiTab::CreatePage(vint index)
			{
				GuiTabPage* page=new GuiTabPage();
				if(CreatePage(page, index))
				{
					return page;
				}
				else
				{
					delete page;
					return 0;
				}
			}

			bool GuiTab::CreatePage(GuiTabPage* page, vint index)
			{
				if(index>=0 && index>=tabPages.Count())
				{
					index=tabPages.Count()-1;
				}
				else if(index<-1)
				{
					index=-1;
				}

				if(page->AssociateTab(this, styleController->CreateTabPageStyleController()))
				{
					index=index==-1?tabPages.Add(page):tabPages.Insert(index, page);
					GetContainerComposition()->AddChild(page->GetContainer()->GetBoundsComposition());
					styleController->InsertTab(index);
					styleController->SetTabText(index, page->GetText());
				
					if(!selectedPage)
					{
						SetSelectedPage(page);
					}
					page->GetContainer()->SetVisible(page==selectedPage);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool GuiTab::RemovePage(GuiTabPage* value)
			{
				if(value->GetOwnerTab()==this && value->DeassociateTab(this))
				{
					vint index=tabPages.IndexOf(value);
					styleController->RemoveTab(index);
					GetContainerComposition()->RemoveChild(value->GetContainer()->GetBoundsComposition());
					tabPages.RemoveAt(index);
					if(tabPages.Count()==0)
					{
						SetSelectedPage(0);
						return 0;
					}
					else if(selectedPage==value)
					{
						SetSelectedPage(tabPages[0]);
					}
					return true;
				}
				else
				{
					return false;
				}
			}

			bool GuiTab::MovePage(GuiTabPage* page, vint newIndex)
			{
				if(!page) return false;
				vint index=tabPages.IndexOf(page);
				if(index==-1) return false;
				tabPages.RemoveAt(index);
				tabPages.Insert(newIndex, page);
				styleController->MoveTab(index, newIndex);
				styleController->SetSelectedTab(tabPages.IndexOf(selectedPage));
				return true;
			}

			const collections::List<GuiTabPage*>& GuiTab::GetPages()
			{
				return tabPages;
			}

			GuiTabPage* GuiTab::GetSelectedPage()
			{
				return selectedPage;
			}

			bool GuiTab::SetSelectedPage(GuiTabPage* value)
			{
				if(value->GetOwnerTab()==this)
				{
					if(selectedPage!=value)
					{
						selectedPage=value;
						for(vint i=0;i<tabPages.Count();i++)
						{
							bool selected=tabPages[i]==value;
							tabPages[i]->GetContainer()->SetVisible(selected);
							if(selected)
							{
								styleController->SetSelectedTab(i);
							}
						}
						SelectedPageChanged.Execute(GetNotifyEventArguments());
					}
					return true;
				}
				else
				{
					return false;
				}
			}

/***********************************************************************
GuiScrollView::StyleController
***********************************************************************/

			void GuiScrollView::StyleController::UpdateTable()
			{
				if(horizontalScroll->GetEnabled() || horizontalAlwaysVisible)
				{
					tableComposition->SetRowOption(1, GuiCellOption::AbsoluteOption(styleProvider->GetDefaultScrollSize()));
				}
				else
				{
					tableComposition->SetRowOption(1, GuiCellOption::AbsoluteOption(0));
				}
				if(verticalScroll->GetEnabled() || verticalAlwaysVisible)
				{
					tableComposition->SetColumnOption(1, GuiCellOption::AbsoluteOption(styleProvider->GetDefaultScrollSize()));
				}
				else
				{
					tableComposition->SetColumnOption(1, GuiCellOption::AbsoluteOption(0));
				}
				tableComposition->UpdateCellBounds();
			}

			GuiScrollView::StyleController::StyleController(IStyleProvider* _styleProvider)
				:styleProvider(_styleProvider)
				,scrollView(0)
				,horizontalAlwaysVisible(true)
				,verticalAlwaysVisible(true)
			{
				horizontalScroll=new GuiScroll(styleProvider->CreateHorizontalScrollStyle());
				horizontalScroll->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
				horizontalScroll->SetEnabled(false);
				verticalScroll=new GuiScroll(styleProvider->CreateVerticalScrollStyle());
				verticalScroll->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
				verticalScroll->SetEnabled(false);

				boundsComposition=new GuiBoundsComposition;
				GuiGraphicsComposition* tableContainerComposition=styleProvider->InstallBackground(boundsComposition);

				tableComposition=new GuiTableComposition;
				tableContainerComposition->AddChild(tableComposition);
				tableComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				tableComposition->SetRowsAndColumns(2, 2);
				tableComposition->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
				tableComposition->SetRowOption(1, GuiCellOption::MinSizeOption());
				tableComposition->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
				tableComposition->SetColumnOption(1, GuiCellOption::MinSizeOption());
				UpdateTable();
				{
					GuiCellComposition* cell=new GuiCellComposition;
					tableComposition->AddChild(cell);
					cell->SetSite(1, 0, 1, 1);
					cell->AddChild(horizontalScroll->GetBoundsComposition());
				}
				{
					GuiCellComposition* cell=new GuiCellComposition;
					tableComposition->AddChild(cell);
					cell->SetSite(0, 1, 1, 1);
					cell->AddChild(verticalScroll->GetBoundsComposition());
				}
				
				containerCellComposition=new GuiCellComposition;
				tableComposition->AddChild(containerCellComposition);
				containerCellComposition->SetSite(0, 0, 1, 1);

				containerComposition=new GuiBoundsComposition;
				containerComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				containerCellComposition->AddChild(containerComposition);

				styleProvider->AssociateStyleController(this);
			}

			GuiScrollView::StyleController::~StyleController()
			{
			}

			void GuiScrollView::StyleController::SetScrollView(GuiScrollView* _scrollView)
			{
				scrollView=_scrollView;
			}

			void GuiScrollView::StyleController::AdjustView(Size fullSize)
			{
				Size viewSize=containerComposition->GetBounds().GetSize();
				if(fullSize.x<=viewSize.x)
				{
					horizontalScroll->SetEnabled(false);
					horizontalScroll->SetPosition(0);
				}
				else
				{
					horizontalScroll->SetEnabled(true);
					horizontalScroll->SetTotalSize(fullSize.x);
					horizontalScroll->SetPageSize(viewSize.x);
				}
				if(fullSize.y<=viewSize.y)
				{
					verticalScroll->SetEnabled(false);
					verticalScroll->SetPosition(0);
				}
				else
				{
					verticalScroll->SetEnabled(true);
					verticalScroll->SetTotalSize(fullSize.y);
					verticalScroll->SetPageSize(viewSize.y);
				}
				UpdateTable();
			}

			GuiScrollView::IStyleProvider* GuiScrollView::StyleController::GetStyleProvider()
			{
				return styleProvider.Obj();
			}

			GuiScroll* GuiScrollView::StyleController::GetHorizontalScroll()
			{
				return horizontalScroll;
			}

			GuiScroll* GuiScrollView::StyleController::GetVerticalScroll()
			{
				return verticalScroll;
			}

			compositions::GuiTableComposition* GuiScrollView::StyleController::GetInternalTableComposition()
			{
				return tableComposition;
			}

			compositions::GuiBoundsComposition* GuiScrollView::StyleController::GetInternalContainerComposition()
			{
				return containerComposition;
			}

			bool GuiScrollView::StyleController::GetHorizontalAlwaysVisible()
			{
				return horizontalAlwaysVisible;
			}

			void GuiScrollView::StyleController::SetHorizontalAlwaysVisible(bool value)
			{
				if(horizontalAlwaysVisible!=value)
				{
					horizontalAlwaysVisible=value;
					scrollView->CalculateView();
				}
			}

			bool GuiScrollView::StyleController::GetVerticalAlwaysVisible()
			{
				return verticalAlwaysVisible;
			}

			void GuiScrollView::StyleController::SetVerticalAlwaysVisible(bool value)
			{
				if(verticalAlwaysVisible!=value)
				{
					verticalAlwaysVisible=value;
					scrollView->CalculateView();
				}
			}

			compositions::GuiBoundsComposition* GuiScrollView::StyleController::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* GuiScrollView::StyleController::GetContainerComposition()
			{
				return containerComposition;
			}

			void GuiScrollView::StyleController::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				styleProvider->SetFocusableComposition(value);
			}

			void GuiScrollView::StyleController::SetText(const WString& value)
			{
				styleProvider->SetText(value);
			}

			void GuiScrollView::StyleController::SetFont(const FontProperties& value)
			{
				styleProvider->SetFont(value);
			}

			void GuiScrollView::StyleController::SetVisuallyEnabled(bool value)
			{
				styleProvider->SetVisuallyEnabled(value);
			}

/***********************************************************************
GuiScrollView
***********************************************************************/

			void GuiScrollView::OnContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				CalculateView();
			}

			void GuiScrollView::OnHorizontalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(!supressScrolling)
				{
					CallUpdateView();
				}
			}

			void GuiScrollView::OnVerticalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(!supressScrolling)
				{
					CallUpdateView();
				}
			}

			void GuiScrollView::CallUpdateView()
			{
				Rect viewBounds=GetViewBounds();
				UpdateView(viewBounds);
			}

			void GuiScrollView::Initialize()
			{
				styleController=dynamic_cast<StyleController*>(GetStyleController());
				styleController->SetScrollView(this);

				styleController->GetInternalContainerComposition()->BoundsChanged.AttachMethod(this, &GuiScrollView::OnContainerBoundsChanged);
				styleController->GetHorizontalScroll()->PositionChanged.AttachMethod(this, &GuiScrollView::OnHorizontalScroll);
				styleController->GetVerticalScroll()->PositionChanged.AttachMethod(this, &GuiScrollView::OnVerticalScroll);
			}

			GuiScrollView::GuiScrollView(StyleController* _styleController)
				:GuiControl(_styleController)
				,supressScrolling(false)
			{
				Initialize();
			}

			GuiScrollView::GuiScrollView(IStyleProvider* styleProvider)
				:GuiControl(new StyleController(styleProvider))
				,supressScrolling(false)
			{
				Initialize();
			}
			
			GuiScrollView::~GuiScrollView()
			{
			}

			void GuiScrollView::CalculateView()
			{
				if(!supressScrolling)
				{
					Size fullSize=QueryFullSize();
					while(true)
					{
						styleController->AdjustView(fullSize);
						styleController->AdjustView(fullSize);
						supressScrolling=true;
						CallUpdateView();
						supressScrolling=false;

						Size newSize=QueryFullSize();
						if(fullSize==newSize)
						{
							break;
						}
						else
						{
							fullSize=newSize;
						}
					}
				}
			}

			Size GuiScrollView::GetViewSize()
			{
				Size viewSize=styleController->GetInternalContainerComposition()->GetBounds().GetSize();
				return viewSize;
			}

			Rect GuiScrollView::GetViewBounds()
			{
				Point viewPosition=
					Point(
						styleController->GetHorizontalScroll()->GetPosition(),
						styleController->GetVerticalScroll()->GetPosition()
						);
				Size viewSize=GetViewSize();
				return Rect(viewPosition, viewSize);
			}

			GuiScroll* GuiScrollView::GetHorizontalScroll()
			{
				return styleController->GetHorizontalScroll();
			}

			GuiScroll* GuiScrollView::GetVerticalScroll()
			{
				return styleController->GetVerticalScroll();
			}

			bool GuiScrollView::GetHorizontalAlwaysVisible()
			{
				return styleController->GetHorizontalAlwaysVisible();
			}

			void GuiScrollView::SetHorizontalAlwaysVisible(bool value)
			{
				styleController->SetHorizontalAlwaysVisible(value);
			}

			bool GuiScrollView::GetVerticalAlwaysVisible()
			{
				return styleController->GetVerticalAlwaysVisible();
			}

			void GuiScrollView::SetVerticalAlwaysVisible(bool value)
			{
				styleController->SetVerticalAlwaysVisible(value);
			}

/***********************************************************************
GuiScrollContainer::StyleController
***********************************************************************/

			GuiScrollContainer::StyleController::StyleController(GuiScrollView::IStyleProvider* styleProvider)
				:GuiScrollView::StyleController(styleProvider)
				,extendToFullWidth(false)
			{
				controlContainerComposition=new GuiBoundsComposition;
				controlContainerComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				GetInternalContainerComposition()->AddChild(controlContainerComposition);
			}

			GuiScrollContainer::StyleController::~StyleController()
			{
			}

			compositions::GuiGraphicsComposition* GuiScrollContainer::StyleController::GetContainerComposition()
			{
				return controlContainerComposition;
			}

			void GuiScrollContainer::StyleController::MoveContainer(Point leftTop)
			{
				controlContainerComposition->SetBounds(Rect(leftTop, Size(0, 0)));
			}

			bool GuiScrollContainer::StyleController::GetExtendToFullWidth()
			{
				return extendToFullWidth;
			}

			void GuiScrollContainer::StyleController::SetExtendToFullWidth(bool value)
			{
				if(extendToFullWidth!=value)
				{
					extendToFullWidth=value;
					if(value)
					{
						controlContainerComposition->SetAlignmentToParent(Margin(0, -1, 0, -1));
					}
					else
					{
						controlContainerComposition->SetAlignmentToParent(Margin(-1, -1, -1, -1));
					}
				}
			}

/***********************************************************************
GuiScrollContainer
***********************************************************************/

			void GuiScrollContainer::OnControlContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				CalculateView();
			}

			Size GuiScrollContainer::QueryFullSize()
			{
				return styleController->GetContainerComposition()->GetBounds().GetSize();
			}

			void GuiScrollContainer::UpdateView(Rect viewBounds)
			{
				styleController->MoveContainer(Point(-viewBounds.x1, -viewBounds.y1));
			}

			GuiScrollContainer::GuiScrollContainer(GuiScrollContainer::IStyleProvider* styleProvider)
				:GuiScrollView(new StyleController(styleProvider))
				,styleController(0)
			{
				styleController=dynamic_cast<StyleController*>(GetStyleController());
				GuiBoundsComposition* composition=dynamic_cast<GuiBoundsComposition*>(styleController->GetContainerComposition());
				composition->BoundsChanged.AttachMethod(this, &GuiScrollContainer::OnControlContainerBoundsChanged);
			}

			GuiScrollContainer::~GuiScrollContainer()
			{
			}

			bool GuiScrollContainer::GetExtendToFullWidth()
			{
				return styleController->GetExtendToFullWidth();
			}

			void GuiScrollContainer::SetExtendToFullWidth(bool value)
			{
				styleController->SetExtendToFullWidth(value);
			}
		}
	}
}

/***********************************************************************
Controls\GuiWindowControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace compositions;

/***********************************************************************
GuiControlHost
***********************************************************************/

			void GuiControlHost::OnNativeWindowChanged()
			{
			}

			void GuiControlHost::OnVisualStatusChanged()
			{
			}

			void GuiControlHost::Moved()
			{
				OnVisualStatusChanged();
			}

			void GuiControlHost::Enabled()
			{
				GuiControl::SetEnabled(true);
				OnVisualStatusChanged();
			}

			void GuiControlHost::Disabled()
			{
				GuiControl::SetEnabled(false);
				OnVisualStatusChanged();
			}

			void GuiControlHost::GotFocus()
			{
				WindowGotFocus.Execute(GetNotifyEventArguments());
				OnVisualStatusChanged();
			}

			void GuiControlHost::LostFocus()
			{
				WindowLostFocus.Execute(GetNotifyEventArguments());
				OnVisualStatusChanged();
			}

			void GuiControlHost::Activated()
			{
				WindowActivated.Execute(GetNotifyEventArguments());
				OnVisualStatusChanged();
			}

			void GuiControlHost::Deactivated()
			{
				WindowDeactivated.Execute(GetNotifyEventArguments());
				OnVisualStatusChanged();
			}

			void GuiControlHost::Opened()
			{
				WindowOpened.Execute(GetNotifyEventArguments());
			}

			void GuiControlHost::Closing(bool& cancel)
			{
				GuiRequestEventArgs arguments(GetStyleController()->GetBoundsComposition());
				arguments.cancel=cancel;
				WindowClosing.Execute(arguments);
				if(!arguments.handled)
				{
					cancel=arguments.cancel;
				}
			}

			void GuiControlHost::Closed()
			{
				WindowClosed.Execute(GetNotifyEventArguments());
			}

			void GuiControlHost::Destroying()
			{
				WindowDestroying.Execute(GetNotifyEventArguments());
				SetNativeWindow(0);
			}

			GuiControlHost::GuiControlHost(GuiControl::IStyleController* _styleController)
				:GuiControl(_styleController)
			{
				GetStyleController()->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
				
				WindowGotFocus.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());
				WindowLostFocus.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());
				WindowActivated.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());
				WindowDeactivated.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());
				WindowOpened.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());
				WindowClosing.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());
				WindowClosed.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());
				WindowDestroying.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());

				host=new GuiGraphicsHost;
				host->GetMainComposition()->AddChild(GetStyleController()->GetBoundsComposition());
			}

			GuiControlHost::~GuiControlHost()
			{
				OnBeforeReleaseGraphicsHost();
				styleController=0;
				for(vint i=0;i<components.Count();i++)
				{
					delete components[i];
				}
				delete host;
			}

			compositions::GuiGraphicsHost* GuiControlHost::GetGraphicsHost()
			{
				return host;
			}

			compositions::GuiGraphicsComposition* GuiControlHost::GetMainComposition()
			{
				return host->GetMainComposition();
			}

			INativeWindow* GuiControlHost::GetNativeWindow()
			{
				return host->GetNativeWindow();
			}

			void GuiControlHost::SetNativeWindow(INativeWindow* window)
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->UninstallListener(this);
				}
				host->SetNativeWindow(window);
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->InstallListener(this);
				}
				OnNativeWindowChanged();
			}

			void GuiControlHost::ForceCalculateSizeImmediately()
			{
				boundsComposition->ForceCalculateSizeImmediately();
				SetBounds(GetBounds());
			}

			void GuiControlHost::Render()
			{
				host->Render();
			}

			bool GuiControlHost::GetEnabled()
			{
				if(host->GetNativeWindow())
				{
					return host->GetNativeWindow()->IsEnabled();
				}
				else
				{
					return false;
				}
			}

			void GuiControlHost::SetEnabled(bool value)
			{
				if(host->GetNativeWindow())
				{
					if(value)
					{
						host->GetNativeWindow()->Enable();
					}
					else
					{
						host->GetNativeWindow()->Disable();
					}
				}
			}

			bool GuiControlHost::GetFocused()
			{
				if(host->GetNativeWindow())
				{
					return host->GetNativeWindow()->IsFocused();
				}
				else
				{
					return false;
				}
			}

			void GuiControlHost::SetFocused()
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->SetFocus();
				}
			}

			bool GuiControlHost::GetActivated()
			{
				if(host->GetNativeWindow())
				{
					return host->GetNativeWindow()->IsActivated();
				}
				else
				{
					return false;
				}
			}

			void GuiControlHost::SetActivated()
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->SetActivate();
				}
			}

			bool GuiControlHost::GetShowInTaskBar()
			{
				if(host->GetNativeWindow())
				{
					return host->GetNativeWindow()->IsAppearedInTaskBar();
				}
				else
				{
					return false;
				}
			}

			void GuiControlHost::SetShowInTaskBar(bool value)
			{
				if(host->GetNativeWindow())
				{
					if(value)
					{
						host->GetNativeWindow()->ShowInTaskBar();
					}
					else
					{
						host->GetNativeWindow()->HideInTaskBar();
					}
				}
			}

			bool GuiControlHost::GetEnabledActivate()
			{
				if(host->GetNativeWindow())
				{
					return host->GetNativeWindow()->IsEnabledActivate();
				}
				else
				{
					return false;
				}
			}

			void GuiControlHost::SetEnabledActivate(bool value)
			{
				if(host->GetNativeWindow())
				{
					if(value)
					{
						host->GetNativeWindow()->EnableActivate();
					}
					else
					{
						host->GetNativeWindow()->DisableActivate();
					}
				}
			}

			bool GuiControlHost::GetTopMost()
			{
				if(host->GetNativeWindow())
				{
					return host->GetNativeWindow()->GetTopMost();
				}
				else
				{
					return false;
				}
			}

			void GuiControlHost::SetTopMost(bool topmost)
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->SetTopMost(topmost);
				}
			}

			bool GuiControlHost::AddComponent(GuiComponent* component)
			{
				if(components.Contains(component))
				{
					return false;
				}
				else
				{
					components.Add(component);
					return true;
				}
			}

			bool GuiControlHost::RemoveComponent(GuiComponent* component)
			{
				return components.Remove(component);
			}

			bool GuiControlHost::ContainsComponent(GuiComponent* component)
			{
				return components.Contains(component);
			}

			compositions::IGuiShortcutKeyManager* GuiControlHost::GetShortcutKeyManager()
			{
				return host->GetShortcutKeyManager();
			}

			void GuiControlHost::SetShortcutKeyManager(compositions::IGuiShortcutKeyManager* value)
			{
				host->SetShortcutKeyManager(value);
			}

			Size GuiControlHost::GetClientSize()
			{
				if(host->GetNativeWindow())
				{
					return host->GetNativeWindow()->GetClientSize();
				}
				else
				{
					return Size(0, 0);
				}
			}

			void GuiControlHost::SetClientSize(Size value)
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->SetClientSize(value);
				}
			}

			Rect GuiControlHost::GetBounds()
			{
				if(host->GetNativeWindow())
				{
					return host->GetNativeWindow()->GetBounds();
				}
				else
				{
					return Rect();
				}
			}

			void GuiControlHost::SetBounds(Rect value)
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->SetBounds(value);
				}
			}

			GuiControlHost* GuiControlHost::GetRelatedControlHost()
			{
				return this;
			}

			const WString& GuiControlHost::GetText()
			{
				WString result;
				if(host->GetNativeWindow())
				{
					result=host->GetNativeWindow()->GetTitle();
				}
				if(result!=GuiControl::GetText())
				{
					GuiControl::SetText(result);
				}
				return GuiControl::GetText();
			}

			void GuiControlHost::SetText(const WString& value)
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->SetTitle(value);
					GuiControl::SetText(value);
				}
			}

			INativeScreen* GuiControlHost::GetRelatedScreen()
			{
				if(host->GetNativeWindow())
				{
					return GetCurrentController()->ScreenService()->GetScreen(host->GetNativeWindow());
				}
				else
				{
					return 0;
				}
			}

			void GuiControlHost::Show()
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->Show();
				}
			}

			void GuiControlHost::ShowDeactivated()
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->ShowDeactivated();
				}
			}

			void GuiControlHost::ShowRestored()
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->ShowRestored();
				}
			}

			void GuiControlHost::ShowMaximized()
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->ShowMaximized();
				}
			}

			void GuiControlHost::ShowMinimized()
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->ShowMinimized();
				}
			}

			void GuiControlHost::Hide()
			{
				if(host->GetNativeWindow())
				{
					host->GetNativeWindow()->Hide();
				}
			}

			void GuiControlHost::Close()
			{
				INativeWindow* window=host->GetNativeWindow();
				if(window)
				{
					if(GetCurrentController()->WindowService()->GetMainWindow()!=window)
					{
						window->Hide();
					}
					else
					{
						SetNativeWindow(0);
						GetCurrentController()->WindowService()->DestroyNativeWindow(window);
					}
				}
			}

			bool GuiControlHost::GetOpening()
			{
				INativeWindow* window=host->GetNativeWindow();
				if(window)
				{
					return window->IsVisible();
				}
				return false;
			}

/***********************************************************************
GuiWindow::DefaultBehaviorStyleController
***********************************************************************/

			GuiWindow::DefaultBehaviorStyleController::DefaultBehaviorStyleController()
				:window(0)
			{
			}

			GuiWindow::DefaultBehaviorStyleController::~DefaultBehaviorStyleController()
			{
			}

			void GuiWindow::DefaultBehaviorStyleController::AttachWindow(GuiWindow* _window)
			{
				window=_window;
			}

			void GuiWindow::DefaultBehaviorStyleController::InitializeNativeWindowProperties()
			{
			}

			bool GuiWindow::DefaultBehaviorStyleController::GetMaximizedBox()
			{
				if(window->GetNativeWindow())
				{
					return window->GetNativeWindow()->GetMaximizedBox();
				}
				else
				{
					return false;
				}
			}

			void GuiWindow::DefaultBehaviorStyleController::SetMaximizedBox(bool visible)
			{
				if(window->GetNativeWindow())
				{
					window->GetNativeWindow()->SetMaximizedBox(visible);
				}
			}

			bool GuiWindow::DefaultBehaviorStyleController::GetMinimizedBox()
			{
				if(window->GetNativeWindow())
				{
					return window->GetNativeWindow()->GetMinimizedBox();
				}
				else
				{
					return false;
				}
			}

			void GuiWindow::DefaultBehaviorStyleController::SetMinimizedBox(bool visible)
			{
				if(window->GetNativeWindow())
				{
					window->GetNativeWindow()->SetMinimizedBox(visible);
				}
			}

			bool GuiWindow::DefaultBehaviorStyleController::GetBorder()
			{
				if(window->GetNativeWindow())
				{
					return window->GetNativeWindow()->GetBorder();
				}
				else
				{
					return false;
				}
			}

			void GuiWindow::DefaultBehaviorStyleController::SetBorder(bool visible)
			{
				if(window->GetNativeWindow())
				{
					window->GetNativeWindow()->SetBorder(visible);
				}
			}

			bool GuiWindow::DefaultBehaviorStyleController::GetSizeBox()
			{
				if(window->GetNativeWindow())
				{
					return window->GetNativeWindow()->GetSizeBox();
				}
				else
				{
					return false;
				}
			}

			void GuiWindow::DefaultBehaviorStyleController::SetSizeBox(bool visible)
			{
				if(window->GetNativeWindow())
				{
					window->GetNativeWindow()->SetSizeBox(visible);
				}
			}

			bool GuiWindow::DefaultBehaviorStyleController::GetIconVisible()
			{
				if(window->GetNativeWindow())
				{
					return window->GetNativeWindow()->GetIconVisible();
				}
				else
				{
					return false;
				}
			}

			void GuiWindow::DefaultBehaviorStyleController::SetIconVisible(bool visible)
			{
				if(window->GetNativeWindow())
				{
					window->GetNativeWindow()->SetIconVisible(visible);
				}
			}

			bool GuiWindow::DefaultBehaviorStyleController::GetTitleBar()
			{
				if(window->GetNativeWindow())
				{
					return window->GetNativeWindow()->GetTitleBar();
				}
				else
				{
					return false;
				}
			}

			void GuiWindow::DefaultBehaviorStyleController::SetTitleBar(bool visible)
			{
				if(window->GetNativeWindow())
				{
					window->GetNativeWindow()->SetTitleBar(visible);
				}
			}

/***********************************************************************
GuiWindow
***********************************************************************/

			void GuiWindow::OnNativeWindowChanged()
			{
				styleController->InitializeNativeWindowProperties();
				GuiControlHost::OnNativeWindowChanged();
			}

			void GuiWindow::OnVisualStatusChanged()
			{
				GuiControlHost::OnVisualStatusChanged();
			}

			void GuiWindow::MouseClickedOnOtherWindow(GuiWindow* window)
			{
			}

			GuiWindow::GuiWindow(IStyleController* _styleController)
				:GuiControlHost(_styleController)
				,styleController(_styleController)
			{
				ClipboardUpdated.SetAssociatedComposition(GetStyleController()->GetBoundsComposition());
				INativeWindow* window=GetCurrentController()->WindowService()->CreateNativeWindow();
				styleController->AttachWindow(this);
				SetNativeWindow(window);
				GetApplication()->RegisterWindow(this);
			}

			GuiWindow::~GuiWindow()
			{
				GetApplication()->UnregisterWindow(this);
				INativeWindow* window=host->GetNativeWindow();
				if(window)
				{
					SetNativeWindow(0);
					GetCurrentController()->WindowService()->DestroyNativeWindow(window);
				}
			}

			void GuiWindow::MoveToScreenCenter()
			{
				INativeScreen* screen=GetRelatedScreen();
				if(screen)
				{
					Rect screenBounds=screen->GetClientBounds();
					Rect windowBounds=GetBounds();
					SetBounds(
						Rect(
							Point(
								windowBounds.Left()+(screenBounds.Width()-windowBounds.Width())/2,
								windowBounds.Top()+(screenBounds.Height()-windowBounds.Height())/2
								),
							windowBounds.GetSize()
							)
						);
				}
			}

			bool GuiWindow::GetMaximizedBox()
			{
				return styleController->GetMaximizedBox();
			}

			void GuiWindow::SetMaximizedBox(bool visible)
			{
				styleController->SetMaximizedBox(visible);
			}

			bool GuiWindow::GetMinimizedBox()
			{
				return styleController->GetMinimizedBox();
			}

			void GuiWindow::SetMinimizedBox(bool visible)
			{
				styleController->SetMinimizedBox(visible);
			}

			bool GuiWindow::GetBorder()
			{
				return styleController->GetBorder();
			}

			void GuiWindow::SetBorder(bool visible)
			{
				styleController->SetBorder(visible);
			}

			bool GuiWindow::GetSizeBox()
			{
				return styleController->GetSizeBox();
			}

			void GuiWindow::SetSizeBox(bool visible)
			{
				styleController->SetSizeBox(visible);
			}

			bool GuiWindow::GetIconVisible()
			{
				return styleController->GetIconVisible();
			}

			void GuiWindow::SetIconVisible(bool visible)
			{
				styleController->SetIconVisible(visible);
			}

			bool GuiWindow::GetTitleBar()
			{
				return styleController->GetTitleBar();
			}

			void GuiWindow::SetTitleBar(bool visible)
			{
				styleController->SetTitleBar(visible);
			}

/***********************************************************************
GuiPopup
***********************************************************************/

			void GuiPopup::MouseClickedOnOtherWindow(GuiWindow* window)
			{
				Hide();
			}

			void GuiPopup::PopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				GetApplication()->RegisterPopupOpened(this);
			}

			void GuiPopup::PopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				GetApplication()->RegisterPopupClosed(this);
			}

			GuiPopup::GuiPopup(IStyleController* _styleController)
				:GuiWindow(_styleController)
			{
				SetMinimizedBox(false);
				SetMaximizedBox(false);
				SetSizeBox(false);
				SetTitleBar(false);
				SetShowInTaskBar(false);
				GetBoundsComposition()->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

				WindowOpened.AttachMethod(this, &GuiPopup::PopupOpened);
				WindowClosed.AttachMethod(this, &GuiPopup::PopupClosed);
			}

			GuiPopup::~GuiPopup()
			{
				GetApplication()->RegisterPopupClosed(this);
			}

			bool GuiPopup::IsClippedByScreen(Point location)
			{
				SetBounds(Rect(location, GetBounds().GetSize()));
				INativeWindow* window=GetNativeWindow();
				if(window)
				{
					INativeScreen* screen=GetCurrentController()->ScreenService()->GetScreen(window);
					if(screen)
					{
						Rect screenBounds=screen->GetClientBounds();
						Rect windowBounds=window->GetBounds();
						return !screenBounds.Contains(windowBounds.LeftTop()) || !screenBounds.Contains(windowBounds.RightBottom());
					}
				}
				return true;
			}

			void GuiPopup::ShowPopup(Point location)
			{
				INativeWindow* window=GetNativeWindow();
				if(window)
				{
					INativeScreen* screen=GetCurrentController()->ScreenService()->GetScreen(window);
					if(screen)
					{
						Rect screenBounds=screen->GetClientBounds();
						Size size=window->GetBounds().GetSize();

						if(location.x<screenBounds.x1)
						{
							location.x=screenBounds.x1;
						}
						else if(location.x+size.x>screenBounds.x2)
						{
							location.x=screenBounds.x2-size.x;
						}

						if(location.y<screenBounds.y1)
						{
							location.y=screenBounds.y1;
						}
						else if(location.y+size.y>screenBounds.y2)
						{
							location.y=screenBounds.y2-size.y;
						}
					}
					SetBounds(Rect(location, GetBounds().GetSize()));
					bool value=GetNativeWindow()->IsEnabledActivate();
					ShowDeactivated();
				}
			}

			void GuiPopup::ShowPopup(GuiControl* control, bool preferredTopBottomSide)
			{
				INativeWindow* window=GetNativeWindow();
				if(window)
				{
					Point locations[4];
					Size size=window->GetBounds().GetSize();
					Rect controlBounds=control->GetBoundsComposition()->GetGlobalBounds();

					GuiControlHost* controlHost=control->GetBoundsComposition()->GetRelatedControlHost();
					if(controlHost)
					{
						INativeWindow* controlWindow=controlHost->GetNativeWindow();
						if(controlWindow)
						{
							Point controlClientOffset=controlWindow->GetClientBoundsInScreen().LeftTop();
							controlBounds.x1+=controlClientOffset.x;
							controlBounds.x2+=controlClientOffset.x;
							controlBounds.y1+=controlClientOffset.y;
							controlBounds.y2+=controlClientOffset.y;

							if(preferredTopBottomSide)
							{
								locations[0]=Point(controlBounds.x1, controlBounds.y2);
								locations[1]=Point(controlBounds.x2-size.x, controlBounds.y2);
								locations[2]=Point(controlBounds.x1, controlBounds.y1-size.y);
								locations[3]=Point(controlBounds.x2-size.x, controlBounds.y1-size.y);
							}
							else
							{
								locations[0]=Point(controlBounds.x2, controlBounds.y1);
								locations[1]=Point(controlBounds.x2, controlBounds.y2-size.y);
								locations[2]=Point(controlBounds.x1-size.x, controlBounds.y1);
								locations[3]=Point(controlBounds.x1-size.x, controlBounds.y2-size.y);
							}

							window->SetParent(controlWindow);
							for(vint i=0;i<4;i++)
							{
								if(!IsClippedByScreen(locations[i]))
								{
									ShowPopup(locations[i]);
									return;
								}
							}
							ShowPopup(locations[0]);
						}
					}
				}
			}
		}
	}
}

/***********************************************************************
Controls\ListControlPackage\GuiComboControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiComboBoxBase::CommandExecutor
***********************************************************************/

			GuiComboBoxBase::CommandExecutor::CommandExecutor(GuiComboBoxBase* _combo)
				:combo(_combo)
			{
			}

			GuiComboBoxBase::CommandExecutor::~CommandExecutor()
			{
			}

			void GuiComboBoxBase::CommandExecutor::ShowPopup()
			{
				combo->ShowPopup();
			}

			void GuiComboBoxBase::CommandExecutor::SelectItem()
			{
				combo->SelectItem();
			}

/***********************************************************************
GuiComboBoxBase
***********************************************************************/

			void GuiComboBoxBase::SelectItem()
			{
				ItemSelecting.Execute(GetNotifyEventArguments());
				styleController->OnItemSelected();
				ItemSelected.Execute(GetNotifyEventArguments());
			}

			void GuiComboBoxBase::OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				styleController->OnClicked();
			}

			void GuiComboBoxBase::OnPopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				styleController->OnPopupOpened();
				PopupOpened.Execute(arguments);
			}

			void GuiComboBoxBase::OnPopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				styleController->OnPopupClosed();
				PopupClosed.Execute(arguments);
			}

			GuiComboBoxBase::GuiComboBoxBase(IStyleController* _styleController)
				:GuiButton(_styleController)
			{
				commandExecutor=new CommandExecutor(this);
				styleController=dynamic_cast<IStyleController*>(GetStyleController());
				styleController->SetCommandExecutor(commandExecutor.Obj());
				popup=new GuiPopup(styleController->CreatePopupStyle());
				popup->GetNativeWindow()->SetAlwaysPassFocusToParent(true);

				PopupOpened.SetAssociatedComposition(boundsComposition);
				PopupClosed.SetAssociatedComposition(boundsComposition);
				ItemSelecting.SetAssociatedComposition(boundsComposition);
				ItemSelected.SetAssociatedComposition(boundsComposition);

				Clicked.AttachMethod(this, &GuiComboBoxBase::OnClicked);
				popup->WindowOpened.AttachMethod(this, &GuiComboBoxBase::OnPopupOpened);
				popup->WindowClosed.AttachMethod(this, &GuiComboBoxBase::OnPopupClosed);
			}

			GuiComboBoxBase::~GuiComboBoxBase()
			{
				delete popup;
			}

			void GuiComboBoxBase::ShowPopup()
			{
				Size size=popup->GetBoundsComposition()->GetPreferredMinSize();
				size.x=GetBoundsComposition()->GetBounds().Width();
				if(size.y<GetFont().size)
				{
					size.y=GetFont().size;
				}
				popup->GetBoundsComposition()->SetPreferredMinSize(size);
				popup->ShowPopup(this, true);
			}

			GuiPopup* GuiComboBoxBase::GetPopup()
			{
				return popup;
			}

/***********************************************************************
GuiComboBoxListControl
***********************************************************************/

			void GuiComboBoxListControl::DisplaySelectedContent(vint itemIndex)
			{
				if(primaryTextView)
				{
					if(itemIndex==-1)
					{
						SetText(L"");
					}
					else if(primaryTextView->ContainsPrimaryText(itemIndex))
					{
						WString text=primaryTextView->GetPrimaryTextViewText(itemIndex);
						SetText(text);
						popup->Hide();
					}
				}
			}

			void GuiComboBoxListControl::OnListControlSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				DisplaySelectedContent(GetSelectedIndex());
				SelectedIndexChanged.Execute(GetNotifyEventArguments());
			}

			GuiComboBoxListControl::GuiComboBoxListControl(IStyleController* _styleController, GuiSelectableListControl* _containedListControl)
				:GuiComboBoxBase(_styleController)
				,containedListControl(_containedListControl)
			{
				containedListControl->SetMultiSelect(false);
				containedListControl->SelectionChanged.AttachMethod(this, &GuiComboBoxListControl::OnListControlSelectionChanged);
				primaryTextView=dynamic_cast<GuiListControl::IItemPrimaryTextView*>(containedListControl->GetItemProvider()->RequestView(GuiListControl::IItemPrimaryTextView::Identifier));

				SelectedIndexChanged.SetAssociatedComposition(GetBoundsComposition());

				containedListControl->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
				popup->GetBoundsComposition()->AddChild(containedListControl->GetBoundsComposition());
				SetFont(GetFont());
			}

			GuiComboBoxListControl::~GuiComboBoxListControl()
			{
				if(primaryTextView)
				{
					containedListControl->GetItemProvider()->ReleaseView(primaryTextView);
				}
			}

			void GuiComboBoxListControl::SetFont(const FontProperties& value)
			{
				GuiComboBoxBase::SetFont(value);
				Size size=popup->GetBoundsComposition()->GetPreferredMinSize();
				size.y=20*value.size;
				popup->GetBoundsComposition()->SetPreferredMinSize(size);
			}

			GuiSelectableListControl* GuiComboBoxListControl::GetContainedListControl()
			{
				return containedListControl;
			}

			vint GuiComboBoxListControl::GetSelectedIndex()
			{
				if(containedListControl->GetSelectedItems().Count()==1)
				{
					return containedListControl->GetSelectedItems()[0];
				}
				else
				{
					return -1;
				}
			}

			void GuiComboBoxListControl::SetSelectedIndex(vint value)
			{
				containedListControl->SetSelected(value, true);
			}

			GuiListControl::IItemProvider* GuiComboBoxListControl::GetItemProvider()
			{
				return containedListControl->GetItemProvider();
			}
		}
	}
}

/***********************************************************************
Controls\ListControlPackage\GuiListControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;

			const wchar_t* const GuiListControl::IItemPrimaryTextView::Identifier = L"vl::presnetation::controls::GuiListControl::IItemPrimaryTextView";

/***********************************************************************
GuiListControl::ItemCallback
***********************************************************************/

			GuiListControl::ItemCallback::ItemCallback(GuiListControl* _listControl)
				:listControl(_listControl)
			{
			}

			GuiListControl::ItemCallback::~ItemCallback()
			{
				ClearCache();
			}

			void GuiListControl::ItemCallback::ClearCache()
			{
				for(vint i=0;i<cachedStyles.Count();i++)
				{
					listControl->itemStyleProvider->DestroyItemStyle(cachedStyles[i]);
				}
				for(vint i=0;i<installedStyles.Count();i++)
				{
					listControl->itemStyleProvider->DestroyItemStyle(installedStyles[i]);
				}
				cachedStyles.Clear();
				installedStyles.Clear();
			}

			void GuiListControl::ItemCallback::OnAttached(IItemProvider* provider)
			{
			}

			void GuiListControl::ItemCallback::OnItemModified(vint start, vint count, vint newCount)
			{
				listControl->OnItemModified(start, count, newCount);
			}

			GuiListControl::IItemStyleController* GuiListControl::ItemCallback::RequestItem(vint itemIndex)
			{
				vint id=listControl->itemStyleProvider->GetItemStyleId(itemIndex);
				IItemStyleController* style=0;
				for(vint i=0;i<cachedStyles.Count();i++)
				{
					IItemStyleController* cachedStyle=cachedStyles[i];
					if(cachedStyle->GetItemStyleId()==id)
					{
						style=cachedStyle;
						cachedStyles.RemoveAt(i);
						break;
					}
				}
				if(!style)
				{
					style=listControl->itemStyleProvider->CreateItemStyle(id);
				}
				listControl->itemStyleProvider->Install(style, itemIndex);
				style->OnInstalled();
				installedStyles.Add(style);
				listControl->GetContainerComposition()->AddChild(style->GetBoundsComposition());
				listControl->OnStyleInstalled(itemIndex, style);
				return style;
			}

			void GuiListControl::ItemCallback::ReleaseItem(IItemStyleController* style)
			{
				vint index=installedStyles.IndexOf(style);
				if(index!=-1)
				{
					listControl->OnStyleUninstalled(style);
					listControl->GetContainerComposition()->RemoveChild(style->GetBoundsComposition());
					installedStyles.RemoveAt(index);
					style->OnUninstalled();
					if(style->IsCacheable())
					{
						cachedStyles.Add(style);
					}
					else
					{
						listControl->itemStyleProvider->DestroyItemStyle(style);
					}
				}
			}

			void GuiListControl::ItemCallback::SetViewLocation(Point value)
			{
				Rect virtualRect(value, listControl->GetViewSize());
				Rect realRect=listControl->itemCoordinateTransformer->VirtualRectToRealRect(listControl->fullSize, virtualRect);
				listControl->GetHorizontalScroll()->SetPosition(realRect.Left());
				listControl->GetVerticalScroll()->SetPosition(realRect.Top());
			}

			Size GuiListControl::ItemCallback::GetStylePreferredSize(IItemStyleController* style)
			{
				Size size=style->GetBoundsComposition()->GetPreferredBounds().GetSize();
				return listControl->itemCoordinateTransformer->RealSizeToVirtualSize(size);
			}

			void GuiListControl::ItemCallback::SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)
			{
				Margin newMargin=listControl->itemCoordinateTransformer->VirtualMarginToRealMargin(margin);
				style->GetBoundsComposition()->SetAlignmentToParent(newMargin);
			}

			Rect GuiListControl::ItemCallback::GetStyleBounds(IItemStyleController* style)
			{
				Rect bounds=style->GetBoundsComposition()->GetBounds();
				return listControl->itemCoordinateTransformer->RealRectToVirtualRect(listControl->GetViewSize(), bounds);
			}

			void GuiListControl::ItemCallback::SetStyleBounds(IItemStyleController* style, Rect bounds)
			{
				Rect newBounds=listControl->itemCoordinateTransformer->VirtualRectToRealRect(listControl->GetViewSize(), bounds);
				return style->GetBoundsComposition()->SetBounds(newBounds);
			}

			compositions::GuiGraphicsComposition* GuiListControl::ItemCallback::GetContainerComposition()
			{
				return listControl->GetContainerComposition();
			}

			void GuiListControl::ItemCallback::OnTotalSizeChanged()
			{
				listControl->CalculateView();
			}

/***********************************************************************
GuiListControl
***********************************************************************/

			void GuiListControl::OnItemModified(vint start, vint count, vint newCount)
			{
			}

			void GuiListControl::OnStyleInstalled(vint itemIndex, IItemStyleController* style)
			{
				AttachItemEvents(style);
			}

			void GuiListControl::OnStyleUninstalled(IItemStyleController* style)
			{
				DetachItemEvents(style);
			}

			void GuiListControl::OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)
			{
				SetStyleProviderAndArranger(itemStyleProvider, itemArranger);
				GuiScrollView::OnRenderTargetChanged(renderTarget);
			}

			void GuiListControl::OnBeforeReleaseGraphicsHost()
			{
				GuiScrollView::OnBeforeReleaseGraphicsHost();
				SetStyleProviderAndArranger(0, 0);
			}

			Size GuiListControl::QueryFullSize()
			{
				Size virtualSize=itemArranger?itemArranger->GetTotalSize():Size(0, 0);
				fullSize=itemCoordinateTransformer->VirtualSizeToRealSize(virtualSize);
				return fullSize;
			}

			void GuiListControl::UpdateView(Rect viewBounds)
			{
				if(itemArranger)
				{
					Rect newBounds=itemCoordinateTransformer->RealRectToVirtualRect(fullSize, viewBounds);
					itemArranger->OnViewChanged(newBounds);
				}
			}

			void GuiListControl::OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(GetVisuallyEnabled())
				{
					boundsComposition->GetRelatedGraphicsHost()->SetFocus(boundsComposition);
				}
			}

			void GuiListControl::SetStyleProviderAndArranger(Ptr<IItemStyleProvider> styleProvider, Ptr<IItemArranger> arranger)
			{
				if(itemStyleProvider)
				{
					itemStyleProvider->DetachListControl();
				}
				if(itemArranger)
				{
					itemArranger->DetachListControl();
					itemArranger->SetCallback(0);
					itemProvider->DetachCallback(itemArranger.Obj());
				}
				callback->ClearCache();

				itemStyleProvider=styleProvider;
				itemArranger=arranger;
				GetVerticalScroll()->SetPosition(0);
				GetHorizontalScroll()->SetPosition(0);

				if(itemStyleProvider)
				{
					itemStyleProvider->AttachListControl(this);
				}
				if(itemArranger)
				{
					itemProvider->AttachCallback(itemArranger.Obj());
					itemArranger->SetCallback(callback.Obj());
					itemArranger->AttachListControl(this);
				}
				CalculateView();
			}

			void GuiListControl::OnItemMouseEvent(compositions::GuiItemMouseEvent& itemEvent, IItemStyleController* style, compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(itemArranger && GetVisuallyEnabled())
				{
					vint itemIndex=itemArranger->GetVisibleIndex(style);
					if(itemIndex!=-1)
					{
						GuiItemMouseEventArgs redirectArguments;
						(GuiMouseEventArgs&)redirectArguments=arguments;
						redirectArguments.compositionSource=GetBoundsComposition();
						redirectArguments.eventSource=GetBoundsComposition();
						redirectArguments.itemIndex=itemIndex;
						itemEvent.Execute(redirectArguments);
						arguments=redirectArguments;
					}
				}
			}

			void GuiListControl::OnItemNotifyEvent(compositions::GuiItemNotifyEvent& itemEvent, IItemStyleController* style, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(itemArranger && GetVisuallyEnabled())
				{
					vint itemIndex=itemArranger->GetVisibleIndex(style);
					if(itemIndex!=-1)
					{
						GuiItemEventArgs redirectArguments;
						(GuiEventArgs&)redirectArguments=arguments;
						redirectArguments.compositionSource=GetBoundsComposition();
						redirectArguments.eventSource=GetBoundsComposition();
						redirectArguments.itemIndex=itemIndex;
						itemEvent.Execute(redirectArguments);
						arguments=redirectArguments;
					}
				}
			}

#define ATTACH_ITEM_MOUSE_EVENT(EVENTNAME, ITEMEVENTNAME)\
					{\
						Func<void(GuiItemMouseEvent&, IItemStyleController*, GuiGraphicsComposition*, GuiMouseEventArgs&)> func(this, &GuiListControl::OnItemMouseEvent);\
						helper->EVENTNAME##Handler=style->GetBoundsComposition()->GetEventReceiver()->EVENTNAME.AttachFunction(\
							Curry(Curry(func)(ITEMEVENTNAME))(style)\
							);\
					}\

#define ATTACH_ITEM_NOTIFY_EVENT(EVENTNAME, ITEMEVENTNAME)\
					{\
						Func<void(GuiItemNotifyEvent&, IItemStyleController*, GuiGraphicsComposition*, GuiEventArgs&)> func(this, &GuiListControl::OnItemNotifyEvent);\
						helper->EVENTNAME##Handler=style->GetBoundsComposition()->GetEventReceiver()->EVENTNAME.AttachFunction(\
							Curry(Curry(func)(ITEMEVENTNAME))(style)\
							);\
					}\

			void GuiListControl::AttachItemEvents(IItemStyleController* style)
			{
				vint index=visibleStyles.Keys().IndexOf(style);
				if(index==-1)
				{
					Ptr<VisibleStyleHelper> helper=new VisibleStyleHelper;
					visibleStyles.Add(style, helper);

					ATTACH_ITEM_MOUSE_EVENT(leftButtonDown, ItemLeftButtonDown);
					ATTACH_ITEM_MOUSE_EVENT(leftButtonUp, ItemLeftButtonUp);
					ATTACH_ITEM_MOUSE_EVENT(leftButtonDoubleClick, ItemLeftButtonDoubleClick);
					ATTACH_ITEM_MOUSE_EVENT(middleButtonDown, ItemMiddleButtonDown);
					ATTACH_ITEM_MOUSE_EVENT(middleButtonUp, ItemMiddleButtonUp);
					ATTACH_ITEM_MOUSE_EVENT(middleButtonDoubleClick, ItemMiddleButtonDoubleClick);
					ATTACH_ITEM_MOUSE_EVENT(rightButtonDown, ItemRightButtonDown);
					ATTACH_ITEM_MOUSE_EVENT(rightButtonUp, ItemRightButtonUp);
					ATTACH_ITEM_MOUSE_EVENT(rightButtonDoubleClick, ItemRightButtonDoubleClick);
					ATTACH_ITEM_MOUSE_EVENT(mouseMove, ItemMouseMove);
					ATTACH_ITEM_NOTIFY_EVENT(mouseEnter, ItemMouseEnter);
					ATTACH_ITEM_NOTIFY_EVENT(mouseLeave, ItemMouseLeave);
				}
			}

#undef ATTACH_ITEM_MOUSE_EVENT
#undef ATTACH_ITEM_NOTIFY_EVENT

#define DETACH_ITEM_EVENT(EVENTNAME) style->GetBoundsComposition()->GetEventReceiver()->EVENTNAME.Detach(helper->EVENTNAME##Handler)

			void GuiListControl::DetachItemEvents(IItemStyleController* style)
			{
				vint index=visibleStyles.Keys().IndexOf(style);
				if(index!=-1)
				{
					Ptr<VisibleStyleHelper> helper=visibleStyles.Values().Get(index);
					visibleStyles.Remove(style);
					
					DETACH_ITEM_EVENT(leftButtonDown);
					DETACH_ITEM_EVENT(leftButtonUp);
					DETACH_ITEM_EVENT(leftButtonDoubleClick);
					DETACH_ITEM_EVENT(middleButtonDown);
					DETACH_ITEM_EVENT(middleButtonUp);
					DETACH_ITEM_EVENT(middleButtonDoubleClick);
					DETACH_ITEM_EVENT(rightButtonDown);
					DETACH_ITEM_EVENT(rightButtonUp);
					DETACH_ITEM_EVENT(rightButtonDoubleClick);
					DETACH_ITEM_EVENT(mouseMove);
					DETACH_ITEM_EVENT(mouseEnter);
					DETACH_ITEM_EVENT(mouseLeave);
				}
			}

#undef DETACH_ITEM_EVENT

			GuiListControl::GuiListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider, bool acceptFocus)
				:GuiScrollView(_styleProvider)
				,itemProvider(_itemProvider)
			{
				StyleProviderChanged.SetAssociatedComposition(boundsComposition);
				ArrangerChanged.SetAssociatedComposition(boundsComposition);
				CoordinateTransformerChanged.SetAssociatedComposition(boundsComposition);
				
				ItemLeftButtonDown.SetAssociatedComposition(boundsComposition);
				ItemLeftButtonUp.SetAssociatedComposition(boundsComposition);
				ItemLeftButtonDoubleClick.SetAssociatedComposition(boundsComposition);
				ItemMiddleButtonDown.SetAssociatedComposition(boundsComposition);
				ItemMiddleButtonUp.SetAssociatedComposition(boundsComposition);
				ItemMiddleButtonDoubleClick.SetAssociatedComposition(boundsComposition);
				ItemRightButtonDown.SetAssociatedComposition(boundsComposition);
				ItemRightButtonUp.SetAssociatedComposition(boundsComposition);
				ItemRightButtonDoubleClick.SetAssociatedComposition(boundsComposition);
				ItemMouseMove.SetAssociatedComposition(boundsComposition);
				ItemMouseEnter.SetAssociatedComposition(boundsComposition);
				ItemMouseLeave.SetAssociatedComposition(boundsComposition);

				callback=new ItemCallback(this);
				itemProvider->AttachCallback(callback.Obj());
				itemCoordinateTransformer=new list::DefaultItemCoordinateTransformer;

				if(acceptFocus)
				{
					boundsComposition->GetEventReceiver()->leftButtonDown.AttachMethod(this, &GuiListControl::OnBoundsMouseButtonDown);
					boundsComposition->GetEventReceiver()->middleButtonDown.AttachMethod(this, &GuiListControl::OnBoundsMouseButtonDown);
					boundsComposition->GetEventReceiver()->rightButtonDown.AttachMethod(this, &GuiListControl::OnBoundsMouseButtonDown);
					SetFocusableComposition(boundsComposition);
				}
			}

			GuiListControl::~GuiListControl()
			{
				if(itemArranger)
				{
					itemProvider->DetachCallback(itemArranger.Obj());
				}
				callback->ClearCache();
				itemStyleProvider=0;
				itemArranger=0;
			}

			GuiListControl::IItemProvider* GuiListControl::GetItemProvider()
			{
				return itemProvider.Obj();
			}

			GuiListControl::IItemStyleProvider* GuiListControl::GetStyleProvider()
			{
				return itemStyleProvider.Obj();
			}

			Ptr<GuiListControl::IItemStyleProvider> GuiListControl::SetStyleProvider(Ptr<IItemStyleProvider> value)
			{
				Ptr<IItemStyleProvider> old=itemStyleProvider;
				SetStyleProviderAndArranger(value, itemArranger);
				StyleProviderChanged.Execute(GetNotifyEventArguments());
				return old;
			}

			GuiListControl::IItemArranger* GuiListControl::GetArranger()
			{
				return itemArranger.Obj();
			}

			Ptr<GuiListControl::IItemArranger> GuiListControl::SetArranger(Ptr<IItemArranger> value)
			{
				Ptr<IItemArranger> old=itemArranger;
				SetStyleProviderAndArranger(itemStyleProvider, value);
				ArrangerChanged.Execute(GetNotifyEventArguments());
				return old;
			}

			GuiListControl::IItemCoordinateTransformer* GuiListControl::GetCoordinateTransformer()
			{
				return itemCoordinateTransformer.Obj();
			}

			Ptr<GuiListControl::IItemCoordinateTransformer> GuiListControl::SetCoordinateTransformer(Ptr<IItemCoordinateTransformer> value)
			{
				Ptr<IItemCoordinateTransformer> old=itemCoordinateTransformer;
				itemCoordinateTransformer=value;
				SetStyleProviderAndArranger(itemStyleProvider, itemArranger);
				CoordinateTransformerChanged.Execute(GetNotifyEventArguments());
				return old;
			}

			bool GuiListControl::EnsureItemVisible(vint itemIndex)
			{
				if(itemIndex<0 || itemIndex>=itemProvider->Count())
				{
					return false;
				}
				return itemArranger?itemArranger->EnsureItemVisible(itemIndex):false;
			}

/***********************************************************************
GuiSelectableListControl
***********************************************************************/

			void GuiSelectableListControl::OnItemModified(vint start, vint count, vint newCount)
			{
				GuiListControl::OnItemModified(start, count, newCount);
				if(count!=newCount)
				{
					ClearSelection();
				}
			}

			void GuiSelectableListControl::OnStyleInstalled(vint itemIndex, IItemStyleController* style)
			{
				GuiListControl::OnStyleInstalled(itemIndex, style);
				selectableStyleProvider->SetStyleSelected(style, selectedItems.Contains(itemIndex));
			}

			void GuiSelectableListControl::OnStyleUninstalled(IItemStyleController* style)
			{
				GuiListControl::OnStyleUninstalled(style);
			}

			void GuiSelectableListControl::OnItemSelectionChanged(vint itemIndex, bool value)
			{
				GuiListControl::IItemStyleController* style=itemArranger->GetVisibleStyle(itemIndex);
				if(style)
				{
					selectableStyleProvider->SetStyleSelected(style, value);
				}
			}

			void GuiSelectableListControl::OnItemSelectionCleared()
			{
				for(vint i=0;i<visibleStyles.Count();i++)
				{
					selectableStyleProvider->SetStyleSelected(visibleStyles.Keys()[i], false);
				}
			}

			void GuiSelectableListControl::OnItemLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments)
			{
				if(GetVisuallyEnabled())
				{
					SelectItemsByClick(arguments.itemIndex, arguments.ctrl, arguments.shift);
				}
			}

			void GuiSelectableListControl::NormalizeSelectedItemIndexStartEnd()
			{
				if(selectedItemIndexStart<0 || selectedItemIndexStart>=itemProvider->Count())
				{
					selectedItemIndexStart=0;
				}
				if(selectedItemIndexEnd<0 || selectedItemIndexEnd>=itemProvider->Count())
				{
					selectedItemIndexEnd=0;
				}
			}

			void GuiSelectableListControl::SetMultipleItemsSelectedSilently(vint start, vint end, bool selected)
			{
				if(start>end)
				{
					vint temp=start;
					start=end;
					end=temp;
				}
				vint count=itemProvider->Count();
				if(start<0) start=0;
				if(end>=count) end=count-1;
				for(vint i=start;i<=end;i++)
				{
					if(selected)
					{
						if(!selectedItems.Contains(i))
						{
							selectedItems.Add(i);
						}
					}
					else
					{
						selectedItems.Remove(i);
					}
					OnItemSelectionChanged(i, selected);
				}
			}

			void GuiSelectableListControl::OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments)
			{
				if(GetVisuallyEnabled())
				{
					if(SelectItemsByKey(arguments.code, arguments.ctrl, arguments.shift))
					{
						arguments.handled=true;
					}
				}
			}

			GuiSelectableListControl::GuiSelectableListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider)
				:GuiListControl(_styleProvider, _itemProvider, true)
				,multiSelect(false)
				,selectedItemIndexStart(-1)
				,selectedItemIndexEnd(-1)
			{
				SelectionChanged.SetAssociatedComposition(boundsComposition);
				ItemLeftButtonDown.AttachMethod(this, &GuiSelectableListControl::OnItemLeftButtonDown);
				if(focusableComposition)
				{
					focusableComposition->GetEventReceiver()->keyDown.AttachMethod(this, &GuiSelectableListControl::OnKeyDown);
				}
			}

			GuiSelectableListControl::~GuiSelectableListControl()
			{
			}

			Ptr<GuiListControl::IItemStyleProvider> GuiSelectableListControl::SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)
			{
				selectableStyleProvider=value?value.Cast<IItemStyleProvider>():0;
				return GuiListControl::SetStyleProvider(value);
			}

			bool GuiSelectableListControl::GetMultiSelect()
			{
				return multiSelect;
			}

			void GuiSelectableListControl::SetMultiSelect(bool value)
			{
				if(multiSelect!=value)
				{
					multiSelect=value;
					ClearSelection();
				}
			}

			const collections::SortedList<vint>& GuiSelectableListControl::GetSelectedItems()
			{
				return selectedItems;
			}

			bool GuiSelectableListControl::GetSelected(vint itemIndex)
			{
				return selectedItems.Contains(itemIndex);
			}

			void GuiSelectableListControl::SetSelected(vint itemIndex, bool value)
			{
				if(value)
				{
					if(!selectedItems.Contains(itemIndex))
					{
						if(!multiSelect)
						{
							selectedItems.Clear();
							OnItemSelectionCleared();
						}
						selectedItems.Add(itemIndex);
						OnItemSelectionChanged(itemIndex, value);
						SelectionChanged.Execute(GetNotifyEventArguments());
					}
				}
				else
				{
					if(selectedItems.Remove(itemIndex))
					{
						OnItemSelectionChanged(itemIndex, value);
						SelectionChanged.Execute(GetNotifyEventArguments());
					}
				}
			}

			bool GuiSelectableListControl::SelectItemsByClick(vint itemIndex, bool ctrl, bool shift)
			{
				NormalizeSelectedItemIndexStartEnd();
				if(0<=itemIndex && itemIndex<itemProvider->Count())
				{
					if(!multiSelect)
					{
						shift=false;
						ctrl=false;
					}
					if(shift)
					{
						if(!ctrl)
						{
							SetMultipleItemsSelectedSilently(selectedItemIndexStart, selectedItemIndexEnd, false);
						}
						selectedItemIndexEnd=itemIndex;
						SetMultipleItemsSelectedSilently(selectedItemIndexStart, selectedItemIndexEnd, true);
						SelectionChanged.Execute(GetNotifyEventArguments());
					}
					else
					{
						if(ctrl)
						{
							vint index=selectedItems.IndexOf(itemIndex);
							if(index==-1)
							{
								selectedItems.Add(itemIndex);
							}
							else
							{
								selectedItems.RemoveAt(index);
							}
							OnItemSelectionChanged(itemIndex, index==-1);
							SelectionChanged.Execute(GetNotifyEventArguments());
						}
						else
						{
							selectedItems.Clear();
							OnItemSelectionCleared();
							selectedItems.Add(itemIndex);
							OnItemSelectionChanged(itemIndex, true);
							SelectionChanged.Execute(GetNotifyEventArguments());
						}
						selectedItemIndexStart=itemIndex;
						selectedItemIndexEnd=itemIndex;
					}
					return true;
				}
				return false;
			}

			bool GuiSelectableListControl::SelectItemsByKey(vint code, bool ctrl, bool shift)
			{
				if(!GetArranger()) return false;

				NormalizeSelectedItemIndexStartEnd();
				KeyDirection keyDirection=Up;
				switch(code)
				{
				case VKEY_UP:
					keyDirection=Up;
					break;
				case VKEY_DOWN:
					keyDirection=Down;
					break;
				case VKEY_LEFT:
					keyDirection=Left;
					break;
				case VKEY_RIGHT:
					keyDirection=Right;
					break;
				case VKEY_HOME:
					keyDirection=Home;
					break;
				case VKEY_END:
					keyDirection=End;
					break;
				case VKEY_PRIOR:
					keyDirection=PageUp;
					break;
				case VKEY_NEXT:
					keyDirection=PageDown;
					break;
				default:
					return false;
				}

				if(GetCoordinateTransformer())
				{
					keyDirection=GetCoordinateTransformer()->RealKeyDirectionToVirtualKeyDirection(keyDirection);
				}
				vint itemIndex=GetArranger()->FindItem(selectedItemIndexEnd, keyDirection);
				if(SelectItemsByClick(itemIndex, ctrl, shift))
				{
					return EnsureItemVisible(itemIndex);
				}
				else
				{
					return false;
				}
			}

			void GuiSelectableListControl::ClearSelection()
			{
				if(selectedItems.Count()>0)
				{
					selectedItems.Clear();
					OnItemSelectionCleared();
					SelectionChanged.Execute(GetNotifyEventArguments());
				}
			}

			namespace list
			{

/***********************************************************************
DefaultItemCoordinateTransformer
***********************************************************************/

				DefaultItemCoordinateTransformer::DefaultItemCoordinateTransformer()
				{
				}

				DefaultItemCoordinateTransformer::~DefaultItemCoordinateTransformer()
				{
				}

				Size DefaultItemCoordinateTransformer::RealSizeToVirtualSize(Size size)
				{
					return size;
				}

				Size DefaultItemCoordinateTransformer::VirtualSizeToRealSize(Size size)
				{
					return size;
				}

				Point DefaultItemCoordinateTransformer::RealPointToVirtualPoint(Size realFullSize, Point point)
				{
					return point;
				}

				Point DefaultItemCoordinateTransformer::VirtualPointToRealPoint(Size realFullSize, Point point)
				{
					return point;
				}

				Rect DefaultItemCoordinateTransformer::RealRectToVirtualRect(Size realFullSize, Rect rect)
				{
					return rect;
				}

				Rect DefaultItemCoordinateTransformer::VirtualRectToRealRect(Size realFullSize, Rect rect)
				{
					return rect;
				}

				Margin DefaultItemCoordinateTransformer::RealMarginToVirtualMargin(Margin margin)
				{
					return margin;
				}

				Margin DefaultItemCoordinateTransformer::VirtualMarginToRealMargin(Margin margin)
				{
					return margin;
				}

				GuiListControl::KeyDirection DefaultItemCoordinateTransformer::RealKeyDirectionToVirtualKeyDirection(GuiListControl::KeyDirection key)
				{
					return key;
				}

/***********************************************************************
AxisAlignedItemCoordinateTransformer
***********************************************************************/

				AxisAlignedItemCoordinateTransformer::AxisAlignedItemCoordinateTransformer(Alignment _alignment)
					:alignment(_alignment)
				{
				}

				AxisAlignedItemCoordinateTransformer::~AxisAlignedItemCoordinateTransformer()
				{
				}

				AxisAlignedItemCoordinateTransformer::Alignment AxisAlignedItemCoordinateTransformer::GetAlignment()
				{
					return alignment;
				}

				Size AxisAlignedItemCoordinateTransformer::RealSizeToVirtualSize(Size size)
				{
					switch(alignment)
					{
					case LeftDown:
					case RightDown:
					case LeftUp:
					case RightUp:
						return Size(size.x, size.y);
					case DownLeft:
					case DownRight:
					case UpLeft:
					case UpRight:
						return Size(size.y, size.x);
					}
					return size;
				}

				Size AxisAlignedItemCoordinateTransformer::VirtualSizeToRealSize(Size size)
				{
					return RealSizeToVirtualSize(size);
				}

				Point AxisAlignedItemCoordinateTransformer::RealPointToVirtualPoint(Size realFullSize, Point point)
				{
					Rect rect(point, Size(0, 0));
					return RealRectToVirtualRect(realFullSize, rect).LeftTop();
				}

				Point AxisAlignedItemCoordinateTransformer::VirtualPointToRealPoint(Size realFullSize, Point point)
				{
					Rect rect(point, Size(0, 0));
					return VirtualRectToRealRect(realFullSize, rect).LeftTop();
				}

				Rect AxisAlignedItemCoordinateTransformer::RealRectToVirtualRect(Size realFullSize, Rect rect)
				{
					vint x1=rect.x1;
					vint x2=realFullSize.x-rect.x2;
					vint y1=rect.y1;
					vint y2=realFullSize.y-rect.y2;
					vint w=rect.Width();
					vint h=rect.Height();
					switch(alignment)
					{
					case LeftDown:
						return Rect(Point(x2, y1), Size(w, h));
					case RightDown:
						return Rect(Point(x1, y1), Size(w, h));
					case LeftUp:
						return Rect(Point(x2, y2), Size(w, h));
					case RightUp:
						return Rect(Point(x1, y2), Size(w, h));
					case DownLeft:
						return Rect(Point(y1, x2), Size(h, w));
					case DownRight:
						return Rect(Point(y1, x1), Size(h, w));
					case UpLeft:
						return Rect(Point(y2, x2), Size(h, w));
					case UpRight:
						return Rect(Point(y2, x1), Size(h, w));
					}
					return rect;
				}

				Rect AxisAlignedItemCoordinateTransformer::VirtualRectToRealRect(Size realFullSize, Rect rect)
				{
					realFullSize=RealSizeToVirtualSize(realFullSize);
					vint x1=rect.x1;
					vint x2=realFullSize.x-rect.x2;
					vint y1=rect.y1;
					vint y2=realFullSize.y-rect.y2;
					vint w=rect.Width();
					vint h=rect.Height();
					switch(alignment)
					{
					case LeftDown:
						return Rect(Point(x2, y1), Size(w, h));
					case RightDown:
						return Rect(Point(x1, y1), Size(w, h));
					case LeftUp:
						return Rect(Point(x2, y2), Size(w, h));
					case RightUp:
						return Rect(Point(x1, y2), Size(w, h));
					case DownLeft:
						return Rect(Point(y2, x1), Size(h, w));
					case DownRight:
						return Rect(Point(y1, x1), Size(h, w));
					case UpLeft:
						return Rect(Point(y2, x2), Size(h, w));
					case UpRight:
						return Rect(Point(y1, x2), Size(h, w));
					}
					return rect;
				}

				Margin AxisAlignedItemCoordinateTransformer::RealMarginToVirtualMargin(Margin margin)
				{
					vint x1=margin.left;
					vint x2=margin.right;
					vint y1=margin.top;
					vint y2=margin.bottom;
					switch(alignment)
					{
					case LeftDown:
						return Margin(x2, y1, x1, y2);
					case RightDown:
						return Margin(x1, y1, x2, y2);
					case LeftUp:
						return Margin(x2, y2, x1, y1);
					case RightUp:
						return Margin(x1, y2, x2, y1);
					case DownLeft:
						return Margin(y1, x2, y2, x1);
					case DownRight:
						return Margin(y1, x1, y2, x2);
					case UpLeft:
						return Margin(y2, x2, y1, x1);
					case UpRight:
						return Margin(y2, x1, y1, x2);
					}
					return margin;
				}

				Margin AxisAlignedItemCoordinateTransformer::VirtualMarginToRealMargin(Margin margin)
				{
					vint x1=margin.left;
					vint x2=margin.right;
					vint y1=margin.top;
					vint y2=margin.bottom;
					switch(alignment)
					{
					case LeftDown:
						return Margin(x2, y1, x1, y2);
					case RightDown:
						return Margin(x1, y1, x2, y2);
					case LeftUp:
						return Margin(x2, y2, x1, y1);
					case RightUp:
						return Margin(x1, y2, x2, y1);
					case DownLeft:
						return Margin(y2, x1, y1, x2);
					case DownRight:
						return Margin(y1, x1, y2, x2);
					case UpLeft:
						return Margin(y2, x2, y1, x1);
					case UpRight:
						return Margin(y1, x2, y2, x1);
					}
					return margin;
				}

				GuiListControl::KeyDirection AxisAlignedItemCoordinateTransformer::RealKeyDirectionToVirtualKeyDirection(GuiListControl::KeyDirection key)
				{
					bool pageKey=false;
					switch(key)
					{
					case GuiListControl::PageUp:
						pageKey=true;
						key=GuiListControl::Up;
						break;
					case GuiListControl::PageDown:
						pageKey=true;
						key=GuiListControl::Down;
						break;
					case GuiListControl::PageLeft:
						pageKey=true;
						key=GuiListControl::Left;
						break;
					case GuiListControl::PageRight:
						pageKey=true;
						key=GuiListControl::Right;
						break;
					}

					switch(key)
					{
					case GuiListControl::Up:
						switch(alignment)
						{
						case LeftDown:	key=GuiListControl::Up;		break;
						case RightDown:	key=GuiListControl::Up;		break;
						case LeftUp:	key=GuiListControl::Down;	break;
						case RightUp:	key=GuiListControl::Down;	break;
						case DownLeft:	key=GuiListControl::Left;	break;
						case DownRight:	key=GuiListControl::Left;	break;
						case UpLeft:	key=GuiListControl::Right;	break;
						case UpRight:	key=GuiListControl::Right;	break;
						}
						break;
					case GuiListControl::Down:
						switch(alignment)
						{
						case LeftDown:	key=GuiListControl::Down;	break;
						case RightDown:	key=GuiListControl::Down;	break;
						case LeftUp:	key=GuiListControl::Up;		break;
						case RightUp:	key=GuiListControl::Up;		break;
						case DownLeft:	key=GuiListControl::Right;	break;
						case DownRight:	key=GuiListControl::Right;	break;
						case UpLeft:	key=GuiListControl::Left;	break;
						case UpRight:	key=GuiListControl::Left;	break;
						}
						break;
					case GuiListControl::Left:
						switch(alignment)
						{
						case LeftDown:	key=GuiListControl::Right;	break;
						case RightDown:	key=GuiListControl::Left;	break;
						case LeftUp:	key=GuiListControl::Right;	break;
						case RightUp:	key=GuiListControl::Left;	break;
						case DownLeft:	key=GuiListControl::Down;	break;
						case DownRight:	key=GuiListControl::Up;		break;
						case UpLeft:	key=GuiListControl::Down;	break;
						case UpRight:	key=GuiListControl::Up;		break;
						}
						break;
					case GuiListControl::Right:
						switch(alignment)
						{
						case LeftDown:	key=GuiListControl::Left;	break;
						case RightDown:	key=GuiListControl::Right;	break;
						case LeftUp:	key=GuiListControl::Left;	break;
						case RightUp:	key=GuiListControl::Right;	break;
						case DownLeft:	key=GuiListControl::Up;		break;
						case DownRight:	key=GuiListControl::Down;	break;
						case UpLeft:	key=GuiListControl::Up;		break;
						case UpRight:	key=GuiListControl::Down;	break;
						}
						break;
					case GuiListControl::Home:
						switch(alignment)
						{
						case LeftDown:	key=GuiListControl::Home;	break;
						case RightDown:	key=GuiListControl::Home;	break;
						case LeftUp:	key=GuiListControl::End;	break;
						case RightUp:	key=GuiListControl::End;	break;
						case DownLeft:	key=GuiListControl::Home;	break;
						case DownRight:	key=GuiListControl::Home;	break;
						case UpLeft:	key=GuiListControl::End;	break;
						case UpRight:	key=GuiListControl::End;	break;
						}
						break;
					case GuiListControl::End:
						switch(alignment)
						{
						case LeftDown:	key=GuiListControl::End;	break;
						case RightDown:	key=GuiListControl::End;	break;
						case LeftUp:	key=GuiListControl::Home;	break;
						case RightUp:	key=GuiListControl::Home;	break;
						case DownLeft:	key=GuiListControl::End;	break;
						case DownRight:	key=GuiListControl::End;	break;
						case UpLeft:	key=GuiListControl::Home;	break;
						case UpRight:	key=GuiListControl::Home;	break;
						}
						break;
					}

					if(pageKey)
					{
						switch(key)
						{
						case GuiListControl::Up:
							key=GuiListControl::PageUp;
							break;
						case GuiListControl::Down:
							key=GuiListControl::PageDown;
							break;
						case GuiListControl::Left:
							key=GuiListControl::PageLeft;
							break;
						case GuiListControl::Right:
							key=GuiListControl::PageRight;
							break;
						}
					}
					return key;
				}

/***********************************************************************
RangedItemArrangerBase
***********************************************************************/

				void RangedItemArrangerBase::ClearStyles()
				{
					startIndex=0;
					if(callback)
					{
						for(vint i=0;i<visibleStyles.Count();i++)
						{
							GuiListControl::IItemStyleController* style=visibleStyles[i];
							callback->ReleaseItem(style);
						}
					}
					visibleStyles.Clear();
					viewBounds=Rect(0, 0, 0, 0);
					OnStylesCleared();
				}

				RangedItemArrangerBase::RangedItemArrangerBase()
					:callback(0)
					,startIndex(0)
				{
				}

				RangedItemArrangerBase::~RangedItemArrangerBase()
				{
				}

				void RangedItemArrangerBase::OnAttached(GuiListControl::IItemProvider* provider)
				{
					itemProvider=provider;
					if(provider)
					{
						OnItemModified(0, 0, provider->Count());
					}
				}

				void RangedItemArrangerBase::OnItemModified(vint start, vint count, vint newCount)
				{
					if(callback)
					{
						vint visibleCount=visibleStyles.Count();
						vint itemCount=itemProvider->Count();
						SortedList<GuiListControl::IItemStyleController*> reusedStyles;
						for(vint i=0;i<visibleCount;i++)
						{
							vint index=startIndex+i;
							if(index>=itemCount)
							{
								break;
							}

							vint oldIndex=-1;
							if(index<start)
							{
								oldIndex=index;
							}
							else if(index>=start+newCount)
							{
								oldIndex=index-newCount+count;
							}

							if(oldIndex!=-1)
							{
								if(oldIndex>=startIndex && oldIndex<startIndex+visibleCount)
								{
									GuiListControl::IItemStyleController* style=visibleStyles[oldIndex-startIndex];
									reusedStyles.Add(style);
									visibleStyles.Add(style);
								}
								else
								{
									oldIndex=-1;
								}
							}
							if(oldIndex==-1)
							{
								GuiListControl::IItemStyleController* style=callback->RequestItem(index);
								visibleStyles.Add(style);
							}
						}

						for(vint i=0;i<visibleCount;i++)
						{
							GuiListControl::IItemStyleController* style=visibleStyles[i];
							if(!reusedStyles.Contains(style))
							{
								callback->ReleaseItem(style);
							}
						}
						visibleStyles.RemoveRange(0, visibleCount);

						callback->OnTotalSizeChanged();
						callback->SetViewLocation(viewBounds.LeftTop());
					}
				}

				void RangedItemArrangerBase::AttachListControl(GuiListControl* value)
				{
				}

				void RangedItemArrangerBase::DetachListControl()
				{
				}

				GuiListControl::IItemArrangerCallback* RangedItemArrangerBase::GetCallback()
				{
					return callback;
				}

				void RangedItemArrangerBase::SetCallback(GuiListControl::IItemArrangerCallback* value)
				{
					if(!value)
					{
						ClearStyles();
					}
					callback=value;
				}

				Size RangedItemArrangerBase::GetTotalSize()
				{
					return OnCalculateTotalSize();
				}

				GuiListControl::IItemStyleController* RangedItemArrangerBase::GetVisibleStyle(vint itemIndex)
				{
					if(startIndex<=itemIndex && itemIndex<startIndex+visibleStyles.Count())
					{
						return visibleStyles[itemIndex-startIndex];
					}
					else
					{
						return 0;
					}
				}

				vint RangedItemArrangerBase::GetVisibleIndex(GuiListControl::IItemStyleController* style)
				{
					vint index=visibleStyles.IndexOf(style);
					return index==-1?-1:index+startIndex;
				}

				void RangedItemArrangerBase::OnViewChanged(Rect bounds)
				{
					Rect oldBounds=viewBounds;
					viewBounds=bounds;
					if(callback)
					{
						OnViewChangedInternal(oldBounds, viewBounds);
					}
				}

/***********************************************************************
FixedHeightItemArranger
***********************************************************************/

				void FixedHeightItemArranger::RearrangeItemBounds()
				{
					vint x0=-viewBounds.Left();
					vint y0=-viewBounds.Top()+GetYOffset();
					vint width=GetWidth();
					for(vint i=0;i<visibleStyles.Count();i++)
					{
						GuiListControl::IItemStyleController* style=visibleStyles[i];
						vint top=y0+(startIndex+i)*rowHeight;
						if(width==-1)
						{
							callback->SetStyleAlignmentToParent(style, Margin(0, -1, 0, -1));
							callback->SetStyleBounds(style, Rect(Point(0, top), Size(0, rowHeight)));
						}
						else
						{
							callback->SetStyleAlignmentToParent(style, Margin(-1, -1, -1, -1));
							callback->SetStyleBounds(style, Rect(Point(x0, top), Size(width, rowHeight)));
						}
					}
				}

				vint FixedHeightItemArranger::GetWidth()
				{
					return -1;
				}

				vint FixedHeightItemArranger::GetYOffset()
				{
					return 0;
				}

				void FixedHeightItemArranger::OnStylesCleared()
				{
					rowHeight=1;
				}

				Size FixedHeightItemArranger::OnCalculateTotalSize()
				{
					if(callback)
					{
						vint width=GetWidth();
						if(width<0) width=0;
						return Size(width, rowHeight*itemProvider->Count()+GetYOffset());
					}
					else
					{
						return Size(0, 0);
					}
				}

				void FixedHeightItemArranger::OnViewChangedInternal(Rect oldBounds, Rect newBounds)
				{
					if(callback)
					{
						if(!suppressOnViewChanged)
						{
							vint oldVisibleCount=visibleStyles.Count();
							vint newRowHeight=rowHeight;
							vint newStartIndex=(newBounds.Top()-GetYOffset())/rowHeight;
							if(newStartIndex<0) newStartIndex=0;

							vint endIndex=startIndex+visibleStyles.Count()-1;
							vint newEndIndex=(newBounds.Bottom()-1)/newRowHeight;
							vint itemCount=itemProvider->Count();

							for(vint i=newStartIndex;i<=newEndIndex && i<itemCount;i++)
							{
								if(startIndex<=i && i<=endIndex)
								{
									GuiListControl::IItemStyleController* style=visibleStyles[i-startIndex];
									visibleStyles.Add(style);
								}
								else
								{
									GuiListControl::IItemStyleController* style=callback->RequestItem(i);
									visibleStyles.Add(style);
									vint styleHeight=callback->GetStylePreferredSize(style).y;
									if(newRowHeight<styleHeight)
									{
										newRowHeight=styleHeight;
										newEndIndex=(newBounds.Bottom()-1)/newRowHeight;
									}
								}
							}

							for(vint i=0;i<oldVisibleCount;i++)
							{
								vint index=startIndex+i;
								if(index<newStartIndex || newEndIndex<index)
								{
									GuiListControl::IItemStyleController* style=visibleStyles[i];
									callback->ReleaseItem(style);
								}
							}
							visibleStyles.RemoveRange(0, oldVisibleCount);

							if(rowHeight!=newRowHeight)
							{
								vint offset=oldBounds.Top()-rowHeight*startIndex;
								rowHeight=newRowHeight;
								suppressOnViewChanged=true;
								callback->OnTotalSizeChanged();
								callback->SetViewLocation(Point(0, rowHeight*newStartIndex+offset));
								suppressOnViewChanged=false;
							}
							startIndex=newStartIndex;
							RearrangeItemBounds();
						}
					}
				}

				FixedHeightItemArranger::FixedHeightItemArranger()
					:rowHeight(1)
					,suppressOnViewChanged(false)
				{
				}

				FixedHeightItemArranger::~FixedHeightItemArranger()
				{
				}

				vint FixedHeightItemArranger::FindItem(vint itemIndex, GuiListControl::KeyDirection key)
				{
					vint count=itemProvider->Count();
					if(count==0) return -1;
					vint groupCount=viewBounds.Height()/rowHeight;
					if(groupCount==0) groupCount=1;
					switch(key)
					{
					case GuiListControl::Up:
						itemIndex--;
						break;
					case GuiListControl::Down:
						itemIndex++;
						break;
					case GuiListControl::Home:
						itemIndex=0;
						break;
					case GuiListControl::End:
						itemIndex=count;
						break;
					case GuiListControl::PageUp:
						itemIndex-=groupCount;
						break;
					case GuiListControl::PageDown:
						itemIndex+=groupCount;
						break;
					default:
						return -1;
					}
					
					if(itemIndex<0) return 0;
					else if(itemIndex>=count) return count-1;
					else return itemIndex;
				}

				bool FixedHeightItemArranger::EnsureItemVisible(vint itemIndex)
				{
					if(callback)
					{
						if(itemIndex<0 || itemIndex>=itemProvider->Count())
						{
							return false;
						}
						while(true)
						{
							vint yOffset=GetYOffset();
							vint top=itemIndex*rowHeight;
							vint bottom=top+rowHeight+yOffset;

							if(viewBounds.Height()<rowHeight)
							{
								if(viewBounds.Top()<bottom && top<viewBounds.Bottom())
								{
									break;
								}
							}

							Point location=viewBounds.LeftTop();
							if(top<viewBounds.Top())
							{
								location.y=top;
							}
							else if(viewBounds.Bottom()<bottom)
							{
								location.y=bottom-viewBounds.Height();
							}
							else
							{
								break;
							}
							callback->SetViewLocation(location);
						}
						return true;
					}
					return false;
				}

/***********************************************************************
FixedSizeMultiColumnItemArranger
***********************************************************************/

				void FixedSizeMultiColumnItemArranger::RearrangeItemBounds()
				{
					vint y0=-viewBounds.Top();
					vint rowItems=viewBounds.Width()/itemSize.x;
					if(rowItems<1) rowItems=1;

					for(vint i=0;i<visibleStyles.Count();i++)
					{
						GuiListControl::IItemStyleController* style=visibleStyles[i];
						vint row=(startIndex+i)/rowItems;
						vint col=(startIndex+i)%rowItems;
						callback->SetStyleBounds(style, Rect(Point(col*itemSize.x, y0+row*itemSize.y), itemSize));
					}
				}

				void FixedSizeMultiColumnItemArranger::CalculateRange(Size itemSize, Rect bounds, vint count, vint& start, vint& end)
				{
					vint startRow=bounds.Top()/itemSize.y;
					if(startRow<0) startRow=0;
					vint endRow=(bounds.Bottom()-1)/itemSize.y;
					vint cols=bounds.Width()/itemSize.x;
					if(cols<1) cols=1;

					start=startRow*cols;
					end=(endRow+1)*cols-1;
					if(end>=count) end=count-1;
				}

				void FixedSizeMultiColumnItemArranger::OnStylesCleared()
				{
					itemSize=Size(1, 1);
				}

				Size FixedSizeMultiColumnItemArranger::OnCalculateTotalSize()
				{
					if(callback)
					{
						vint rowItems=viewBounds.Width()/itemSize.x;
						if(rowItems<1) rowItems=1;
						vint rows=itemProvider->Count()/rowItems;
						if(itemProvider->Count()%rowItems) rows++;

						return Size(itemSize.x*rowItems, itemSize.y*rows);
					}
					else
					{
						return Size(0, 0);
					}
				}

				void FixedSizeMultiColumnItemArranger::OnViewChangedInternal(Rect oldBounds, Rect newBounds)
				{
					if(callback)
					{
						if(!suppressOnViewChanged)
						{
							vint oldVisibleCount=visibleStyles.Count();
							Size newItemSize=itemSize;
							vint endIndex=startIndex+visibleStyles.Count()-1;

							vint newStartIndex=0;
							vint newEndIndex=0;
							vint itemCount=itemProvider->Count();
							CalculateRange(newItemSize, newBounds, itemCount, newStartIndex, newEndIndex);
							if(newItemSize==Size(1, 1) && newStartIndex<newEndIndex)
							{
								newEndIndex=newStartIndex;
							}

							vint previousStartIndex=-1;
							vint previousEndIndex=-1;

							while(true)
							{
								for(vint i=newStartIndex;i<=newEndIndex;i++)
								{
									if(startIndex<=i && i<=endIndex)
									{
										GuiListControl::IItemStyleController* style=visibleStyles[i-startIndex];
										visibleStyles.Add(style);
									}
									else if(i<previousStartIndex || i>previousEndIndex)
									{
										GuiListControl::IItemStyleController* style=callback->RequestItem(i);

										if(i<previousStartIndex)
										{
											visibleStyles.Insert(oldVisibleCount+(i-newStartIndex), style);
										}
										else
										{
											visibleStyles.Add(style);
										}
										
										Size styleSize=callback->GetStylePreferredSize(style);
										if(newItemSize.x<styleSize.x) newItemSize.x=styleSize.x;
										if(newItemSize.y<styleSize.y) newItemSize.y=styleSize.y;
									}
								}

								vint updatedStartIndex=0;
								vint updatedEndIndex=0;
								CalculateRange(newItemSize, newBounds, itemCount, updatedStartIndex, updatedEndIndex);
								bool again=updatedStartIndex<newStartIndex || updatedEndIndex>newEndIndex;
								previousStartIndex=newStartIndex;
								previousEndIndex=newEndIndex;
								if(updatedStartIndex<newStartIndex) newStartIndex=updatedStartIndex;
								if(updatedEndIndex>newEndIndex) newEndIndex=updatedEndIndex;
								if(!again) break;
							}

							for(vint i=0;i<oldVisibleCount;i++)
							{
								vint index=startIndex+i;
								if(index<newStartIndex || newEndIndex<index)
								{
									GuiListControl::IItemStyleController* style=visibleStyles[i];
									callback->ReleaseItem(style);
								}
							}
							visibleStyles.RemoveRange(0, oldVisibleCount);

							if(itemSize!=newItemSize)
							{
								itemSize=newItemSize;
								suppressOnViewChanged=true;
								callback->OnTotalSizeChanged();
								suppressOnViewChanged=false;
							}
							startIndex=newStartIndex;
							RearrangeItemBounds();
						}
					}
				}

				FixedSizeMultiColumnItemArranger::FixedSizeMultiColumnItemArranger()
					:itemSize(1, 1)
					,suppressOnViewChanged(false)
				{
				}

				FixedSizeMultiColumnItemArranger::~FixedSizeMultiColumnItemArranger()
				{
				}

				vint FixedSizeMultiColumnItemArranger::FindItem(vint itemIndex, GuiListControl::KeyDirection key)
				{
					vint count=itemProvider->Count();
					vint columnCount=viewBounds.Width()/itemSize.x;
					if(columnCount==0) columnCount=1;
					vint rowCount=viewBounds.Height()/itemSize.y;
					if(rowCount==0) rowCount=1;

					switch(key)
					{
					case GuiListControl::Up:
						itemIndex-=columnCount;
						break;
					case GuiListControl::Down:
						itemIndex+=columnCount;
						break;
					case GuiListControl::Left:
						itemIndex--;
						break;
					case GuiListControl::Right:
						itemIndex++;
						break;
					case GuiListControl::Home:
						itemIndex=0;
						break;
					case GuiListControl::End:
						itemIndex=count;
						break;
					case GuiListControl::PageUp:
						itemIndex-=columnCount*rowCount;
						break;
					case GuiListControl::PageDown:
						itemIndex+=columnCount*rowCount;
						break;
					case GuiListControl::PageLeft:
						itemIndex-=itemIndex%columnCount;
						break;
					case GuiListControl::PageRight:
						itemIndex+=columnCount-itemIndex%columnCount-1;
						break;
					default:
						return -1;
					}
					
					if(itemIndex<0) return 0;
					else if(itemIndex>=count) return count-1;
					else return itemIndex;
				}

				bool FixedSizeMultiColumnItemArranger::EnsureItemVisible(vint itemIndex)
				{
					if(callback)
					{
						if(itemIndex<0 || itemIndex>=itemProvider->Count())
						{
							return false;
						}
						while(true)
						{
							vint rowHeight=itemSize.y;
							vint columnCount=viewBounds.Width()/itemSize.x;
							if(columnCount==0) columnCount=1;
							vint rowIndex=itemIndex/columnCount;

							vint top=rowIndex*rowHeight;
							vint bottom=top+rowHeight;

							if(viewBounds.Height()<rowHeight)
							{
								if(viewBounds.Top()<bottom && top<viewBounds.Bottom())
								{
									break;
								}
							}

							Point location=viewBounds.LeftTop();
							if(top<viewBounds.Top())
							{
								location.y=top;
							}
							else if(viewBounds.Bottom()<bottom)
							{
								location.y=bottom-viewBounds.Height();
							}
							else
							{
								break;
							}
							callback->SetViewLocation(location);
						}
						return true;
					}
					return false;
				}

/***********************************************************************
FixedHeightMultiColumnItemArranger
***********************************************************************/

				void FixedHeightMultiColumnItemArranger::RearrangeItemBounds()
				{
					vint rows=0;
					vint startColumn=0;
					CalculateRange(itemHeight, viewBounds, rows, startColumn);
					vint currentWidth=0;
					vint totalWidth=0;
					for(vint i=0;i<visibleStyles.Count();i++)
					{
						vint column=i%rows;
						if(column==0)
						{
							totalWidth+=currentWidth;
							currentWidth=0;
						}
						GuiListControl::IItemStyleController* style=visibleStyles[i];
						vint itemWidth=callback->GetStylePreferredSize(style).x;
						if(currentWidth<itemWidth) currentWidth=itemWidth;
						callback->SetStyleBounds(style, Rect(Point(totalWidth, itemHeight*column), Size(0, 0)));
					}
				}

				void FixedHeightMultiColumnItemArranger::CalculateRange(vint itemHeight, Rect bounds, vint& rows, vint& startColumn)
				{
					rows=bounds.Height()/itemHeight;
					if(rows<1) rows=1;
					startColumn=bounds.Left()/bounds.Width();
				}

				void FixedHeightMultiColumnItemArranger::OnStylesCleared()
				{
					itemHeight=1;
				}

				Size FixedHeightMultiColumnItemArranger::OnCalculateTotalSize()
				{
					if(callback)
					{
						vint rows=viewBounds.Height()/itemHeight;
						if(rows<1) rows=1;
						vint columns=itemProvider->Count()/rows;
						if(itemProvider->Count()%rows) columns+=1;
						return Size(viewBounds.Width()*columns, 0);
					}
					else
					{
						return Size(0, 0);
					}
				}

				void FixedHeightMultiColumnItemArranger::OnViewChangedInternal(Rect oldBounds, Rect newBounds)
				{
					if(callback)
					{
						if(!suppressOnViewChanged)
						{
							vint oldVisibleCount=visibleStyles.Count();
							vint endIndex=startIndex+oldVisibleCount-1;

							vint newItemHeight=itemHeight;
							vint itemCount=itemProvider->Count();

							vint previousStartIndex=-1;
							vint previousEndIndex=-1;
							vint newStartIndex=-1;
							vint newEndIndex=-1;

							while(true)
							{
								vint newRows=0;
								vint newStartColumn=0;
								vint currentWidth=0;
								vint totalWidth=0;
								CalculateRange(newItemHeight, newBounds, newRows, newStartColumn);
								newStartIndex=newRows*newStartColumn;
								vint currentItemHeight=newItemHeight;

								for(vint i=newStartIndex;i<itemCount;i++)
								{
									if(i%newRows==0)
									{
										totalWidth+=currentWidth;
										currentWidth=0;
										if(totalWidth>=newBounds.Width())
										{
											break;
										}
									}
									newEndIndex=i;

									if(startIndex<=i && i<=endIndex)
									{
										GuiListControl::IItemStyleController* style=visibleStyles[i-startIndex];
										visibleStyles.Add(style);
									}
									else if(i<previousStartIndex || i>previousEndIndex)
									{
										GuiListControl::IItemStyleController* style=callback->RequestItem(i);

										if(i<previousStartIndex)
										{
											visibleStyles.Insert(oldVisibleCount+(i-newStartIndex), style);
										}
										else
										{
											visibleStyles.Add(style);
										}
										
										Size styleSize=callback->GetStylePreferredSize(style);
										if(currentWidth<styleSize.x) currentWidth=styleSize.x;
										if(newItemHeight<styleSize.y) newItemHeight=styleSize.y;
										if(currentItemHeight!=newItemHeight) break;
									}
								}

								if(previousStartIndex==-1 || previousStartIndex<newStartIndex) previousStartIndex=newStartIndex;
								if(previousEndIndex==-1 || previousEndIndex>newEndIndex) previousEndIndex=newEndIndex;
								if(currentItemHeight==newItemHeight)
								{
									break;
								}
							}
							newStartIndex=previousStartIndex;
							newEndIndex=previousEndIndex;

							for(vint i=0;i<oldVisibleCount;i++)
							{
								vint index=startIndex+i;
								if(index<newStartIndex || newEndIndex<index)
								{
									GuiListControl::IItemStyleController* style=visibleStyles[i];
									callback->ReleaseItem(style);
								}
							}
							visibleStyles.RemoveRange(0, oldVisibleCount);

							if(itemHeight!=newItemHeight)
							{
								itemHeight=newItemHeight;
								suppressOnViewChanged=true;
								callback->OnTotalSizeChanged();
								suppressOnViewChanged=false;
							}
							startIndex=newStartIndex;
							RearrangeItemBounds();
						}
					}
				}

				FixedHeightMultiColumnItemArranger::FixedHeightMultiColumnItemArranger()
					:itemHeight(1)
					,suppressOnViewChanged(false)
				{
				}

				FixedHeightMultiColumnItemArranger::~FixedHeightMultiColumnItemArranger()
				{
				}

				vint FixedHeightMultiColumnItemArranger::FindItem(vint itemIndex, GuiListControl::KeyDirection key)
				{
					vint count=itemProvider->Count();
					vint groupCount=viewBounds.Height()/itemHeight;
					if(groupCount==0) groupCount=1;
					switch(key)
					{
					case GuiListControl::Up:
						itemIndex--;
						break;
					case GuiListControl::Down:
						itemIndex++;
						break;
					case GuiListControl::Left:
						itemIndex-=groupCount;
						break;
					case GuiListControl::Right:
						itemIndex+=groupCount;
						break;
					case GuiListControl::Home:
						itemIndex=0;
						break;
					case GuiListControl::End:
						itemIndex=count;
						break;
					case GuiListControl::PageUp:
						itemIndex-=itemIndex%groupCount;
						break;
					case GuiListControl::PageDown:
						itemIndex+=groupCount-itemIndex%groupCount-1;
						break;
					default:
						return -1;
					}
					
					if(itemIndex<0) return 0;
					else if(itemIndex>=count) return count-1;
					else return itemIndex;
				}

				bool FixedHeightMultiColumnItemArranger::EnsureItemVisible(vint itemIndex)
				{
					if(callback)
					{
						if(itemIndex<0 || itemIndex>=itemProvider->Count())
						{
							return false;
						}
						while(true)
						{
							vint rowCount=viewBounds.Height()/itemHeight;
							if(rowCount==0) rowCount=1;
							vint columnIndex=itemIndex/rowCount;
							vint minIndex=startIndex;
							vint maxIndex=startIndex+visibleStyles.Count()-1;

							Point location=viewBounds.LeftTop();
							if(minIndex<=itemIndex && itemIndex<=maxIndex)
							{
								Rect bounds=callback->GetStyleBounds(visibleStyles[itemIndex-startIndex]);
								if(0<bounds.Bottom() && bounds.Top()<viewBounds.Width() && bounds.Width()>viewBounds.Width())
								{
									break;
								}
								else if(bounds.Left()<0)
								{
									location.x-=viewBounds.Width();
								}
								else if(bounds.Right()>viewBounds.Width())
								{
									location.x+=viewBounds.Width();
								}
								else
								{
									break;
								}
							}
							else if(columnIndex<minIndex/rowCount)
							{
								location.x-=viewBounds.Width();
							}
							else if(columnIndex>=maxIndex/rowCount)
							{
								location.x+=viewBounds.Width();
							}
							else
							{
								break;
							}
							callback->SetViewLocation(location);
						}
						return true;
					}
					return false;
				}

/***********************************************************************
ItemStyleControllerBase
***********************************************************************/

				void ItemStyleControllerBase::Initialize(compositions::GuiBoundsComposition* _boundsComposition, GuiControl* _associatedControl)
				{
					boundsComposition=_boundsComposition;
					associatedControl=_associatedControl;
				}

				void ItemStyleControllerBase::Finalize()
				{
					if(boundsComposition && !isInstalled)
					{
						if(associatedControl)
						{
							delete associatedControl;
						}
						else
						{
							delete boundsComposition;
						}
					}
					boundsComposition=0;
					associatedControl=0;
				}

				ItemStyleControllerBase::ItemStyleControllerBase(GuiListControl::IItemStyleProvider* _provider, vint _styleId)
					:provider(_provider)
					,styleId(_styleId)
					,boundsComposition(0)
					,associatedControl(0)
					,isInstalled(false)
				{
				}

				ItemStyleControllerBase::~ItemStyleControllerBase()
				{
					Finalize();
				}
					
				GuiListControl::IItemStyleProvider* ItemStyleControllerBase::GetStyleProvider()
				{
					return provider;
				}

				vint ItemStyleControllerBase::GetItemStyleId()
				{
					return styleId;
				}

				compositions::GuiBoundsComposition* ItemStyleControllerBase::GetBoundsComposition()
				{
					return boundsComposition;
				}

				bool ItemStyleControllerBase::IsCacheable()
				{
					return true;
				}

				bool ItemStyleControllerBase::IsInstalled()
				{
					return isInstalled;
				}

				void ItemStyleControllerBase::OnInstalled()
				{
					isInstalled=true;
				}

				void ItemStyleControllerBase::OnUninstalled()
				{
					isInstalled=false;
				}

/***********************************************************************
ItemProviderBase
***********************************************************************/

				void ItemProviderBase::InvokeOnItemModified(vint start, vint count, vint newCount)
				{
					for(vint i=0;i<callbacks.Count();i++)
					{
						callbacks[i]->OnItemModified(start, count, newCount);
					}
				}

				ItemProviderBase::ItemProviderBase()
				{
				}

				ItemProviderBase::~ItemProviderBase()
				{
					for(vint i=0;i<callbacks.Count();i++)
					{
						callbacks[i]->OnAttached(0);
					}
				}

				bool ItemProviderBase::AttachCallback(GuiListControl::IItemProviderCallback* value)
				{
					if(callbacks.Contains(value))
					{
						return false;
					}
					else
					{
						callbacks.Add(value);
						value->OnAttached(this);
						return true;
					}
				}

				bool ItemProviderBase::DetachCallback(GuiListControl::IItemProviderCallback* value)
				{
					vint index=callbacks.IndexOf(value);
					if(index==-1)
					{
						return false;
					}
					else
					{
						value->OnAttached(0);
						callbacks.Remove(value);
						return true;
					}
				}
			}
		}
	}
}

/***********************************************************************
Controls\ListControlPackage\GuiListViewControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace compositions;

			namespace list
			{

/***********************************************************************
ListViewItemStyleProviderBase::TextItemStyleController
***********************************************************************/

				ListViewItemStyleProviderBase::ListViewItemStyleController::ListViewItemStyleController(ListViewItemStyleProviderBase* provider)
					:ItemStyleControllerBase(provider, 0)
					,backgroundButton(0)
					,listViewItemStyleProvider(provider)
				{
					backgroundButton=new GuiSelectableButton(listViewItemStyleProvider->listControl->GetListViewStyleProvider()->CreateItemBackground());
					backgroundButton->SetAutoSelection(false);
					Initialize(backgroundButton->GetBoundsComposition(), backgroundButton);
				}

				ListViewItemStyleProviderBase::ListViewItemStyleController::~ListViewItemStyleController()
				{
				}

				bool ListViewItemStyleProviderBase::ListViewItemStyleController::GetSelected()
				{
					return backgroundButton->GetSelected();
				}

				void ListViewItemStyleProviderBase::ListViewItemStyleController::SetSelected(bool value)
				{
					backgroundButton->SetSelected(value);
				}

/***********************************************************************
ListViewItemStyleProviderBase
***********************************************************************/

				ListViewItemStyleProviderBase::ListViewItemStyleProviderBase()
					:listControl(0)
				{
				}

				ListViewItemStyleProviderBase::~ListViewItemStyleProviderBase()
				{
				}

				void ListViewItemStyleProviderBase::AttachListControl(GuiListControl* value)
				{
					listControl=dynamic_cast<GuiListViewBase*>(value);
				}

				void ListViewItemStyleProviderBase::DetachListControl()
				{
					listControl=0;
				}

				vint ListViewItemStyleProviderBase::GetItemStyleId(vint itemIndex)
				{
					return 0;
				}

				void ListViewItemStyleProviderBase::SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)
				{
					ListViewItemStyleController* textStyle=dynamic_cast<ListViewItemStyleController*>(style);
					textStyle->SetSelected(value);
				}
			}

/***********************************************************************
GuiListViewColumnHeader
***********************************************************************/
			
			GuiListViewColumnHeader::GuiListViewColumnHeader(IStyleController* _styleController)
				:GuiMenuButton(_styleController)
				,columnSortingState(NotSorted)
				,styleController(_styleController)
			{
				styleController->SetColumnSortingState(columnSortingState);
			}

			GuiListViewColumnHeader::~GuiListViewColumnHeader()
			{
			}

			GuiListViewColumnHeader::ColumnSortingState GuiListViewColumnHeader::GetColumnSortingState()
			{
				return columnSortingState;
			}

			void GuiListViewColumnHeader::SetColumnSortingState(ColumnSortingState value)
			{
				if(columnSortingState!=value)
				{
					columnSortingState=value;
					styleController->SetColumnSortingState(columnSortingState);
				}
			}

/***********************************************************************
GuiListViewBase
***********************************************************************/

			GuiListViewBase::GuiListViewBase(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider)
				:GuiSelectableListControl(_styleProvider, _itemProvider)
				,styleProvider(0)
			{
				styleProvider=dynamic_cast<IStyleProvider*>(styleController->GetStyleProvider());
				ColumnClicked.SetAssociatedComposition(boundsComposition);
			}

			GuiListViewBase::~GuiListViewBase()
			{
			}

			GuiListViewBase::IStyleProvider* GuiListViewBase::GetListViewStyleProvider()
			{
				return styleProvider;
			}

			Ptr<GuiListControl::IItemStyleProvider> GuiListViewBase::SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)
			{
				if(value.Cast<list::ListViewItemStyleProvider>())
				{
					return GuiSelectableListControl::SetStyleProvider(value);
				}
				else
				{
					return 0;
				}
			}

			namespace list
			{

/***********************************************************************
ListViewItemStyleProvider::ListViewContentItemStyleController
***********************************************************************/

				ListViewItemStyleProvider::ListViewContentItemStyleController::ListViewContentItemStyleController(ListViewItemStyleProvider* provider)
					:ListViewItemStyleController(provider)
					,listViewItemStyleProvider(provider)
				{
					content=listViewItemStyleProvider->listViewItemContentProvider->CreateItemContent(backgroundButton->GetFont());
					GuiBoundsComposition* composition=content->GetContentComposition();
					composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					backgroundButton->GetContainerComposition()->AddChild(composition);

					GuiBoundsComposition* decorator=content->GetBackgroundDecorator();
					if(decorator)
					{
						backgroundButton->GetBoundsComposition()->AddChild(decorator);
						backgroundButton->GetBoundsComposition()->MoveChild(decorator, 0);
					}
				}

				ListViewItemStyleProvider::ListViewContentItemStyleController::~ListViewContentItemStyleController()
				{
				}

				ListViewItemStyleProvider::IListViewItemContent* ListViewItemStyleProvider::ListViewContentItemStyleController::GetItemContent()
				{
					return content.Obj();
				}

				void ListViewItemStyleProvider::ListViewContentItemStyleController::Install(IListViewItemView* view, vint itemIndex)
				{
					content->Install(listViewItemStyleProvider->listControl->GetListViewStyleProvider(), view, itemIndex);
				}

/***********************************************************************
ListViewItemStyleProvider
***********************************************************************/

				const wchar_t* const ListViewItemStyleProvider::IListViewItemView::Identifier = L"vl::presentation::controls::list::ListViewItemStyleProvider::IListViewItemView";

				ListViewItemStyleProvider::ListViewItemStyleProvider(IListViewItemContentProvider* itemContentProvider)
					:listViewItemView(0)
					,listViewItemContentProvider(itemContentProvider)
				{
				}

				ListViewItemStyleProvider::~ListViewItemStyleProvider()
				{
				}

				void ListViewItemStyleProvider::AttachListControl(GuiListControl* value)
				{
					ListViewItemStyleProviderBase::AttachListControl(value);
					listViewItemView=dynamic_cast<IListViewItemView*>(value->GetItemProvider()->RequestView(IListViewItemView::Identifier));
					listViewItemContentProvider->AttachListControl(value);
				}

				void ListViewItemStyleProvider::DetachListControl()
				{
					listViewItemContentProvider->DetachListControl();
					listControl->GetItemProvider()->ReleaseView(listViewItemView);
					listViewItemView=0;
					ListViewItemStyleProviderBase::DetachListControl();
				}

				GuiListControl::IItemStyleController* ListViewItemStyleProvider::CreateItemStyle(vint styleId)
				{
					ListViewContentItemStyleController* itemStyle=new ListViewContentItemStyleController(this);
					itemStyles.Add(itemStyle);
					return itemStyle;
				}

				void ListViewItemStyleProvider::DestroyItemStyle(GuiListControl::IItemStyleController* style)
				{
					ListViewContentItemStyleController* itemStyle=dynamic_cast<ListViewContentItemStyleController*>(style);
					if(itemStyle)
					{
						itemStyles.Remove(itemStyle);
						delete itemStyle;
					}
				}

				void ListViewItemStyleProvider::Install(GuiListControl::IItemStyleController* style, vint itemIndex)
				{
					ListViewContentItemStyleController* itemStyle=dynamic_cast<ListViewContentItemStyleController*>(style);
					itemStyle->Install(listViewItemView, itemIndex);
				}

				const ListViewItemStyleProvider::ItemStyleList& ListViewItemStyleProvider::GetCreatedItemStyles()
				{
					return itemStyles;
				}

				bool ListViewItemStyleProvider::IsItemStyleAttachedToListView(GuiListControl::IItemStyleController* itemStyle)
				{
					return itemStyle && itemStyle->GetBoundsComposition()->GetParent();
				}
				
/***********************************************************************
ListViewBigIconContentProvider
***********************************************************************/

				ListViewBigIconContentProvider::ItemContent::ItemContent(Size iconSize, const FontProperties& font)
					:contentComposition(0)
				{
					contentComposition=new GuiBoundsComposition;
					contentComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

					GuiTableComposition* table=new GuiTableComposition;
					contentComposition->AddChild(table);
					table->SetRowsAndColumns(2, 3);
					table->SetRowOption(0, GuiCellOption::MinSizeOption());
					table->SetRowOption(1, GuiCellOption::MinSizeOption());
					table->SetColumnOption(0, GuiCellOption::PercentageOption(0.5));
					table->SetColumnOption(1, GuiCellOption::MinSizeOption());
					table->SetColumnOption(2, GuiCellOption::PercentageOption(0.5));
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetCellPadding(5);
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 1, 1);
						cell->SetPreferredMinSize(iconSize);

						image=GuiImageFrameElement::Create();
						image->SetStretch(true);
						cell->SetOwnedElement(image);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetMinSizeLimitation(GuiGraphicsComposition::NoLimit);
						cell->SetSite(1, 0, 1, 3);
						cell->SetPreferredMinSize(Size(64, 40));

						text=GuiSolidLabelElement::Create();
						text->SetAlignments(Alignment::Center, Alignment::Top);
						text->SetFont(font);
						text->SetWrapLine(true);
						text->SetEllipse(true);
						cell->SetOwnedElement(text);
					}
				}

				ListViewBigIconContentProvider::ItemContent::~ItemContent()
				{
				}

				compositions::GuiBoundsComposition* ListViewBigIconContentProvider::ItemContent::GetContentComposition()
				{
					return contentComposition;
				}

				compositions::GuiBoundsComposition* ListViewBigIconContentProvider::ItemContent::GetBackgroundDecorator()
				{
					return 0;
				}

				void ListViewBigIconContentProvider::ItemContent::Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)
				{
					Ptr<GuiImageData> imageData=view->GetLargeImage(itemIndex);
					if(imageData)
					{
						image->SetImage(imageData->GetImage(), imageData->GetFrameIndex());
					}
					else
					{
						image->SetImage(0);
					}
					text->SetText(view->GetText(itemIndex));
					text->SetColor(styleProvider->GetPrimaryTextColor());
				}

				ListViewBigIconContentProvider::ListViewBigIconContentProvider(Size _iconSize)
					:iconSize(_iconSize)
				{
				}

				ListViewBigIconContentProvider::~ListViewBigIconContentProvider()
				{
				}

				GuiListControl::IItemCoordinateTransformer* ListViewBigIconContentProvider::CreatePreferredCoordinateTransformer()
				{
					return new DefaultItemCoordinateTransformer;
				}

				GuiListControl::IItemArranger* ListViewBigIconContentProvider::CreatePreferredArranger()
				{
					return new FixedSizeMultiColumnItemArranger;
				}

				ListViewItemStyleProvider::IListViewItemContent* ListViewBigIconContentProvider::CreateItemContent(const FontProperties& font)
				{
					return new ItemContent(iconSize, font);
				}

				void ListViewBigIconContentProvider::AttachListControl(GuiListControl* value)
				{
				}

				void ListViewBigIconContentProvider::DetachListControl()
				{
				}
				
/***********************************************************************
ListViewSmallIconContentProvider
***********************************************************************/

				ListViewSmallIconContentProvider::ItemContent::ItemContent(Size iconSize, const FontProperties& font)
					:contentComposition(0)
				{
					contentComposition=new GuiBoundsComposition;
					contentComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

					GuiTableComposition* table=new GuiTableComposition;
					contentComposition->AddChild(table);
					table->SetRowsAndColumns(3, 2);
					table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
					table->SetRowOption(1, GuiCellOption::MinSizeOption());
					table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
					table->SetColumnOption(0, GuiCellOption::MinSizeOption());
					table->SetColumnOption(1, GuiCellOption::MinSizeOption());
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetCellPadding(2);
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(1, 0, 1, 1);
						cell->SetPreferredMinSize(iconSize);

						image=GuiImageFrameElement::Create();
						image->SetStretch(true);
						cell->SetOwnedElement(image);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 3, 1);
						cell->SetPreferredMinSize(Size(192, 0));

						text=GuiSolidLabelElement::Create();
						text->SetAlignments(Alignment::Left, Alignment::Center);
						text->SetFont(font);
						text->SetEllipse(true);
						cell->SetOwnedElement(text);
					}
				}

				ListViewSmallIconContentProvider::ItemContent::~ItemContent()
				{
				}

				compositions::GuiBoundsComposition* ListViewSmallIconContentProvider::ItemContent::GetContentComposition()
				{
					return contentComposition;
				}

				compositions::GuiBoundsComposition* ListViewSmallIconContentProvider::ItemContent::GetBackgroundDecorator()
				{
					return 0;
				}

				void ListViewSmallIconContentProvider::ItemContent::Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)
				{
					Ptr<GuiImageData> imageData=view->GetSmallImage(itemIndex);
					if(imageData)
					{
						image->SetImage(imageData->GetImage(), imageData->GetFrameIndex());
					}
					else
					{
						image->SetImage(0);
					}
					text->SetText(view->GetText(itemIndex));
					text->SetColor(styleProvider->GetPrimaryTextColor());
				}

				ListViewSmallIconContentProvider::ListViewSmallIconContentProvider(Size _iconSize)
					:iconSize(_iconSize)
				{
				}

				ListViewSmallIconContentProvider::~ListViewSmallIconContentProvider()
				{
				}

				GuiListControl::IItemCoordinateTransformer* ListViewSmallIconContentProvider::CreatePreferredCoordinateTransformer()
				{
					return new DefaultItemCoordinateTransformer;
				}

				GuiListControl::IItemArranger* ListViewSmallIconContentProvider::CreatePreferredArranger()
				{
					return new FixedSizeMultiColumnItemArranger;
				}

				ListViewItemStyleProvider::IListViewItemContent* ListViewSmallIconContentProvider::CreateItemContent(const FontProperties& font)
				{
					return new ItemContent(iconSize, font);
				}

				void ListViewSmallIconContentProvider::AttachListControl(GuiListControl* value)
				{
				}

				void ListViewSmallIconContentProvider::DetachListControl()
				{
				}
				
/***********************************************************************
ListViewListContentProvider
***********************************************************************/

				ListViewListContentProvider::ItemContent::ItemContent(Size iconSize, const FontProperties& font)
					:contentComposition(0)
				{
					contentComposition=new GuiBoundsComposition;
					contentComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

					GuiTableComposition* table=new GuiTableComposition;
					contentComposition->AddChild(table);
					table->SetRowsAndColumns(3, 2);
					table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
					table->SetRowOption(1, GuiCellOption::MinSizeOption());
					table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
					table->SetColumnOption(0, GuiCellOption::MinSizeOption());
					table->SetColumnOption(1, GuiCellOption::MinSizeOption());
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetCellPadding(2);
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(1, 0, 1, 1);
						cell->SetPreferredMinSize(iconSize);

						image=GuiImageFrameElement::Create();
						image->SetStretch(true);
						cell->SetOwnedElement(image);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 3, 1);
						cell->SetMargin(Margin(0, 0, 16, 0));

						text=GuiSolidLabelElement::Create();
						text->SetAlignments(Alignment::Left, Alignment::Center);
						text->SetFont(font);
						cell->SetOwnedElement(text);
					}
				}

				ListViewListContentProvider::ItemContent::~ItemContent()
				{
				}

				compositions::GuiBoundsComposition* ListViewListContentProvider::ItemContent::GetContentComposition()
				{
					return contentComposition;
				}

				compositions::GuiBoundsComposition* ListViewListContentProvider::ItemContent::GetBackgroundDecorator()
				{
					return 0;
				}

				void ListViewListContentProvider::ItemContent::Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)
				{
					Ptr<GuiImageData> imageData=view->GetSmallImage(itemIndex);
					if(imageData)
					{
						image->SetImage(imageData->GetImage(), imageData->GetFrameIndex());
					}
					else
					{
						image->SetImage(0);
					}
					text->SetText(view->GetText(itemIndex));
					text->SetColor(styleProvider->GetPrimaryTextColor());
				}

				ListViewListContentProvider::ListViewListContentProvider(Size _iconSize)
					:iconSize(_iconSize)
				{
				}

				ListViewListContentProvider::~ListViewListContentProvider()
				{
				}

				GuiListControl::IItemCoordinateTransformer* ListViewListContentProvider::CreatePreferredCoordinateTransformer()
				{
					return new DefaultItemCoordinateTransformer;
				}

				GuiListControl::IItemArranger* ListViewListContentProvider::CreatePreferredArranger()
				{
					return new FixedHeightMultiColumnItemArranger;
				}

				ListViewItemStyleProvider::IListViewItemContent* ListViewListContentProvider::CreateItemContent(const FontProperties& font)
				{
					return new ItemContent(iconSize, font);
				}

				void ListViewListContentProvider::AttachListControl(GuiListControl* value)
				{
				}

				void ListViewListContentProvider::DetachListControl()
				{
				}
				
/***********************************************************************
ListViewTileContentProvider
***********************************************************************/

				void ListViewTileContentProvider::ItemContent::RemoveTextElement(vint textRow)
				{
					GuiCellComposition* cell=textTable->GetSitedCell(textRow+1, 0);
					textTable->RemoveChild(cell);
					delete cell;
				}

				elements::GuiSolidLabelElement* ListViewTileContentProvider::ItemContent::CreateTextElement(vint textRow, const FontProperties& font)
				{
					GuiCellComposition* cell=new GuiCellComposition;
					textTable->AddChild(cell);
					cell->SetSite(textRow+1, 0, 1, 1);

					elements::GuiSolidLabelElement* textElement=GuiSolidLabelElement::Create();
					textElement->SetAlignments(Alignment::Left, Alignment::Center);
					textElement->SetFont(font);
					textElement->SetEllipse(true);
					cell->SetOwnedElement(textElement);
					return textElement;
				}

				void ListViewTileContentProvider::ItemContent::ResetTextTable(vint textRows)
				{
					textTable->SetRowsAndColumns(textRows+2, 1);
					textTable->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
					for(vint i=0;i<textRows;i++)
					{
						textTable->SetRowOption(i+1, GuiCellOption::MinSizeOption());
					}
					textTable->SetRowOption(textRows+1, GuiCellOption::PercentageOption(0.5));
					textTable->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
				}

				ListViewTileContentProvider::ItemContent::ItemContent(Size iconSize, const FontProperties& font)
					:contentComposition(0)
				{
					contentComposition=new GuiBoundsComposition;
					contentComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

					GuiTableComposition* table=new GuiTableComposition;
					contentComposition->AddChild(table);
					table->SetRowsAndColumns(3, 2);
					table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
					table->SetRowOption(1, GuiCellOption::MinSizeOption());
					table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
					table->SetColumnOption(0, GuiCellOption::MinSizeOption());
					table->SetColumnOption(1, GuiCellOption::MinSizeOption());
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetCellPadding(4);
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(1, 0, 1, 1);
						cell->SetPreferredMinSize(iconSize);

						image=GuiImageFrameElement::Create();
						image->SetStretch(true);
						cell->SetOwnedElement(image);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 3, 1);
						cell->SetPreferredMinSize(Size(224, 0));

						textTable=new GuiTableComposition;
						textTable->SetCellPadding(1);
						ResetTextTable(1);
						textTable->SetAlignmentToParent(Margin(0, 0, 0, 0));
						cell->AddChild(textTable);
						{
							text=CreateTextElement(0, font);
						}
					}
				}

				ListViewTileContentProvider::ItemContent::~ItemContent()
				{
				}

				compositions::GuiBoundsComposition* ListViewTileContentProvider::ItemContent::GetContentComposition()
				{
					return contentComposition;
				}

				compositions::GuiBoundsComposition* ListViewTileContentProvider::ItemContent::GetBackgroundDecorator()
				{
					return 0;
				}

				void ListViewTileContentProvider::ItemContent::Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)
				{
					Ptr<GuiImageData> imageData=view->GetLargeImage(itemIndex);
					if(imageData)
					{
						image->SetImage(imageData->GetImage(), imageData->GetFrameIndex());
					}
					else
					{
						image->SetImage(0);
					}
					text->SetText(view->GetText(itemIndex));
					text->SetColor(styleProvider->GetPrimaryTextColor());

					for(vint i=0;i<dataTexts.Count();i++)
					{
						RemoveTextElement(i+1);
					}
					vint dataColumnCount=view->GetDataColumnCount();
					ResetTextTable(dataColumnCount+1);
					dataTexts.Resize(dataColumnCount);
					for(vint i=0;i<dataColumnCount;i++)
					{
						dataTexts[i]=CreateTextElement(i+1, text->GetFont());
						dataTexts[i]->SetText(view->GetSubItem(itemIndex, view->GetDataColumn(i)));
						dataTexts[i]->SetColor(styleProvider->GetSecondaryTextColor());
					}
				}

				ListViewTileContentProvider::ListViewTileContentProvider(Size _iconSize)
					:iconSize(_iconSize)
				{
				}

				ListViewTileContentProvider::~ListViewTileContentProvider()
				{
				}

				GuiListControl::IItemCoordinateTransformer* ListViewTileContentProvider::CreatePreferredCoordinateTransformer()
				{
					return new DefaultItemCoordinateTransformer;
				}

				GuiListControl::IItemArranger* ListViewTileContentProvider::CreatePreferredArranger()
				{
					return new FixedSizeMultiColumnItemArranger;
				}

				ListViewItemStyleProvider::IListViewItemContent* ListViewTileContentProvider::CreateItemContent(const FontProperties& font)
				{
					return new ItemContent(iconSize, font);
				}

				void ListViewTileContentProvider::AttachListControl(GuiListControl* value)
				{
				}

				void ListViewTileContentProvider::DetachListControl()
				{
				}
				
/***********************************************************************
ListViewInformationContentProvider
***********************************************************************/

				ListViewInformationContentProvider::ItemContent::ItemContent(Size iconSize, const FontProperties& font)
					:contentComposition(0)
					,baselineFont(font)
				{
					contentComposition=new GuiBoundsComposition;
					contentComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					{
						bottomLine=GuiSolidBackgroundElement::Create();
						bottomLineComposition=new GuiBoundsComposition;
						bottomLineComposition->SetOwnedElement(bottomLine);
						bottomLineComposition->SetAlignmentToParent(Margin(8, -1, 8, 0));
						bottomLineComposition->SetPreferredMinSize(Size(0, 1));
					}

					GuiTableComposition* table=new GuiTableComposition;
					contentComposition->AddChild(table);
					table->SetRowsAndColumns(3, 3);
					table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
					table->SetRowOption(1, GuiCellOption::MinSizeOption());
					table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
					table->SetColumnOption(0, GuiCellOption::MinSizeOption());
					table->SetColumnOption(1, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(2, GuiCellOption::MinSizeOption());
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetCellPadding(4);
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(1, 0, 1, 1);
						cell->SetPreferredMinSize(iconSize);

						image=GuiImageFrameElement::Create();
						image->SetStretch(true);
						cell->SetOwnedElement(image);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 3, 1);

						FontProperties textFont=font;
						textFont.size=(vint)(textFont.size*1.2);

						text=GuiSolidLabelElement::Create();
						text->SetFont(textFont);
						text->SetEllipse(true);
						cell->SetOwnedElement(text);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 2, 3, 1);
						cell->SetPreferredMinSize(Size(224, 0));

						textTable=new GuiTableComposition;
						textTable->SetCellPadding(4);
						textTable->SetAlignmentToParent(Margin(0, 0, 0, 0));
						cell->AddChild(textTable);
					}
				}

				ListViewInformationContentProvider::ItemContent::~ItemContent()
				{
				}

				compositions::GuiBoundsComposition* ListViewInformationContentProvider::ItemContent::GetContentComposition()
				{
					return contentComposition;
				}

				compositions::GuiBoundsComposition* ListViewInformationContentProvider::ItemContent::GetBackgroundDecorator()
				{
					return bottomLineComposition;
				}

				void ListViewInformationContentProvider::ItemContent::Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)
				{
					Ptr<GuiImageData> imageData=view->GetLargeImage(itemIndex);
					if(imageData)
					{
						image->SetImage(imageData->GetImage(), imageData->GetFrameIndex());
					}
					else
					{
						image->SetImage(0);
					}
					text->SetText(view->GetText(itemIndex));
					text->SetColor(styleProvider->GetPrimaryTextColor());
					bottomLine->SetColor(styleProvider->GetItemSeparatorColor());

					for(vint i=0;i<dataTexts.Count();i++)
					{
						GuiCellComposition* cell=textTable->GetSitedCell(i, 0);
						textTable->RemoveChild(cell);
						delete cell;
					}

					vint dataColumnCount=view->GetDataColumnCount();
					dataTexts.Resize(dataColumnCount);
					textTable->SetRowsAndColumns(dataColumnCount, 1);
					textTable->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
					for(vint i=0;i<dataColumnCount;i++)
					{
						textTable->SetRowOption(i, GuiCellOption::MinSizeOption());
					}
					
					for(vint i=0;i<dataColumnCount;i++)
					{
						GuiCellComposition* cell=new GuiCellComposition;
						textTable->AddChild(cell);
						cell->SetSite(i, 0, 1, 1);

						GuiTableComposition* dataTable=new GuiTableComposition;
						dataTable->SetRowsAndColumns(1, 2);
						dataTable->SetRowOption(0, GuiCellOption::MinSizeOption());
						dataTable->SetColumnOption(0, GuiCellOption::MinSizeOption());
						dataTable->SetColumnOption(1, GuiCellOption::PercentageOption(1.0));
						dataTable->SetAlignmentToParent(Margin(0, 0, 0, 0));
						cell->AddChild(dataTable);
						{
							GuiCellComposition* cell=new GuiCellComposition;
							dataTable->AddChild(cell);
							cell->SetSite(0, 0, 1, 1);

							GuiSolidLabelElement* textColumn=GuiSolidLabelElement::Create();
							textColumn->SetFont(baselineFont);
							textColumn->SetText(view->GetColumnText(view->GetDataColumn(i)+1)+L": ");
							textColumn->SetColor(styleProvider->GetSecondaryTextColor());
							cell->SetOwnedElement(textColumn);
						}
						{
							GuiCellComposition* cell=new GuiCellComposition;
							dataTable->AddChild(cell);
							cell->SetSite(0, 1, 1, 1);

							GuiSolidLabelElement* textData=GuiSolidLabelElement::Create();
							textData->SetFont(baselineFont);
							textData->SetEllipse(true);
							textData->SetText(view->GetSubItem(itemIndex, view->GetDataColumn(i)));
							textData->SetColor(styleProvider->GetPrimaryTextColor());
							cell->SetOwnedElement(textData);
						}
					}
				}

				ListViewInformationContentProvider::ListViewInformationContentProvider(Size _iconSize)
					:iconSize(_iconSize)
				{
				}

				ListViewInformationContentProvider::~ListViewInformationContentProvider()
				{
				}

				GuiListControl::IItemCoordinateTransformer* ListViewInformationContentProvider::CreatePreferredCoordinateTransformer()
				{
					return new DefaultItemCoordinateTransformer;
				}

				GuiListControl::IItemArranger* ListViewInformationContentProvider::CreatePreferredArranger()
				{
					return new FixedHeightItemArranger;
				}

				ListViewItemStyleProvider::IListViewItemContent* ListViewInformationContentProvider::CreateItemContent(const FontProperties& font)
				{
					return new ItemContent(iconSize, font);
				}

				void ListViewInformationContentProvider::AttachListControl(GuiListControl* value)
				{
				}

				void ListViewInformationContentProvider::DetachListControl()
				{
				}
				
/***********************************************************************
ListViewColumnItemArranger::ColumnItemViewCallback
***********************************************************************/

				ListViewColumnItemArranger::ColumnItemViewCallback::ColumnItemViewCallback(ListViewColumnItemArranger* _arranger)
					:arranger(_arranger)
				{
				}

				ListViewColumnItemArranger::ColumnItemViewCallback::~ColumnItemViewCallback()
				{
				}

				void ListViewColumnItemArranger::ColumnItemViewCallback::OnColumnChanged()
				{
					arranger->RebuildColumns();
				}
				
/***********************************************************************
ListViewColumnItemArranger
***********************************************************************/

				const wchar_t* const ListViewColumnItemArranger::IColumnItemView::Identifier = L"vl::presentation::controls::list::ListViewColumnItemArranger::IColumnItemView";

				void ListViewColumnItemArranger::ColumnClicked(vint index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
				{
					GuiItemEventArgs args(listView->ColumnClicked.GetAssociatedComposition());
					args.itemIndex=index;
					listView->ColumnClicked.Execute(args);
				}

				void ListViewColumnItemArranger::ColumnHeaderSplitterLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
				{
					if(listView->GetVisuallyEnabled())
					{
						arguments.handled=true;
						splitterDragging=true;
						splitterLatestX=arguments.x;
					}
				}

				void ListViewColumnItemArranger::ColumnHeaderSplitterLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
				{
					if(listView->GetVisuallyEnabled())
					{
						arguments.handled=true;
						splitterDragging=false;
						splitterLatestX=0;
					}
				}

				void ListViewColumnItemArranger::ColumnHeaderSplitterMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
				{
					if(splitterDragging)
					{
						vint offset=arguments.x-splitterLatestX;
						vint index=columnHeaderSplitters.IndexOf(dynamic_cast<GuiBoundsComposition*>(sender));
						if(index!=-1)
						{
							GuiBoundsComposition* buttonBounds=columnHeaderButtons[index]->GetBoundsComposition();
							Rect bounds=buttonBounds->GetBounds();
							Rect newBounds(bounds.LeftTop(), Size(bounds.Width()+offset, bounds.Height()));
							buttonBounds->SetBounds(newBounds);

							vint finalSize=buttonBounds->GetBounds().Width();
							columnItemView->SetColumnSize(index, finalSize);
						}
					}
				}

				void ListViewColumnItemArranger::RearrangeItemBounds()
				{
					FixedHeightItemArranger::RearrangeItemBounds();
					vint count=columnHeaders->GetParent()->Children().Count();
					columnHeaders->GetParent()->MoveChild(columnHeaders, count-1);
					columnHeaders->SetBounds(Rect(Point(-viewBounds.Left(), 0), Size(0, 0)));
				}

				vint ListViewColumnItemArranger::GetWidth()
				{
					vint width=columnHeaders->GetBounds().Width()-SplitterWidth;
					if(width<SplitterWidth)
					{
						width=SplitterWidth;
					}
					return width;
				}

				vint ListViewColumnItemArranger::GetYOffset()
				{
					return columnHeaders->GetBounds().Height();
				}

				Size ListViewColumnItemArranger::OnCalculateTotalSize()
				{
					Size size=FixedHeightItemArranger::OnCalculateTotalSize();
					size.x+=SplitterWidth;
					return size;
				}

				void ListViewColumnItemArranger::DeleteColumnButtons()
				{
					for(vint i=columnHeaders->GetStackItems().Count()-1;i>=0;i--)
					{
						GuiStackItemComposition* item=columnHeaders->GetStackItems().Get(i);
						columnHeaders->RemoveChild(item);

						GuiControl* button=item->Children().Get(0)->GetAssociatedControl();
						if(button)
						{
							item->RemoveChild(button->GetBoundsComposition());
							delete button;
						}
						delete item;
					}
					columnHeaderButtons.Clear();
					columnHeaderSplitters.Clear();
				}

				void ListViewColumnItemArranger::RebuildColumns()
				{
					if(columnItemView && columnHeaderButtons.Count()==columnItemView->GetColumnCount())
					{
						for(vint i=0;i<columnItemView->GetColumnCount();i++)
						{
							GuiListViewColumnHeader* button=columnHeaderButtons[i];
							button->SetText(columnItemView->GetColumnText(i));
							button->SetSubMenu(columnItemView->GetDropdownPopup(i), false);
							button->SetColumnSortingState(columnItemView->GetSortingState(i));
							button->GetBoundsComposition()->SetBounds(Rect(Point(0, 0), Size(columnItemView->GetColumnSize(i), 0)));
						}
					}
					else
					{
						DeleteColumnButtons();
						if(columnItemView)
						{
							for(vint i=0;i<columnItemView->GetColumnCount();i++)
							{
								GuiBoundsComposition* splitterComposition=new GuiBoundsComposition;
								splitterComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
								splitterComposition->SetAssociatedCursor(GetCurrentController()->ResourceService()->GetSystemCursor(INativeCursor::SizeWE));
								splitterComposition->SetAlignmentToParent(Margin(0, 0, -1, 0));
								splitterComposition->SetPreferredMinSize(Size(SplitterWidth, 0));
								columnHeaderSplitters.Add(splitterComposition);

								splitterComposition->GetEventReceiver()->leftButtonDown.AttachMethod(this, &ListViewColumnItemArranger::ColumnHeaderSplitterLeftButtonDown);
								splitterComposition->GetEventReceiver()->leftButtonUp.AttachMethod(this, &ListViewColumnItemArranger::ColumnHeaderSplitterLeftButtonUp);
								splitterComposition->GetEventReceiver()->mouseMove.AttachMethod(this, &ListViewColumnItemArranger::ColumnHeaderSplitterMouseMove);
							}
							for(vint i=0;i<columnItemView->GetColumnCount();i++)
							{
								GuiListViewColumnHeader* button=new GuiListViewColumnHeader(styleProvider->CreateColumnStyle());
								button->SetText(columnItemView->GetColumnText(i));
								button->SetSubMenu(columnItemView->GetDropdownPopup(i), false);
								button->SetColumnSortingState(columnItemView->GetSortingState(i));
								button->GetBoundsComposition()->SetBounds(Rect(Point(0, 0), Size(columnItemView->GetColumnSize(i), 0)));
								button->Clicked.AttachLambda(Curry(Func<void(vint, GuiGraphicsComposition*, GuiEventArgs&)>(this, &ListViewColumnItemArranger::ColumnClicked))(i));
								columnHeaderButtons.Add(button);
								if(i>0)
								{
									button->GetContainerComposition()->AddChild(columnHeaderSplitters[i-1]);
								}

								GuiStackItemComposition* item=new GuiStackItemComposition;
								item->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
								item->AddChild(button->GetBoundsComposition());
								columnHeaders->AddChild(item);
							}
							if(columnItemView->GetColumnCount()>0)
							{
								GuiBoundsComposition* splitterComposition=columnHeaderSplitters[columnItemView->GetColumnCount()-1];

								GuiStackItemComposition* item=new GuiStackItemComposition;
								item->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
								item->AddChild(splitterComposition);
								columnHeaders->AddChild(item);
							}
						}
					}
					callback->OnTotalSizeChanged();
				}

				ListViewColumnItemArranger::ListViewColumnItemArranger()
					:listView(0)
					,styleProvider(0)
					,columnItemView(0)
					,splitterDragging(false)
					,splitterLatestX(0)
				{
					columnHeaders=new GuiStackComposition;
					columnHeaders->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					columnItemViewCallback=new ColumnItemViewCallback(this);
				}

				ListViewColumnItemArranger::~ListViewColumnItemArranger()
				{
					if(!columnHeaders->GetParent())
					{
						DeleteColumnButtons();
						delete columnHeaders;
					}
				}

				void ListViewColumnItemArranger::AttachListControl(GuiListControl* value)
				{
					FixedHeightItemArranger::AttachListControl(value);
					listView=dynamic_cast<GuiListViewBase*>(value);
					if(listView)
					{
						styleProvider=listView->GetListViewStyleProvider();
						listView->GetContainerComposition()->AddChild(columnHeaders);
						columnItemView=dynamic_cast<IColumnItemView*>(listView->GetItemProvider()->RequestView(IColumnItemView::Identifier));
						if(columnItemView)
						{
							columnItemView->AttachCallback(columnItemViewCallback.Obj());
							RebuildColumns();
						}
					}
				}

				void ListViewColumnItemArranger::DetachListControl()
				{
					if(listView)
					{
						if(columnItemView)
						{
							columnItemView->DetachCallback(columnItemViewCallback.Obj());
							listView->GetItemProvider()->ReleaseView(columnItemView);
							columnItemView=0;
						}
						listView->GetContainerComposition()->RemoveChild(columnHeaders);
						styleProvider=0;
						listView=0;
					}
					FixedHeightItemArranger::DetachListControl();
				}
				
/***********************************************************************
ListViewDetailContentProvider
***********************************************************************/

				ListViewDetailContentProvider::ItemContent::ItemContent(Size iconSize, const FontProperties& font, GuiListControl::IItemProvider* _itemProvider)
					:contentComposition(0)
					,itemProvider(_itemProvider)
				{
					columnItemView=dynamic_cast<ListViewColumnItemArranger::IColumnItemView*>(itemProvider->RequestView(ListViewColumnItemArranger::IColumnItemView::Identifier));
					contentComposition=new GuiBoundsComposition;
					contentComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

					textTable=new GuiTableComposition;
					textTable->SetAlignmentToParent(Margin(0, 0, 0, 0));
					textTable->SetRowsAndColumns(1, 1);
					textTable->SetRowOption(0, GuiCellOption::MinSizeOption());
					textTable->SetColumnOption(0, GuiCellOption::AbsoluteOption(0));
					contentComposition->AddChild(textTable);
					{
						GuiCellComposition* cell=new GuiCellComposition;
						textTable->AddChild(cell);
						cell->SetSite(0, 0, 1, 1);

						GuiTableComposition* table=new GuiTableComposition;
						cell->AddChild(table);
						table->SetRowsAndColumns(3, 2);
						table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
						table->SetRowOption(1, GuiCellOption::MinSizeOption());
						table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
						table->SetColumnOption(0, GuiCellOption::MinSizeOption());
						table->SetColumnOption(1, GuiCellOption::PercentageOption(1.0));
						table->SetAlignmentToParent(Margin(0, 0, 0, 0));
						table->SetCellPadding(2);
						{
							GuiCellComposition* cell=new GuiCellComposition;
							table->AddChild(cell);
							cell->SetSite(1, 0, 1, 1);
							cell->SetPreferredMinSize(iconSize);

							image=GuiImageFrameElement::Create();
							image->SetStretch(true);
							cell->SetOwnedElement(image);
						}
						{
							GuiCellComposition* cell=new GuiCellComposition;
							table->AddChild(cell);
							cell->SetSite(0, 1, 3, 1);
							cell->SetMargin(Margin(0, 0, 8, 0));

							text=GuiSolidLabelElement::Create();
							text->SetAlignments(Alignment::Left, Alignment::Center);
							text->SetFont(font);
							text->SetEllipse(true);
							cell->SetOwnedElement(text);
						}
					}
				}

				ListViewDetailContentProvider::ItemContent::~ItemContent()
				{
					if(columnItemView)
					{
						itemProvider->ReleaseView(columnItemView);
					}
				}

				compositions::GuiBoundsComposition* ListViewDetailContentProvider::ItemContent::GetContentComposition()
				{
					return contentComposition;
				}

				compositions::GuiBoundsComposition* ListViewDetailContentProvider::ItemContent::GetBackgroundDecorator()
				{
					return 0;
				}

				void ListViewDetailContentProvider::ItemContent::UpdateSubItemSize()
				{
					vint columnCount=columnItemView->GetColumnCount();
					for(vint i=0;i<columnCount;i++)
					{
						textTable->SetColumnOption(i, GuiCellOption::AbsoluteOption(columnItemView->GetColumnSize(i)));
					}
					textTable->UpdateCellBounds();
				}

				void ListViewDetailContentProvider::ItemContent::Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)
				{
					for(vint i=1;i<textTable->GetColumns();i++)
					{
						GuiCellComposition* cell=textTable->GetSitedCell(0, i);
						textTable->RemoveChild(cell);
						delete cell;
					}

					Ptr<GuiImageData> imageData=view->GetSmallImage(itemIndex);
					if(imageData)
					{
						image->SetImage(imageData->GetImage(), imageData->GetFrameIndex());
					}
					else
					{
						image->SetImage(0);
					}
					text->SetText(view->GetText(itemIndex));
					text->SetColor(styleProvider->GetPrimaryTextColor());

					vint columnCount=columnItemView->GetColumnCount();
					textTable->SetRowsAndColumns(1, columnCount);
					for(vint i=1;i<columnCount;i++)
					{
						GuiCellComposition* cell=new GuiCellComposition;
						textTable->AddChild(cell);
						cell->SetSite(0, i, 1, 1);
						cell->SetMargin(Margin(8, 0, 8, 0));

						GuiSolidLabelElement* subText=GuiSolidLabelElement::Create();
						subText->SetAlignments(Alignment::Left, Alignment::Center);
						subText->SetFont(text->GetFont());
						subText->SetEllipse(true);
						subText->SetText(view->GetSubItem(itemIndex, i-1));
						subText->SetColor(styleProvider->GetSecondaryTextColor());
						cell->SetOwnedElement(subText);
					}
					UpdateSubItemSize();
				}

				void ListViewDetailContentProvider::OnColumnChanged()
				{
					vint count=listViewItemStyleProvider->GetCreatedItemStyles().Count();
					for(vint i=0;i<count;i++)
					{
						GuiListControl::IItemStyleController* itemStyleController=listViewItemStyleProvider->GetCreatedItemStyles().Get(i);
						ItemContent* itemContent=listViewItemStyleProvider->GetItemContent<ItemContent>(itemStyleController);
						if(itemContent)
						{
							itemContent->UpdateSubItemSize();
						}
					}
				}

				ListViewDetailContentProvider::ListViewDetailContentProvider(Size _iconSize)
					:iconSize(_iconSize)
					,itemProvider(0)
					,columnItemView(0)
					,listViewItemStyleProvider(0)
				{
				}

				ListViewDetailContentProvider::~ListViewDetailContentProvider()
				{
				}

				GuiListControl::IItemCoordinateTransformer* ListViewDetailContentProvider::CreatePreferredCoordinateTransformer()
				{
					return new DefaultItemCoordinateTransformer;
				}

				GuiListControl::IItemArranger* ListViewDetailContentProvider::CreatePreferredArranger()
				{
					return new ListViewColumnItemArranger;
				}

				ListViewItemStyleProvider::IListViewItemContent* ListViewDetailContentProvider::CreateItemContent(const FontProperties& font)
				{
					return new ItemContent(iconSize, font, itemProvider);
				}

				void ListViewDetailContentProvider::AttachListControl(GuiListControl* value)
				{
					listViewItemStyleProvider=dynamic_cast<ListViewItemStyleProvider*>(value->GetStyleProvider());
					itemProvider=value->GetItemProvider();
					columnItemView=dynamic_cast<ListViewColumnItemArranger::IColumnItemView*>(itemProvider->RequestView(ListViewColumnItemArranger::IColumnItemView::Identifier));
					if(columnItemView)
					{
						columnItemView->AttachCallback(this);
					}
				}

				void ListViewDetailContentProvider::DetachListControl()
				{
					if(columnItemView)
					{
						columnItemView->DetachCallback(this);
						itemProvider->ReleaseView(columnItemView);
					}
					itemProvider=0;
					listViewItemStyleProvider=0;
				}

/***********************************************************************
ListViewColumn
***********************************************************************/

				ListViewColumn::ListViewColumn(const WString& _text, vint _size)
					:text(_text)
					,size(_size)
					,dropdownPopup(0)
					,sortingState(GuiListViewColumnHeader::NotSorted)
				{
				}

/***********************************************************************
ListViewDataColumns
***********************************************************************/

				void ListViewDataColumns::NotifyUpdateInternal(vint start, vint count, vint newCount)
				{
					itemProvider->NotifyUpdate(0, itemProvider->Count());
				}

				ListViewDataColumns::ListViewDataColumns()
					:itemProvider(0)
				{
				}

				ListViewDataColumns::~ListViewDataColumns()
				{
				}

/***********************************************************************
ListViewColumns
***********************************************************************/

				void ListViewColumns::NotifyUpdateInternal(vint start, vint count, vint newCount)
				{
					for(vint i=0;i<itemProvider->columnItemViewCallbacks.Count();i++)
					{
						itemProvider->columnItemViewCallbacks[i]->OnColumnChanged();
					}
					itemProvider->NotifyUpdate(0, itemProvider->Count());
				}

				ListViewColumns::ListViewColumns()
					:itemProvider(0)
				{
				}

				ListViewColumns::~ListViewColumns()
				{
				}

/***********************************************************************
ListViewItemProvider
***********************************************************************/

				bool ListViewItemProvider::ContainsPrimaryText(vint itemIndex)
				{
					return true;
				}

				WString ListViewItemProvider::GetPrimaryTextViewText(vint itemIndex)
				{
					return Get(itemIndex)->text;
				}

				Ptr<GuiImageData> ListViewItemProvider::GetSmallImage(vint itemIndex)
				{
					return Get(itemIndex)->smallImage;
				}

				Ptr<GuiImageData> ListViewItemProvider::GetLargeImage(vint itemIndex)
				{
					return Get(itemIndex)->largeImage;
				}

				WString ListViewItemProvider::GetText(vint itemIndex)
				{
					return Get(itemIndex)->text;
				}

				WString ListViewItemProvider::GetSubItem(vint itemIndex, vint index)
				{
					Ptr<ListViewItem> item=Get(itemIndex);
					if(index<0 || index>=item->subItems.Count())
					{
						return L"";
					}
					else
					{
						return item->subItems[index];
					}
				}

				vint ListViewItemProvider::GetDataColumnCount()
				{
					return dataColumns.Count();
				}

				vint ListViewItemProvider::GetDataColumn(vint index)
				{
					return dataColumns[index];
				}

				bool ListViewItemProvider::AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)
				{
					if(columnItemViewCallbacks.Contains(value))
					{
						return false;
					}
					else
					{
						columnItemViewCallbacks.Add(value);
						return true;
					}
				}

				bool ListViewItemProvider::DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)
				{
					vint index=columnItemViewCallbacks.IndexOf(value);
					if(index==-1)
					{
						return false;
					}
					else
					{
						columnItemViewCallbacks.Remove(value);
						return true;
					}
				}

				vint ListViewItemProvider::GetColumnCount()
				{
					return columns.Count();
				}

				WString ListViewItemProvider::GetColumnText(vint index)
				{
					if(index<0 || index>=columns.Count())
					{
						return L"";
					}
					else
					{
						return columns[index]->text;
					}
				}

				vint ListViewItemProvider::GetColumnSize(vint index)
				{
					if(index<0 || index>=columns.Count())
					{
						return 0;
					}
					else
					{
						return columns[index]->size;
					}
				}

				void ListViewItemProvider::SetColumnSize(vint index, vint value)
				{
					if(index>=0 && index<columns.Count())
					{
						columns[index]->size=value;
						for(vint i=0;i<columnItemViewCallbacks.Count();i++)
						{
							columnItemViewCallbacks[i]->OnColumnChanged();
						}
					}
				}

				GuiMenu* ListViewItemProvider::GetDropdownPopup(vint index)
				{
					if(index<0 || index>=columns.Count())
					{
						return 0;
					}
					else
					{
						return columns[index]->dropdownPopup;
					}
				}

				GuiListViewColumnHeader::ColumnSortingState ListViewItemProvider::GetSortingState(vint index)
				{
					if(index<0 || index>=columns.Count())
					{
						return GuiListViewColumnHeader::NotSorted;
					}
					else
					{
						return columns[index]->sortingState;
					}
				}

				ListViewItemProvider::ListViewItemProvider()
				{
					columns.itemProvider=this;
					dataColumns.itemProvider=this;
				}

				ListViewItemProvider::~ListViewItemProvider()
				{
				}

				IDescriptable* ListViewItemProvider::RequestView(const WString& identifier)
				{
					if(identifier==ListViewItemStyleProvider::IListViewItemView::Identifier)
					{
						return (ListViewItemStyleProvider::IListViewItemView*)this;
					}
					else if(identifier==ListViewColumnItemArranger::IColumnItemView::Identifier)
					{
						return (ListViewColumnItemArranger::IColumnItemView*)this;
					}
					else if(identifier==GuiListControl::IItemPrimaryTextView::Identifier)
					{
						return (GuiListControl::IItemPrimaryTextView*)this;
					}
					else
					{
						return 0;
					}
				}

				void ListViewItemProvider::ReleaseView(IDescriptable* view)
				{
				}

				ListViewDataColumns& ListViewItemProvider::GetDataColumns()
				{
					return dataColumns;
				}

				ListViewColumns& ListViewItemProvider::GetColumns()
				{
					return columns;
				}
			}

/***********************************************************************
GuiListView
***********************************************************************/

			GuiVirtualListView::GuiVirtualListView(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider)
				:GuiListViewBase(_styleProvider, _itemProvider)
			{
				ChangeItemStyle(new list::ListViewBigIconContentProvider);
			}

			GuiVirtualListView::~GuiVirtualListView()
			{
			}

			void GuiVirtualListView::ChangeItemStyle(list::ListViewItemStyleProvider::IListViewItemContentProvider* contentProvider)
			{
				SetStyleProvider(0);
				SetArranger(0);
				SetCoordinateTransformer(contentProvider->CreatePreferredCoordinateTransformer());
				SetStyleProvider(new list::ListViewItemStyleProvider(contentProvider));
				SetArranger(contentProvider->CreatePreferredArranger());
			}

/***********************************************************************
GuiListView
***********************************************************************/

			GuiListView::GuiListView(IStyleProvider* _styleProvider)
				:GuiVirtualListView(_styleProvider, new list::ListViewItemProvider)
			{
				items=dynamic_cast<list::ListViewItemProvider*>(itemProvider.Obj());
			}

			GuiListView::~GuiListView()
			{
			}

			list::ListViewItemProvider& GuiListView::GetItems()
			{
				return *items;
			}
		}
	}
}

/***********************************************************************
Controls\ListControlPackage\GuiTextListControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;

			namespace list
			{

/***********************************************************************
TextItemStyleProvider::TextItemStyleController
***********************************************************************/

				void TextItemStyleProvider::TextItemStyleController::OnBulletSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
				{
					textItemStyleProvider->OnStyleCheckedChanged(this);
				}

				TextItemStyleProvider::TextItemStyleController::TextItemStyleController(TextItemStyleProvider* provider)
					:ItemStyleControllerBase(provider, 0)
					,backgroundButton(0)
					,bulletButton(0)
					,textElement(0)
					,textItemStyleProvider(provider)
				{
					backgroundButton=new GuiSelectableButton(textItemStyleProvider->textItemStyleProvider->CreateBackgroundStyleController());
					backgroundButton->SetAutoSelection(false);
					
					textElement=GuiSolidLabelElement::Create();
					textElement->SetAlignments(Alignment::Left, Alignment::Center);
					textElement->SetFont(backgroundButton->GetFont());

					GuiBoundsComposition* textComposition=new GuiBoundsComposition;
					textComposition->SetOwnedElement(textElement);
					textComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);

					GuiSelectableButton::IStyleController* bulletStyleController=textItemStyleProvider->textItemStyleProvider->CreateBulletStyleController();
					if(bulletStyleController)
					{
						bulletButton=new GuiSelectableButton(bulletStyleController);
						bulletButton->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
						bulletButton->SelectedChanged.AttachMethod(this, &TextItemStyleController::OnBulletSelectedChanged);

						GuiTableComposition* table=new GuiTableComposition;
						backgroundButton->GetContainerComposition()->AddChild(table);
						table->SetAlignmentToParent(Margin(0, 0, 0, 0));
						table->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
						table->SetRowsAndColumns(1, 2);
						table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
						table->SetColumnOption(0, GuiCellOption::MinSizeOption());
						table->SetColumnOption(1, GuiCellOption::PercentageOption(1.0));
						{
							GuiCellComposition* cell=new GuiCellComposition;
							table->AddChild(cell);
							cell->SetSite(0, 0, 1, 1);
							cell->AddChild(bulletButton->GetBoundsComposition());
						}
						{
							GuiCellComposition* cell=new GuiCellComposition;
							table->AddChild(cell);
							cell->SetSite(0, 1, 1, 1);
							cell->AddChild(textComposition);
							textComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
						}
					}
					else
					{
						backgroundButton->GetContainerComposition()->AddChild(textComposition);
						textComposition->SetAlignmentToParent(Margin(5, 0, 0, 0));
					}
					Initialize(backgroundButton->GetBoundsComposition(), backgroundButton);
				}

				TextItemStyleProvider::TextItemStyleController::~TextItemStyleController()
				{
				}

				bool TextItemStyleProvider::TextItemStyleController::GetSelected()
				{
					return backgroundButton->GetSelected();
				}

				void TextItemStyleProvider::TextItemStyleController::SetSelected(bool value)
				{
					backgroundButton->SetSelected(value);
				}

				bool TextItemStyleProvider::TextItemStyleController::GetChecked()
				{
					return bulletButton?bulletButton->GetSelected():false;
				}

				void TextItemStyleProvider::TextItemStyleController::SetChecked(bool value)
				{
					if(bulletButton) bulletButton->SetSelected(value);
				}
				
				const WString& TextItemStyleProvider::TextItemStyleController::GetText()
				{
					return textElement->GetText();
				}

				void TextItemStyleProvider::TextItemStyleController::SetText(const WString& value)
				{
					textElement->SetText(value);
				}

/***********************************************************************
TextItemStyleProvider
***********************************************************************/

				const wchar_t* const TextItemStyleProvider::ITextItemView::Identifier = L"vl::presentation::controls::list::TextItemStyleProvider::ITextItemView";

				void TextItemStyleProvider::OnStyleCheckedChanged(TextItemStyleController* style)
				{
					vint index=listControl->GetArranger()->GetVisibleIndex(style);
					if(index!=-1)
					{
						textItemView->SetCheckedSilently(index, style->GetChecked());
					}
				}

				TextItemStyleProvider::TextItemStyleProvider(ITextItemStyleProvider* _textItemStyleProvider)
					:textItemStyleProvider(_textItemStyleProvider)
					,textItemView(0)
					,listControl(0)
				{
				}

				TextItemStyleProvider::~TextItemStyleProvider()
				{
				}

				void TextItemStyleProvider::AttachListControl(GuiListControl* value)
				{
					listControl=value;;
					textItemView=dynamic_cast<ITextItemView*>(value->GetItemProvider()->RequestView(ITextItemView::Identifier));
				}

				void TextItemStyleProvider::DetachListControl()
				{
					listControl->GetItemProvider()->ReleaseView(textItemView);
					textItemView=0;
					listControl=0;
				}

				vint TextItemStyleProvider::GetItemStyleId(vint itemIndex)
				{
					return 0;
				}

				GuiListControl::IItemStyleController* TextItemStyleProvider::CreateItemStyle(vint styleId)
				{
					return new TextItemStyleController(this);
				}

				void TextItemStyleProvider::DestroyItemStyle(GuiListControl::IItemStyleController* style)
				{
					delete dynamic_cast<TextItemStyleController*>(style);
				}

				void TextItemStyleProvider::Install(GuiListControl::IItemStyleController* style, vint itemIndex)
				{
					TextItemStyleController* textStyle=dynamic_cast<TextItemStyleController*>(style);
					textStyle->SetText(textItemView->GetText(itemIndex));
					textStyle->SetChecked(textItemView->GetChecked(itemIndex));
				}

				void TextItemStyleProvider::SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)
				{
					TextItemStyleController* textStyle=dynamic_cast<TextItemStyleController*>(style);
					textStyle->SetSelected(value);
				}

/***********************************************************************
TextItem
***********************************************************************/

				TextItem::TextItem()
					:checked(false)
				{
				}

				TextItem::TextItem(const TextItem& item)
					:text(item.text)
					,checked(item.checked)
				{
				}

				TextItem::TextItem(const WString& _text, bool _checked)
					:text(_text)
					,checked(_checked)
				{
				}

				TextItem::TextItem(const wchar_t* _text, bool _checked)
					:text(_text)
					,checked(_checked)
				{
				}

				TextItem::~TextItem()
				{
				}

				bool TextItem::operator==(const TextItem& value)const
				{
					return text==value.text;
				}

				bool TextItem::operator!=(const TextItem& value)const
				{
					return text!=value.text;
				}

				const WString& TextItem::GetText()const
				{
					return text;
				}

				bool TextItem::GetChecked()const
				{
					return checked;
				}

/***********************************************************************
TextItemProvider
***********************************************************************/

				bool TextItemProvider::ContainsPrimaryText(vint itemIndex)
				{
					return true;
				}

				WString TextItemProvider::GetPrimaryTextViewText(vint itemIndex)
				{
					return Get(itemIndex).GetText();
				}
				
				WString TextItemProvider::GetText(vint itemIndex)
				{
					return Get(itemIndex).GetText();
				}

				bool TextItemProvider::GetChecked(vint itemIndex)
				{
					return Get(itemIndex).GetChecked();
				}

				void TextItemProvider::SetCheckedSilently(vint itemIndex, bool value)
				{
					items[itemIndex].checked=value;
				}

				TextItemProvider::TextItemProvider()
				{
				}

				TextItemProvider::~TextItemProvider()
				{
				}
					
				void TextItemProvider::SetText(vint itemIndex, const WString& value)
				{
					items[itemIndex].text=value;
					InvokeOnItemModified(itemIndex, 1, 1);
				}

				void TextItemProvider::SetChecked(vint itemIndex, bool value)
				{
					SetCheckedSilently(itemIndex, value);
					InvokeOnItemModified(itemIndex, 1, 1);
				}

				IDescriptable* TextItemProvider::RequestView(const WString& identifier)
				{
					if(identifier==TextItemStyleProvider::ITextItemView::Identifier)
					{
						return (TextItemStyleProvider::ITextItemView*)this;
					}
					else if(identifier==GuiListControl::IItemPrimaryTextView::Identifier)
					{
						return (GuiListControl::IItemPrimaryTextView*)this;
					}
					else
					{
						return 0;
					}
				}

				void TextItemProvider::ReleaseView(IDescriptable* view)
				{
				}
			}

/***********************************************************************
GuiTextList
***********************************************************************/

			GuiVirtualTextList::GuiVirtualTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider, GuiListControl::IItemProvider* _itemProvider)
				:GuiSelectableListControl(_styleProvider, _itemProvider)
			{
				ChangeItemStyle(_itemStyleProvider);
				SetArranger(new list::FixedHeightItemArranger);
			}

			GuiVirtualTextList::~GuiVirtualTextList()
			{
			}

			Ptr<GuiListControl::IItemStyleProvider> GuiVirtualTextList::SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)
			{
				if(value.Cast<list::TextItemStyleProvider>())
				{
					return GuiSelectableListControl::SetStyleProvider(value);
				}
				else
				{
					return 0;
				}
			}

			Ptr<GuiListControl::IItemStyleProvider> GuiVirtualTextList::ChangeItemStyle(list::TextItemStyleProvider::ITextItemStyleProvider* itemStyleProvider)
			{
				if(itemStyleProvider)
				{
					return SetStyleProvider(new list::TextItemStyleProvider(itemStyleProvider));
				}
				else
				{
					return 0;
				}
			}

/***********************************************************************
GuiTextList
***********************************************************************/

			GuiTextList::GuiTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider)
				:GuiVirtualTextList(_styleProvider, _itemStyleProvider, new list::TextItemProvider)
			{
				items=dynamic_cast<list::TextItemProvider*>(itemProvider.Obj());
			}

			GuiTextList::~GuiTextList()
			{
			}

			list::TextItemProvider& GuiTextList::GetItems()
			{
				return *items;
			}
		}
	}
}

/***********************************************************************
Controls\ListControlPackage\GuiTreeViewControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace compositions;

			namespace tree
			{
				const wchar_t* const INodeItemView::Identifier = L"vl::presentation::controls::tree::INodeItemView";
				const wchar_t* const INodeItemPrimaryTextView::Identifier = L"vl::presentation:;cotnrols::tree::INodeItemPrimaryTextView";

/***********************************************************************
NodeItemProvider
***********************************************************************/

				INodeProvider* NodeItemProvider::GetNodeByOffset(INodeProvider* provider, vint offset)
				{
					if(offset==0) return provider;
					INodeProvider* result=0;
					if(provider->GetExpanding() && offset>0)
					{
						offset-=1;
						vint count=provider->GetChildCount();
						for(vint i=0;(!result && i<count);i++)
						{
							INodeProvider* child=provider->GetChild(i);
							vint visibleCount=child->CalculateTotalVisibleNodes();
							if(offset<visibleCount)
							{
								result=GetNodeByOffset(child, offset);
							}
							else
							{
								offset-=visibleCount;
							}
						}
					}
					ReleaseNode(provider);
					return result;
				}

				void NodeItemProvider::OnAttached(INodeRootProvider* provider)
				{
				}

				void NodeItemProvider::OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)
				{
					offsetBeforeChildModified=0;
					vint base=CalculateNodeVisibilityIndexInternal(parentNode);
					if(base!=-2 && parentNode->GetExpanding())
					{
						for(vint i=0;i<count;i++)
						{
							INodeProvider* child=parentNode->GetChild(start+i);
							offsetBeforeChildModified+=child->CalculateTotalVisibleNodes();
							child->Release();
						}
					}
				}

				void NodeItemProvider::OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)
				{
					vint base=CalculateNodeVisibilityIndexInternal(parentNode);
					if(base!=-2 && parentNode->GetExpanding())
					{
						vint offset=0;
						vint firstChildStart=-1;
						for(vint i=0;i<newCount;i++)
						{
							INodeProvider* child=parentNode->GetChild(start+i);
							if(i==0)
							{
								firstChildStart=CalculateNodeVisibilityIndexInternal(child);
							}
							offset+=child->CalculateTotalVisibleNodes();
							child->Release();
						}

						if(firstChildStart==-1)
						{
							vint childCount=parentNode->GetChildCount();
							if(childCount==0)
							{
								firstChildStart=base+1;
							}
							else if(start<childCount)
							{
								INodeProvider* child=parentNode->GetChild(start);
								firstChildStart=CalculateNodeVisibilityIndexInternal(child);
								child->Release();
							}
							else
							{
								INodeProvider* child=parentNode->GetChild(start-1);
								firstChildStart=CalculateNodeVisibilityIndexInternal(child);
								firstChildStart+=child->CalculateTotalVisibleNodes();
								child->Release();
							}
						}
						InvokeOnItemModified(firstChildStart, offsetBeforeChildModified, offset);
					}
				}

				void NodeItemProvider::OnItemExpanded(INodeProvider* node)
				{
					vint base=CalculateNodeVisibilityIndexInternal(node);
					if(base!=-2)
					{
						vint visibility=node->CalculateTotalVisibleNodes();
						InvokeOnItemModified(base+1, 0, visibility-1);
					}
				}

				void NodeItemProvider::OnItemCollapsed(INodeProvider* node)
				{
					vint base=CalculateNodeVisibilityIndexInternal(node);
					if(base!=-2)
					{
						vint visibility=0;
						vint count=node->GetChildCount();
						for(vint i=0;i<count;i++)
						{
							INodeProvider* child=node->GetChild(i);
							visibility+=child->CalculateTotalVisibleNodes();
							child->Release();
						}
						InvokeOnItemModified(base+1, visibility, 0);
					}
				}

				vint NodeItemProvider::CalculateNodeVisibilityIndexInternal(INodeProvider* node)
				{
					INodeProvider* parent=node->GetParent();
					if(parent==0)
					{
						return -1;
					}
					if(!parent->GetExpanding())
					{
						return -2;
					}

					vint index=CalculateNodeVisibilityIndexInternal(parent);
					if(index==-2)
					{
						return -2;
					}

					vint count=parent->GetChildCount();
					for(vint i=0;i<count;i++)
					{
						INodeProvider* child=parent->GetChild(i);
						bool findResult=child==node;
						if(findResult)
						{
							index++;
						}
						else
						{
							index+=child->CalculateTotalVisibleNodes();
						}
						child->Release();
						if(findResult)
						{
							return index;
						}
					}
					return -1;
				}

				vint NodeItemProvider::CalculateNodeVisibilityIndex(INodeProvider* node)
				{
					vint result=CalculateNodeVisibilityIndexInternal(node);
					return result<0?-1:result;
				}

				bool NodeItemProvider::ContainsPrimaryText(vint itemIndex)
				{
					if(nodeItemPrimaryTextView)
					{
						INodeProvider* node=RequestNode(itemIndex);
						if(node)
						{
							bool result=node->GetChildCount()==0;
							ReleaseNode(node);
							return result;
						}
					}
					return true;
				}

				WString NodeItemProvider::GetPrimaryTextViewText(vint itemIndex)
				{
					if(nodeItemPrimaryTextView)
					{
						INodeProvider* node=RequestNode(itemIndex);
						if(node)
						{
							WString result=nodeItemPrimaryTextView->GetPrimaryTextViewText(node);
							ReleaseNode(node);
							return result;
						}
					}
					return L"";
				}

				INodeProvider* NodeItemProvider::RequestNode(vint index)
				{
					if(root->CanGetNodeByVisibleIndex())
					{
						return root->GetNodeByVisibleIndex(index+1);
					}
					else
					{
						return GetNodeByOffset(root->GetRootNode(), index+1);
					}
				}

				void NodeItemProvider::ReleaseNode(INodeProvider* node)
				{
					if(node)
					{
						node->Release();
					}
				}

				NodeItemProvider::NodeItemProvider(INodeRootProvider* _root)
					:root(_root)
				{
					root->AttachCallback(this);
					nodeItemPrimaryTextView=dynamic_cast<INodeItemPrimaryTextView*>(root->RequestView(INodeItemPrimaryTextView::Identifier));
				}

				NodeItemProvider::~NodeItemProvider()
				{
					if(nodeItemPrimaryTextView)
					{
						root->ReleaseView(nodeItemPrimaryTextView);
					}
					root->DetachCallback(this);
				}

				Ptr<INodeRootProvider> NodeItemProvider::GetRoot()
				{
					return root;
				}

				vint NodeItemProvider::Count()
				{
					return root->GetRootNode()->CalculateTotalVisibleNodes()-1;
				}

				IDescriptable* NodeItemProvider::RequestView(const WString& identifier)
				{
					if(identifier==INodeItemView::Identifier)
					{
						return (INodeItemView*)this;
					}
					else if(identifier==GuiListControl::IItemPrimaryTextView::Identifier)
					{
						return (GuiListControl::IItemPrimaryTextView*)this;
					}
					else
					{
						return root->RequestView(identifier);
					}
				}

				void NodeItemProvider::ReleaseView(IDescriptable* view)
				{
					if(dynamic_cast<INodeItemView*>(view)==0)
					{
						root->ReleaseView(view);
					}
				}

/***********************************************************************
NodeItemProvider
***********************************************************************/

				NodeItemStyleProvider::NodeItemStyleProvider(Ptr<INodeItemStyleProvider> provider)
					:nodeItemStyleProvider(provider)
					,listControl(0)
					,nodeItemView(0)
				{
					nodeItemStyleProvider->BindItemStyleProvider(this);
				}

				NodeItemStyleProvider::~NodeItemStyleProvider()
				{
				}

				void NodeItemStyleProvider::AttachListControl(GuiListControl* value)
				{
					listControl=value;
					nodeItemView=dynamic_cast<INodeItemView*>(listControl->GetItemProvider()->RequestView(INodeItemView::Identifier));
					nodeItemStyleProvider->AttachListControl(value);
				}

				void NodeItemStyleProvider::DetachListControl()
				{
					nodeItemStyleProvider->DetachListControl();
					if(nodeItemView)
					{
						listControl->GetItemProvider()->ReleaseView(nodeItemView);
						nodeItemView=0;
					}
					listControl=0;
				}

				vint NodeItemStyleProvider::GetItemStyleId(vint itemIndex)
				{
					vint result=-1;
					if(nodeItemView)
					{
						INodeProvider* node=nodeItemView->RequestNode(itemIndex);
						if(node)
						{
							result=nodeItemStyleProvider->GetItemStyleId(node);
							nodeItemView->ReleaseNode(node);
						}
					}
					return result;
				}

				GuiListControl::IItemStyleController* NodeItemStyleProvider::CreateItemStyle(vint styleId)
				{
					return nodeItemStyleProvider->CreateItemStyle(styleId);
				}

				void NodeItemStyleProvider::DestroyItemStyle(GuiListControl::IItemStyleController* style)
				{
					INodeItemStyleController* nodeStyle=dynamic_cast<INodeItemStyleController*>(style);
					if(nodeStyle)
					{
						nodeItemStyleProvider->DestroyItemStyle(nodeStyle);
					}
				}

				void NodeItemStyleProvider::Install(GuiListControl::IItemStyleController* style, vint itemIndex)
				{
					if(nodeItemView)
					{
						INodeItemStyleController* nodeStyle=dynamic_cast<INodeItemStyleController*>(style);
						if(nodeStyle)
						{
							INodeProvider* node=nodeItemView->RequestNode(itemIndex);
							if(node)
							{
								nodeItemStyleProvider->Install(nodeStyle, node);
							}
						}
					}
				}

				void NodeItemStyleProvider::SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)
				{
					if(nodeItemView)
					{
						INodeItemStyleController* nodeStyle=dynamic_cast<INodeItemStyleController*>(style);
						if(nodeStyle)
						{
							nodeItemStyleProvider->SetStyleSelected(nodeStyle, value);
						}
					}
				}

/***********************************************************************
MemoryNodeProvider::NodeCollection
***********************************************************************/

				void MemoryNodeProvider::NodeCollection::OnBeforeChildModified(vint start, vint count, vint newCount)
				{
					ownerProvider->offsetBeforeChildModified=0;
					if(ownerProvider->expanding)
					{
						for(vint i=0;i<count;i++)
						{
							ownerProvider->offsetBeforeChildModified+=items[start+i]->totalVisibleNodeCount;
						}
					}
					INodeProviderCallback* proxy=ownerProvider->GetCallbackProxyInternal();
					if(proxy)
					{
						proxy->OnBeforeItemModified(ownerProvider, start, count, newCount);
					}
				}

				void MemoryNodeProvider::NodeCollection::OnAfterChildModified(vint start, vint count, vint newCount)
				{
					ownerProvider->childCount+=(newCount-count);
					if(ownerProvider->expanding)
					{
						vint offset=0;
						for(vint i=0;i<newCount;i++)
						{
							offset+=items[start+i]->totalVisibleNodeCount;
						}
						ownerProvider->OnChildTotalVisibleNodesChanged(offset-ownerProvider->offsetBeforeChildModified);
					}
					INodeProviderCallback* proxy=ownerProvider->GetCallbackProxyInternal();
					if(proxy)
					{
						proxy->OnAfterItemModified(ownerProvider, start, count, newCount);
					}
				}

				bool MemoryNodeProvider::NodeCollection::InsertInternal(vint index, Ptr<MemoryNodeProvider> const& child)
				{
					if(child->parent==0)
					{
						OnBeforeChildModified(index, 0, 1);
						child->parent=ownerProvider;
						items.Insert(index, child);
						OnAfterChildModified(index, 0, 1);
						return true;
					}
					return false;
				}

				bool MemoryNodeProvider::NodeCollection::RemoveAtInternal(vint index, Ptr<MemoryNodeProvider> const& child)
				{
					if(child->parent==ownerProvider)
					{
						OnBeforeChildModified(index, 1, 0);
						child->parent=0;
						items.RemoveAt(index);
						OnAfterChildModified(index, 1, 0);
						return true;
					}
					return false;
				}

				MemoryNodeProvider::NodeCollection::NodeCollection()
					:ownerProvider(0)
				{
				}

/***********************************************************************
MemoryNodeProvider
***********************************************************************/

				INodeProviderCallback* MemoryNodeProvider::GetCallbackProxyInternal()
				{
					if(parent)
					{
						return parent->GetCallbackProxyInternal();
					}
					else
					{
						return 0;
					}
				}

				void MemoryNodeProvider::OnChildTotalVisibleNodesChanged(vint offset)
				{
					totalVisibleNodeCount+=offset;
					if(parent)
					{
						parent->OnChildTotalVisibleNodesChanged(offset);
					}
				}

				MemoryNodeProvider::MemoryNodeProvider()
					:parent(0)
					,expanding(false)
					,childCount(0)
					,totalVisibleNodeCount(1)
					,offsetBeforeChildModified(0)
				{
					children.ownerProvider=this;
				}

				MemoryNodeProvider::MemoryNodeProvider(const Ptr<DescriptableObject>& _data)
					:parent(0)
					,expanding(false)
					,childCount(0)
					,totalVisibleNodeCount(1)
					,offsetBeforeChildModified(0)
					,data(_data)
				{
					children.ownerProvider=this;
				}

				MemoryNodeProvider::~MemoryNodeProvider()
				{
				}

				Ptr<DescriptableObject> MemoryNodeProvider::GetData()
				{
					return data;
				}

				void MemoryNodeProvider::SetData(const Ptr<DescriptableObject>& value)
				{
					data=value;
					NotifyDataModified();
				}

				void MemoryNodeProvider::NotifyDataModified()
				{
					if(parent)
					{
						vint index=parent->children.IndexOf(this);
						INodeProviderCallback* proxy=GetCallbackProxyInternal();
						if(proxy)
						{
							proxy->OnBeforeItemModified(parent, index, 1, 1);
							proxy->OnAfterItemModified(parent, index, 1, 1);
						}
					}
				}

				MemoryNodeProvider::NodeCollection& MemoryNodeProvider::Children()
				{
					return children;
				}

				bool MemoryNodeProvider::GetExpanding()
				{
					return expanding;
				}

				void MemoryNodeProvider::SetExpanding(bool value)
				{
					if(expanding!=value)
					{
						expanding=value;
						vint offset=0;
						for(vint i=0;i<childCount;i++)
						{
							offset+=children[i]->totalVisibleNodeCount;
						}

						OnChildTotalVisibleNodesChanged(expanding?offset:-offset);
						INodeProviderCallback* proxy=GetCallbackProxyInternal();
						if(proxy)
						{
							if(expanding)
							{
								proxy->OnItemExpanded(this);
							}
							else
							{
								proxy->OnItemCollapsed(this);
							}
						}
					}
				}

				vint MemoryNodeProvider::CalculateTotalVisibleNodes()
				{
					return totalVisibleNodeCount;
				}

				vint MemoryNodeProvider::GetChildCount()
				{
					return childCount;
				}

				INodeProvider* MemoryNodeProvider::GetParent()
				{
					return parent;
				}

				INodeProvider* MemoryNodeProvider::GetChild(vint index)
				{
					if(0<=index && index<childCount)
					{
						return children[index].Obj();
					}
					else
					{
						return 0;
					}
				}

				void MemoryNodeProvider::Increase()
				{
				}

				void MemoryNodeProvider::Release()
				{
				}

/***********************************************************************
NodeRootProviderBase
***********************************************************************/

				void NodeRootProviderBase::OnAttached(INodeRootProvider* provider)
				{
				}

				void NodeRootProviderBase::OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)
				{
					for(vint i=0;i<callbacks.Count();i++)
					{
						callbacks[i]->OnBeforeItemModified(parentNode, start, count, newCount);
					}
				}

				void NodeRootProviderBase::OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)
				{
					for(vint i=0;i<callbacks.Count();i++)
					{
						callbacks[i]->OnAfterItemModified(parentNode, start, count, newCount);
					}
				}

				void NodeRootProviderBase::OnItemExpanded(INodeProvider* node)
				{
					for(vint i=0;i<callbacks.Count();i++)
					{
						callbacks[i]->OnItemExpanded(node);
					}
				}

				void NodeRootProviderBase::OnItemCollapsed(INodeProvider* node)
				{
					for(vint i=0;i<callbacks.Count();i++)
					{
						callbacks[i]->OnItemCollapsed(node);
					}
				}

				NodeRootProviderBase::NodeRootProviderBase()
				{
				}

				NodeRootProviderBase::~NodeRootProviderBase()
				{
				}

				bool NodeRootProviderBase::CanGetNodeByVisibleIndex()
				{
					return false;
				}

				INodeProvider* NodeRootProviderBase::GetNodeByVisibleIndex(vint index)
				{
					return 0;
				}

				bool NodeRootProviderBase::AttachCallback(INodeProviderCallback* value)
				{
					if(callbacks.Contains(value))
					{
						return false;
					}
					else
					{
						callbacks.Add(value);
						value->OnAttached(this);
						return true;
					}
				}

				bool NodeRootProviderBase::DetachCallback(INodeProviderCallback* value)
				{
					vint index=callbacks.IndexOf(value);
					if(index==-1)
					{
						return false;
					}
					else
					{
						value->OnAttached(0);
						callbacks.Remove(value);
						return true;
					}
				}

				IDescriptable* NodeRootProviderBase::RequestView(const WString& identifier)
				{
					return 0;
				}

				void NodeRootProviderBase::ReleaseView(IDescriptable* view)
				{
				}

/***********************************************************************
MemoryNodeRootProvider
***********************************************************************/

				INodeProviderCallback* MemoryNodeRootProvider::GetCallbackProxyInternal()
				{
					return this;
				}

				MemoryNodeRootProvider::MemoryNodeRootProvider()
				{
					SetExpanding(true);
				}

				MemoryNodeRootProvider::~MemoryNodeRootProvider()
				{
				}

				INodeProvider* MemoryNodeRootProvider::GetRootNode()
				{
					return this;
				}

				MemoryNodeProvider* MemoryNodeRootProvider::GetMemoryNode(INodeProvider* node)
				{
					return dynamic_cast<MemoryNodeProvider*>(node);
				}
			}

/***********************************************************************
GuiVirtualTreeListControl
***********************************************************************/

			void GuiVirtualTreeListControl::OnAttached(tree::INodeRootProvider* provider)
			{
			}

			void GuiVirtualTreeListControl::OnBeforeItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)
			{
			}

			void GuiVirtualTreeListControl::OnAfterItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)
			{
			}

			void GuiVirtualTreeListControl::OnItemExpanded(tree::INodeProvider* node)
			{
				GuiNodeEventArgs arguments;
				(GuiEventArgs&)arguments=GetNotifyEventArguments();
				arguments.node=node;
				NodeExpanded.Execute(arguments);
			}

			void GuiVirtualTreeListControl::OnItemCollapsed(tree::INodeProvider* node)
			{
				GuiNodeEventArgs arguments;
				(GuiEventArgs&)arguments=GetNotifyEventArguments();
				arguments.node=node;
				NodeCollapsed.Execute(arguments);
			}

			void GuiVirtualTreeListControl::OnItemMouseEvent(compositions::GuiNodeMouseEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments)
			{
				tree::INodeProvider* node=GetNodeItemView()->RequestNode(arguments.itemIndex);
				if(node)
				{
					GuiNodeMouseEventArgs redirectArguments;
					(GuiMouseEventArgs&)redirectArguments=arguments;
					redirectArguments.node=node;
					nodeEvent.Execute(redirectArguments);
					(GuiMouseEventArgs&)arguments=redirectArguments;
					GetNodeItemView()->ReleaseNode(node);
				}
			}

			void GuiVirtualTreeListControl::OnItemNotifyEvent(compositions::GuiNodeNotifyEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments)
			{
				tree::INodeProvider* node=GetNodeItemView()->RequestNode(arguments.itemIndex);
				if(node)
				{
					GuiNodeEventArgs redirectArguments;
					(GuiEventArgs&)redirectArguments=arguments;
					redirectArguments.node=node;
					nodeEvent.Execute(redirectArguments);
					(GuiEventArgs&)arguments=redirectArguments;
					GetNodeItemView()->ReleaseNode(node);
				}
			}

#define ATTACH_ITEM_MOUSE_EVENT(NODEEVENTNAME, ITEMEVENTNAME)\
					{\
						Func<void(GuiNodeMouseEvent&, GuiGraphicsComposition*, GuiItemMouseEventArgs&)> func(this, &GuiVirtualTreeListControl::OnItemMouseEvent);\
						ITEMEVENTNAME.AttachFunction(Curry(func)(NODEEVENTNAME));\
					}\

#define ATTACH_ITEM_NOTIFY_EVENT(NODEEVENTNAME, ITEMEVENTNAME)\
					{\
						Func<void(GuiNodeNotifyEvent&, GuiGraphicsComposition*, GuiItemEventArgs&)> func(this, &GuiVirtualTreeListControl::OnItemNotifyEvent);\
						ITEMEVENTNAME.AttachFunction(Curry(func)(NODEEVENTNAME));\
					}\

			GuiVirtualTreeListControl::GuiVirtualTreeListControl(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider)
				:GuiSelectableListControl(_styleProvider, new tree::NodeItemProvider(_nodeRootProvider))
			{
				nodeItemProvider=dynamic_cast<tree::NodeItemProvider*>(GetItemProvider());
				nodeItemView=dynamic_cast<tree::INodeItemView*>(GetItemProvider()->RequestView(tree::INodeItemView::Identifier));
				
				NodeLeftButtonDown.SetAssociatedComposition(boundsComposition);
				NodeLeftButtonUp.SetAssociatedComposition(boundsComposition);
				NodeLeftButtonDoubleClick.SetAssociatedComposition(boundsComposition);
				NodeMiddleButtonDown.SetAssociatedComposition(boundsComposition);
				NodeMiddleButtonUp.SetAssociatedComposition(boundsComposition);
				NodeMiddleButtonDoubleClick.SetAssociatedComposition(boundsComposition);
				NodeRightButtonDown.SetAssociatedComposition(boundsComposition);
				NodeRightButtonUp.SetAssociatedComposition(boundsComposition);
				NodeRightButtonDoubleClick.SetAssociatedComposition(boundsComposition);
				NodeMouseMove.SetAssociatedComposition(boundsComposition);
				NodeMouseEnter.SetAssociatedComposition(boundsComposition);
				NodeMouseLeave.SetAssociatedComposition(boundsComposition);
				NodeExpanded.SetAssociatedComposition(boundsComposition);
				NodeCollapsed.SetAssociatedComposition(boundsComposition);

				ATTACH_ITEM_MOUSE_EVENT(NodeLeftButtonDown, ItemLeftButtonDown);
				ATTACH_ITEM_MOUSE_EVENT(NodeLeftButtonUp, ItemLeftButtonUp);
				ATTACH_ITEM_MOUSE_EVENT(NodeLeftButtonDoubleClick, ItemLeftButtonDoubleClick);
				ATTACH_ITEM_MOUSE_EVENT(NodeMiddleButtonDown, ItemMiddleButtonDown);
				ATTACH_ITEM_MOUSE_EVENT(NodeMiddleButtonUp, ItemMiddleButtonUp);
				ATTACH_ITEM_MOUSE_EVENT(NodeMiddleButtonDoubleClick, ItemMiddleButtonDoubleClick);
				ATTACH_ITEM_MOUSE_EVENT(NodeRightButtonDown, ItemRightButtonDown);
				ATTACH_ITEM_MOUSE_EVENT(NodeRightButtonUp, ItemRightButtonUp);
				ATTACH_ITEM_MOUSE_EVENT(NodeRightButtonDoubleClick, ItemRightButtonDoubleClick);
				ATTACH_ITEM_MOUSE_EVENT(NodeMouseMove, ItemMouseMove);
				ATTACH_ITEM_NOTIFY_EVENT(NodeMouseEnter, ItemMouseEnter);
				ATTACH_ITEM_NOTIFY_EVENT(NodeMouseLeave, ItemMouseLeave);

				nodeItemProvider->GetRoot()->AttachCallback(this);
			}

#undef ATTACH_ITEM_MOUSE_EVENT
#undef ATTACH_ITEM_NOTIFY_EVENT

			GuiVirtualTreeListControl::~GuiVirtualTreeListControl()
			{
				GetItemProvider()->ReleaseView(nodeItemView);
			}

			tree::INodeItemView* GuiVirtualTreeListControl::GetNodeItemView()
			{
				return nodeItemView;
			}

			tree::INodeRootProvider* GuiVirtualTreeListControl::GetNodeRootProvider()
			{
				return nodeItemProvider->GetRoot().Obj();
			}

			tree::INodeItemStyleProvider* GuiVirtualTreeListControl::GetNodeStyleProvider()
			{
				return nodeStyleProvider.Obj();
			}

			Ptr<tree::INodeItemStyleProvider> GuiVirtualTreeListControl::SetNodeStyleProvider(Ptr<tree::INodeItemStyleProvider> styleProvider)
			{
				Ptr<tree::INodeItemStyleProvider> old=nodeStyleProvider;
				nodeStyleProvider=styleProvider;
				GuiSelectableListControl::SetStyleProvider(new tree::NodeItemStyleProvider(nodeStyleProvider));
				return old;
			}

			namespace tree
			{

/***********************************************************************
TreeViewItem
***********************************************************************/

				const wchar_t* const ITreeViewItemView::Identifier = L"vl::presentation::controls::tree::ITreeViewItemView";

				TreeViewItem::TreeViewItem()
				{
				}

				TreeViewItem::TreeViewItem(const Ptr<GuiImageData>& _image, const WString& _text)
					:image(_image)
					,text(_text)
				{
				}

/***********************************************************************
TreeViewItemRootProvider
***********************************************************************/

				WString TreeViewItemRootProvider::GetPrimaryTextViewText(INodeProvider* node)
				{
					return GetNodeText(node);
				}

				Ptr<GuiImageData> TreeViewItemRootProvider::GetNodeImage(INodeProvider* node)
				{
					MemoryNodeProvider* memoryNode=dynamic_cast<MemoryNodeProvider*>(node);
					if(memoryNode)
					{
						Ptr<TreeViewItem> data=memoryNode->GetData().Cast<TreeViewItem>();
						if(data)
						{
							return data->image;
						}
					}
					return 0;
				}

				WString	TreeViewItemRootProvider::GetNodeText(INodeProvider* node)
				{
					MemoryNodeProvider* memoryNode=dynamic_cast<MemoryNodeProvider*>(node);
					if(memoryNode)
					{
						Ptr<TreeViewItem> data=memoryNode->GetData().Cast<TreeViewItem>();
						if(data)
						{
							return data->text;
						}
					}
					return L"";
				}

				TreeViewItemRootProvider::TreeViewItemRootProvider()
				{
				}

				TreeViewItemRootProvider::~TreeViewItemRootProvider()
				{
				}

				IDescriptable* TreeViewItemRootProvider::RequestView(const WString& identifier)
				{
					if(identifier==ITreeViewItemView::Identifier)
					{
						return (ITreeViewItemView*)this;
					}
					else if(identifier==INodeItemPrimaryTextView::Identifier)
					{
						return (INodeItemPrimaryTextView*)this;
					}
					else
					{
						return MemoryNodeRootProvider::RequestView(identifier);
					}
				}

				void TreeViewItemRootProvider::ReleaseView(IDescriptable* view)
				{
					return MemoryNodeRootProvider::ReleaseView(view);
				}

				Ptr<TreeViewItem> TreeViewItemRootProvider::GetTreeViewData(INodeProvider* node)
				{
					Ptr<MemoryNodeProvider> memoryNode=GetMemoryNode(node);
					if(memoryNode)
					{
						return memoryNode->GetData().Cast<TreeViewItem>();
					}
					else
					{
						return 0;
					}
				}

				void TreeViewItemRootProvider::SetTreeViewData(INodeProvider* node, Ptr<TreeViewItem> value)
				{
					Ptr<MemoryNodeProvider> memoryNode=GetMemoryNode(node);
					if(memoryNode)
					{
						memoryNode->SetData(value);
					}
				}
				
				void TreeViewItemRootProvider::UpdateTreeViewData(INodeProvider* node)
				{
					Ptr<MemoryNodeProvider> memoryNode=GetMemoryNode(node);
					if(memoryNode)
					{
						memoryNode->NotifyDataModified();
					}
				}

/***********************************************************************
TreeViewNodeItemStyleProvider::ItemController
***********************************************************************/

				void TreeViewNodeItemStyleProvider::ItemController::SwitchNodeExpanding()
				{
					if(backgroundButton->GetBoundsComposition()->GetParent())
					{
						GuiListControl::IItemArranger* arranger=styleProvider->treeControl->GetArranger();
						vint index=arranger->GetVisibleIndex(this);
						if(index!=-1)
						{
							INodeItemView* view=styleProvider->treeControl->GetNodeItemView();
							INodeProvider* node=view->RequestNode(index);
							if(node)
							{
								bool expanding=node->GetExpanding();
								node->SetExpanding(!expanding);
								view->ReleaseNode(node);
							}
						}
					}
				}

				void TreeViewNodeItemStyleProvider::ItemController::OnBackgroundButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
				{
					if(backgroundButton->GetVisuallyEnabled())
					{
						SwitchNodeExpanding();
					}
				}

				void TreeViewNodeItemStyleProvider::ItemController::OnExpandingButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
				{
					arguments.handled=true;
				}

				void TreeViewNodeItemStyleProvider::ItemController::OnExpandingButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
				{
					if(expandingButton->GetVisuallyEnabled())
					{
						SwitchNodeExpanding();
					}
				}

				TreeViewNodeItemStyleProvider::ItemController::ItemController(TreeViewNodeItemStyleProvider* _styleProvider)
					:list::ItemStyleControllerBase(_styleProvider->GetBindedItemStyleProvider(), 0)
					,styleProvider(_styleProvider)
				{
					backgroundButton=new GuiSelectableButton(styleProvider->treeControl->GetTreeViewStyleProvider()->CreateItemBackground());
					backgroundButton->SetAutoSelection(false);
					backgroundButton->GetBoundsComposition()->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					backgroundButton->GetEventReceiver()->leftButtonDoubleClick.AttachMethod(this, &ItemController::OnBackgroundButtonDoubleClick);

					table=new GuiTableComposition;
					backgroundButton->GetBoundsComposition()->AddChild(table);
					table->SetRowsAndColumns(3, 4);
					table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
					table->SetRowOption(1, GuiCellOption::MinSizeOption());
					table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
					table->SetColumnOption(0, GuiCellOption::AbsoluteOption(0));
					table->SetColumnOption(1, GuiCellOption::MinSizeOption());
					table->SetColumnOption(2, GuiCellOption::MinSizeOption());
					table->SetColumnOption(3, GuiCellOption::MinSizeOption());
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetCellPadding(2);
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 3, 1);
						cell->SetPreferredMinSize(Size(16, 16));

						expandingButton=new GuiSelectableButton(styleProvider->treeControl->GetTreeViewStyleProvider()->CreateItemExpandingDecorator());
						expandingButton->SetAutoSelection(false);
						expandingButton->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
						expandingButton->GetEventReceiver()->leftButtonDoubleClick.AttachMethod(this, &ItemController::OnExpandingButtonDoubleClick);
						expandingButton->Clicked.AttachMethod(this, &ItemController::OnExpandingButtonClicked);
						cell->AddChild(expandingButton->GetBoundsComposition());
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(1, 2, 1, 1);
						cell->SetPreferredMinSize(Size(16, 16));

						image=GuiImageFrameElement::Create();
						image->SetStretch(true);
						cell->SetOwnedElement(image);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 3, 3, 1);
						cell->SetPreferredMinSize(Size(192, 0));

						text=GuiSolidLabelElement::Create();
						text->SetAlignments(Alignment::Left, Alignment::Center);
						text->SetFont(styleProvider->treeControl->GetFont());
						text->SetEllipse(true);
						cell->SetOwnedElement(text);
					}
					Initialize(backgroundButton->GetBoundsComposition(), backgroundButton);
				}

				INodeItemStyleProvider* TreeViewNodeItemStyleProvider::ItemController::GetNodeStyleProvider()
				{
					return styleProvider;
				}

				void TreeViewNodeItemStyleProvider::ItemController::Install(INodeProvider* node)
				{
					ITreeViewItemView* view=styleProvider->treeViewItemView;
					Ptr<GuiImageData> imageData=view->GetNodeImage(node);
					if(imageData)
					{
						image->SetImage(imageData->GetImage(), imageData->GetFrameIndex());
					}
					else
					{
						image->SetImage(0);
					}
					text->SetText(view->GetNodeText(node));
					text->SetColor(styleProvider->treeControl->GetTreeViewStyleProvider()->GetTextColor());
					UpdateExpandingButton(node);

					vint level=-2;
					while(node)
					{
						node=node->GetParent();
						level++;
					}
					table->SetColumnOption(0, GuiCellOption::AbsoluteOption(level*16));
				}

				bool TreeViewNodeItemStyleProvider::ItemController::GetSelected()
				{
					return backgroundButton->GetSelected();
				}

				void TreeViewNodeItemStyleProvider::ItemController::SetSelected(bool value)
				{
					backgroundButton->SetSelected(value);
				}

				void TreeViewNodeItemStyleProvider::ItemController::UpdateExpandingButton(INodeProvider* associatedNode)
				{
					expandingButton->SetSelected(associatedNode->GetExpanding());
					expandingButton->SetVisible(associatedNode->GetChildCount()>0);
				}

/***********************************************************************
TreeViewNodeItemStyleProvider
***********************************************************************/

				TreeViewNodeItemStyleProvider::TreeViewNodeItemStyleProvider()
					:treeControl(0)
					,bindedItemStyleProvider(0)
					,treeViewItemView(0)
				{
				}

				TreeViewNodeItemStyleProvider::~TreeViewNodeItemStyleProvider()
				{
				}

				TreeViewNodeItemStyleProvider::ItemController* TreeViewNodeItemStyleProvider::GetRelatedController(INodeProvider* node)
				{
					vint index=treeControl->GetNodeItemView()->CalculateNodeVisibilityIndex(node);
					if(index!=-1)
					{
						GuiListControl::IItemStyleController* style=treeControl->GetArranger()->GetVisibleStyle(index);
						if(style)
						{
							ItemController* itemController=dynamic_cast<ItemController*>(style);
							return itemController;
						}
					}
					return 0;
				}

				void TreeViewNodeItemStyleProvider::UpdateExpandingButton(INodeProvider* node)
				{
					ItemController* itemController=GetRelatedController(node);
					if(itemController)
					{
						itemController->UpdateExpandingButton(node);
					}
				}

				void TreeViewNodeItemStyleProvider::OnAttached(INodeRootProvider* provider)
				{
				}

				void TreeViewNodeItemStyleProvider::OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)
				{
				}

				void TreeViewNodeItemStyleProvider::OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)
				{
					UpdateExpandingButton(parentNode);
				}

				void TreeViewNodeItemStyleProvider::OnItemExpanded(INodeProvider* node)
				{
					UpdateExpandingButton(node);
				}

				void TreeViewNodeItemStyleProvider::OnItemCollapsed(INodeProvider* node)
				{
					UpdateExpandingButton(node);
				}

				void TreeViewNodeItemStyleProvider::BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)
				{
					bindedItemStyleProvider=styleProvider;
				}

				GuiListControl::IItemStyleProvider* TreeViewNodeItemStyleProvider::GetBindedItemStyleProvider()
				{
					return bindedItemStyleProvider;
				}

				void TreeViewNodeItemStyleProvider::AttachListControl(GuiListControl* value)
				{
					treeControl=dynamic_cast<GuiVirtualTreeView*>(value);
					if(treeControl)
					{
						treeViewItemView=dynamic_cast<ITreeViewItemView*>(treeControl->GetItemProvider()->RequestView(ITreeViewItemView::Identifier));
						treeControl->GetNodeRootProvider()->AttachCallback(this);
					}
				}

				void TreeViewNodeItemStyleProvider::DetachListControl()
				{
					if(treeViewItemView)
					{
						treeControl->GetItemProvider()->ReleaseView(treeViewItemView);
						treeViewItemView=0;
					}
					if(treeControl)
					{
						treeControl->GetNodeRootProvider()->DetachCallback(this);
						treeControl=0;
					}
				}

				vint TreeViewNodeItemStyleProvider::GetItemStyleId(INodeProvider* node)
				{
					return 0;
				}

				INodeItemStyleController* TreeViewNodeItemStyleProvider::CreateItemStyle(vint styleId)
				{
					return new ItemController(this);
				}

				void TreeViewNodeItemStyleProvider::DestroyItemStyle(INodeItemStyleController* style)
				{
					ItemController* itemController=dynamic_cast<ItemController*>(style);
					if(itemController)
					{
						delete itemController;
					}
				}

				void TreeViewNodeItemStyleProvider::Install(INodeItemStyleController* style, INodeProvider* node)
				{
					ItemController* itemController=dynamic_cast<ItemController*>(style);
					if(itemController)
					{
						itemController->Install(node);
					}
				}

				void TreeViewNodeItemStyleProvider::SetStyleSelected(INodeItemStyleController* style, bool value)
				{
					ItemController* itemController=dynamic_cast<ItemController*>(style);
					if(itemController)
					{
						itemController->SetSelected(value);
					}
				}
			}

/***********************************************************************
GuiVirtualTreeView
***********************************************************************/

			GuiVirtualTreeView::GuiVirtualTreeView(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider)
				:GuiVirtualTreeListControl(_styleProvider, _nodeRootProvider)
			{
				styleProvider=dynamic_cast<IStyleProvider*>(styleController->GetStyleProvider());
				SetNodeStyleProvider(new tree::TreeViewNodeItemStyleProvider);
				SetArranger(new list::FixedHeightItemArranger);
			}

			GuiVirtualTreeView::~GuiVirtualTreeView()
			{
			}

			GuiVirtualTreeView::IStyleProvider* GuiVirtualTreeView::GetTreeViewStyleProvider()
			{
				return styleProvider;
			}

/***********************************************************************
GuiTreeView
***********************************************************************/

			GuiTreeView::GuiTreeView(IStyleProvider* _styleProvider)
				:GuiVirtualTreeView(_styleProvider, new tree::TreeViewItemRootProvider)
			{
				nodes=nodeItemProvider->GetRoot().Cast<tree::TreeViewItemRootProvider>();
			}

			GuiTreeView::~GuiTreeView()
			{
			}

			Ptr<tree::TreeViewItemRootProvider> GuiTreeView::Nodes()
			{
				return nodes;
			}
		}
	}
}

/***********************************************************************
Controls\Styles\GuiCommonStyles.cpp
***********************************************************************/
#include <math.h>

namespace vl
{
	namespace presentation
	{
		namespace common_styles
		{
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
CommonScrollStyle
***********************************************************************/

			void CommonScrollStyle::UpdateHandle()
			{
				double handlePageSize=(double)pageSize/totalSize;
				double handleRatio=(double)position/totalSize;
				switch(direction)
				{
				case Horizontal:
					handleComposition->SetWidthRatio(handleRatio);
					handleComposition->SetWidthPageSize(handlePageSize);
					break;
				case Vertical:
					handleComposition->SetHeightRatio(handleRatio);
					handleComposition->SetHeightPageSize(handlePageSize);
					break;
				}
			}

			void CommonScrollStyle::OnDecreaseButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(commandExecutor)
				{
					commandExecutor->SmallDecrease();
				}
			}

			void CommonScrollStyle::OnIncreaseButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(commandExecutor)
				{
					commandExecutor->SmallIncrease();
				}
			}

			void CommonScrollStyle::OnHandleMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(commandExecutor && handleButton->GetVisuallyEnabled())
				{
					draggingHandle=true;
					draggingStartLocation=Point(arguments.x, arguments.y);
				}
			}

			void CommonScrollStyle::OnHandleMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(draggingHandle)
				{
					vint totalPixels=0;
					vint currentOffset=0;
					vint newOffset=0;
					switch(direction)
					{
					case Horizontal:
						totalPixels=handleComposition->GetParent()->GetBounds().Width();
						currentOffset=handleComposition->GetBounds().Left();
						newOffset=currentOffset+(arguments.x-draggingStartLocation.x);
						break;
					case Vertical:
						totalPixels=handleComposition->GetParent()->GetBounds().Height();
						currentOffset=handleComposition->GetBounds().Top();
						newOffset=currentOffset+(arguments.y-draggingStartLocation.y);
						break;
					}

					double ratio=(double)newOffset/totalPixels;
					vint newPosition=(vint)(ratio*totalSize);

					vint offset1=(vint)(((double)newPosition/totalSize)*totalPixels);
					vint offset2=vint(((double)(newPosition+1)/totalSize)*totalPixels);
					vint delta1=abs((int)(offset1-newOffset));
					vint delta2=abs((int)(offset2-newOffset));
					if(delta1<delta2)
					{
						commandExecutor->SetPosition(newPosition);
					}
					else
					{
						commandExecutor->SetPosition(newPosition+1);
					}
				}
			}

			void CommonScrollStyle::OnHandleMouseUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				draggingHandle=false;
			}

			void CommonScrollStyle::OnBigMoveMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(commandExecutor && handleButton->GetVisuallyEnabled())
				{
					if(arguments.eventSource==arguments.compositionSource)
					{
						Rect handleBounds=handleComposition->GetBounds();
						switch(direction)
						{
						case Horizontal:
							if(arguments.x<handleBounds.x1)
							{
								commandExecutor->BigDecrease();
							}
							else if(arguments.x>=handleBounds.x2)
							{
								commandExecutor->BigIncrease();
							}
							break;
						case Vertical:
							if(arguments.y<handleBounds.y1)
							{
								commandExecutor->BigDecrease();
							}
							else if(arguments.y>=handleBounds.y2)
							{
								commandExecutor->BigIncrease();
							}
							break;
						}
					}
				}
			}

			void CommonScrollStyle::BuildStyle(vint defaultSize, vint arrowSize)
			{
				boundsComposition=new GuiBoundsComposition;
				containerComposition=InstallBackground(boundsComposition, direction);
				{
					GuiBoundsComposition* handleBoundsComposition=new GuiBoundsComposition;
					containerComposition->AddChild(handleBoundsComposition);

					handleComposition=new GuiPartialViewComposition;
					handleBoundsComposition->AddChild(handleComposition);
					handleBoundsComposition->GetEventReceiver()->leftButtonDown.AttachMethod(this, &CommonScrollStyle::OnBigMoveMouseDown);

					switch(direction)
					{
					case Horizontal:
						handleBoundsComposition->SetAlignmentToParent(Margin(defaultSize, 0, defaultSize, 0));
						handleComposition->SetPreferredMinSize(Size(defaultSize, 0));
						boundsComposition->SetPreferredMinSize(Size(0, defaultSize));
						break;
					case Vertical:
						handleBoundsComposition->SetAlignmentToParent(Margin(0, defaultSize, 0, defaultSize));
						handleComposition->SetPreferredMinSize(Size(0, defaultSize));
						boundsComposition->SetPreferredMinSize(Size(defaultSize, 0));
						break;
					}
					
					handleButton=new GuiButton(CreateHandleButtonStyle(direction));
					handleButton->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
					handleComposition->AddChild(handleButton->GetBoundsComposition());

					handleButton->GetBoundsComposition()->GetEventReceiver()->leftButtonDown.AttachMethod(this, &CommonScrollStyle::OnHandleMouseDown);
					handleButton->GetBoundsComposition()->GetEventReceiver()->mouseMove.AttachMethod(this, &CommonScrollStyle::OnHandleMouseMove);
					handleButton->GetBoundsComposition()->GetEventReceiver()->leftButtonUp.AttachMethod(this, &CommonScrollStyle::OnHandleMouseUp);
				}
				{
					decreaseButton=new GuiButton(CreateDecreaseButtonStyle(direction));
					decreaseButton->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
					decreaseButton->Clicked.AttachMethod(this, &CommonScrollStyle::OnDecreaseButtonClicked);
					
					increaseButton=new GuiButton(CreateIncreaseButtonStyle(direction));
					increaseButton->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
					increaseButton->Clicked.AttachMethod(this, &CommonScrollStyle::OnIncreaseButtonClicked);
				}
				{
					GuiSideAlignedComposition* decreaseComposition=new GuiSideAlignedComposition;
					decreaseComposition->SetMaxLength(defaultSize);
					decreaseComposition->SetMaxRatio(0.5);
					decreaseComposition->AddChild(decreaseButton->GetBoundsComposition());
					containerComposition->AddChild(decreaseComposition);

					GuiSideAlignedComposition* increaseComposition=new GuiSideAlignedComposition;
					increaseComposition->SetMaxLength(defaultSize);
					increaseComposition->SetMaxRatio(0.5);
					increaseComposition->AddChild(increaseButton->GetBoundsComposition());
					containerComposition->AddChild(increaseComposition);

					switch(direction)
					{
					case Horizontal:
						{
							decreaseComposition->SetDirection(GuiSideAlignedComposition::Left);
							increaseComposition->SetDirection(GuiSideAlignedComposition::Right);
						}
						break;
					case Vertical:
						{
							decreaseComposition->SetDirection(GuiSideAlignedComposition::Top);
							increaseComposition->SetDirection(GuiSideAlignedComposition::Bottom);
						}
						break;
					}
				}
			}

			CommonScrollStyle::CommonScrollStyle(Direction _direction)
				:direction(_direction)
				,commandExecutor(0)
				,decreaseButton(0)
				,increaseButton(0)
				,boundsComposition(0)
				,containerComposition(0)
				,totalSize(1)
				,pageSize(1)
				,position(0)
				,draggingHandle(false)
			{
			}

			CommonScrollStyle::~CommonScrollStyle()
			{
			}

			compositions::GuiBoundsComposition* CommonScrollStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* CommonScrollStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void CommonScrollStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void CommonScrollStyle::SetText(const WString& value)
			{
			}

			void CommonScrollStyle::SetFont(const FontProperties& value)
			{
			}

			void CommonScrollStyle::SetVisuallyEnabled(bool value)
			{
			}

			void CommonScrollStyle::SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)
			{
				commandExecutor=value;
			}

			void CommonScrollStyle::SetTotalSize(vint value)
			{
				if(totalSize!=value)
				{
					totalSize=value;
					UpdateHandle();
				}
			}

			void CommonScrollStyle::SetPageSize(vint value)
			{
				if(pageSize!=value)
				{
					pageSize=value;
					UpdateHandle();
				}
			}

			void CommonScrollStyle::SetPosition(vint value)
			{
				if(position!=value)
				{
					position=value;
					UpdateHandle();
				}
			}

/***********************************************************************
CommonTrackStyle
***********************************************************************/

			void CommonTrackStyle::UpdateHandle()
			{
				vint maxSize=totalSize-pageSize;
				if(maxSize<1) maxSize=1;
				double ratio=(double)position/maxSize;
				switch(direction)
				{
				case Horizontal:
					handleComposition->SetColumnOption(0, GuiCellOption::PercentageOption(ratio));
					handleComposition->SetColumnOption(2, GuiCellOption::PercentageOption(1-ratio));
					break;
				case Vertical:
					handleComposition->SetRowOption(0, GuiCellOption::PercentageOption(1-ratio));
					handleComposition->SetRowOption(2, GuiCellOption::PercentageOption(ratio));
					break;
				}
				handleComposition->UpdateCellBounds();
			}

			void CommonTrackStyle::OnHandleMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(commandExecutor && handleButton->GetVisuallyEnabled())
				{
					draggingHandle=true;
					draggingStartLocation=Point(arguments.x, arguments.y);
				}
			}

			void CommonTrackStyle::OnHandleMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(draggingHandle)
				{
					vint totalPixels=0;
					vint currentOffset=0;
					vint newOffset=0;

					Rect handleArea=handleComposition->GetBounds();
					Rect handleBounds=handleButton->GetBoundsComposition()->GetParent()->GetBounds();
					switch(direction)
					{
					case Horizontal:
						totalPixels=handleArea.Width()-handleBounds.Width();
						currentOffset=handleBounds.Left();
						newOffset=currentOffset+(arguments.x-draggingStartLocation.x);
						break;
					case Vertical:
						totalPixels=handleArea.Height()-handleBounds.Height();
						currentOffset=handleArea.Height()-handleBounds.Bottom();
						newOffset=currentOffset-(arguments.y-draggingStartLocation.y);
						break;
					}

					double ratio=(double)newOffset/totalPixels;
					vint maxSize=totalSize-pageSize;
					if(maxSize<1) maxSize=1;
					vint newPosition=(vint)(ratio*maxSize);

					vint offset1=(vint)(((double)newPosition/maxSize)*totalPixels);
					vint offset2=vint(((double)(newPosition+1)/maxSize)*totalPixels);
					vint delta1=abs((int)(offset1-newOffset));
					vint delta2=abs((int)(offset2-newOffset));
					if(delta1<delta2)
					{
						commandExecutor->SetPosition(newPosition);
					}
					else
					{
						commandExecutor->SetPosition(newPosition+1);
					}
				}
			}

			void CommonTrackStyle::OnHandleMouseUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				draggingHandle=false;
			}

			void CommonTrackStyle::BuildStyle(vint trackThickness, vint trackPadding, vint handleLong, vint handleShort)
			{
				boundsComposition=new GuiBoundsComposition;
				InstallBackground(boundsComposition, direction);
				{
					GuiTableComposition* table=new GuiTableComposition;
					boundsComposition->AddChild(table);
					boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetRowsAndColumns(3, 3);
					table->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					switch(direction)
					{
					case Horizontal:
						table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
						table->SetRowOption(1, GuiCellOption::AbsoluteOption(handleLong));
						table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
						table->SetColumnOption(0, GuiCellOption::AbsoluteOption(trackPadding));
						table->SetColumnOption(1, GuiCellOption::PercentageOption(1.0));
						table->SetColumnOption(2, GuiCellOption::AbsoluteOption(trackPadding));
						break;
					case Vertical:
						table->SetRowOption(0, GuiCellOption::AbsoluteOption(trackPadding));
						table->SetRowOption(1, GuiCellOption::PercentageOption(1.0));
						table->SetRowOption(2, GuiCellOption::AbsoluteOption(trackPadding));
						table->SetColumnOption(0, GuiCellOption::PercentageOption(0.5));
						table->SetColumnOption(1, GuiCellOption::AbsoluteOption(handleLong));
						table->SetColumnOption(2, GuiCellOption::PercentageOption(0.5));
						break;
					}
					{
						GuiCellComposition* contentCell=new GuiCellComposition;
						table->AddChild(contentCell);
						contentCell->SetSite(1, 1, 1, 1);
						{
							GuiTableComposition* trackTable=new GuiTableComposition;
							trackTable->SetAlignmentToParent(Margin(0, 0, 0, 0));
							contentCell->AddChild(trackTable);
							GuiCellComposition* trackCell=new GuiCellComposition;
							trackTable->AddChild(trackCell);

							switch(direction)
							{
							case Horizontal:
								trackTable->SetRowsAndColumns(3, 1);
								trackTable->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
								trackTable->SetRowOption(1, GuiCellOption::AbsoluteOption(trackThickness));
								trackTable->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
								trackCell->SetSite(1, 0, 1, 1);
								break;
							case Vertical:
								trackTable->SetRowsAndColumns(1, 3);
								trackTable->SetColumnOption(0, GuiCellOption::PercentageOption(0.5));
								trackTable->SetColumnOption(1, GuiCellOption::AbsoluteOption(trackThickness));
								trackTable->SetColumnOption(2, GuiCellOption::PercentageOption(0.5));
								trackCell->SetSite(0, 1, 1, 1);
								break;
							}
							InstallTrack(trackCell, direction);
						}
						{
							handleComposition=new GuiTableComposition;
							handleComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
							contentCell->AddChild(handleComposition);
							GuiCellComposition* handleCell=new GuiCellComposition;
							handleComposition->AddChild(handleCell);

							switch(direction)
							{
							case Horizontal:
								handleComposition->SetRowsAndColumns(1, 3);
								handleComposition->SetColumnOption(0, GuiCellOption::PercentageOption(0.0));
								handleComposition->SetColumnOption(1, GuiCellOption::AbsoluteOption(handleShort));
								handleComposition->SetColumnOption(2, GuiCellOption::PercentageOption(1.0));
								handleCell->SetSite(0, 1, 1, 1);
								break;
							case Vertical:
								handleComposition->SetRowsAndColumns(3, 1);
								handleComposition->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
								handleComposition->SetRowOption(1, GuiCellOption::AbsoluteOption(handleShort));
								handleComposition->SetRowOption(2, GuiCellOption::PercentageOption(0.0));
								handleCell->SetSite(1, 0, 1, 1);
								break;
							}

							handleButton=new GuiButton(CreateHandleButtonStyle(direction));
							handleButton->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
							handleCell->AddChild(handleButton->GetBoundsComposition());

							handleButton->GetBoundsComposition()->GetEventReceiver()->leftButtonDown.AttachMethod(this, &CommonTrackStyle::OnHandleMouseDown);
							handleButton->GetBoundsComposition()->GetEventReceiver()->mouseMove.AttachMethod(this, &CommonTrackStyle::OnHandleMouseMove);
							handleButton->GetBoundsComposition()->GetEventReceiver()->leftButtonUp.AttachMethod(this, &CommonTrackStyle::OnHandleMouseUp);
						}
					}
				}
			}

			CommonTrackStyle::CommonTrackStyle(Direction _direction)
				:direction(_direction)
				,commandExecutor(0)
				,totalSize(1)
				,pageSize(1)
				,position(0)
				,draggingHandle(false)
			{
			}

			CommonTrackStyle::~CommonTrackStyle()
			{
			}

			compositions::GuiBoundsComposition* CommonTrackStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* CommonTrackStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void CommonTrackStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void CommonTrackStyle::SetText(const WString& value)
			{
			}

			void CommonTrackStyle::SetFont(const FontProperties& value)
			{
			}

			void CommonTrackStyle::SetVisuallyEnabled(bool value)
			{
			}

			void CommonTrackStyle::SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)
			{
				commandExecutor=value;
				if(value)
				{
					value->SetPageSize(0);
				}
			}

			void CommonTrackStyle::SetTotalSize(vint value)
			{
				if(totalSize!=value)
				{
					totalSize=value;
					UpdateHandle();
				}
			}

			void CommonTrackStyle::SetPageSize(vint value)
			{
				if(pageSize!=value)
				{
					pageSize=value;
					UpdateHandle();
				}
			}

			void CommonTrackStyle::SetPosition(vint value)
			{
				if(position!=value)
				{
					position=value;
					UpdateHandle();
				}
			}

/***********************************************************************
CommonFragmentBuilder
***********************************************************************/

			void CommonFragmentBuilder::FillUpArrow(elements::GuiPolygonElement* element)
			{
				Point points[]={Point(0, 3), Point(3, 0), Point(6, 3)};
				element->SetSize(Size(7, 4));
				element->SetPoints(points, sizeof(points)/sizeof(*points));
			}

			void CommonFragmentBuilder::FillDownArrow(elements::GuiPolygonElement* element)
			{
				Point points[]={Point(0, 0), Point(3, 3), Point(6, 0)};
				element->SetSize(Size(7, 4));
				element->SetPoints(points, sizeof(points)/sizeof(*points));
			}

			void CommonFragmentBuilder::FillLeftArrow(elements::GuiPolygonElement* element)
			{
				Point points[]={Point(3, 0), Point(0, 3), Point(3, 6)};
				element->SetSize(Size(4, 7));
				element->SetPoints(points, sizeof(points)/sizeof(*points));
			}

			void CommonFragmentBuilder::FillRightArrow(elements::GuiPolygonElement* element)
			{
				Point points[]={Point(0, 0), Point(3, 3), Point(0, 6)};
				element->SetSize(Size(4, 7));
				element->SetPoints(points, sizeof(points)/sizeof(*points));
			}

			elements::GuiPolygonElement* CommonFragmentBuilder::BuildUpArrow()
			{
				GuiPolygonElement* element=GuiPolygonElement::Create();
				FillUpArrow(element);
				element->SetBorderColor(Color(0, 0, 0));
				element->SetBackgroundColor(Color(0, 0, 0));
				return element;
			}

			elements::GuiPolygonElement* CommonFragmentBuilder::BuildDownArrow()
			{
				GuiPolygonElement* element=GuiPolygonElement::Create();
				FillDownArrow(element);
				element->SetBorderColor(Color(0, 0, 0));
				element->SetBackgroundColor(Color(0, 0, 0));
				return element;
			}

			elements::GuiPolygonElement* CommonFragmentBuilder::BuildLeftArrow()
			{
				GuiPolygonElement* element=GuiPolygonElement::Create();
				FillLeftArrow(element);
				element->SetBorderColor(Color(0, 0, 0));
				element->SetBackgroundColor(Color(0, 0, 0));
				return element;
			}

			elements::GuiPolygonElement* CommonFragmentBuilder::BuildRightArrow()
			{
				GuiPolygonElement* element=GuiPolygonElement::Create();
				FillRightArrow(element);
				element->SetBorderColor(Color(0, 0, 0));
				element->SetBackgroundColor(Color(0, 0, 0));
				return element;
			}

			compositions::GuiBoundsComposition* CommonFragmentBuilder::BuildDockedElementContainer(elements::IGuiGraphicsElement* element)
			{
				GuiBoundsComposition* composition=new GuiBoundsComposition;
				composition->SetOwnedElement(element);
				composition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				return composition;
			}

			compositions::GuiBoundsComposition* CommonFragmentBuilder::BuildUpArrow(elements::GuiPolygonElement*& elementOut)
			{
				elementOut=BuildUpArrow();
				return BuildDockedElementContainer(elementOut);
			}

			compositions::GuiBoundsComposition* CommonFragmentBuilder::BuildDownArrow(elements::GuiPolygonElement*& elementOut)
			{
				elementOut=BuildDownArrow();
				return BuildDockedElementContainer(elementOut);
			}

			compositions::GuiBoundsComposition* CommonFragmentBuilder::BuildLeftArrow(elements::GuiPolygonElement*& elementOut)
			{
				elementOut=BuildLeftArrow();
				return BuildDockedElementContainer(elementOut);
			}

			compositions::GuiBoundsComposition* CommonFragmentBuilder::BuildRightArrow(elements::GuiPolygonElement*& elementOut)
			{
				elementOut=BuildRightArrow();
				return BuildDockedElementContainer(elementOut);
			}
		}

/***********************************************************************
Helpers
***********************************************************************/

		unsigned char IntToColor(vint color)
		{
			return color<0?0:color>255?255:(unsigned char)color;
		}

		Color BlendColor(Color c1, Color c2, vint currentPosition, vint totalLength)
		{
			return Color(
				(unsigned char)IntToColor((c2.r*currentPosition+c1.r*(totalLength-currentPosition))/totalLength),
				(unsigned char)IntToColor((c2.g*currentPosition+c1.g*(totalLength-currentPosition))/totalLength),
				(unsigned char)IntToColor((c2.b*currentPosition+c1.b*(totalLength-currentPosition))/totalLength),
				(unsigned char)IntToColor((c2.a*currentPosition+c1.a*(totalLength-currentPosition))/totalLength)
				);
		}
	}
}

/***********************************************************************
Controls\Styles\GuiThemeStyleFactory.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			ITheme* currentTheme=0;

			ITheme* GetCurrentTheme()
			{
				return currentTheme;
			}

			void SetCurrentTheme(ITheme* theme)
			{
				currentTheme=theme;
			}

			namespace g
			{
				controls::GuiWindow* NewWindow()
				{
					return new controls::GuiWindow(GetCurrentTheme()->CreateWindowStyle());
				}

				controls::GuiLabel* NewLabel()
				{
					return new controls::GuiLabel(GetCurrentTheme()->CreateLabelStyle());
				}

				controls::GuiScrollContainer* NewScrollContainer()
				{
					return new controls::GuiScrollContainer(GetCurrentTheme()->CreateScrollContainerStyle());
				}

				controls::GuiControl* NewGroupBox()
				{
					return new controls::GuiControl(GetCurrentTheme()->CreateGroupBoxStyle());
				}

				controls::GuiTab* NewTab()
				{
					return new controls::GuiTab(GetCurrentTheme()->CreateTabStyle());
				}

				controls::GuiComboBoxListControl* NewComboBox(controls::GuiSelectableListControl* containedListControl)
				{
					return new controls::GuiComboBoxListControl(GetCurrentTheme()->CreateComboBoxStyle(), containedListControl);
				}

				controls::GuiMultilineTextBox* NewMultilineTextBox()
				{
					return new controls::GuiMultilineTextBox(GetCurrentTheme()->CreateMultilineTextBoxStyle());
				}

				controls::GuiSinglelineTextBox* NewTextBox()
				{
					return new controls::GuiSinglelineTextBox(GetCurrentTheme()->CreateTextBoxStyle());
				}

				controls::GuiListView* NewListViewBigIcon()
				{
					controls::GuiListView* listview=new controls::GuiListView(GetCurrentTheme()->CreateListViewStyle());
					listview->ChangeItemStyle(new controls::list::ListViewBigIconContentProvider);
					return listview;
				}

				controls::GuiListView* NewListViewSmallIcon()
				{
					controls::GuiListView* listview=new controls::GuiListView(GetCurrentTheme()->CreateListViewStyle());
					listview->ChangeItemStyle(new controls::list::ListViewSmallIconContentProvider);
					return listview;
				}

				controls::GuiListView* NewListViewList()
				{
					controls::GuiListView* listview=new controls::GuiListView(GetCurrentTheme()->CreateListViewStyle());
					listview->ChangeItemStyle(new controls::list::ListViewListContentProvider);
					return listview;
				}

				controls::GuiListView* NewListViewDetail()
				{
					controls::GuiListView* listview=new controls::GuiListView(GetCurrentTheme()->CreateListViewStyle());
					listview->ChangeItemStyle(new controls::list::ListViewDetailContentProvider);
					return listview;
				}

				controls::GuiListView* NewListViewTile()
				{
					controls::GuiListView* listview=new controls::GuiListView(GetCurrentTheme()->CreateListViewStyle());
					listview->ChangeItemStyle(new controls::list::ListViewTileContentProvider);
					return listview;
				}

				controls::GuiListView* NewListViewInformation()
				{
					controls::GuiListView* listview=new controls::GuiListView(GetCurrentTheme()->CreateListViewStyle());
					listview->ChangeItemStyle(new controls::list::ListViewInformationContentProvider);
					return listview;
				}

				controls::GuiTreeView* NewTreeView()
				{
					return new controls::GuiTreeView(GetCurrentTheme()->CreateTreeViewStyle());
				}

				controls::GuiToolstripMenu* NewMenu(controls::GuiControl* owner)
				{
					return new controls::GuiToolstripMenu(GetCurrentTheme()->CreateMenuStyle(), owner);
				}

				controls::GuiToolstripMenuBar* NewMenuBar()
				{
					return new controls::GuiToolstripMenuBar(GetCurrentTheme()->CreateMenuBarStyle());
				}

				controls::GuiControl* NewMenuSplitter()
				{
					return new controls::GuiControl(GetCurrentTheme()->CreateMenuSplitterStyle());
				}

				controls::GuiToolstripButton* NewMenuBarButton()
				{
					return new controls::GuiToolstripButton(GetCurrentTheme()->CreateMenuBarButtonStyle());
				}

				controls::GuiToolstripButton* NewMenuItemButton()
				{
					return new controls::GuiToolstripButton(GetCurrentTheme()->CreateMenuItemButtonStyle());
				}

				controls::GuiToolstripToolbar* NewToolbar()
				{
					return new controls::GuiToolstripToolbar(GetCurrentTheme()->CreateToolbarStyle());
				}

				controls::GuiToolstripButton* NewToolbarButton()
				{
					return new controls::GuiToolstripButton(GetCurrentTheme()->CreateToolbarButtonStyle());
				}

				controls::GuiToolstripButton* NewToolbarDropdownButton()
				{
					return new controls::GuiToolstripButton(GetCurrentTheme()->CreateToolbarDropdownButtonStyle());
				}

				controls::GuiToolstripButton* NewToolbarSplitButton()
				{
					return new controls::GuiToolstripButton(GetCurrentTheme()->CreateToolbarSplitButtonStyle());
				}

				controls::GuiControl* NewToolbarSplitter()
				{
					return new controls::GuiControl(GetCurrentTheme()->CreateToolbarSplitterStyle());
				}

				controls::GuiButton* NewButton()
				{
					return new controls::GuiButton(GetCurrentTheme()->CreateButtonStyle());
				}

				controls::GuiSelectableButton* NewCheckBox()
				{
					return new controls::GuiSelectableButton(GetCurrentTheme()->CreateCheckBoxStyle());
				}

				controls::GuiSelectableButton* NewRadioButton()
				{
					return new controls::GuiSelectableButton(GetCurrentTheme()->CreateRadioButtonStyle());
				}

				controls::GuiScroll* NewHScroll()
				{
					return new controls::GuiScroll(GetCurrentTheme()->CreateHScrollStyle());
				}

				controls::GuiScroll* NewVScroll()
				{
					return new controls::GuiScroll(GetCurrentTheme()->CreateVScrollStyle());
				}

				controls::GuiScroll* NewHTracker()
				{
					controls::GuiScroll* scroll=new controls::GuiScroll(GetCurrentTheme()->CreateHTrackerStyle());
					scroll->SetPageSize(0);
					return scroll;
				}

				controls::GuiScroll* NewVTracker()
				{
					controls::GuiScroll* scroll=new controls::GuiScroll(GetCurrentTheme()->CreateVTrackerStyle());
					scroll->SetPageSize(0);
					return scroll;
				}
				
				controls::GuiScroll* NewProgressBar()
				{
					controls::GuiScroll* scroll=new controls::GuiScroll(GetCurrentTheme()->CreateProgressBarStyle());
					scroll->SetPageSize(0);
					return scroll;
				}

				controls::GuiTextList* NewTextList()
				{
					return new controls::GuiTextList(GetCurrentTheme()->CreateTextListStyle(), GetCurrentTheme()->CreateTextListItemStyle());
				}

				controls::GuiTextList* NewCheckTextList()
				{
					return new controls::GuiTextList(GetCurrentTheme()->CreateTextListStyle(), GetCurrentTheme()->CreateCheckTextListItemStyle());
				}

				controls::GuiTextList* NewRadioTextList()
				{
					return new controls::GuiTextList(GetCurrentTheme()->CreateTextListStyle(), GetCurrentTheme()->CreateRadioTextListItemStyle());
				}
			}
		}
	}
}

/***********************************************************************
Controls\Styles\GuiWin7Styles.cpp
***********************************************************************/


namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7Theme
***********************************************************************/

			Win7Theme::Win7Theme()
			{
			}

			Win7Theme::~Win7Theme()
			{
			}

			controls::GuiWindow::IStyleController* Win7Theme::CreateWindowStyle()
			{
				return new Win7WindowStyle;
			}

			controls::GuiLabel::IStyleController* Win7Theme::CreateLabelStyle()
			{
				return new Win7LabelStyle;
			}

			controls::GuiScrollContainer::IStyleProvider* Win7Theme::CreateScrollContainerStyle()
			{
				return new Win7ScrollViewProvider;
			}

			controls::GuiControl::IStyleController* Win7Theme::CreateGroupBoxStyle()
			{
				return new Win7GroupBoxStyle;
			}

			controls::GuiTab::IStyleController* Win7Theme::CreateTabStyle()
			{
				return new Win7TabStyle;
			}

			controls::GuiComboBoxBase::IStyleController* Win7Theme::CreateComboBoxStyle()
			{
				return new Win7DropDownComboBoxStyle;
			}

			controls::GuiScrollView::IStyleProvider* Win7Theme::CreateMultilineTextBoxStyle()
			{
				return new Win7MultilineTextBoxProvider;
			}

			controls::GuiSinglelineTextBox::IStyleProvider* Win7Theme::CreateTextBoxStyle()
			{
				return new Win7SinglelineTextBoxProvider;
			}

			controls::GuiListView::IStyleProvider* Win7Theme::CreateListViewStyle()
			{
				return new Win7ListViewProvider;
			}

			controls::GuiTreeView::IStyleProvider* Win7Theme::CreateTreeViewStyle()
			{
				return new Win7TreeViewProvider;
			}

			controls::GuiSelectableButton::IStyleController* Win7Theme::CreateListItemBackgroundStyle()
			{
				return new Win7SelectableItemStyle();
			}

			elements::text::ColorEntry Win7Theme::GetDefaultTextBoxColorEntry()
			{
				return Win7GetTextBoxTextColor();
			}

			controls::GuiToolstripMenu::IStyleController* Win7Theme::CreateMenuStyle()
			{
				return new Win7MenuStyle;
			}

			controls::GuiToolstripMenuBar::IStyleController* Win7Theme::CreateMenuBarStyle()
			{
				return new Win7MenuBarStyle;
			}

			controls::GuiControl::IStyleController* Win7Theme::CreateMenuSplitterStyle()
			{
				return new Win7MenuSplitterStyle;
			}

			controls::GuiToolstripButton::IStyleController* Win7Theme::CreateMenuBarButtonStyle()
			{
				return new Win7MenuBarButtonStyle;
			}

			controls::GuiToolstripButton::IStyleController* Win7Theme::CreateMenuItemButtonStyle()
			{
				return new Win7MenuItemButtonStyle;
			}

			controls::GuiControl::IStyleController* Win7Theme::CreateToolbarStyle()
			{
				return new Win7ToolstripToolbarStyle;
			}

			controls::GuiToolstripButton::IStyleController* Win7Theme::CreateToolbarButtonStyle()
			{
				return new Win7ToolstripButtonStyle(Win7ToolstripButtonStyle::CommandButton);
			}

			controls::GuiToolstripButton::IStyleController* Win7Theme::CreateToolbarDropdownButtonStyle()
			{
				return new Win7ToolstripButtonStyle(Win7ToolstripButtonStyle::DropdownButton);
			}

			controls::GuiToolstripButton::IStyleController* Win7Theme::CreateToolbarSplitButtonStyle()
			{
				return new Win7ToolstripButtonStyle(Win7ToolstripButtonStyle::SplitButton);
			}

			controls::GuiControl::IStyleController* Win7Theme::CreateToolbarSplitterStyle()
			{
				return new Win7ToolstripSplitterStyle;
			}

			controls::GuiButton::IStyleController* Win7Theme::CreateButtonStyle()
			{
				return new Win7ButtonStyle;
			}

			controls::GuiSelectableButton::IStyleController* Win7Theme::CreateCheckBoxStyle()
			{
				return new Win7CheckBoxStyle(Win7CheckBoxStyle::CheckBox);
			}

			controls::GuiSelectableButton::IStyleController* Win7Theme::CreateRadioButtonStyle()
			{
				return new Win7CheckBoxStyle(Win7CheckBoxStyle::RadioButton);
			}

			controls::GuiScroll::IStyleController* Win7Theme::CreateHScrollStyle()
			{
				return new Win7ScrollStyle(Win7ScrollStyle::Horizontal);
			}

			controls::GuiScroll::IStyleController* Win7Theme::CreateVScrollStyle()
			{
				return new Win7ScrollStyle(Win7ScrollStyle::Vertical);
			}

			controls::GuiScroll::IStyleController* Win7Theme::CreateHTrackerStyle()
			{
				return new Win7TrackStyle(Win7TrackStyle::Horizontal);
			}

			controls::GuiScroll::IStyleController* Win7Theme::CreateVTrackerStyle()
			{
				return new Win7TrackStyle(Win7TrackStyle::Vertical);
			}

			controls::GuiScroll::IStyleController* Win7Theme::CreateProgressBarStyle()
			{
				return new Win7ProgressBarStyle;
			}

			vint Win7Theme::GetScrollDefaultSize()
			{
				return Win7ScrollStyle::DefaultSize;
			}

			vint Win7Theme::GetTrackerDefaultSize()
			{
				return Win7TrackStyle::HandleLong;
			}

			controls::GuiScrollView::IStyleProvider* Win7Theme::CreateTextListStyle()
			{
				return new Win7MultilineTextBoxProvider;
			}

			controls::list::TextItemStyleProvider::ITextItemStyleProvider* Win7Theme::CreateTextListItemStyle()
			{
				return new Win7TextListProvider;
			}

			controls::list::TextItemStyleProvider::ITextItemStyleProvider* Win7Theme::CreateCheckTextListItemStyle()
			{
				return new Win7CheckTextListProvider;
			}

			controls::list::TextItemStyleProvider::ITextItemStyleProvider* Win7Theme::CreateRadioTextListItemStyle()
			{
				return new Win7RadioTextListProvider;
			}
		}
	}
}

/***********************************************************************
Controls\Styles\GuiWin8Styles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win8Theme
***********************************************************************/

			Win8Theme::Win8Theme()
			{
			}

			Win8Theme::~Win8Theme()
			{
			}

			controls::GuiWindow::IStyleController* Win8Theme::CreateWindowStyle()
			{
				return new Win8WindowStyle;
			}

			controls::GuiLabel::IStyleController* Win8Theme::CreateLabelStyle()
			{
				return new Win8LabelStyle;
			}

			controls::GuiScrollContainer::IStyleProvider* Win8Theme::CreateScrollContainerStyle()
			{
				return new Win8ScrollViewProvider;
			}

			controls::GuiControl::IStyleController* Win8Theme::CreateGroupBoxStyle()
			{
				return new Win8GroupBoxStyle;
			}

			//controls::GuiTab::IStyleController* Win8Theme::CreateTabStyle()
			//{
			//	throw 0;
			//}

			controls::GuiComboBoxBase::IStyleController* Win8Theme::CreateComboBoxStyle()
			{
				return new Win8DropDownComboBoxStyle;
			}

			controls::GuiScrollView::IStyleProvider* Win8Theme::CreateMultilineTextBoxStyle()
			{
				return new Win8MultilineTextBoxProvider;
			}

			controls::GuiSinglelineTextBox::IStyleProvider* Win8Theme::CreateTextBoxStyle()
			{
				return new Win8SinglelineTextBoxProvider;
			}

			controls::GuiListView::IStyleProvider* Win8Theme::CreateListViewStyle()
			{
				return new Win8ListViewProvider;
			}

			controls::GuiTreeView::IStyleProvider* Win8Theme::CreateTreeViewStyle()
			{
				return new Win8TreeViewProvider;
			}

			controls::GuiSelectableButton::IStyleController* Win8Theme::CreateListItemBackgroundStyle()
			{
				return new Win8SelectableItemStyle();
			}

			elements::text::ColorEntry Win8Theme::GetDefaultTextBoxColorEntry()
			{
				return Win8GetTextBoxTextColor();
			}

			controls::GuiToolstripMenu::IStyleController* Win8Theme::CreateMenuStyle()
			{
				return new Win8MenuStyle;
			}

			controls::GuiToolstripMenuBar::IStyleController* Win8Theme::CreateMenuBarStyle()
			{
				return new Win8MenuBarStyle;
			}

			controls::GuiControl::IStyleController* Win8Theme::CreateMenuSplitterStyle()
			{
				return new Win8MenuSplitterStyle;
			}

			controls::GuiToolstripButton::IStyleController* Win8Theme::CreateMenuBarButtonStyle()
			{
				return new Win8MenuBarButtonStyle;
			}

			controls::GuiToolstripButton::IStyleController* Win8Theme::CreateMenuItemButtonStyle()
			{
				return new Win8MenuItemButtonStyle;
			}

			controls::GuiControl::IStyleController* Win8Theme::CreateToolbarStyle()
			{
				return new Win8ToolstripToolbarStyle;
			}

			controls::GuiToolstripButton::IStyleController* Win8Theme::CreateToolbarButtonStyle()
			{
				return new Win8ToolstripButtonStyle(Win8ToolstripButtonStyle::CommandButton);
			}

			controls::GuiToolstripButton::IStyleController* Win8Theme::CreateToolbarDropdownButtonStyle()
			{
				return new Win8ToolstripButtonStyle(Win8ToolstripButtonStyle::DropdownButton);
			}

			controls::GuiToolstripButton::IStyleController* Win8Theme::CreateToolbarSplitButtonStyle()
			{
				return new Win8ToolstripButtonStyle(Win8ToolstripButtonStyle::SplitButton);
			}

			controls::GuiControl::IStyleController* Win8Theme::CreateToolbarSplitterStyle()
			{
				return new Win8ToolstripSplitterStyle;
			}

			controls::GuiButton::IStyleController* Win8Theme::CreateButtonStyle()
			{
				return new Win8ButtonStyle;
			}

			controls::GuiSelectableButton::IStyleController* Win8Theme::CreateCheckBoxStyle()
			{
				return new Win8CheckBoxStyle(Win8CheckBoxStyle::CheckBox);
			}

			controls::GuiSelectableButton::IStyleController* Win8Theme::CreateRadioButtonStyle()
			{
				return new Win8CheckBoxStyle(Win8CheckBoxStyle::RadioButton);
			}

			controls::GuiScroll::IStyleController* Win8Theme::CreateHScrollStyle()
			{
				return new Win8ScrollStyle(common_styles::CommonScrollStyle::Horizontal);
			}

			controls::GuiScroll::IStyleController* Win8Theme::CreateVScrollStyle()
			{
				return new Win8ScrollStyle(common_styles::CommonScrollStyle::Vertical);
			}

			controls::GuiScroll::IStyleController* Win8Theme::CreateHTrackerStyle()
			{
				return new Win8TrackStyle(common_styles::CommonTrackStyle::Horizontal);
			}

			controls::GuiScroll::IStyleController* Win8Theme::CreateVTrackerStyle()
			{
				return new Win8TrackStyle(common_styles::CommonTrackStyle::Vertical);
			}

			controls::GuiScroll::IStyleController* Win8Theme::CreateProgressBarStyle()
			{
				return new Win8ProgressBarStyle;
			}

			vint Win8Theme::GetScrollDefaultSize()
			{
				return Win8ScrollStyle::DefaultSize;
			}

			vint Win8Theme::GetTrackerDefaultSize()
			{
				return Win8TrackStyle::HandleLong;
			}

			controls::GuiScrollView::IStyleProvider* Win8Theme::CreateTextListStyle()
			{
				return new Win8MultilineTextBoxProvider;
			}

			controls::list::TextItemStyleProvider::ITextItemStyleProvider* Win8Theme::CreateTextListItemStyle()
			{
				return new Win8TextListProvider;
			}

			controls::list::TextItemStyleProvider::ITextItemStyleProvider* Win8Theme::CreateCheckTextListItemStyle()
			{
				return new Win8CheckTextListProvider;
			}

			controls::list::TextItemStyleProvider::ITextItemStyleProvider* Win8Theme::CreateRadioTextListItemStyle()
			{
				return new Win8RadioTextListProvider;
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win7Styles\GuiWin7ButtonStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7ButtonStyleBase
***********************************************************************/

			IMPLEMENT_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7ButtonStyleBase)
			{
				colorCurrent=Win7ButtonColors::Blend(colorBegin, colorEnd, currentPosition, totalLength);
				style->elements.Apply(colorCurrent);
				style->AfterApplyColors(colorCurrent);
			}

			void Win7ButtonStyleBase::AfterApplyColors(const Win7ButtonColors& colors)
			{
			}

			Win7ButtonStyleBase::Win7ButtonStyleBase(bool verticalGradient, bool roundBorder, const Win7ButtonColors& initialColor, Alignment::Type horizontal, Alignment::Type vertical)
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isSelected(false)
				,transparentWhenInactive(false)
				,transparentWhenDisabled(false)
			{
				elements=Win7ButtonElements::Create(verticalGradient, roundBorder, horizontal, vertical);
				elements.Apply(initialColor);
				transferringAnimation=new TransferringAnimation(this, initialColor);
			}

			Win7ButtonStyleBase::~Win7ButtonStyleBase()
			{
				transferringAnimation->Disable();
			}

			compositions::GuiBoundsComposition* Win7ButtonStyleBase::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win7ButtonStyleBase::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win7ButtonStyleBase::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7ButtonStyleBase::SetText(const WString& value)
			{
				elements.textElement->SetText(value);
			}

			void Win7ButtonStyleBase::SetFont(const FontProperties& value)
			{
				Win7SetFont(elements.textElement, elements.textComposition, value);
			}

			void Win7ButtonStyleBase::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win7ButtonStyleBase::SetSelected(bool value)
			{
				if(isSelected!=value)
				{
					isSelected=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win7ButtonStyleBase::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			bool Win7ButtonStyleBase::GetTransparentWhenInactive()
			{
				return transparentWhenInactive;
			}

			void Win7ButtonStyleBase::SetTransparentWhenInactive(bool value)
			{
				transparentWhenInactive=value;
				TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
			}

			bool Win7ButtonStyleBase::GetTransparentWhenDisabled()
			{
				return transparentWhenDisabled;
			}

			void Win7ButtonStyleBase::SetTransparentWhenDisabled(bool value)
			{
				transparentWhenDisabled=value;
				TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
			}

			bool Win7ButtonStyleBase::GetAutoSizeForText()
			{
				return elements.textComposition->GetMinSizeLimitation()!=GuiGraphicsComposition::NoLimit;
			}

			void Win7ButtonStyleBase::SetAutoSizeForText(bool value)
			{
				if(value)
				{
					elements.textComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				}
				else
				{
					elements.textComposition->SetMinSizeLimitation(GuiGraphicsComposition::NoLimit);
				}
			}

/***********************************************************************
Win7ButtonStyle
***********************************************************************/

			void Win7ButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				Win7ButtonColors targetColor;
				if(enabled)
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win7ButtonColors::ButtonNormal();
						if(transparentWhenInactive)
						{
							targetColor.SetAlphaWithoutText(0);
						}
						break;
					case GuiButton::Active:
						targetColor=Win7ButtonColors::ButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win7ButtonColors::ButtonPressed();
						break;
					}
				}
				else
				{
					targetColor=Win7ButtonColors::ButtonDisabled();
					if(transparentWhenDisabled)
					{
						targetColor.SetAlphaWithoutText(0);
					}
				}
				transferringAnimation->Transfer(targetColor);
			}

			Win7ButtonStyle::Win7ButtonStyle(bool verticalGradient)
				:Win7ButtonStyleBase(verticalGradient, true, Win7ButtonColors::ButtonNormal(), Alignment::Center, Alignment::Center)
			{
			}

			Win7ButtonStyle::~Win7ButtonStyle()
			{
			}

/***********************************************************************
Win7CheckBoxStyle
***********************************************************************/

			IMPLEMENT_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7CheckBoxStyle)
			{
				colorCurrent=Win7ButtonColors::Blend(colorBegin, colorEnd, currentPosition, totalLength);
				style->elements.Apply(colorCurrent);
			}

			void Win7CheckBoxStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				if(enabled)
				{
					switch(value)
					{
					case GuiButton::Normal:
						transferringAnimation->Transfer(Win7ButtonColors::CheckedNormal(selected));
						break;
					case GuiButton::Active:
						transferringAnimation->Transfer(Win7ButtonColors::CheckedActive(selected));
						break;
					case GuiButton::Pressed:
						transferringAnimation->Transfer(Win7ButtonColors::CheckedPressed(selected));
						break;
					}
				}
				else
				{
					transferringAnimation->Transfer(Win7ButtonColors::CheckedDisabled(selected));
				}
			}

			Win7CheckBoxStyle::Win7CheckBoxStyle(BulletStyle bulletStyle, bool backgroundVisible)
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isSelected(false)
			{
				Win7ButtonColors initialColor=Win7ButtonColors::CheckedNormal(isSelected);
				elements=Win7CheckedButtonElements::Create(bulletStyle==CheckBox?ElementShape::Rectangle:ElementShape::Ellipse, backgroundVisible);
				elements.Apply(initialColor);
				transferringAnimation=new TransferringAnimation(this, initialColor);
			}

			Win7CheckBoxStyle::~Win7CheckBoxStyle()
			{
				transferringAnimation->Disable();
			}

			compositions::GuiBoundsComposition* Win7CheckBoxStyle::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win7CheckBoxStyle::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win7CheckBoxStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7CheckBoxStyle::SetText(const WString& value)
			{
				elements.textElement->SetText(value);
			}

			void Win7CheckBoxStyle::SetFont(const FontProperties& value)
			{
				Win7SetFont(elements.textElement, elements.textComposition, value);
			}

			void Win7CheckBoxStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win7CheckBoxStyle::SetSelected(bool value)
			{
				if(isSelected!=value)
				{
					isSelected=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win7CheckBoxStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win7Styles\GuiWin7ControlStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7EmptyStyle
***********************************************************************/

			Win7EmptyStyle::Win7EmptyStyle(Color color)
			{
				GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
				element->SetColor(color);
				
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetOwnedElement(element);
			}

			Win7EmptyStyle::~Win7EmptyStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7EmptyStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7EmptyStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win7EmptyStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7EmptyStyle::SetText(const WString& value)
			{
			}

			void Win7EmptyStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7EmptyStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win7WindowStyle
***********************************************************************/

			Win7WindowStyle::Win7WindowStyle()
			{
				GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
				element->SetColor(Win7GetSystemWindowColor());
				
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetOwnedElement(element);
			}

			Win7WindowStyle::~Win7WindowStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7WindowStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7WindowStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win7WindowStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7WindowStyle::SetText(const WString& value)
			{
			}

			void Win7WindowStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7WindowStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win7LabelStyle
***********************************************************************/

			Win7LabelStyle::Win7LabelStyle()
			{
				textElement=GuiSolidLabelElement::Create();
				textElement->SetColor(GetDefaultTextColor());
				
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetOwnedElement(textElement);
				boundsComposition->SetMinSizeLimitation(GuiBoundsComposition::LimitToElement);
			}

			Win7LabelStyle::~Win7LabelStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7LabelStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7LabelStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win7LabelStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7LabelStyle::SetText(const WString& value)
			{
				textElement->SetText(value);
			}

			void Win7LabelStyle::SetFont(const FontProperties& value)
			{
				textElement->SetFont(value);
			}

			void Win7LabelStyle::SetVisuallyEnabled(bool value)
			{
			}

			Color Win7LabelStyle::GetDefaultTextColor()
			{
				return Win7GetSystemTextColor(true);
			}

			void Win7LabelStyle::SetTextColor(Color value)
			{
				textElement->SetColor(value);
			}

/***********************************************************************
Win7GroupBoxStyle
***********************************************************************/
			
			IMPLEMENT_TRANSFERRING_ANIMATION(Color, Win7GroupBoxStyle)
			{
				colorCurrent=BlendColor(colorBegin, colorEnd, currentPosition, totalLength);
				style->textElement->SetColor(colorCurrent);
			}

			void Win7GroupBoxStyle::SetMargins(vint fontSize)
			{
				fontSize+=4;
				vint half=fontSize/2;
				sinkBorderComposition->SetAlignmentToParent(Margin(0, half, 1, 1));
				raisedBorderComposition->SetAlignmentToParent(Margin(1, half+1, 0, 0));
				containerComposition->SetAlignmentToParent(Margin(2, fontSize, 2, 2));
				textBackgroundComposition->SetAlignmentToParent(Margin(half, 2, -1, -1));
			}

			Win7GroupBoxStyle::Win7GroupBoxStyle()
			{
				boundsComposition=new GuiBoundsComposition;
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win7GetSystemWindowColor());

					boundsComposition->SetOwnedElement(element);
					boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}

				sinkBorderComposition=new GuiBoundsComposition;
				{
					GuiRoundBorderElement* element=GuiRoundBorderElement::Create();
					element->SetRadius(3);
					element->SetColor(Color(213, 223, 229));

					sinkBorderComposition->SetOwnedElement(element);
					boundsComposition->AddChild(sinkBorderComposition);
				}

				raisedBorderComposition=new GuiBoundsComposition;
				{
					GuiRoundBorderElement* element=GuiRoundBorderElement::Create();
					element->SetRadius(3);
					element->SetColor(Color(255, 255, 255));

					raisedBorderComposition->SetOwnedElement(element);
					boundsComposition->AddChild(raisedBorderComposition);
				}

				textBackgroundComposition=new GuiBoundsComposition;
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win7GetSystemWindowColor());

					textBackgroundComposition->SetOwnedElement(element);
					textBackgroundComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					boundsComposition->AddChild(textBackgroundComposition);
				}

				textComposition=new GuiBoundsComposition;
				{
					GuiSolidLabelElement* element=GuiSolidLabelElement::Create();
					element->SetColor(Win7GetSystemTextColor(true));
					textElement=element;

					textComposition->SetOwnedElement(element);
					textComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					textComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
					textBackgroundComposition->AddChild(textComposition);
				}

				containerComposition=new GuiBoundsComposition;
				{
					boundsComposition->AddChild(containerComposition);
				}

				SetMargins(0);
				transferringAnimation=new TransferringAnimation(this, Win7GetSystemTextColor(true));
			}

			Win7GroupBoxStyle::~Win7GroupBoxStyle()
			{
				transferringAnimation->Disable();
			}

			compositions::GuiBoundsComposition* Win7GroupBoxStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7GroupBoxStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win7GroupBoxStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7GroupBoxStyle::SetText(const WString& value)
			{
				textElement->SetText(value);
			}

			void Win7GroupBoxStyle::SetFont(const FontProperties& value)
			{
				textElement->SetFont(value);
				SetMargins(value.size);
			}

			void Win7GroupBoxStyle::SetVisuallyEnabled(bool value)
			{
				if(value)
				{
					transferringAnimation->Transfer(Win7GetSystemTextColor(true));
				}
				else
				{
					transferringAnimation->Transfer(Win7GetSystemTextColor(false));
				}
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win7Styles\GuiWin7ListStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7SelectableItemStyle
***********************************************************************/

			void Win7SelectableItemStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				if(!enabled)
				{
					transferringAnimation->Transfer(Win7ButtonColors::ItemDisabled());
				}
				else if(selected)
				{
					transferringAnimation->Transfer(Win7ButtonColors::ItemSelected());
				}
				else
				{
					switch(value)
					{
					case GuiButton::Normal:
						transferringAnimation->Transfer(Win7ButtonColors::ItemNormal());
						break;
					case GuiButton::Active:
						transferringAnimation->Transfer(Win7ButtonColors::ItemActive());
						break;
					case GuiButton::Pressed:
						transferringAnimation->Transfer(Win7ButtonColors::ItemSelected());
						break;
					}
				}
			}

			Win7SelectableItemStyle::Win7SelectableItemStyle()
				:Win7ButtonStyleBase(true, true, Win7ButtonColors::ItemNormal(), Alignment::Left, Alignment::Center)
			{
				transferringAnimation->SetEnableAnimation(false);
			}

			Win7SelectableItemStyle::~Win7SelectableItemStyle()
			{
			}

/***********************************************************************
Win7ListViewColumnDropDownStyle
***********************************************************************/

			void Win7ListViewColumnDropDownStyle::TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)
			{
				if(!enabled) value=GuiButton::Normal;
				switch(value)
				{
				case GuiButton::Normal:
					{
						leftBorderComposition->SetVisible(true);
						borderComposition->SetVisible(false);
						gradientComposition->SetVisible(false);

						leftBorderElement->SetColors(Color(223, 234, 247), Color(252, 252, 252));
					}
					break;
				case GuiButton::Active:
				case GuiButton::Pressed:
					{
						leftBorderComposition->SetVisible(false);
						borderComposition->SetVisible(true);
						gradientComposition->SetVisible(true);

						borderElement->SetColor(Color(192, 203, 217));
						gradientElement->SetColors(Color(230, 241, 255), Color(224, 226, 253));
					}
					break;
				}
			}

			Win7ListViewColumnDropDownStyle::Win7ListViewColumnDropDownStyle()
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isSelected(false)
			{
				mainComposition=new GuiBoundsComposition;
				mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

				leftBorderElement=GuiGradientBackgroundElement::Create();
				leftBorderElement->SetDirection(GuiGradientBackgroundElement::Vertical);
				leftBorderComposition=new GuiBoundsComposition;
				leftBorderComposition->SetOwnedElement(leftBorderElement);
				leftBorderComposition->SetAlignmentToParent(Margin(0, 1, -1, 1));
				leftBorderComposition->SetPreferredMinSize(Size(1, 1));
				mainComposition->AddChild(leftBorderComposition);

				borderElement=GuiSolidBorderElement::Create();
				borderComposition=new GuiBoundsComposition;
				borderComposition->SetOwnedElement(borderElement);
				borderComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				mainComposition->AddChild(borderComposition);

				gradientElement=GuiGradientBackgroundElement::Create();
				gradientElement->SetDirection(GuiGradientBackgroundElement::Vertical);
				gradientComposition=new GuiBoundsComposition;
				gradientComposition->SetOwnedElement(gradientElement);
				gradientComposition->SetAlignmentToParent(Margin(2, 2, 2, 2));
				gradientComposition->SetPreferredMinSize(Size(0, 4));
				mainComposition->AddChild(gradientComposition);

				arrowElement=common_styles::CommonFragmentBuilder::BuildDownArrow();
				arrowElement->SetBackgroundColor(Color(76, 96, 122));
				arrowElement->SetBorderColor(Color(76, 96, 122));
				arrowComposition=new GuiBoundsComposition;
				arrowComposition->SetOwnedElement(arrowElement);
				arrowComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				arrowComposition->SetAlignmentToParent(Margin(3, 3, 3, 3));
				mainComposition->AddChild(arrowComposition);

				TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
			}

			Win7ListViewColumnDropDownStyle::~Win7ListViewColumnDropDownStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7ListViewColumnDropDownStyle::GetBoundsComposition()
			{
				return mainComposition;
			}

			compositions::GuiGraphicsComposition* Win7ListViewColumnDropDownStyle::GetContainerComposition()
			{
				return mainComposition;
			}

			void Win7ListViewColumnDropDownStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7ListViewColumnDropDownStyle::SetText(const WString& value)
			{
			}

			void Win7ListViewColumnDropDownStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7ListViewColumnDropDownStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win7ListViewColumnDropDownStyle::SetSelected(bool value)
			{
				if(isSelected!=value)
				{
					isSelected=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win7ListViewColumnDropDownStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

/***********************************************************************
Win7ListViewColumnHeaderStyle
***********************************************************************/

			void Win7ListViewColumnHeaderStyle::TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool subMenuExisting, bool subMenuOpening)
			{
				if(!enabled) value=GuiButton::Normal;
				switch(value)
				{
				case GuiButton::Normal:
					{
						rightBorderComposition->SetVisible(true);
						borderComposition->SetVisible(false);
						gradientComposition->SetVisible(false);

						backgroundElement->SetColor(Color(252, 252, 252));
						rightBorderElement->SetColors(Color(223, 234, 247), Color(252, 252, 252));

						dropdownButton->SetVisible(subMenuOpening);
					}
					break;
				case GuiButton::Active:
					{
						rightBorderComposition->SetVisible(false);
						borderComposition->SetVisible(true);
						gradientComposition->SetVisible(true);
						gradientComposition->SetAlignmentToParent(Margin(2, 2, 2, 2));

						backgroundElement->SetColor(Color(252, 252, 252));
						borderElement->SetColor(Color(223, 233, 246));
						gradientElement->SetColors(Color(243, 248, 253), Color(239, 243, 249));

						dropdownButton->SetVisible(isSubMenuExisting);
					}
					break;
				case GuiButton::Pressed:
					{
						rightBorderComposition->SetVisible(false);
						borderComposition->SetVisible(true);
						gradientComposition->SetVisible(true);
						gradientComposition->SetAlignmentToParent(Margin(1, 0, 1, -1));

						backgroundElement->SetColor(Color(246, 247, 248));
						borderElement->SetColor(Color(192, 203, 217));
						gradientElement->SetColors(Color(193, 204, 218), Color(252, 252, 252));

						dropdownButton->SetVisible(isSubMenuExisting);
					}
					break;
				}
			}

			Win7ListViewColumnHeaderStyle::Win7ListViewColumnHeaderStyle()
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isSubMenuExisting(false)
				,isSubMenuOpening(false)
			{
				backgroundElement=GuiSolidBackgroundElement::Create();
				mainComposition=new GuiBoundsComposition;
				mainComposition->SetOwnedElement(backgroundElement);
				mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

				rightBorderElement=GuiGradientBackgroundElement::Create();
				rightBorderElement->SetDirection(GuiGradientBackgroundElement::Vertical);
				rightBorderComposition=new GuiBoundsComposition;
				rightBorderComposition->SetOwnedElement(rightBorderElement);
				rightBorderComposition->SetAlignmentToParent(Margin(-1, 0, 0, 0));
				rightBorderComposition->SetPreferredMinSize(Size(1, 1));
				mainComposition->AddChild(rightBorderComposition);

				borderElement=GuiSolidBorderElement::Create();
				borderComposition=new GuiBoundsComposition;
				borderComposition->SetOwnedElement(borderElement);
				borderComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				mainComposition->AddChild(borderComposition);

				gradientElement=GuiGradientBackgroundElement::Create();
				gradientElement->SetDirection(GuiGradientBackgroundElement::Vertical);
				gradientComposition=new GuiBoundsComposition;
				gradientComposition->SetOwnedElement(gradientElement);
				gradientComposition->SetAlignmentToParent(Margin(2, 2, 2, 2));
				gradientComposition->SetPreferredMinSize(Size(0, 4));
				mainComposition->AddChild(gradientComposition);

				textElement=GuiSolidLabelElement::Create();
				textElement->SetColor(Color(76, 96, 122));
				textComposition=new GuiBoundsComposition;
				textComposition->SetOwnedElement(textElement);
				textComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				textComposition->SetAlignmentToParent(Margin(15, 7, 18, 5));
				mainComposition->AddChild(textComposition);

				arrowElement=GuiPolygonElement::Create();
				arrowElement->SetBackgroundColor(Color(76, 96, 122));
				arrowElement->SetBorderColor(Color(76, 96, 122));
				arrowComposition=new GuiBoundsComposition;
				arrowComposition->SetOwnedElement(arrowElement);
				arrowComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				arrowComposition->SetAlignmentToParent(Margin(0, 2, 0, -1));
				mainComposition->AddChild(arrowComposition);

				dropdownButton=new GuiButton(new Win7ListViewColumnDropDownStyle);
				dropdownButton->GetBoundsComposition()->SetAlignmentToParent(Margin(-1, 0, 0, 0));
				dropdownButton->SetVisible(false);
				mainComposition->AddChild(dropdownButton->GetBoundsComposition());

				TransferInternal(controlStyle, isVisuallyEnabled, isSubMenuExisting, isSubMenuOpening);
			}

			Win7ListViewColumnHeaderStyle::~Win7ListViewColumnHeaderStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7ListViewColumnHeaderStyle::GetBoundsComposition()
			{
				return mainComposition;
			}

			compositions::GuiGraphicsComposition* Win7ListViewColumnHeaderStyle::GetContainerComposition()
			{
				return mainComposition;
			}

			void Win7ListViewColumnHeaderStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7ListViewColumnHeaderStyle::SetText(const WString& value)
			{
				textElement->SetText(value);
			}

			void Win7ListViewColumnHeaderStyle::SetFont(const FontProperties& value)
			{
				textElement->SetFont(value);
			}

			void Win7ListViewColumnHeaderStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSubMenuExisting, isSubMenuOpening);
				}
			}

			void Win7ListViewColumnHeaderStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSubMenuExisting, isSubMenuOpening);
				}
			}

			controls::GuiMenu::IStyleController* Win7ListViewColumnHeaderStyle::CreateSubMenuStyleController()
			{
				return new Win7MenuStyle;
			}

			void Win7ListViewColumnHeaderStyle::SetSubMenuExisting(bool value)
			{
				if(isSubMenuExisting!=value)
				{
					isSubMenuExisting=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSubMenuExisting, isSubMenuOpening);
				}
			}

			void Win7ListViewColumnHeaderStyle::SetSubMenuOpening(bool value)
			{
				if(isSubMenuOpening!=value)
				{
					isSubMenuOpening=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSubMenuExisting, isSubMenuOpening);
				}
			}

			controls::GuiButton* Win7ListViewColumnHeaderStyle::GetSubMenuHost()
			{
				return dropdownButton;
			}

			void Win7ListViewColumnHeaderStyle::SetImage(Ptr<controls::GuiImageData> value)
			{
			}

			void Win7ListViewColumnHeaderStyle::SetShortcutText(const WString& value)
			{
			}

			compositions::GuiSubComponentMeasurer::IMeasuringSource* Win7ListViewColumnHeaderStyle::GetMeasuringSource()
			{
				return 0;
			}

			void Win7ListViewColumnHeaderStyle::SetColumnSortingState(controls::GuiListViewColumnHeader::ColumnSortingState value)
			{
				Margin margin=arrowComposition->GetAlignmentToParent();
				switch(value)
				{
				case controls::GuiListViewColumnHeader::NotSorted:
					arrowElement->SetPoints(0, 0);
					break;
				case controls::GuiListViewColumnHeader::Ascending:
					common_styles::CommonFragmentBuilder::FillUpArrow(arrowElement);
					break;
				case controls::GuiListViewColumnHeader::Descending:
					common_styles::CommonFragmentBuilder::FillDownArrow(arrowElement);
					break;
				}
			}

/***********************************************************************
Win7TreeViewExpandingButtonStyle
***********************************************************************/

			void Win7TreeViewExpandingButtonStyle::TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)
			{
				bool expanding=false;
				bool activated=false;
				if(isVisuallyEnabled)
				{
					expanding=selected;
					activated=value!=GuiButton::Normal;
				}

				Point points[3];
				if(expanding)
				{
					points[0]=Point(5, 2);
					points[1]=Point(5, 7);
					points[2]=Point(0, 7);
				}
				else
				{
					points[0]=Point(0, 1);
					points[1]=Point(4, 5);
					points[2]=Point(0, 9);
				}
				polygonElement->SetPoints(points, sizeof(points)/sizeof(*points));

				if(activated)
				{
					polygonElement->SetBorderColor(Color(28, 196, 247));
					polygonElement->SetBackgroundColor(Color(130, 223, 251));
				}
				else if(expanding)
				{
					polygonElement->SetBorderColor(Color(38, 38, 38));
					polygonElement->SetBackgroundColor(Color(89, 89, 89));
				}
				else
				{
					polygonElement->SetBorderColor(Color(166, 166, 166));
					polygonElement->SetBackgroundColor(Color(255, 255, 255));
				}
			}

			Win7TreeViewExpandingButtonStyle::Win7TreeViewExpandingButtonStyle()
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isSelected(false)
			{
				polygonElement=GuiPolygonElement::Create();
				polygonElement->SetSize(Size(6, 11));

				mainComposition=new GuiBoundsComposition;
				mainComposition->SetOwnedElement(polygonElement);
				mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);

				TransferInternal(controlStyle, true, isSelected);
			}

			Win7TreeViewExpandingButtonStyle::~Win7TreeViewExpandingButtonStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7TreeViewExpandingButtonStyle::GetBoundsComposition()
			{
				return mainComposition;
			}

			compositions::GuiGraphicsComposition* Win7TreeViewExpandingButtonStyle::GetContainerComposition()
			{
				return mainComposition;
			}

			void Win7TreeViewExpandingButtonStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7TreeViewExpandingButtonStyle::SetText(const WString& value)
			{
			}

			void Win7TreeViewExpandingButtonStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7TreeViewExpandingButtonStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win7TreeViewExpandingButtonStyle::SetSelected(bool value)
			{
				if(isSelected!=value)
				{
					isSelected=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win7TreeViewExpandingButtonStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

/***********************************************************************
Win7DropDownComboBoxStyle
***********************************************************************/

			void Win7DropDownComboBoxStyle::TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)
			{
				Win7ButtonColors targetColor;
				if(enabled)
				{
					if(selected) value=GuiButton::Pressed;
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win7ButtonColors::ButtonNormal();
						break;
					case GuiButton::Active:
						targetColor=Win7ButtonColors::ButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win7ButtonColors::ButtonPressed();
						break;
					}
				}
				else
				{
					targetColor=Win7ButtonColors::ButtonDisabled();
				}
				transferringAnimation->Transfer(targetColor);
			}

			void Win7DropDownComboBoxStyle::AfterApplyColors(const Win7ButtonColors& colors)
			{
				Win7ButtonStyle::AfterApplyColors(colors);
				dropDownElement->SetBorderColor(colors.textColor);
				dropDownElement->SetBackgroundColor(colors.textColor);
			}

			Win7DropDownComboBoxStyle::Win7DropDownComboBoxStyle()
				:Win7ButtonStyle(true)
				,commandExecutor(0)
			{
				table=new GuiTableComposition;
				table->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				table->SetAlignmentToParent(Margin(0, 0, 0, 0));
				table->SetRowsAndColumns(3, 2);
				table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
				table->SetRowOption(1, GuiCellOption::MinSizeOption());
				table->SetRowOption(2, GuiCellOption::PercentageOption(1.0));
				table->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
				table->SetColumnOption(1, GuiCellOption::MinSizeOption());
				elements.textComposition->AddChild(table);
				elements.textComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

				textComposition=new GuiCellComposition;
				table->AddChild(textComposition);
				textComposition->SetSite(1, 0, 1, 1);

				Ptr<IGuiGraphicsElement> element=elements.textComposition->GetOwnedElement();
				elements.textComposition->SetOwnedElement(0);
				textComposition->SetOwnedElement(element);
				elements.textElement->SetEllipse(true);
				elements.textElement->SetAlignments(Alignment::Left, Alignment::Center);

				dropDownElement=common_styles::CommonFragmentBuilder::BuildDownArrow();

				dropDownComposition=new GuiCellComposition;
				table->AddChild(dropDownComposition);
				dropDownComposition->SetSite(1, 1, 1, 1);
				dropDownComposition->SetOwnedElement(dropDownElement);
				dropDownComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				dropDownComposition->SetMargin(Margin(3, 0, 3, 0));
			}

			Win7DropDownComboBoxStyle::~Win7DropDownComboBoxStyle()
			{
			}

			compositions::GuiGraphicsComposition* Win7DropDownComboBoxStyle::GetContainerComposition()
			{
				return textComposition;
			}

			void Win7DropDownComboBoxStyle::SetCommandExecutor(controls::GuiComboBoxBase::ICommandExecutor* value)
			{
				commandExecutor=value;
			}

			void Win7DropDownComboBoxStyle::OnClicked()
			{
				commandExecutor->ShowPopup();
			}

			void Win7DropDownComboBoxStyle::OnPopupOpened()
			{
				SetSelected(true);
			}

			void Win7DropDownComboBoxStyle::OnPopupClosed()
			{
				SetSelected(false);
			}

			void Win7DropDownComboBoxStyle::OnItemSelected()
			{
			}

			controls::GuiWindow::IStyleController* Win7DropDownComboBoxStyle::CreatePopupStyle()
			{
				return new Win7WindowStyle;
			}

/***********************************************************************
Win7TextListProvider
***********************************************************************/
			
			Win7TextListProvider::Win7TextListProvider()
			{
			}

			Win7TextListProvider::~Win7TextListProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win7TextListProvider::CreateBackgroundStyleController()
			{
				return new Win7SelectableItemStyle;
			}

			controls::GuiSelectableButton::IStyleController* Win7TextListProvider::CreateBulletStyleController()
			{
				return 0;
			}

/***********************************************************************
Win7CheckTextListProvider
***********************************************************************/

			Win7CheckTextListProvider::Win7CheckTextListProvider()
			{
			}

			Win7CheckTextListProvider::~Win7CheckTextListProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win7CheckTextListProvider::CreateBulletStyleController()
			{
				return new Win7CheckBoxStyle(Win7CheckBoxStyle::CheckBox, false);
			}

/***********************************************************************
Win7RadioTextListProvider
***********************************************************************/

			Win7RadioTextListProvider::Win7RadioTextListProvider()
			{
			}

			Win7RadioTextListProvider::~Win7RadioTextListProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win7RadioTextListProvider::CreateBulletStyleController()
			{
				return new Win7CheckBoxStyle(Win7CheckBoxStyle::RadioButton, false);
			}

/***********************************************************************
Win7ListViewProvider
***********************************************************************/

			Win7ListViewProvider::Win7ListViewProvider()
			{
			}

			Win7ListViewProvider::~Win7ListViewProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win7ListViewProvider::CreateItemBackground()
			{
				return new Win7SelectableItemStyle;
			}

			controls::GuiListViewColumnHeader::IStyleController* Win7ListViewProvider::CreateColumnStyle()
			{
				return new Win7ListViewColumnHeaderStyle;
			}

			Color Win7ListViewProvider::GetPrimaryTextColor()
			{
				return Win7GetSystemTextColor(true);
			}

			Color Win7ListViewProvider::GetSecondaryTextColor()
			{
				return Win7GetSystemTextColor(false);
			}

			Color Win7ListViewProvider::GetItemSeparatorColor()
			{
				return Color(220, 220, 220);
			}

/***********************************************************************
Win7TreeViewProvider
***********************************************************************/

			Win7TreeViewProvider::Win7TreeViewProvider()
			{
			}

			Win7TreeViewProvider::~Win7TreeViewProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win7TreeViewProvider::CreateItemBackground()
			{
				return new Win7SelectableItemStyle;
			}

			controls::GuiSelectableButton::IStyleController* Win7TreeViewProvider::CreateItemExpandingDecorator()
			{
				return new Win7TreeViewExpandingButtonStyle;
			}

			Color Win7TreeViewProvider::GetTextColor()
			{
				return Win7GetSystemTextColor(true);
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win7Styles\GuiWin7MenuStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7MenuStyle
***********************************************************************/

			Win7MenuStyle::Win7MenuStyle()
			{
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					element->SetColor(Color(151, 151, 151));
					boundsComposition=new GuiBoundsComposition;
					boundsComposition->SetOwnedElement(element);
				}
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Color(245, 245, 245));
					GuiBoundsComposition* subBorder=new GuiBoundsComposition;
					subBorder->SetOwnedElement(element);
					subBorder->SetAlignmentToParent(Margin(1, 1, 1, 1));
					boundsComposition->AddChild(subBorder);
				}
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win7GetSystemWindowColor());
					containerComposition=new GuiBoundsComposition;
					containerComposition->SetOwnedElement(element);
					containerComposition->SetAlignmentToParent(Margin(3, 3, 3, 3));
					containerComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					boundsComposition->AddChild(containerComposition);
				}
			}

			Win7MenuStyle::~Win7MenuStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7MenuStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7MenuStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win7MenuStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7MenuStyle::SetText(const WString& value)
			{
			}

			void Win7MenuStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7MenuStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win7MenuBarStyle
***********************************************************************/

			Win7MenuBarStyle::Win7MenuBarStyle()
			{
				GuiTableComposition* table=new GuiTableComposition;
				table->SetAlignmentToParent(Margin(0, 0, 0, 1));
				table->SetRowsAndColumns(2, 1);
				table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
				table->SetRowOption(1, GuiCellOption::PercentageOption(0.5));
				table->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
				{
					GuiGradientBackgroundElement* gradient=GuiGradientBackgroundElement::Create();
					gradient->SetDirection(GuiGradientBackgroundElement::Vertical);
					gradient->SetColors(Color(252, 253, 254), Color(229, 234, 245));

					GuiCellComposition* cell=new GuiCellComposition;
					table->AddChild(cell);
					cell->SetSite(0, 0, 1, 1);
					cell->SetOwnedElement(gradient);
				}
				{
					GuiGradientBackgroundElement* gradient=GuiGradientBackgroundElement::Create();
					gradient->SetDirection(GuiGradientBackgroundElement::Vertical);
					gradient->SetColors(Color(212, 219, 237), Color(225, 230, 246));

					GuiCellComposition* cell=new GuiCellComposition;
					table->AddChild(cell);
					cell->SetSite(1, 0, 1, 1);
					cell->SetOwnedElement(gradient);
				}

				boundsComposition=new GuiBoundsComposition;
				{
					GuiSolidBackgroundElement* solid=GuiSolidBackgroundElement::Create();
					solid->SetColor(Color(182, 188, 204));
					boundsComposition->SetOwnedElement(solid);
					boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				boundsComposition->AddChild(table);
			}

			Win7MenuBarStyle::~Win7MenuBarStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7MenuBarStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7MenuBarStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win7MenuBarStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7MenuBarStyle::SetText(const WString& value)
			{
			}

			void Win7MenuBarStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7MenuBarStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win7MenuBarButtonStyle
***********************************************************************/

			void Win7MenuBarButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool opening)
			{
				Win7ButtonColors targetColor;
				if(!enabled)
				{
					targetColor=Win7ButtonColors::MenuBarButtonDisabled();
					targetColor.SetAlphaWithoutText(0);
				}
				else if(opening)
				{
					targetColor=Win7ButtonColors::MenuBarButtonPressed();
				}
				else
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win7ButtonColors::MenuBarButtonNormal();
						targetColor.SetAlphaWithoutText(0);
						break;
					case GuiButton::Active:
						targetColor=Win7ButtonColors::MenuBarButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win7ButtonColors::MenuBarButtonPressed();
						break;
					}
				}
				elements.Apply(targetColor);
			}

			Win7MenuBarButtonStyle::Win7MenuBarButtonStyle()
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isOpening(false)
			{
				Win7ButtonColors initialColor=Win7ButtonColors::MenuBarButtonNormal();
				initialColor.SetAlphaWithoutText(0);

				elements=Win7ButtonElements::Create(true, true, Alignment::Center, Alignment::Center);
				elements.Apply(initialColor);
			}

			Win7MenuBarButtonStyle::~Win7MenuBarButtonStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7MenuBarButtonStyle::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win7MenuBarButtonStyle::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win7MenuBarButtonStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7MenuBarButtonStyle::SetText(const WString& value)
			{
				elements.textElement->SetText(value);
			}

			void Win7MenuBarButtonStyle::SetFont(const FontProperties& value)
			{
				Win7SetFont(elements.textElement, elements.textComposition, value);
				Margin margin=elements.textComposition->GetMargin();
				margin.left*=3;
				margin.right*=3;
				elements.textComposition->SetMargin(margin);
			}

			void Win7MenuBarButtonStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiMenu::IStyleController* Win7MenuBarButtonStyle::CreateSubMenuStyleController()
			{
				return new Win7MenuStyle;
			}

			void Win7MenuBarButtonStyle::SetSubMenuExisting(bool value)
			{
			}

			void Win7MenuBarButtonStyle::SetSubMenuOpening(bool value)
			{
				if(isOpening!=value)
				{
					isOpening=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiButton* Win7MenuBarButtonStyle::GetSubMenuHost()
			{
				return 0;
			}

			void Win7MenuBarButtonStyle::SetImage(Ptr<controls::GuiImageData> value)
			{
			}

			void Win7MenuBarButtonStyle::SetShortcutText(const WString& value)
			{
			}

			compositions::GuiSubComponentMeasurer::IMeasuringSource* Win7MenuBarButtonStyle::GetMeasuringSource()
			{
				return 0;
			}

			void Win7MenuBarButtonStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

/***********************************************************************
Win7MenuItemButtonStyle::MeasuringSource
***********************************************************************/

			Win7MenuItemButtonStyle::MeasuringSource::MeasuringSource(Win7MenuItemButtonStyle* _style)
				:GuiSubComponentMeasurer::MeasuringSource(GuiMenuButton::MenuItemSubComponentMeasuringCategoryName, _style->elements.mainComposition)
				,style(_style)
			{
				AddSubComponent(L"text", style->elements.textComposition);
				AddSubComponent(L"shortcut", style->elements.shortcutComposition);
			}

			Win7MenuItemButtonStyle::MeasuringSource::~MeasuringSource()
			{
			}

			void Win7MenuItemButtonStyle::MeasuringSource::SubComponentPreferredMinSizeUpdated()
			{
				GetMainComposition()->ForceCalculateSizeImmediately();
			}

/***********************************************************************
Win7MenuItemButtonStyle
***********************************************************************/

			void Win7MenuItemButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool opening)
			{
				Win7ButtonColors targetColor;
				bool active=false;
				if(enabled)
				{
					if(opening)
					{
						targetColor=Win7ButtonColors::MenuItemButtonNormalActive();
						active=true;
					}
					else
					{
						switch(value)
						{
						case GuiButton::Normal:
							targetColor=Win7ButtonColors::MenuItemButtonNormal();
							break;
						case GuiButton::Active:
						case GuiButton::Pressed:
							targetColor=Win7ButtonColors::MenuItemButtonNormalActive();
							active=true;
							break;
						}
					}
				}
				else
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win7ButtonColors::MenuItemButtonDisabled();
						break;
					case GuiButton::Active:
					case GuiButton::Pressed:
						targetColor=Win7ButtonColors::MenuItemButtonDisabledActive();
						active=true;
						break;
					}
				}
				elements.Apply(targetColor);
				elements.SetActive(active);
			}

			Win7MenuItemButtonStyle::Win7MenuItemButtonStyle()
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isOpening(false)
			{
				elements=Win7MenuItemButtonElements::Create();
				elements.Apply(Win7ButtonColors::MenuItemButtonNormal());
				measuringSource=new MeasuringSource(this);
			}

			Win7MenuItemButtonStyle::~Win7MenuItemButtonStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7MenuItemButtonStyle::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win7MenuItemButtonStyle::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win7MenuItemButtonStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7MenuItemButtonStyle::SetText(const WString& value)
			{
				elements.textElement->SetText(value);
			}

			void Win7MenuItemButtonStyle::SetFont(const FontProperties& value)
			{
				Win7SetFont(elements.textElement, elements.textComposition, value);
				Win7SetFont(elements.shortcutElement, elements.shortcutComposition, value);
			}

			void Win7MenuItemButtonStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					elements.imageElement->SetEnabled(value);
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiMenu::IStyleController* Win7MenuItemButtonStyle::CreateSubMenuStyleController()
			{
				return new Win7MenuStyle;
			}

			void Win7MenuItemButtonStyle::SetSubMenuExisting(bool value)
			{
				elements.SetSubMenuExisting(value);
			}

			void Win7MenuItemButtonStyle::SetSubMenuOpening(bool value)
			{
				if(isOpening!=value)
				{
					isOpening=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiButton* Win7MenuItemButtonStyle::GetSubMenuHost()
			{
				return 0;
			}

			void Win7MenuItemButtonStyle::SetImage(Ptr<controls::GuiImageData> value)
			{
				if(value)
				{
					elements.imageElement->SetImage(value->GetImage(), value->GetFrameIndex());
				}
				else
				{
					elements.imageElement->SetImage(0, 0);
				}
			}

			void Win7MenuItemButtonStyle::SetShortcutText(const WString& value)
			{
				elements.shortcutElement->SetText(value);
			}

			compositions::GuiSubComponentMeasurer::IMeasuringSource* Win7MenuItemButtonStyle::GetMeasuringSource()
			{
				return measuringSource.Obj();
			}

			void Win7MenuItemButtonStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

/***********************************************************************
Win7MenuSplitterStyle
***********************************************************************/

			Win7MenuSplitterStyle::Win7MenuSplitterStyle()
			{
				Color dark=Win7GetSystemBorderSinkColor();
				Color bright=Win7GetSystemBorderRaiseColor();

				GuiTableComposition* table=new GuiTableComposition;
				table->SetAlignmentToParent(Margin(0, 0, 0, 0));
				table->SetRowsAndColumns(1, 3);
				table->SetPreferredMinSize(Size(0, 6));

				table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
				table->SetColumnOption(0, GuiCellOption::AbsoluteOption(26));
				table->SetColumnOption(1, GuiCellOption::AbsoluteOption(2));
				table->SetColumnOption(2, GuiCellOption::MinSizeOption());

				{
					GuiCellComposition* cell=new GuiCellComposition;
					table->AddChild(cell);
					cell->SetSite(0, 1, 1, 1);

					Gui3DSplitterElement* element=Gui3DSplitterElement::Create();
					element->SetDirection(Gui3DSplitterElement::Vertical);
					element->SetColors(dark, bright);
					cell->SetOwnedElement(element);
				}
				{
					GuiCellComposition* cell=new GuiCellComposition;
					table->AddChild(cell);
					cell->SetSite(0, 2, 1, 1);

					Gui3DSplitterElement* element=Gui3DSplitterElement::Create();
					element->SetDirection(Gui3DSplitterElement::Horizontal);
					element->SetColors(dark, bright);
					cell->SetOwnedElement(element);
				}
				boundsComposition=table;
			}

			Win7MenuSplitterStyle::~Win7MenuSplitterStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7MenuSplitterStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7MenuSplitterStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win7MenuSplitterStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7MenuSplitterStyle::SetText(const WString& value)
			{
			}

			void Win7MenuSplitterStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7MenuSplitterStyle::SetVisuallyEnabled(bool value)
			{
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win7Styles\GuiWin7ScrollableStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7ButtonStyle
***********************************************************************/

			void Win7ScrollArrowButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				Win7ButtonColors targetColor;
				if(enabled)
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win7ButtonColors::ButtonNormal();
						targetColor.SetAlphaWithoutText(0);
						break;
					case GuiButton::Active:
						targetColor=Win7ButtonColors::ButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win7ButtonColors::ButtonPressed();
						break;
					}
				}
				else
				{
					targetColor=Win7ButtonColors::ButtonDisabled();
					targetColor.SetAlphaWithoutText(0);
				}
				transferringAnimation->Transfer(targetColor);
			}

			void Win7ScrollArrowButtonStyle::AfterApplyColors(const Win7ButtonColors& colors)
			{
				Win7ButtonStyleBase::AfterApplyColors(colors);
				arrowElement->SetBorderColor(colors.textColor);
				arrowElement->SetBackgroundColor(colors.textColor);
			}

			Win7ScrollArrowButtonStyle::Win7ScrollArrowButtonStyle(common_styles::CommonScrollStyle::Direction direction, bool increaseButton)
				:Win7ButtonStyleBase(direction==common_styles::CommonScrollStyle::Horizontal, true, Win7ButtonColors::ButtonNormal(), Alignment::Center, Alignment::Center)
			{
				switch(direction)
				{
				case common_styles::CommonScrollStyle::Horizontal:
					if(increaseButton)
					{
						GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildRightArrow(arrowElement));
					}
					else
					{
						GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildLeftArrow(arrowElement));
					}
					break;
				case common_styles::CommonScrollStyle::Vertical:
					if(increaseButton)
					{
						GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildDownArrow(arrowElement));
					}
					else
					{
						GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildUpArrow(arrowElement));
					}
					break;
				}
			}

			Win7ScrollArrowButtonStyle::~Win7ScrollArrowButtonStyle()
			{
			}

/***********************************************************************
Win7ScrollStyle
***********************************************************************/

			controls::GuiButton::IStyleController* Win7ScrollStyle::CreateDecreaseButtonStyle(Direction direction)
			{
				Win7ScrollArrowButtonStyle* decreaseButtonStyle=new Win7ScrollArrowButtonStyle(direction, false);
				return decreaseButtonStyle;
			}

			controls::GuiButton::IStyleController* Win7ScrollStyle::CreateIncreaseButtonStyle(Direction direction)
			{
				Win7ScrollArrowButtonStyle* increaseButtonStyle=new Win7ScrollArrowButtonStyle(direction, true);
				return increaseButtonStyle;
			}

			controls::GuiButton::IStyleController* Win7ScrollStyle::CreateHandleButtonStyle(Direction direction)
			{
				Win7ButtonStyle* handleButtonStyle=new Win7ButtonStyle(direction==Horizontal);
				handleButtonStyle->SetTransparentWhenDisabled(true);
				return handleButtonStyle;
			}

			compositions::GuiBoundsComposition* Win7ScrollStyle::InstallBackground(compositions::GuiBoundsComposition* boundsComposition, Direction direction)
			{
				Color sinkColor=Win7GetSystemBorderSinkColor();
				GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
				element->SetColor(Win7GetSystemWindowColor());
				boundsComposition->SetOwnedElement(element);

				{
					GuiSideAlignedComposition* composition=new GuiSideAlignedComposition;
					composition->SetMaxLength(DefaultSize);
					composition->SetMaxRatio(0.2);
					boundsComposition->AddChild(composition);

					GuiGradientBackgroundElement* gradient=GuiGradientBackgroundElement::Create();
					gradient->SetColors(sinkColor, Win7GetSystemWindowColor());
					composition->SetOwnedElement(gradient);

					switch(direction)
					{
					case Horizontal:
						composition->SetDirection(GuiSideAlignedComposition::Top);
						gradient->SetDirection(GuiGradientBackgroundElement::Vertical);
						break;
					case Vertical:
						composition->SetDirection(GuiSideAlignedComposition::Left);
						gradient->SetDirection(GuiGradientBackgroundElement::Horizontal);
						break;
					}
				}
				{
					GuiSideAlignedComposition* composition=new GuiSideAlignedComposition;
					composition->SetMaxLength(DefaultSize);
					composition->SetMaxRatio(0.2);
					boundsComposition->AddChild(composition);

					GuiGradientBackgroundElement* gradient=GuiGradientBackgroundElement::Create();
					gradient->SetColors(Win7GetSystemWindowColor(), sinkColor);
					composition->SetOwnedElement(gradient);

					switch(direction)
					{
					case Horizontal:
						composition->SetDirection(GuiSideAlignedComposition::Bottom);
						gradient->SetDirection(GuiGradientBackgroundElement::Vertical);
						break;
					case Vertical:
						composition->SetDirection(GuiSideAlignedComposition::Right);
						gradient->SetDirection(GuiGradientBackgroundElement::Horizontal);
						break;
					}
				}
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					element->SetColor(sinkColor);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					composition->SetOwnedElement(element);
					boundsComposition->AddChild(composition);
				}

				return boundsComposition;
			}

			Win7ScrollStyle::Win7ScrollStyle(Direction _direction)
				:CommonScrollStyle(_direction)
			{
				BuildStyle(DefaultSize, ArrowSize);
			}

			Win7ScrollStyle::~Win7ScrollStyle()
			{
			}

/***********************************************************************
Win7TrackStyle
***********************************************************************/

			controls::GuiButton::IStyleController* Win7TrackStyle::CreateHandleButtonStyle(Direction direction)
			{
				Win7ButtonStyle* handleButtonStyle=new Win7ButtonStyle(direction==Horizontal);
				return handleButtonStyle;
			}

			void Win7TrackStyle::InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)
			{
				GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
				element->SetColor(Win7GetSystemWindowColor());
				boundsComposition->SetOwnedElement(element);
			}

			void Win7TrackStyle::InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)
			{
				Gui3DBorderElement* element=Gui3DBorderElement::Create();
				element->SetColors(Color(176, 176, 176), Color(252, 252, 252));
				trackComposition->SetOwnedElement(element);
			}

			Win7TrackStyle::Win7TrackStyle(Direction _direction)
				:CommonTrackStyle(_direction)
			{
				BuildStyle(TrackThickness, TrackPadding, HandleLong, HandleShort);
			}

			Win7TrackStyle::~Win7TrackStyle()
			{
			}

/***********************************************************************
Win7ProgressBarStyle
***********************************************************************/

			void Win7ProgressBarStyle::UpdateProgressBar()
			{
				vint max=totalSize-pageSize;
				if(position<0)
				{
					progressComposition->SetWidthPageSize(0);
				}
				else if(position>=max)
				{
					progressComposition->SetWidthPageSize(1);
				}
				else
				{
					progressComposition->SetWidthPageSize((double)position/max);
				}
			}

			void Win7ProgressBarStyle::FillProgressColors(compositions::GuiGraphicsComposition* parent, Color g1, Color g2, Color g3, Color g4, Color g5)
			{
				{
					GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
					element->SetDirection(GuiGradientBackgroundElement::Vertical);
					element->SetColors(g1, g2);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetAlignmentToParent(Margin(0, 0, 0, -1));
					composition->SetPreferredMinSize(Size(0, 6));
					composition->SetOwnedElement(element);
					parent->AddChild(composition);
				}
				{
					GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
					element->SetDirection(GuiGradientBackgroundElement::Vertical);
					element->SetColors(g3, g4);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetAlignmentToParent(Margin(0, 6, 0, 6));
					composition->SetOwnedElement(element);
					parent->AddChild(composition);
				}
				{
					GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
					element->SetDirection(GuiGradientBackgroundElement::Vertical);
					element->SetColors(g4, g5);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetAlignmentToParent(Margin(0, -1, 0, 0));
					composition->SetPreferredMinSize(Size(0, 6));
					composition->SetOwnedElement(element);
					parent->AddChild(composition);
				}
			}

			Win7ProgressBarStyle::Win7ProgressBarStyle()
				:totalSize(1)
				,pageSize(0)
				,position(0)
			{
				{
					boundsComposition=new GuiBoundsComposition;
				}
				{
					containerComposition=new GuiBoundsComposition;
					containerComposition->SetAlignmentToParent(Margin(1, 1, 1, 1));
					boundsComposition->AddChild(containerComposition);
					FillProgressColors(containerComposition, Color(239, 239, 239), Color(218, 218, 218), Color(201, 201, 201), Color(203, 203, 203), Color(213, 213, 213));
				}
				{
					GuiRoundBorderElement* element=GuiRoundBorderElement::Create();
					element->SetColor(Color(178, 178, 178));
					element->SetRadius(2);

					GuiBoundsComposition* borderComposition=new GuiBoundsComposition;
					borderComposition->SetOwnedElement(element);
					borderComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					boundsComposition->AddChild(borderComposition);
				}
				{
					progressComposition=new GuiPartialViewComposition;
					progressComposition->SetWidthRatio(0);
					progressComposition->SetWidthPageSize(0);
					progressComposition->SetHeightRatio(0);
					progressComposition->SetHeightPageSize(1);
					containerComposition->AddChild(progressComposition);
					FillProgressColors(progressComposition, Color(205, 255, 205), Color(156, 238, 172), Color(0, 211, 40), Color(0, 213, 47), Color(74, 232, 93));
				}
			}

			Win7ProgressBarStyle::~Win7ProgressBarStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7ProgressBarStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7ProgressBarStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win7ProgressBarStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7ProgressBarStyle::SetText(const WString& value)
			{
			}

			void Win7ProgressBarStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7ProgressBarStyle::SetVisuallyEnabled(bool value)
			{
			}

			void Win7ProgressBarStyle::SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)
			{
			}

			void Win7ProgressBarStyle::SetTotalSize(vint value)
			{
				totalSize=value;
				UpdateProgressBar();
			}

			void Win7ProgressBarStyle::SetPageSize(vint value)
			{
				pageSize=value;
				UpdateProgressBar();
			}

			void Win7ProgressBarStyle::SetPosition(vint value)
			{
				position=value;
				UpdateProgressBar();
			}

/***********************************************************************
Win7ScrollViewProvider
***********************************************************************/

			Win7ScrollViewProvider::Win7ScrollViewProvider()
			{
			}

			Win7ScrollViewProvider::~Win7ScrollViewProvider()
			{
			}

			void Win7ScrollViewProvider::AssociateStyleController(controls::GuiControl::IStyleController* controller)
			{
			}
			
			void Win7ScrollViewProvider::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7ScrollViewProvider::SetText(const WString& value)
			{
			}

			void Win7ScrollViewProvider::SetFont(const FontProperties& value)
			{
			}

			void Win7ScrollViewProvider::SetVisuallyEnabled(bool value)
			{
			}

			controls::GuiScroll::IStyleController* Win7ScrollViewProvider::CreateHorizontalScrollStyle()
			{
				return new Win7ScrollStyle(Win7ScrollStyle::Horizontal);
			}

			controls::GuiScroll::IStyleController* Win7ScrollViewProvider::CreateVerticalScrollStyle()
			{
				return new Win7ScrollStyle(Win7ScrollStyle::Vertical);
			}

			vint Win7ScrollViewProvider::GetDefaultScrollSize()
			{
				return Win7ScrollStyle::DefaultSize;
			}

			compositions::GuiGraphicsComposition* Win7ScrollViewProvider::InstallBackground(compositions::GuiBoundsComposition* boundsComposition)
			{
				GuiSolidBorderElement* border=GuiSolidBorderElement::Create();
				border->SetColor(Win7GetSystemBorderColor());
				boundsComposition->SetOwnedElement(border);
				boundsComposition->SetInternalMargin(Margin(1, 1, 1, 1));
				
				GuiSolidBackgroundElement* background=GuiSolidBackgroundElement::Create();
				background->SetColor(Win7GetSystemWindowColor());

				GuiBoundsComposition* backgroundComposition=new GuiBoundsComposition;
				boundsComposition->AddChild(backgroundComposition);
				backgroundComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				backgroundComposition->SetOwnedElement(background);

				return boundsComposition;
			}

/***********************************************************************
Win7TextBoxBackground
***********************************************************************/

#define HOST_GETTER_BY_FOCUSABLE_COMPOSITION(STYLE) (style->focusableComposition->GetRelatedGraphicsHost())

			IMPLEMENT_TRANSFERRING_ANIMATION_BASE(Win7TextBoxColors, Win7TextBoxBackground, HOST_GETTER_BY_FOCUSABLE_COMPOSITION)
			{
				colorCurrent=Win7TextBoxColors::Blend(colorBegin, colorEnd, currentPosition, totalLength);
				style->Apply(colorCurrent);
			}

			void Win7TextBoxBackground::UpdateStyle()
			{
				if(!isVisuallyEnabled)
				{
					transferringAnimation->Transfer(Win7TextBoxColors::Disabled());
				}
				else if(isFocused)
				{
					transferringAnimation->Transfer(Win7TextBoxColors::Focused());
				}
				else if(isMouseEnter)
				{
					transferringAnimation->Transfer(Win7TextBoxColors::Active());
				}
				else
				{
					transferringAnimation->Transfer(Win7TextBoxColors::Normal());
				}
			}

			void Win7TextBoxBackground::Apply(const Win7TextBoxColors& colors)
			{
				borderElement->SetColor(colors.borderColor);
				backgroundElement->SetColor(colors.backgroundColor);
			}

			void Win7TextBoxBackground::OnBoundsMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				isMouseEnter=true;
				UpdateStyle();
			}

			void Win7TextBoxBackground::OnBoundsMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				isMouseEnter=false;
				UpdateStyle();
			}

			void Win7TextBoxBackground::OnBoundsGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				isFocused=true;
				UpdateStyle();
			}

			void Win7TextBoxBackground::OnBoundsLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				isFocused=false;
				UpdateStyle();
			}

			Win7TextBoxBackground::Win7TextBoxBackground()
				:backgroundElement(0)
				,borderElement(0)
				,focusableComposition(0)
				,isMouseEnter(false)
				,isFocused(false)
				,isVisuallyEnabled(false)
				,styleController(0)
				,textElement(0)
			{
				transferringAnimation=new TransferringAnimation(this, Win7TextBoxColors::Normal());
			}

			Win7TextBoxBackground::~Win7TextBoxBackground()
			{
				transferringAnimation->Disable();
			}

			void Win7TextBoxBackground::AssociateStyleController(controls::GuiControl::IStyleController* controller)
			{
				styleController=controller;
			}
			
			void Win7TextBoxBackground::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				focusableComposition=value;
				focusableComposition->GetEventReceiver()->mouseEnter.AttachMethod(this, &Win7TextBoxBackground::OnBoundsMouseEnter);
				focusableComposition->GetEventReceiver()->mouseLeave.AttachMethod(this, &Win7TextBoxBackground::OnBoundsMouseLeave);
				focusableComposition->GetEventReceiver()->gotFocus.AttachMethod(this, &Win7TextBoxBackground::OnBoundsGotFocus);
				focusableComposition->GetEventReceiver()->lostFocus.AttachMethod(this, &Win7TextBoxBackground::OnBoundsLostFocus);
			}

			void Win7TextBoxBackground::SetVisuallyEnabled(bool value)
			{
				isVisuallyEnabled=value;
				UpdateStyle();
			}

			compositions::GuiGraphicsComposition* Win7TextBoxBackground::InstallBackground(compositions::GuiBoundsComposition* boundsComposition)
			{
				{
					GuiSolidBackgroundElement* background=GuiSolidBackgroundElement::Create();
					background->SetColor(Color(255, 255, 255));

					GuiBoundsComposition* backgroundComposition=new GuiBoundsComposition;
					boundsComposition->AddChild(backgroundComposition);
					backgroundComposition->SetAlignmentToParent(Margin(1, 1, 1, 1));
					backgroundComposition->SetOwnedElement(background);
					backgroundElement=background;
				}
				{
					GuiRoundBorderElement* border=GuiRoundBorderElement::Create();
					border->SetColor(Win7GetSystemBorderColor());
					border->SetRadius(2);
					borderElement=border;

					GuiBoundsComposition* borderComposition=new GuiBoundsComposition;
					boundsComposition->AddChild(borderComposition);
					borderComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					borderComposition->SetOwnedElement(border);
				}
				Apply(Win7TextBoxColors::Normal());
				{
					GuiBoundsComposition* containerComposition=new GuiBoundsComposition;
					boundsComposition->AddChild(containerComposition);
					containerComposition->SetAlignmentToParent(Margin(2, 2, 2, 2));
					return containerComposition;
				}
			}

			void Win7TextBoxBackground::InitializeTextElement(elements::GuiColorizedTextElement* _textElement)
			{
				textElement=_textElement;

				Array<text::ColorEntry> colors;
				colors.Resize(1);
				{
					colors[0]=Win7GetTextBoxTextColor();
				}
				textElement->SetColors(colors);
				textElement->SetCaretColor(Color(0, 0, 0));
			}

/***********************************************************************
Win7MultilineTextBoxProvider
***********************************************************************/

			Win7MultilineTextBoxProvider::Win7MultilineTextBoxProvider()
				:styleController(0)
			{
			}

			Win7MultilineTextBoxProvider::~Win7MultilineTextBoxProvider()
			{
			}

			void Win7MultilineTextBoxProvider::AssociateStyleController(controls::GuiControl::IStyleController* controller)
			{
				styleController=controller;
				background.AssociateStyleController(controller);
			}
			
			void Win7MultilineTextBoxProvider::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				background.SetFocusableComposition(value);
				GuiMultilineTextBox::StyleController* textBoxController=dynamic_cast<GuiMultilineTextBox::StyleController*>(styleController);
				if(textBoxController)
				{
					background.InitializeTextElement(textBoxController->GetTextElement());
				}
			}

			void Win7MultilineTextBoxProvider::SetVisuallyEnabled(bool value)
			{
				background.SetVisuallyEnabled(value);
			}

			compositions::GuiGraphicsComposition* Win7MultilineTextBoxProvider::InstallBackground(compositions::GuiBoundsComposition* boundsComposition)
			{
				return background.InstallBackground(boundsComposition);
			}

/***********************************************************************
Win7SinglelineTextBoxProvider
***********************************************************************/

			Win7SinglelineTextBoxProvider::Win7SinglelineTextBoxProvider()
				:styleController(0)
			{
			}

			Win7SinglelineTextBoxProvider::~Win7SinglelineTextBoxProvider()
			{
			}

			void Win7SinglelineTextBoxProvider::AssociateStyleController(controls::GuiControl::IStyleController* controller)
			{
				styleController=controller;
				background.AssociateStyleController(controller);
			}
			
			void Win7SinglelineTextBoxProvider::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				background.SetFocusableComposition(value);
				GuiSinglelineTextBox::StyleController* textBoxController=dynamic_cast<GuiSinglelineTextBox::StyleController*>(styleController);
				background.InitializeTextElement(textBoxController->GetTextElement());
			}

			void Win7SinglelineTextBoxProvider::SetText(const WString& value)
			{
			}

			void Win7SinglelineTextBoxProvider::SetFont(const FontProperties& value)
			{
			}

			void Win7SinglelineTextBoxProvider::SetVisuallyEnabled(bool value)
			{
				background.SetVisuallyEnabled(value);
			}

			compositions::GuiGraphicsComposition* Win7SinglelineTextBoxProvider::InstallBackground(compositions::GuiBoundsComposition* boundsComposition)
			{
				return background.InstallBackground(boundsComposition);
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win7Styles\GuiWin7StylesCommon.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7ButtonColors
***********************************************************************/

			void Win7ButtonColors::SetAlphaWithoutText(unsigned char a)
			{
				borderColor.a=a;
				backgroundColor.a=a;
				g1.a=a;
				g2.a=a;
				g3.a=a;
				g4.a=a;
			}

			Win7ButtonColors Win7ButtonColors::Blend(const Win7ButtonColors& c1, const Win7ButtonColors& c2, vint ratio, vint total)
			{
				if(ratio<0) ratio=0;
				else if(ratio>total) ratio=total;

				Win7ButtonColors result;
				result.borderColor=BlendColor(c1.borderColor, c2.borderColor, ratio, total);
				result.backgroundColor=BlendColor(c1.backgroundColor, c2.backgroundColor, ratio, total);
				result.g1=BlendColor(c1.g1, c2.g1, ratio, total);
				result.g2=BlendColor(c1.g2, c2.g2, ratio, total);
				result.g3=BlendColor(c1.g3, c2.g3, ratio, total);
				result.g4=BlendColor(c1.g4, c2.g4, ratio, total);
				result.textColor=BlendColor(c1.textColor, c2.textColor, ratio, total);
				result.bulletLight=BlendColor(c1.bulletLight, c2.bulletLight, ratio, total);
				result.bulletDark=BlendColor(c1.bulletDark, c2.bulletDark, ratio, total);
				return result;
			}

			//---------------------------------------------------------

			Win7ButtonColors Win7ButtonColors::ButtonNormal()
			{
				Win7ButtonColors colors=
				{
					Color(122, 122, 122),
					Color(251, 251, 251),
					Color(250, 250, 250),
					Color(235, 235, 235),
					Color(221, 221, 221),
					Color(207, 207, 207),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ButtonActive()
			{
				Win7ButtonColors colors=
				{
					Color(60, 127, 177),
					Color(220, 244, 254),
					Color(246, 252, 255),
					Color(240, 250, 255),
					Color(225, 245, 254),
					Color(215, 245, 254),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ButtonPressed()
			{
				Win7ButtonColors colors=
				{
					Color(44, 98, 139),
					Color(158, 176, 186),
					Color(225, 246, 255),
					Color(204, 239, 254),
					Color(181, 231, 253),
					Color(164, 225, 251),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ButtonDisabled()
			{
				Win7ButtonColors colors=
				{
					Color(173, 178, 181),
					Color(252, 252, 252),
					Color(244, 244, 244),
					Color(244, 244, 244),
					Color(244, 244, 244),
					Color(244, 244, 244),
					Win7GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win7ButtonColors Win7ButtonColors::ItemNormal()
			{
				Win7ButtonColors colors=
				{
					Color(184, 214, 251, 0),
					Color(252, 253, 254, 0),
					Color(250, 251, 253, 0),
					Color(242, 247, 253, 0),
					Color(242, 247, 253, 0),
					Color(235, 243, 253, 0),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ItemActive()
			{
				Win7ButtonColors colors=
				{
					Color(184, 214, 251),
					Color(252, 253, 254),
					Color(250, 251, 253),
					Color(242, 247, 253),
					Color(242, 247, 253),
					Color(235, 243, 253),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ItemSelected()
			{
				Win7ButtonColors colors=
				{
					Color(118, 158, 206),
					Color(235, 244, 253),
					Color(220, 235, 252),
					Color(208, 227, 252),
					Color(208, 227, 252),
					Color(193, 219, 252),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ItemDisabled()
			{
				Win7ButtonColors colors=
				{
					Color(184, 214, 251, 0),
					Color(252, 253, 254, 0),
					Color(250, 251, 253, 0),
					Color(242, 247, 253, 0),
					Color(242, 247, 253, 0),
					Color(235, 243, 253, 0),
					Win7GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win7ButtonColors Win7ButtonColors::CheckedNormal(bool selected)
			{
				Win7ButtonColors colors=
				{
					Color(142, 143, 143),
					Color(244, 244, 244),
					Color(174, 179, 185),
					Color(233, 233, 234),
					Color(203, 207, 213),
					Color(235, 235, 236),
					Win7GetSystemTextColor(true),
					Color(76, 97, 152),
					Color(76, 97, 152),
				};
				if(!selected)
				{
					colors.bulletLight.a=0;
					colors.bulletDark.a=0;
				}
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::CheckedActive(bool selected)
			{
				Win7ButtonColors colors=
				{
					Color(85, 134, 163),
					Color(222, 249, 250),
					Color(121, 198, 249),
					Color(207, 236, 253),
					Color(177, 233, 253),
					Color(231, 247, 254),
					Win7GetSystemTextColor(true),
					Color(4, 34, 113),
					Color(4, 34, 113),
				};
				if(!selected)
				{
					colors.bulletLight.a=0;
					colors.bulletDark.a=0;
				}
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::CheckedPressed(bool selected)
			{
				Win7ButtonColors colors=
				{
					Color(44, 98, 139),
					Color(194, 228, 254),
					Color(94, 182, 247),
					Color(193, 230, 252),
					Color(157, 213, 252),
					Color(224, 244, 254),
					Win7GetSystemTextColor(true),
					Color(63, 93, 153),
					Color(63, 93, 153),
				};
				if(!selected)
				{
					colors.bulletLight.a=0;
					colors.bulletDark.a=0;
				}
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::CheckedDisabled(bool selected)
			{
				Win7ButtonColors colors=
				{
					Color(177, 177, 177),
					Color(240, 240, 240),
					Color(240, 240, 240),
					Color(240, 240, 240),
					Color(240, 240, 240),
					Color(240, 240, 240),
					Win7GetSystemTextColor(false),
					Color(177, 177, 177),
					Color(177, 177, 177),
				};
				if(!selected)
				{
					colors.bulletLight.a=0;
					colors.bulletDark.a=0;
				}
				return colors;
			}

			//---------------------------------------------------------

			Win7ButtonColors Win7ButtonColors::ToolstripButtonNormal()
			{
				Win7ButtonColors colors=
				{
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ToolstripButtonActive()
			{
				Win7ButtonColors colors=
				{
					Color(168, 168, 168),
					Color(248, 248, 248),
					Color(250, 250, 250),
					Color(232, 232, 232),
					Color(218, 218, 218),
					Color(240, 240, 240),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ToolstripButtonPressed()
			{
				Win7ButtonColors colors=
				{
					Color(84, 84, 84),
					Color(156, 156, 156),
					Color(240, 240, 240),
					Color(228, 228, 228),
					Color(222, 222, 222),
					Color(230, 230, 230),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::ToolstripButtonDisabled()
			{
				Win7ButtonColors colors=
				{
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemWindowColor(),
					Win7GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win7ButtonColors Win7ButtonColors::MenuBarButtonNormal()
			{
				Win7ButtonColors colors=
				{
					Color(176, 176, 176),
					Color(234, 238, 247),
					Color(246, 248, 250),
					Color(211, 217, 231),
					Color(199, 204, 218),
					Color(224, 228, 243),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::MenuBarButtonActive()
			{
				Win7ButtonColors colors=
				{
					Color(176, 176, 176),
					Color(234, 238, 247),
					Color(246, 248, 250),
					Color(211, 217, 231),
					Color(199, 204, 218),
					Color(224, 228, 243),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::MenuBarButtonPressed()
			{
				Win7ButtonColors colors=
				{
					Color(88, 88, 89),
					Color(159, 160, 162),
					Color(200, 202, 208),
					Color(205, 209, 219),
					Color(197, 204, 221),
					Color(213, 218, 233),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::MenuBarButtonDisabled()
			{
				Win7ButtonColors colors=
				{
					Color(176, 176, 176),
					Color(234, 238, 247),
					Color(246, 248, 250),
					Color(211, 217, 231),
					Color(199, 204, 218),
					Color(224, 228, 243),
					Win7GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win7ButtonColors Win7ButtonColors::MenuItemButtonNormal()
			{
				Win7ButtonColors colors=
				{
					Color(0, 0, 0, 0),
					Color(0, 0, 0, 0),
					Color(0, 0, 0, 0),
					Color(0, 0, 0, 0),
					Color(227, 227, 227),
					Color(255, 255, 255),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::MenuItemButtonNormalActive()
			{
				Win7ButtonColors colors=
				{
					Color(175, 208, 247),
					Color(248, 248, 250),
					Color(243, 245, 247),
					Color(231, 238, 247),
					Color(229, 233, 238),
					Color(245, 249, 255),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::MenuItemButtonDisabled()
			{
				Win7ButtonColors colors=
				{
					Color(0, 0, 0, 0),
					Color(0, 0, 0, 0),
					Color(0, 0, 0, 0),
					Color(0, 0, 0, 0),
					Color(227, 227, 227),
					Color(255, 255, 255),
					Win7GetSystemTextColor(false),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::MenuItemButtonDisabledActive()
			{
				Win7ButtonColors colors=
				{
					Color(212, 212, 212),
					Color(244, 244, 244),
					Color(243, 243, 243),
					Color(229, 229, 229),
					Color(232, 232, 232),
					Color(239, 239, 239),
					Win7GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win7ButtonColors Win7ButtonColors::TabPageHeaderNormal()
			{
				Win7ButtonColors colors=
				{
					Color(137, 140, 149),
					Color(243, 243, 243),
					Color(242, 242, 242),
					Color(235, 235, 235),
					Color(219, 219, 219),
					Color(207, 207, 207),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::TabPageHeaderActive()
			{
				Win7ButtonColors colors=
				{
					Color(60, 127, 177),
					Color(233, 245, 252),
					Color(234, 246, 253),
					Color(217, 240, 252),
					Color(188, 229, 252),
					Color(167, 217, 245),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

			Win7ButtonColors Win7ButtonColors::TabPageHeaderSelected()
			{
				Win7ButtonColors colors=
				{
					Color(137, 140, 149),
					Win7GetSystemTabContentColor(),
					Win7GetSystemTabContentColor(),
					Win7GetSystemTabContentColor(),
					Win7GetSystemTabContentColor(),
					Win7GetSystemTabContentColor(),
					Win7GetSystemTextColor(true),
				};
				return colors;
			}

/***********************************************************************
Win7ButtonElements
***********************************************************************/

			Win7ButtonElements Win7ButtonElements::Create(bool verticalGradient, bool roundBorder, Alignment::Type horizontal, Alignment::Type vertical)
			{
				Win7ButtonElements button;
				button.rectBorderElement=0;
				button.roundBorderElement=0;
				{
					button.mainComposition=new GuiBoundsComposition;
					button.mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				if(roundBorder)
				{
					{
						GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
						button.backgroundElement=element;

						GuiBoundsComposition* composition=new GuiBoundsComposition;
						button.backgroundComposition=composition;
						button.mainComposition->AddChild(composition);
						composition->SetAlignmentToParent(Margin(1, 1, 1, 1));
						composition->SetOwnedElement(element);
					}
					{
						GuiRoundBorderElement* element=GuiRoundBorderElement::Create();
						button.roundBorderElement=element;
						element->SetRadius(2);

						GuiBoundsComposition* composition=new GuiBoundsComposition;
						button.mainComposition->AddChild(composition);
						composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
						composition->SetOwnedElement(element);
					}
				}
				else
				{
					{
						GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
						button.rectBorderElement=element;

						GuiBoundsComposition* composition=new GuiBoundsComposition;
						button.mainComposition->AddChild(composition);
						composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
						composition->SetOwnedElement(element);
					}
					{
						GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
						button.backgroundElement=element;

						GuiBoundsComposition* composition=new GuiBoundsComposition;
						button.backgroundComposition=composition;
						button.mainComposition->AddChild(composition);
						composition->SetAlignmentToParent(Margin(1, 1, 1, 1));
						composition->SetOwnedElement(element);
					}
				}
				{
					GuiTableComposition* table=new GuiTableComposition;
					button.gradientComposition=table;
					table->SetAlignmentToParent(Margin(2, 2, 2, 2));
					button.mainComposition->AddChild(table);
					if(verticalGradient)
					{
						table->SetRowsAndColumns(2, 1);
						table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
						table->SetRowOption(1, GuiCellOption::PercentageOption(0.5));
						table->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
					}
					else
					{
						table->SetRowsAndColumns(1, 2);
						table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
						table->SetColumnOption(0, GuiCellOption::PercentageOption(0.5));
						table->SetColumnOption(1, GuiCellOption::PercentageOption(0.5));
					}
					{
						GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
						button.topGradientElement=element;
						element->SetDirection(verticalGradient?GuiGradientBackgroundElement::Vertical:GuiGradientBackgroundElement::Horizontal);

						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 0, 1, 1);
						cell->SetOwnedElement(element);
					}
					{
						GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
						button.bottomGradientElement=element;
						element->SetDirection(verticalGradient?GuiGradientBackgroundElement::Vertical:GuiGradientBackgroundElement::Horizontal);

						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						if(verticalGradient)
						{
							cell->SetSite(1, 0, 1, 1);
						}
						else
						{
							cell->SetSite(0, 1, 1, 1);
						}
						cell->SetOwnedElement(element);
					}
				}
				{
					Win7CreateSolidLabelElement(button.textElement, button.textComposition, horizontal, vertical);
					button.mainComposition->AddChild(button.textComposition);
				}
				return button;
			}

			void Win7ButtonElements::Apply(const Win7ButtonColors& colors)
			{
				if(rectBorderElement)
				{
					rectBorderElement->SetColor(colors.borderColor);
				}
				if(roundBorderElement)
				{
					roundBorderElement->SetColor(colors.borderColor);
				}
				backgroundElement->SetColor(colors.backgroundColor);
				topGradientElement->SetColors(colors.g1, colors.g2);
				bottomGradientElement->SetColors(colors.g3, colors.g4);
				textElement->SetColor(colors.textColor);
			}

/***********************************************************************
Win7CheckedButtonElements
***********************************************************************/

			Win7CheckedButtonElements Win7CheckedButtonElements::Create(elements::ElementShape::Type shape, bool backgroundVisible)
			{
				const vint checkSize=13;
				const vint checkPadding=2;

				Win7CheckedButtonElements button;
				{
					button.mainComposition=new GuiBoundsComposition;
					button.mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				{
					GuiTableComposition* mainTable=new GuiTableComposition;
					button.mainComposition->AddChild(mainTable);
					if(backgroundVisible)
					{
						GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
						element->SetColor(Win7GetSystemWindowColor());
						mainTable->SetOwnedElement(element);
					}
					mainTable->SetRowsAndColumns(1, 2);
					mainTable->SetAlignmentToParent(Margin(0, 0, 0, 0));
					mainTable->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
					mainTable->SetColumnOption(0, GuiCellOption::AbsoluteOption(checkSize+2*checkPadding));
					mainTable->SetColumnOption(1, GuiCellOption::PercentageOption(1.0));
					
					{
						GuiCellComposition* cell=new GuiCellComposition;
						mainTable->AddChild(cell);
						cell->SetSite(0, 0, 1, 1);

						GuiTableComposition* table=new GuiTableComposition;
						cell->AddChild(table);
						table->SetRowsAndColumns(3, 1);
						table->SetAlignmentToParent(Margin(0, 0, 0, 0));
						table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
						table->SetRowOption(1, GuiCellOption::MinSizeOption());
						table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));

						{
							GuiCellComposition* checkCell=new GuiCellComposition;
							table->AddChild(checkCell);
							checkCell->SetSite(1, 0, 1, 1);
							{
								GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
								button.backgroundElement=element;
								element->SetShape(shape);

								GuiBoundsComposition* borderBounds=new GuiBoundsComposition;
								checkCell->AddChild(borderBounds);
								borderBounds->SetOwnedElement(element);
								borderBounds->SetAlignmentToParent(Margin(checkPadding, -1, checkPadding, -1));
								borderBounds->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
								{
									GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
									button.borderElement=element;
									element->SetShape(shape);

									GuiBoundsComposition* bounds=new GuiBoundsComposition;
									borderBounds->AddChild(bounds);
									bounds->SetOwnedElement(element);
									bounds->SetAlignmentToParent(Margin(0, 0, 0, 0));
									bounds->SetBounds(Rect(Point(0, 0), Size(checkSize, checkSize)));
								}
								{
									GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
									button.outerGradientElement=element;
									element->SetShape(shape);
									element->SetDirection(GuiGradientBackgroundElement::Backslash);

									GuiBoundsComposition* bounds=new GuiBoundsComposition;
									borderBounds->AddChild(bounds);
									bounds->SetOwnedElement(element);
									bounds->SetAlignmentToParent(Margin(2, 2, 2, 2));
								}
								{
									GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
									button.innerGradientElement=element;
									element->SetDirection(GuiGradientBackgroundElement::Backslash);
									element->SetShape(shape);

									GuiBoundsComposition* bounds=new GuiBoundsComposition;
									borderBounds->AddChild(bounds);
									bounds->SetOwnedElement(element);
									bounds->SetAlignmentToParent(Margin(3, 3, 3, 3));
								}
							}

							button.bulletCheckElement=0;
							button.bulletRadioElement=0;
							if(shape==ElementShape::Rectangle)
							{
								button.bulletCheckElement=GuiSolidLabelElement::Create();
								{
									FontProperties font;
									font.fontFamily=L"Wingdings 2";
									font.size=16;
									font.bold=true;
									button.bulletCheckElement->SetFont(font);
								}
								button.bulletCheckElement->SetText(L"P");
								button.bulletCheckElement->SetAlignments(Alignment::Center, Alignment::Center);

								GuiBoundsComposition* composition=new GuiBoundsComposition;
								composition->SetOwnedElement(button.bulletCheckElement);
								composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
								checkCell->AddChild(composition);
							}
							else
							{
								button.bulletRadioElement=GuiSolidBackgroundElement::Create();
								button.bulletRadioElement->SetShape(ElementShape::Ellipse);

								GuiBoundsComposition* composition=new GuiBoundsComposition;
								composition->SetOwnedElement(button.bulletRadioElement);
								composition->SetAlignmentToParent(Margin(checkPadding+3, 3, checkPadding+3, 3));
								checkCell->AddChild(composition);
							}
						}
					}

					{
						GuiCellComposition* textCell=new GuiCellComposition;
						mainTable->AddChild(textCell);
						textCell->SetSite(0, 1, 1, 1);
						{
							Win7CreateSolidLabelElement(button.textElement, button.textComposition, Alignment::Left, Alignment::Center);
							textCell->AddChild(button.textComposition);
						}
					}
				}
				return button;
			}

			void Win7CheckedButtonElements::Apply(const Win7ButtonColors& colors)
			{
				borderElement->SetColor(colors.borderColor);
				backgroundElement->SetColor(colors.backgroundColor);
				outerGradientElement->SetColors(colors.g1, colors.g2);
				innerGradientElement->SetColors(colors.g3, colors.g4);
				textElement->SetColor(colors.textColor);
				if(bulletCheckElement)
				{
					bulletCheckElement->SetColor(colors.bulletDark);
				}
				if(bulletRadioElement)
				{
					bulletRadioElement->SetColor(colors.bulletDark);
				}
			}

/***********************************************************************
Win7MenuItemButtonElements
***********************************************************************/

			Win7MenuItemButtonElements Win7MenuItemButtonElements::Create()
			{
				Win7MenuItemButtonElements button;
				{
					button.mainComposition=new GuiBoundsComposition;
					button.mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					button.backgroundElement=element;

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					button.mainComposition->AddChild(composition);
					composition->SetAlignmentToParent(Margin(1, 1, 1, 1));
					composition->SetOwnedElement(element);
				}
				{
					GuiRoundBorderElement* element=GuiRoundBorderElement::Create();
					button.borderElement=element;
					element->SetRadius(2);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					button.mainComposition->AddChild(composition);
					composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					composition->SetOwnedElement(element);
				}
				{
					GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
					button.gradientElement=element;
					element->SetDirection(GuiGradientBackgroundElement::Vertical);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					button.mainComposition->AddChild(composition);
					composition->SetAlignmentToParent(Margin(2, 2, 2, 2));
					composition->SetOwnedElement(element);
				}
				{
					GuiTableComposition* table=new GuiTableComposition;
					button.mainComposition->AddChild(table);
					table->SetAlignmentToParent(Margin(2, 0, 2, 0));
					table->SetRowsAndColumns(1, 5);

					table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(0, GuiCellOption::AbsoluteOption(24));
					table->SetColumnOption(1, GuiCellOption::AbsoluteOption(2));
					table->SetColumnOption(2, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(3, GuiCellOption::MinSizeOption());
					table->SetColumnOption(4, GuiCellOption::AbsoluteOption(10));
					
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 0, 1, 1);
						button.splitterComposition=cell;

						GuiImageFrameElement* element=GuiImageFrameElement::Create();
						button.imageElement=element;
						element->SetStretch(false);
						element->SetAlignments(Alignment::Center, Alignment::Center);
						cell->SetOwnedElement(element);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 1, 1);
						button.splitterComposition=cell;

						Gui3DSplitterElement* element=Gui3DSplitterElement::Create();
						button.splitterElement=element;
						element->SetDirection(Gui3DSplitterElement::Vertical);
						cell->SetOwnedElement(element);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 2, 1, 1);

						Win7CreateSolidLabelElement(button.textElement, button.textComposition, Alignment::Left, Alignment::Center);
						cell->AddChild(button.textComposition);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 3, 1, 1);

						Win7CreateSolidLabelElement(button.shortcutElement, button.shortcutComposition, Alignment::Right, Alignment::Center);
						cell->AddChild(button.shortcutComposition);
					}
					{
						button.subMenuArrowElement=common_styles::CommonFragmentBuilder::BuildRightArrow();

						GuiCellComposition* cell=new GuiCellComposition;
						button.subMenuArrowComposition=cell;
						cell->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
						table->AddChild(cell);
						cell->SetSite(0, 4, 1, 1);
						cell->SetOwnedElement(button.subMenuArrowElement);
						cell->SetVisible(false);
					}
				}
				return button;
			}

			void Win7MenuItemButtonElements::Apply(const Win7ButtonColors& colors)
			{
				borderElement->SetColor(colors.borderColor);
				backgroundElement->SetColor(colors.backgroundColor);
				gradientElement->SetColors(colors.g1, colors.g2);
				splitterElement->SetColors(colors.g3, colors.g4);
				textElement->SetColor(colors.textColor);
				shortcutElement->SetColor(colors.textColor);
				subMenuArrowElement->SetBackgroundColor(colors.textColor);
				subMenuArrowElement->SetBorderColor(colors.textColor);
			}

			void Win7MenuItemButtonElements::SetActive(bool value)
			{
				if(value)
				{
					splitterComposition->SetMargin(Margin(0, 1, 0, 2));
				}
				else
				{
					splitterComposition->SetMargin(Margin(0, 0, 0, 0));
				}
			}

			void Win7MenuItemButtonElements::SetSubMenuExisting(bool value)
			{
				subMenuArrowComposition->SetVisible(value);
			}

/***********************************************************************
Win7TextBoxColors
***********************************************************************/

			Win7TextBoxColors Win7TextBoxColors::Blend(const Win7TextBoxColors& c1, const Win7TextBoxColors& c2, vint ratio, vint total)
			{
				if(ratio<0) ratio=0;
				else if(ratio>total) ratio=total;

				Win7TextBoxColors result;
				result.borderColor=BlendColor(c1.borderColor, c2.borderColor, ratio, total);
				result.backgroundColor=BlendColor(c1.backgroundColor, c2.backgroundColor, ratio, total);
				return result;
			}
			
			Win7TextBoxColors Win7TextBoxColors::Normal()
			{
				Win7TextBoxColors result=
				{
					Color(197, 197, 197),
					Color(255, 255, 255),
				};
				return result;
			}

			Win7TextBoxColors Win7TextBoxColors::Active()
			{
				Win7TextBoxColors result=
				{
					Color(197, 218, 237),
					Color(255, 255, 255),
				};
				return result;
			}

			Win7TextBoxColors Win7TextBoxColors::Focused()
			{
				Win7TextBoxColors result=
				{
					Color(61, 123, 173),
					Color(255, 255, 255),
				};
				return result;
			}

			Win7TextBoxColors Win7TextBoxColors::Disabled()
			{
				Win7TextBoxColors result=
				{
					Color(175, 175, 175),
					Win7GetSystemWindowColor(),
				};
				return result;
			}

/***********************************************************************
Helpers
***********************************************************************/

			Color Win7GetSystemWindowColor()
			{
				return Color(240, 240, 240);
			}

			Color Win7GetSystemTabContentColor()
			{
				return Color(255, 255, 255);
			}

			Color Win7GetSystemBorderColor()
			{
				return Color(100, 100, 100);
			}

			Color Win7GetSystemBorderSinkColor()
			{
				return Color(227, 227, 227);
			}

			Color Win7GetSystemBorderRaiseColor()
			{
				return Color(255, 255, 255);
			}

			Color Win7GetSystemTextColor(bool enabled)
			{
				return enabled?Color(0, 0, 0):Color(131, 131, 131);
			}

			void Win7SetFont(GuiSolidLabelElement* element, GuiBoundsComposition* composition, const FontProperties& fontProperties)
			{
				vint margin=3;
				element->SetFont(fontProperties);
				composition->SetMargin(Margin(margin, margin, margin, margin));
			}

			void Win7CreateSolidLabelElement(GuiSolidLabelElement*& element, GuiBoundsComposition*& composition, Alignment::Type horizontal, Alignment::Type vertical)
			{
				element=GuiSolidLabelElement::Create();
				element->SetAlignments(horizontal, vertical);

				composition=new GuiBoundsComposition;
				composition->SetOwnedElement(element);
				composition->SetMargin(Margin(0, 0, 0, 0));
				composition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
			}

			elements::text::ColorEntry Win7GetTextBoxTextColor()
			{
				elements::text::ColorEntry entry;
				entry.normal.text=Color(0, 0, 0);
				entry.normal.background=Color(0, 0, 0, 0);
				entry.selectedFocused.text=Color(255, 255, 255);
				entry.selectedFocused.background=Color(51, 153, 255);
				entry.selectedUnfocused.text=Color(255, 255, 255);
				entry.selectedUnfocused.background=Color(51, 153, 255);
				return entry;
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win7Styles\GuiWin7TabStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7TabPageHeaderStyle
***********************************************************************/

			void Win7TabPageHeaderStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				if(selected)
				{
					transferringAnimation->Transfer(Win7ButtonColors::TabPageHeaderSelected());
				}
				else
				{
					switch(value)
					{
					case GuiButton::Normal:
						transferringAnimation->Transfer(Win7ButtonColors::TabPageHeaderNormal());
						break;
					case GuiButton::Active:
					case GuiButton::Pressed:
						transferringAnimation->Transfer(Win7ButtonColors::TabPageHeaderActive());
						break;
					}
				}
			}

			Win7TabPageHeaderStyle::Win7TabPageHeaderStyle()
				:Win7ButtonStyleBase(true, false, Win7ButtonColors::TabPageHeaderNormal(), Alignment::Left, Alignment::Center)
			{
				transferringAnimation->SetEnableAnimation(false);
				{
					Margin margin=elements.backgroundComposition->GetAlignmentToParent();
					margin.bottom=0;
					elements.backgroundComposition->SetAlignmentToParent(margin);
				}
				{
					Margin margin=elements.gradientComposition->GetAlignmentToParent();
					margin.bottom=0;
					elements.gradientComposition->SetAlignmentToParent(margin);
				}
			}

			Win7TabPageHeaderStyle::~Win7TabPageHeaderStyle()
			{
			}

			void Win7TabPageHeaderStyle::SetFont(const FontProperties& value)
			{
				Win7ButtonStyleBase::SetFont(value);
				Margin margin=elements.textComposition->GetMargin();
				margin.left*=2;
				margin.right*=2;
				elements.textComposition->SetMargin(margin);
			}

/***********************************************************************
Win7TabStyle
***********************************************************************/

			void Win7TabStyle::OnHeaderButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(commandExecutor)
				{
					vint index=headerButtons.IndexOf(dynamic_cast<GuiSelectableButton*>(sender->GetAssociatedControl()));
					if(index!=-1)
					{
						commandExecutor->ShowTab(index);
					}
				}
			}

			void Win7TabStyle::OnTabHeaderBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				vint height=headerOverflowButton->GetBoundsComposition()->GetBounds().Height();
				headerOverflowButton->GetBoundsComposition()->SetBounds(Rect(Point(0, 0), Size(height, 0)));
				UpdateHeaderOverflowButtonVisibility();
			}

			void Win7TabStyle::OnHeaderOverflowButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				for(vint i=headerOverflowMenuStack->GetStackItems().Count()-1;i>=0;i--)
				{
					GuiStackItemComposition* item=headerOverflowMenuStack->GetStackItems().Get(i);
					GuiControl* button=item->Children().Get(0)->GetAssociatedControl();

					headerOverflowMenuStack->RemoveChild(item);
					item->RemoveChild(button->GetBoundsComposition());
					delete button;
					delete item;
				}

				for(vint i=0;i<headerButtons.Count();i++)
				{
					GuiStackItemComposition* item=new GuiStackItemComposition;
					headerOverflowMenuStack->AddChild(item);

					GuiMenuButton* button=new GuiMenuButton(new Win7MenuItemButtonStyle);
					button->SetText(headerButtons[i]->GetText());
					button->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
					button->Clicked.AttachMethod(this, &Win7TabStyle::OnHeaderOverflowMenuButtonClicked);
					item->AddChild(button->GetBoundsComposition());
				}

				headerOverflowMenu->SetClientSize(Size(0, 0));
				headerOverflowMenu->ShowPopup(headerOverflowButton, true);
			}

			void Win7TabStyle::OnHeaderOverflowMenuButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				vint index=headerOverflowMenuStack->GetStackItems().IndexOf(dynamic_cast<GuiStackItemComposition*>(sender->GetParent()));
				if(index!=-1)
				{
					commandExecutor->ShowTab(index);
				}
			}

			void Win7TabStyle::UpdateHeaderOverflowButtonVisibility()
			{
				headerOverflowButton->SetVisible(tabHeaderComposition->IsStackItemClipped());
			}

			void Win7TabStyle::UpdateHeaderZOrder()
			{
				vint itemCount=tabHeaderComposition->GetStackItems().Count();
				vint childCount=tabHeaderComposition->Children().Count();
				for(vint i=0;i<itemCount;i++)
				{
					GuiStackItemComposition* item=tabHeaderComposition->GetStackItems().Get(i);
					if(headerButtons[i]->GetSelected())
					{
						tabHeaderComposition->MoveChild(item, childCount-1);
						item->SetExtraMargin(Margin(2, 2, 2, 0));
					}
					else
					{
						item->SetExtraMargin(Margin(0, 0, 0, 0));
					}
				}
				tabHeaderComposition->MoveChild(tabContentTopLineComposition, childCount-2);
			}

			Win7TabStyle::Win7TabStyle()
				:commandExecutor(0)
			{
				boundsComposition=new GuiTableComposition;
				boundsComposition->SetRowsAndColumns(2, 1);
				boundsComposition->SetRowOption(0, GuiCellOption::MinSizeOption());
				boundsComposition->SetRowOption(1, GuiCellOption::PercentageOption(1.0));
				boundsComposition->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
				{
					GuiCellComposition* cell=new GuiCellComposition;
					boundsComposition->AddChild(cell);
					cell->SetSite(0, 0, 1, 1);

					tabHeaderComposition=new GuiStackComposition;
					tabHeaderComposition->SetExtraMargin(Margin(2, 2, 2, 0));
					tabHeaderComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					tabHeaderComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					tabHeaderComposition->BoundsChanged.AttachMethod(this, &Win7TabStyle::OnTabHeaderBoundsChanged);
					cell->AddChild(tabHeaderComposition);

					headerOverflowButton=new GuiButton(new Win7ButtonStyle);
					headerOverflowButton->GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildDownArrow(headerOverflowArrowElement));
					headerOverflowButton->SetVisible(false);
					headerOverflowButton->GetBoundsComposition()->SetAlignmentToParent(Margin(-1, 0, 0, 0));
					headerOverflowButton->Clicked.AttachMethod(this, &Win7TabStyle::OnHeaderOverflowButtonClicked);
					cell->AddChild(headerOverflowButton->GetBoundsComposition());
				}
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win7ButtonColors::TabPageHeaderNormal().borderColor);

					tabContentTopLineComposition=new GuiBoundsComposition;
					tabContentTopLineComposition->SetOwnedElement(element);
					tabContentTopLineComposition->SetAlignmentToParent(Margin(0, -1, 0, 0));
					tabContentTopLineComposition->SetPreferredMinSize(Size(0, 1));
					tabHeaderComposition->AddChild(tabContentTopLineComposition);
				}
				{
					GuiCellComposition* cell=new GuiCellComposition;
					boundsComposition->AddChild(cell);
					cell->SetSite(1, 0, 1, 1);

					containerComposition=new GuiBoundsComposition;
					containerComposition->SetAlignmentToParent(Margin(1, 0, 1, 1));
					containerComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					cell->AddChild(containerComposition);

					{
						GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
						element->SetColor(Win7ButtonColors::TabPageHeaderNormal().borderColor);
						cell->SetOwnedElement(element);
					}
					{
						GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
						element->SetColor(Win7GetSystemTabContentColor());
						containerComposition->SetOwnedElement(element);
					}
				}
				{
					headerOverflowMenu=new GuiMenu(new Win7MenuStyle, 0);
					headerOverflowMenuStack=new GuiStackComposition;
					headerOverflowMenuStack->SetDirection(GuiStackComposition::Vertical);
					headerOverflowMenuStack->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					headerOverflowMenuStack->SetAlignmentToParent(Margin(0, 0, 0, 0));
					headerOverflowMenu->GetContainerComposition()->AddChild(headerOverflowMenuStack);
				}

				headerController=new GuiSelectableButton::MutexGroupController;
			}

			Win7TabStyle::~Win7TabStyle()
			{
				delete headerOverflowMenu;
			}

			compositions::GuiBoundsComposition* Win7TabStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7TabStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win7TabStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7TabStyle::SetText(const WString& value)
			{
			}

			void Win7TabStyle::SetFont(const FontProperties& value)
			{
				headerFont=value;
			}

			void Win7TabStyle::SetVisuallyEnabled(bool value)
			{
			}

			void Win7TabStyle::SetCommandExecutor(controls::GuiTab::ICommandExecutor* value)
			{
				commandExecutor=value;
			}

			void Win7TabStyle::InsertTab(vint index)
			{
				GuiSelectableButton* button=new GuiSelectableButton(new Win7TabPageHeaderStyle);
				button->SetAutoSelection(false);
				button->SetFont(headerFont);
				button->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
				button->SetGroupController(headerController.Obj());
				button->Clicked.AttachMethod(this, &Win7TabStyle::OnHeaderButtonClicked);

				GuiStackItemComposition* item=new GuiStackItemComposition;
				item->AddChild(button->GetBoundsComposition());
				tabHeaderComposition->InsertStackItem(index, item);
				headerButtons.Insert(index, button);
				UpdateHeaderZOrder();
			}

			void Win7TabStyle::SetTabText(vint index, const WString& value)
			{
				headerButtons[index]->SetText(value);
				UpdateHeaderOverflowButtonVisibility();
			}

			void Win7TabStyle::RemoveTab(vint index)
			{
				GuiStackItemComposition* item=tabHeaderComposition->GetStackItems().Get(index);
				GuiSelectableButton* button=headerButtons[index];

				tabHeaderComposition->RemoveChild(item);
				item->RemoveChild(button->GetBoundsComposition());
				headerButtons.RemoveAt(index);

				delete item;
				delete button;
				UpdateHeaderOverflowButtonVisibility();
			}

			void Win7TabStyle::MoveTab(vint oldIndex, vint newIndex)
			{
				GuiStackItemComposition* item=tabHeaderComposition->GetStackItems().Get(oldIndex);
				tabHeaderComposition->RemoveChild(item);
				tabHeaderComposition->InsertStackItem(newIndex, item);

				GuiSelectableButton* button=headerButtons[oldIndex];
				headerButtons.RemoveAt(oldIndex);
				headerButtons.Insert(newIndex, button);
				UpdateHeaderZOrder();
				UpdateHeaderOverflowButtonVisibility();
			}

			void Win7TabStyle::SetSelectedTab(vint index)
			{
				headerButtons[index]->SetSelected(true);
				UpdateHeaderZOrder();
				UpdateHeaderOverflowButtonVisibility();
			}

			controls::GuiControl::IStyleController* Win7TabStyle::CreateTabPageStyleController()
			{
				GuiControl::IStyleController* style=new Win7EmptyStyle(Win7GetSystemTabContentColor());
				style->GetBoundsComposition()->SetAlignmentToParent(Margin(2, 2, 2, 2));
				return style;
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win7Styles\GuiWin7ToolstripStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win7
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win7WindowStyle
***********************************************************************/

			Win7ToolstripToolbarStyle::Win7ToolstripToolbarStyle()
				:Win7EmptyStyle(Win7GetSystemWindowColor())
			{
				boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
			}

			Win7ToolstripToolbarStyle::~Win7ToolstripToolbarStyle()
			{
			}

/***********************************************************************
Win7ToolstripButtonDropdownStyle
***********************************************************************/

			void Win7ToolstripButtonDropdownStyle::TransferInternal(controls::GuiButton::ControlState value, bool enabled)
			{
				splitterComposition->SetVisible(value!=GuiButton::Normal && enabled);
			}

			Win7ToolstripButtonDropdownStyle::Win7ToolstripButtonDropdownStyle()
				:isVisuallyEnabled(false)
				,controlState(GuiButton::Normal)
			{
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				{
					Gui3DSplitterElement* splitterElement=Gui3DSplitterElement::Create();
					splitterElement->SetColors(Win7GetSystemBorderSinkColor(), Win7GetSystemBorderRaiseColor());
					splitterElement->SetDirection(Gui3DSplitterElement::Vertical);

					splitterComposition=new GuiBoundsComposition;
					splitterComposition->SetAlignmentToParent(Margin(0, 3, -1, 3));
					splitterComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
					splitterComposition->SetOwnedElement(splitterElement);
					splitterComposition->SetPreferredMinSize(Size(2, 0));
					splitterComposition->SetVisible(false);
					boundsComposition->AddChild(splitterComposition);
				}
				{
					containerComposition=new GuiBoundsComposition;
					containerComposition->SetAlignmentToParent(Margin(4, 0, 4, 0));
					containerComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					boundsComposition->AddChild(containerComposition);
				}
			}

			Win7ToolstripButtonDropdownStyle::~Win7ToolstripButtonDropdownStyle()
			{
			}
				
			compositions::GuiBoundsComposition* Win7ToolstripButtonDropdownStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7ToolstripButtonDropdownStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win7ToolstripButtonDropdownStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7ToolstripButtonDropdownStyle::SetText(const WString& value)
			{
			}

			void Win7ToolstripButtonDropdownStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7ToolstripButtonDropdownStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlState, isVisuallyEnabled);
				}
			}

			void Win7ToolstripButtonDropdownStyle::Transfer(controls::GuiButton::ControlState value)
			{
				if(controlState!=value)
				{
					controlState=value;
					TransferInternal(controlState, isVisuallyEnabled);
				}
			}

/***********************************************************************
Win7ToolstripButtonStyle
***********************************************************************/

			IMPLEMENT_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7ToolstripButtonStyle)
			{
				colorCurrent=Win7ButtonColors::Blend(colorBegin, colorEnd, currentPosition, totalLength);
				style->elements.Apply(colorCurrent);
			}

			void Win7ToolstripButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool menuOpening)
			{
				Win7ButtonColors targetColor;
				if(enabled)
				{
					if(menuOpening)
					{
						value=GuiButton::Pressed;
					}
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win7ButtonColors::ToolstripButtonNormal();
						break;
					case GuiButton::Active:
						targetColor=Win7ButtonColors::ToolstripButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win7ButtonColors::ToolstripButtonPressed();
						break;
					}
				}
				else
				{
					targetColor=Win7ButtonColors::ToolstripButtonDisabled();
				}
				transferringAnimation->Transfer(targetColor);
			}

			Win7ToolstripButtonStyle::Win7ToolstripButtonStyle(ButtonStyle _buttonStyle)
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isOpening(false)
				,buttonStyle(_buttonStyle)
				,subMenuHost(0)
			{
				elements=Win7ButtonElements::Create(true, true, Alignment::Center, Alignment::Center);
				elements.Apply(Win7ButtonColors::ToolstripButtonNormal());
				transferringAnimation=new TransferringAnimation(this, Win7ButtonColors::ToolstripButtonNormal());

				elements.textComposition->SetMinSizeLimitation(GuiGraphicsComposition::NoLimit);
				imageElement=GuiImageFrameElement::Create();
				imageComposition=new GuiBoundsComposition;
				imageComposition->SetOwnedElement(imageElement);
				imageComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				imageComposition->SetAlignmentToParent(Margin(4, 4, 4, 4));

				if(_buttonStyle==CommandButton)
				{
					GetContainerComposition()->AddChild(imageComposition);
				}
				else
				{
					GuiTableComposition* table=new GuiTableComposition;
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetRowsAndColumns(1, 2);
					table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(1, GuiCellOption::MinSizeOption());

					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 0, 1, 1);

						cell->AddChild(imageComposition);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 1, 1);
						GuiPolygonElement* arrow=0;
						GuiBoundsComposition* arrowComposition=common_styles::CommonFragmentBuilder::BuildDownArrow(arrow);

						switch(_buttonStyle)
						{
						case DropdownButton:
							{
								arrowComposition->SetAlignmentToParent(Margin(0, 0, 4, 0));
								cell->AddChild(arrowComposition);
							}
							break;
						case SplitButton:
							{

								subMenuHost=new GuiButton(new Win7ToolstripButtonDropdownStyle);
								subMenuHost->GetContainerComposition()->AddChild(arrowComposition);
								subMenuHost->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
								cell->AddChild(subMenuHost->GetBoundsComposition());
							}
							break;
						}
					}
					GetContainerComposition()->AddChild(table);
				}
			}

			Win7ToolstripButtonStyle::~Win7ToolstripButtonStyle()
			{
				transferringAnimation->Disable();
			}

			compositions::GuiBoundsComposition* Win7ToolstripButtonStyle::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win7ToolstripButtonStyle::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win7ToolstripButtonStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7ToolstripButtonStyle::SetText(const WString& value)
			{
			}

			void Win7ToolstripButtonStyle::SetFont(const FontProperties& value)
			{
				Win7SetFont(elements.textElement, elements.textComposition, value);
			}

			void Win7ToolstripButtonStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					imageElement->SetEnabled(value);
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiMenu::IStyleController* Win7ToolstripButtonStyle::CreateSubMenuStyleController()
			{
				return new Win7MenuStyle;
			}

			void Win7ToolstripButtonStyle::SetSubMenuExisting(bool value)
			{
			}

			void Win7ToolstripButtonStyle::SetSubMenuOpening(bool value)
			{
				if(isOpening!=value)
				{
					isOpening=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiButton* Win7ToolstripButtonStyle::GetSubMenuHost()
			{
				return subMenuHost;
			}

			void Win7ToolstripButtonStyle::SetImage(Ptr<controls::GuiImageData> value)
			{
				if(value)
				{
					imageElement->SetImage(value->GetImage(), value->GetFrameIndex());
				}
				else
				{
					imageElement->SetImage(0, 0);
				}
			}

			void Win7ToolstripButtonStyle::SetShortcutText(const WString& value)
			{
			}

			compositions::GuiSubComponentMeasurer::IMeasuringSource* Win7ToolstripButtonStyle::GetMeasuringSource()
			{
				return 0;
			}

			void Win7ToolstripButtonStyle::Transfer(controls::GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

/***********************************************************************
Win7ToolstripSplitterStyle
***********************************************************************/

			Win7ToolstripSplitterStyle::Win7ToolstripSplitterStyle()
			{
				Color dark=Win7GetSystemBorderSinkColor();
				Color bright=Win7GetSystemBorderRaiseColor();

				GuiBoundsComposition* bounds=new GuiBoundsComposition;
				bounds->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				boundsComposition=bounds;

				GuiSolidBackgroundElement* backgroundElement=GuiSolidBackgroundElement::Create();
				bounds->SetOwnedElement(backgroundElement);
				backgroundElement->SetColor(Win7GetSystemWindowColor());

				GuiBoundsComposition* splitterComposition=new GuiBoundsComposition;
				bounds->AddChild(splitterComposition);
				splitterComposition->SetAlignmentToParent(Margin(3, 3, 3, 3));

				Gui3DSplitterElement* splitterElement=Gui3DSplitterElement::Create();
				splitterComposition->SetOwnedElement(splitterElement);
				splitterElement->SetColors(dark, bright);
				splitterElement->SetDirection(Gui3DSplitterElement::Vertical);
			}

			Win7ToolstripSplitterStyle::~Win7ToolstripSplitterStyle()
			{
			}

			compositions::GuiBoundsComposition* Win7ToolstripSplitterStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win7ToolstripSplitterStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win7ToolstripSplitterStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win7ToolstripSplitterStyle::SetText(const WString& value)
			{
			}

			void Win7ToolstripSplitterStyle::SetFont(const FontProperties& value)
			{
			}

			void Win7ToolstripSplitterStyle::SetVisuallyEnabled(bool value)
			{
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win8Styles\GuiWin8ButtonStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win8ButtonStyleBase
***********************************************************************/

			IMPLEMENT_TRANSFERRING_ANIMATION(Win8ButtonColors, Win8ButtonStyleBase)
			{
				colorCurrent=Win8ButtonColors::Blend(colorBegin, colorEnd, currentPosition, totalLength);
				style->elements.Apply(colorCurrent);
				style->AfterApplyColors(colorCurrent);
			}

			void Win8ButtonStyleBase::AfterApplyColors(const Win8ButtonColors& colors)
			{
			}

			Win8ButtonStyleBase::Win8ButtonStyleBase(const Win8ButtonColors& initialColor, Alignment::Type horizontal, Alignment::Type vertical)
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isSelected(false)
				,transparentWhenInactive(false)
				,transparentWhenDisabled(false)
			{
				elements=Win8ButtonElements::Create(horizontal, vertical);
				elements.Apply(initialColor);
				transferringAnimation=new TransferringAnimation(this, initialColor);
			}

			Win8ButtonStyleBase::~Win8ButtonStyleBase()
			{
				transferringAnimation->Disable();
			}

			compositions::GuiBoundsComposition* Win8ButtonStyleBase::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win8ButtonStyleBase::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win8ButtonStyleBase::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8ButtonStyleBase::SetText(const WString& value)
			{
				elements.textElement->SetText(value);
			}

			void Win8ButtonStyleBase::SetFont(const FontProperties& value)
			{
				Win8SetFont(elements.textElement, elements.textComposition, value);
			}

			void Win8ButtonStyleBase::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win8ButtonStyleBase::SetSelected(bool value)
			{
				if(isSelected!=value)
				{
					isSelected=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win8ButtonStyleBase::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			bool Win8ButtonStyleBase::GetTransparentWhenInactive()
			{
				return transparentWhenInactive;
			}

			void Win8ButtonStyleBase::SetTransparentWhenInactive(bool value)
			{
				transparentWhenInactive=value;
				TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
			}

			bool Win8ButtonStyleBase::GetTransparentWhenDisabled()
			{
				return transparentWhenDisabled;
			}

			void Win8ButtonStyleBase::SetTransparentWhenDisabled(bool value)
			{
				transparentWhenDisabled=value;
				TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
			}

			bool Win8ButtonStyleBase::GetAutoSizeForText()
			{
				return elements.textComposition->GetMinSizeLimitation()!=GuiGraphicsComposition::NoLimit;
			}

			void Win8ButtonStyleBase::SetAutoSizeForText(bool value)
			{
				if(value)
				{
					elements.textComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				}
				else
				{
					elements.textComposition->SetMinSizeLimitation(GuiGraphicsComposition::NoLimit);
				}
			}

/***********************************************************************
Win8ButtonStyle
***********************************************************************/

			void Win8ButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				Win8ButtonColors targetColor;
				if(enabled)
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win8ButtonColors::ButtonNormal();
						if(transparentWhenInactive)
						{
							targetColor.SetAlphaWithoutText(0);
						}
						break;
					case GuiButton::Active:
						targetColor=Win8ButtonColors::ButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win8ButtonColors::ButtonPressed();
						break;
					}
				}
				else
				{
					targetColor=Win8ButtonColors::ButtonDisabled();
					if(transparentWhenDisabled)
					{
						targetColor.SetAlphaWithoutText(0);
					}
				}
				transferringAnimation->Transfer(targetColor);
			}

			Win8ButtonStyle::Win8ButtonStyle()
				:Win8ButtonStyleBase(Win8ButtonColors::ButtonNormal(), Alignment::Center, Alignment::Center)
			{
			}

			Win8ButtonStyle::~Win8ButtonStyle()
			{
			}

/***********************************************************************
Win7CheckBoxStyle
***********************************************************************/

			IMPLEMENT_TRANSFERRING_ANIMATION(Win8ButtonColors, Win8CheckBoxStyle)
			{
				colorCurrent=Win8ButtonColors::Blend(colorBegin, colorEnd, currentPosition, totalLength);
				style->elements.Apply(colorCurrent);
			}

			void Win8CheckBoxStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				if(enabled)
				{
					switch(value)
					{
					case GuiButton::Normal:
						transferringAnimation->Transfer(Win8ButtonColors::CheckedNormal(selected));
						break;
					case GuiButton::Active:
						transferringAnimation->Transfer(Win8ButtonColors::CheckedActive(selected));
						break;
					case GuiButton::Pressed:
						transferringAnimation->Transfer(Win8ButtonColors::CheckedPressed(selected));
						break;
					}
				}
				else
				{
					transferringAnimation->Transfer(Win8ButtonColors::CheckedDisabled(selected));
				}
			}

			Win8CheckBoxStyle::Win8CheckBoxStyle(BulletStyle bulletStyle, bool backgroundVisible)
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isSelected(false)
			{
				Win8ButtonColors initialColor=Win8ButtonColors::CheckedNormal(isSelected);
				elements=Win8CheckedButtonElements::Create(bulletStyle==CheckBox?ElementShape::Rectangle:ElementShape::Ellipse, backgroundVisible);
				elements.Apply(initialColor);
				transferringAnimation=new TransferringAnimation(this, initialColor);
			}

			Win8CheckBoxStyle::~Win8CheckBoxStyle()
			{
				transferringAnimation->Disable();
			}

			compositions::GuiBoundsComposition* Win8CheckBoxStyle::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win8CheckBoxStyle::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win8CheckBoxStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8CheckBoxStyle::SetText(const WString& value)
			{
				elements.textElement->SetText(value);
			}

			void Win8CheckBoxStyle::SetFont(const FontProperties& value)
			{
				Win8SetFont(elements.textElement, elements.textComposition, value);
			}

			void Win8CheckBoxStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win8CheckBoxStyle::SetSelected(bool value)
			{
				if(isSelected!=value)
				{
					isSelected=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}

			void Win8CheckBoxStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isSelected);
				}
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win8Styles\GuiWin8ControlStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win8EmptyStyle
***********************************************************************/

			Win8EmptyStyle::Win8EmptyStyle(Color color)
			{
				GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
				element->SetColor(color);
				
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetOwnedElement(element);
			}

			Win8EmptyStyle::~Win8EmptyStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8EmptyStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8EmptyStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win8EmptyStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8EmptyStyle::SetText(const WString& value)
			{
			}

			void Win8EmptyStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8EmptyStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win8WindowStyle
***********************************************************************/

			Win8WindowStyle::Win8WindowStyle()
			{
				GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
				element->SetColor(Win8GetSystemWindowColor());
				
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetOwnedElement(element);
			}

			Win8WindowStyle::~Win8WindowStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8WindowStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8WindowStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win8WindowStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8WindowStyle::SetText(const WString& value)
			{
			}

			void Win8WindowStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8WindowStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win8LabelStyle
***********************************************************************/

			Win8LabelStyle::Win8LabelStyle()
			{
				textElement=GuiSolidLabelElement::Create();
				textElement->SetColor(GetDefaultTextColor());
				
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetOwnedElement(textElement);
				boundsComposition->SetMinSizeLimitation(GuiBoundsComposition::LimitToElement);
			}

			Win8LabelStyle::~Win8LabelStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8LabelStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8LabelStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win8LabelStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8LabelStyle::SetText(const WString& value)
			{
				textElement->SetText(value);
			}

			void Win8LabelStyle::SetFont(const FontProperties& value)
			{
				textElement->SetFont(value);
			}

			void Win8LabelStyle::SetVisuallyEnabled(bool value)
			{
			}

			Color Win8LabelStyle::GetDefaultTextColor()
			{
				return Win8GetSystemTextColor(true);
			}

			void Win8LabelStyle::SetTextColor(Color value)
			{
				textElement->SetColor(value);
			}

/***********************************************************************
Win8GroupBoxStyle
***********************************************************************/
			
			IMPLEMENT_TRANSFERRING_ANIMATION(Color, Win8GroupBoxStyle)
			{
				colorCurrent=BlendColor(colorBegin, colorEnd, currentPosition, totalLength);
				style->textElement->SetColor(colorCurrent);
			}

			void Win8GroupBoxStyle::SetMargins(vint fontSize)
			{
				fontSize+=4;
				vint half=fontSize/2;
				borderComposition->SetAlignmentToParent(Margin(0, half, 0, 0));
				containerComposition->SetAlignmentToParent(Margin(1, fontSize, 1, 1));
				textBackgroundComposition->SetAlignmentToParent(Margin(half, 2, -1, -1));
			}

			Win8GroupBoxStyle::Win8GroupBoxStyle()
			{
				boundsComposition=new GuiBoundsComposition;
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win8GetSystemWindowColor());

					boundsComposition->SetOwnedElement(element);
					boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}

				borderComposition=new GuiBoundsComposition;
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					element->SetColor(Color(221, 221, 221));

					borderComposition->SetOwnedElement(element);
					boundsComposition->AddChild(borderComposition);
				}

				textBackgroundComposition=new GuiBoundsComposition;
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win8GetSystemWindowColor());

					textBackgroundComposition->SetOwnedElement(element);
					textBackgroundComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					boundsComposition->AddChild(textBackgroundComposition);
				}

				textComposition=new GuiBoundsComposition;
				{
					GuiSolidLabelElement* element=GuiSolidLabelElement::Create();
					element->SetColor(Win8GetSystemTextColor(true));
					textElement=element;

					textComposition->SetOwnedElement(element);
					textComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					textComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
					textBackgroundComposition->AddChild(textComposition);
				}

				containerComposition=new GuiBoundsComposition;
				{
					boundsComposition->AddChild(containerComposition);
				}

				SetMargins(0);
				transferringAnimation=new TransferringAnimation(this, Win8GetSystemTextColor(true));
			}

			Win8GroupBoxStyle::~Win8GroupBoxStyle()
			{
				transferringAnimation->Disable();
			}

			compositions::GuiBoundsComposition* Win8GroupBoxStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8GroupBoxStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win8GroupBoxStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8GroupBoxStyle::SetText(const WString& value)
			{
				textElement->SetText(value);
			}

			void Win8GroupBoxStyle::SetFont(const FontProperties& value)
			{
				textElement->SetFont(value);
				SetMargins(value.size);
			}

			void Win8GroupBoxStyle::SetVisuallyEnabled(bool value)
			{
				if(value)
				{
					transferringAnimation->Transfer(Win8GetSystemTextColor(true));
				}
				else
				{
					transferringAnimation->Transfer(Win8GetSystemTextColor(false));
				}
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win8Styles\GuiWin8ListStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win8SelectableItemStyle
***********************************************************************/

			void Win8SelectableItemStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				if(!enabled)
				{
					transferringAnimation->Transfer(Win8ButtonColors::ItemDisabled());
				}
				else if(selected)
				{
					transferringAnimation->Transfer(Win8ButtonColors::ItemSelected());
				}
				else
				{
					switch(value)
					{
					case GuiButton::Normal:
						transferringAnimation->Transfer(Win8ButtonColors::ItemNormal());
						break;
					case GuiButton::Active:
						transferringAnimation->Transfer(Win8ButtonColors::ItemActive());
						break;
					case GuiButton::Pressed:
						transferringAnimation->Transfer(Win8ButtonColors::ItemSelected());
						break;
					}
				}
			}

			Win8SelectableItemStyle::Win8SelectableItemStyle()
				:Win8ButtonStyleBase(Win8ButtonColors::ItemNormal(), Alignment::Left, Alignment::Center)
			{
				transferringAnimation->SetEnableAnimation(false);
			}

			Win8SelectableItemStyle::~Win8SelectableItemStyle()
			{
			}

/***********************************************************************
Win8DropDownComboBoxStyle
***********************************************************************/

			void Win8DropDownComboBoxStyle::TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)
			{
				Win8ButtonColors targetColor;
				if(enabled)
				{
					if(selected) value=GuiButton::Pressed;
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win8ButtonColors::ButtonNormal();
						break;
					case GuiButton::Active:
						targetColor=Win8ButtonColors::ButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win8ButtonColors::ButtonPressed();
						break;
					}
				}
				else
				{
					targetColor=Win8ButtonColors::ButtonDisabled();
				}
				transferringAnimation->Transfer(targetColor);
			}

			void Win8DropDownComboBoxStyle::AfterApplyColors(const Win8ButtonColors& colors)
			{
				Win8ButtonStyle::AfterApplyColors(colors);
				dropDownElement->SetBorderColor(colors.textColor);
				dropDownElement->SetBackgroundColor(colors.textColor);
			}

			Win8DropDownComboBoxStyle::Win8DropDownComboBoxStyle()
				:commandExecutor(0)
			{
				table=new GuiTableComposition;
				table->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				table->SetAlignmentToParent(Margin(0, 0, 0, 0));
				table->SetRowsAndColumns(3, 2);
				table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
				table->SetRowOption(1, GuiCellOption::MinSizeOption());
				table->SetRowOption(2, GuiCellOption::PercentageOption(1.0));
				table->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
				table->SetColumnOption(1, GuiCellOption::MinSizeOption());
				elements.textComposition->AddChild(table);
				elements.textComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);

				textComposition=new GuiCellComposition;
				table->AddChild(textComposition);
				textComposition->SetSite(1, 0, 1, 1);

				Ptr<IGuiGraphicsElement> element=elements.textComposition->GetOwnedElement();
				elements.textComposition->SetOwnedElement(0);
				textComposition->SetOwnedElement(element);
				elements.textElement->SetEllipse(true);
				elements.textElement->SetAlignments(Alignment::Left, Alignment::Center);

				dropDownElement=common_styles::CommonFragmentBuilder::BuildDownArrow();

				dropDownComposition=new GuiCellComposition;
				table->AddChild(dropDownComposition);
				dropDownComposition->SetSite(1, 1, 1, 1);
				dropDownComposition->SetOwnedElement(dropDownElement);
				dropDownComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				dropDownComposition->SetMargin(Margin(3, 0, 3, 0));
			}

			Win8DropDownComboBoxStyle::~Win8DropDownComboBoxStyle()
			{
			}

			compositions::GuiGraphicsComposition* Win8DropDownComboBoxStyle::GetContainerComposition()
			{
				return textComposition;
			}

			void Win8DropDownComboBoxStyle::SetCommandExecutor(controls::GuiComboBoxBase::ICommandExecutor* value)
			{
				commandExecutor=value;
			}

			void Win8DropDownComboBoxStyle::OnClicked()
			{
				commandExecutor->ShowPopup();
			}

			void Win8DropDownComboBoxStyle::OnPopupOpened()
			{
				SetSelected(true);
			}

			void Win8DropDownComboBoxStyle::OnPopupClosed()
			{
				SetSelected(false);
			}

			void Win8DropDownComboBoxStyle::OnItemSelected()
			{
			}

			controls::GuiWindow::IStyleController* Win8DropDownComboBoxStyle::CreatePopupStyle()
			{
				return new Win8WindowStyle;
			}

/***********************************************************************
Win8TextListProvider
***********************************************************************/
			
			Win8TextListProvider::Win8TextListProvider()
			{
			}

			Win8TextListProvider::~Win8TextListProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win8TextListProvider::CreateBackgroundStyleController()
			{
				return new Win8SelectableItemStyle;
			}

			controls::GuiSelectableButton::IStyleController* Win8TextListProvider::CreateBulletStyleController()
			{
				return 0;
			}

/***********************************************************************
Win8CheckTextListProvider
***********************************************************************/

			Win8CheckTextListProvider::Win8CheckTextListProvider()
			{
			}

			Win8CheckTextListProvider::~Win8CheckTextListProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win8CheckTextListProvider::CreateBulletStyleController()
			{
				return new Win8CheckBoxStyle(Win8CheckBoxStyle::CheckBox, false);
			}

/***********************************************************************
Win8RadioTextListProvider
***********************************************************************/

			Win8RadioTextListProvider::Win8RadioTextListProvider()
			{
			}

			Win8RadioTextListProvider::~Win8RadioTextListProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win8RadioTextListProvider::CreateBulletStyleController()
			{
				return new Win8CheckBoxStyle(Win8CheckBoxStyle::RadioButton, false);
			}

/***********************************************************************
Win8ListViewProvider
***********************************************************************/

			Win8ListViewProvider::Win8ListViewProvider()
			{
			}

			Win8ListViewProvider::~Win8ListViewProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win8ListViewProvider::CreateItemBackground()
			{
				return new Win8SelectableItemStyle;
			}

			controls::GuiListViewColumnHeader::IStyleController* Win8ListViewProvider::CreateColumnStyle()
			{
				return new win7::Win7ListViewColumnHeaderStyle;
			}

			Color Win8ListViewProvider::GetPrimaryTextColor()
			{
				return Win8GetSystemTextColor(true);
			}

			Color Win8ListViewProvider::GetSecondaryTextColor()
			{
				return Win8GetSystemTextColor(false);
			}

			Color Win8ListViewProvider::GetItemSeparatorColor()
			{
				return Color(220, 220, 220);
			}

/***********************************************************************
Win8TreeViewProvider
***********************************************************************/

			Win8TreeViewProvider::Win8TreeViewProvider()
			{
			}

			Win8TreeViewProvider::~Win8TreeViewProvider()
			{
			}

			controls::GuiSelectableButton::IStyleController* Win8TreeViewProvider::CreateItemBackground()
			{
				return new Win8SelectableItemStyle;
			}

			controls::GuiSelectableButton::IStyleController* Win8TreeViewProvider::CreateItemExpandingDecorator()
			{
				return new win7::Win7TreeViewExpandingButtonStyle;
			}

			Color Win8TreeViewProvider::GetTextColor()
			{
				return Win8GetSystemTextColor(true);
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win8Styles\GuiWin8MenuStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win8MenuStyle
***********************************************************************/

			Win8MenuStyle::Win8MenuStyle()
			{
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					element->SetColor(Win8GetMenuBorderColor());
					boundsComposition=new GuiBoundsComposition;
					boundsComposition->SetOwnedElement(element);
				}
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win8GetSystemWindowColor());
					GuiBoundsComposition* subBorder=new GuiBoundsComposition;
					subBorder->SetOwnedElement(element);
					subBorder->SetAlignmentToParent(Margin(1, 1, 1, 1));
					boundsComposition->AddChild(subBorder);
				}
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win8GetSystemWindowColor());
					containerComposition=new GuiBoundsComposition;
					containerComposition->SetOwnedElement(element);
					containerComposition->SetAlignmentToParent(Margin(3, 3, 3, 3));
					containerComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					boundsComposition->AddChild(containerComposition);
				}
			}

			Win8MenuStyle::~Win8MenuStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8MenuStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8MenuStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win8MenuStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8MenuStyle::SetText(const WString& value)
			{
			}

			void Win8MenuStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8MenuStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win8MenuBarStyle
***********************************************************************/

			Win8MenuBarStyle::Win8MenuBarStyle()
			{
				boundsComposition=new GuiBoundsComposition;
				{
					GuiSolidBackgroundElement* solid=GuiSolidBackgroundElement::Create();
					solid->SetColor(Color(245, 246, 247));
					boundsComposition->SetOwnedElement(solid);
					boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				{
					Gui3DSplitterElement* element=Gui3DSplitterElement::Create();
					element->SetColors(Color(232, 233, 234), Color(240, 240, 240));
					element->SetDirection(Gui3DSplitterElement::Horizontal);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetOwnedElement(element);
					composition->SetPreferredMinSize(Size(0, 2));
					composition->SetAlignmentToParent(Margin(0, -1, 0, 0));
					boundsComposition->AddChild(composition);
				}
				containerComposition=new GuiBoundsComposition;
				{
					containerComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					containerComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					boundsComposition->AddChild(containerComposition);
				}
			}

			Win8MenuBarStyle::~Win8MenuBarStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8MenuBarStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8MenuBarStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win8MenuBarStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8MenuBarStyle::SetText(const WString& value)
			{
			}

			void Win8MenuBarStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8MenuBarStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win8MenuBarButtonStyle
***********************************************************************/

			void Win8MenuBarButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool opening)
			{
				Win8ButtonColors targetColor;
				if(!enabled)
				{
					targetColor=Win8ButtonColors::MenuBarButtonDisabled();
					targetColor.SetAlphaWithoutText(0);
				}
				else if(opening)
				{
					targetColor=Win8ButtonColors::MenuBarButtonPressed();
				}
				else
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win8ButtonColors::MenuBarButtonNormal();
						targetColor.SetAlphaWithoutText(0);
						break;
					case GuiButton::Active:
						targetColor=Win8ButtonColors::MenuBarButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win8ButtonColors::MenuBarButtonPressed();
						break;
					}
				}
				elements.Apply(targetColor);
			}

			Win8MenuBarButtonStyle::Win8MenuBarButtonStyle()
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isOpening(false)
			{
				Win8ButtonColors initialColor=Win8ButtonColors::MenuBarButtonNormal();
				initialColor.SetAlphaWithoutText(0);

				elements=Win8ButtonElements::Create(Alignment::Center, Alignment::Center);
				elements.Apply(initialColor);
			}

			Win8MenuBarButtonStyle::~Win8MenuBarButtonStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8MenuBarButtonStyle::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win8MenuBarButtonStyle::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win8MenuBarButtonStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8MenuBarButtonStyle::SetText(const WString& value)
			{
				elements.textElement->SetText(value);
			}

			void Win8MenuBarButtonStyle::SetFont(const FontProperties& value)
			{
				Win8SetFont(elements.textElement, elements.textComposition, value);
				Margin margin=elements.textComposition->GetMargin();
				margin.left*=3;
				margin.right*=3;
				elements.textComposition->SetMargin(margin);
			}

			void Win8MenuBarButtonStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiMenu::IStyleController* Win8MenuBarButtonStyle::CreateSubMenuStyleController()
			{
				return new Win8MenuStyle;
			}

			void Win8MenuBarButtonStyle::SetSubMenuExisting(bool value)
			{
			}

			void Win8MenuBarButtonStyle::SetSubMenuOpening(bool value)
			{
				if(isOpening!=value)
				{
					isOpening=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiButton* Win8MenuBarButtonStyle::GetSubMenuHost()
			{
				return 0;
			}

			void Win8MenuBarButtonStyle::SetImage(Ptr<controls::GuiImageData> value)
			{
			}

			void Win8MenuBarButtonStyle::SetShortcutText(const WString& value)
			{
			}

			compositions::GuiSubComponentMeasurer::IMeasuringSource* Win8MenuBarButtonStyle::GetMeasuringSource()
			{
				return 0;
			}

			void Win8MenuBarButtonStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

/***********************************************************************
Win8MenuItemButtonStyle::MeasuringSource
***********************************************************************/

			Win8MenuItemButtonStyle::MeasuringSource::MeasuringSource(Win8MenuItemButtonStyle* _style)
				:GuiSubComponentMeasurer::MeasuringSource(GuiMenuButton::MenuItemSubComponentMeasuringCategoryName, _style->elements.mainComposition)
				,style(_style)
			{
				AddSubComponent(L"text", style->elements.textComposition);
				AddSubComponent(L"shortcut", style->elements.shortcutComposition);
			}

			Win8MenuItemButtonStyle::MeasuringSource::~MeasuringSource()
			{
			}

			void Win8MenuItemButtonStyle::MeasuringSource::SubComponentPreferredMinSizeUpdated()
			{
				GetMainComposition()->ForceCalculateSizeImmediately();
			}

/***********************************************************************
Win8MenuItemButtonStyle
***********************************************************************/

			void Win8MenuItemButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool opening)
			{
				Win8ButtonColors targetColor;
				bool active=false;
				if(enabled)
				{
					if(opening)
					{
						targetColor=Win8ButtonColors::MenuItemButtonNormalActive();
						active=true;
					}
					else
					{
						switch(value)
						{
						case GuiButton::Normal:
							targetColor=Win8ButtonColors::MenuItemButtonNormal();
							break;
						case GuiButton::Active:
						case GuiButton::Pressed:
							targetColor=Win8ButtonColors::MenuItemButtonNormalActive();
							active=true;
							break;
						}
					}
				}
				else
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win8ButtonColors::MenuItemButtonDisabled();
						break;
					case GuiButton::Active:
					case GuiButton::Pressed:
						targetColor=Win8ButtonColors::MenuItemButtonDisabledActive();
						active=true;
						break;
					}
				}
				elements.Apply(targetColor);
				elements.SetActive(active);
			}

			Win8MenuItemButtonStyle::Win8MenuItemButtonStyle()
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isOpening(false)
			{
				elements=Win8MenuItemButtonElements::Create();
				elements.Apply(Win8ButtonColors::MenuItemButtonNormal());
				measuringSource=new MeasuringSource(this);
			}

			Win8MenuItemButtonStyle::~Win8MenuItemButtonStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8MenuItemButtonStyle::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win8MenuItemButtonStyle::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win8MenuItemButtonStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8MenuItemButtonStyle::SetText(const WString& value)
			{
				elements.textElement->SetText(value);
			}

			void Win8MenuItemButtonStyle::SetFont(const FontProperties& value)
			{
				Win8SetFont(elements.textElement, elements.textComposition, value);
				Win8SetFont(elements.shortcutElement, elements.shortcutComposition, value);
			}

			void Win8MenuItemButtonStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					elements.imageElement->SetEnabled(value);
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiMenu::IStyleController* Win8MenuItemButtonStyle::CreateSubMenuStyleController()
			{
				return new Win8MenuStyle;
			}

			void Win8MenuItemButtonStyle::SetSubMenuExisting(bool value)
			{
				elements.SetSubMenuExisting(value);
			}

			void Win8MenuItemButtonStyle::SetSubMenuOpening(bool value)
			{
				if(isOpening!=value)
				{
					isOpening=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiButton* Win8MenuItemButtonStyle::GetSubMenuHost()
			{
				return 0;
			}

			void Win8MenuItemButtonStyle::SetImage(Ptr<controls::GuiImageData> value)
			{
				if(value)
				{
					elements.imageElement->SetImage(value->GetImage(), value->GetFrameIndex());
				}
				else
				{
					elements.imageElement->SetImage(0, 0);
				}
			}

			void Win8MenuItemButtonStyle::SetShortcutText(const WString& value)
			{
				elements.shortcutElement->SetText(value);
			}

			compositions::GuiSubComponentMeasurer::IMeasuringSource* Win8MenuItemButtonStyle::GetMeasuringSource()
			{
				return measuringSource.Obj();
			}

			void Win8MenuItemButtonStyle::Transfer(GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

/***********************************************************************
Win8MenuSplitterStyle
***********************************************************************/

			Win8MenuSplitterStyle::Win8MenuSplitterStyle()
			{
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetPreferredMinSize(Size(26, 5));
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					element->SetColor(Win8GetMenuSplitterColor());

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetPreferredMinSize(Size(1, 0));
					composition->SetOwnedElement(element);
					composition->SetAlignmentToParent(Margin(26, 0, -1, 0));
					boundsComposition->AddChild(composition);
				}
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					element->SetColor(Win8GetMenuSplitterColor());

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetPreferredMinSize(Size(0, 1));
					composition->SetOwnedElement(element);
					composition->SetAlignmentToParent(Margin(27, 2, 0, 2));
					boundsComposition->AddChild(composition);
				}
			}

			Win8MenuSplitterStyle::~Win8MenuSplitterStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8MenuSplitterStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8MenuSplitterStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win8MenuSplitterStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8MenuSplitterStyle::SetText(const WString& value)
			{
			}

			void Win8MenuSplitterStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8MenuSplitterStyle::SetVisuallyEnabled(bool value)
			{
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win8Styles\GuiWin8ScrollableStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win8ScrollHandleButtonStyle
***********************************************************************/

			void Win8ScrollHandleButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				Win8ButtonColors targetColor;
				if(enabled)
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win8ButtonColors::ScrollHandleNormal();
						break;
					case GuiButton::Active:
						targetColor=Win8ButtonColors::ScrollHandleActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win8ButtonColors::ScrollHandlePressed();
						break;
					}
				}
				else
				{
					targetColor=Win8ButtonColors::ScrollHandleDisabled();
				}
				transferringAnimation->Transfer(targetColor);
			}

			Win8ScrollHandleButtonStyle::Win8ScrollHandleButtonStyle()
				:Win8ButtonStyleBase(Win8ButtonColors::ScrollHandleNormal(), Alignment::Center, Alignment::Center)
			{
			}

			Win8ScrollHandleButtonStyle::~Win8ScrollHandleButtonStyle()
			{
			}

/***********************************************************************
Win8ScrollArrowButtonStyle
***********************************************************************/

			void Win8ScrollArrowButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool selected)
			{
				Win8ButtonColors targetColor;
				if(enabled)
				{
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win8ButtonColors::ScrollArrowNormal();
						break;
					case GuiButton::Active:
						targetColor=Win8ButtonColors::ScrollArrowActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win8ButtonColors::ScrollArrowPressed();
						break;
					}
				}
				else
				{
					targetColor=Win8ButtonColors::ScrollArrowDisabled();
				}
				transferringAnimation->Transfer(targetColor);
			}

			void Win8ScrollArrowButtonStyle::AfterApplyColors(const Win8ButtonColors& colors)
			{
				Win8ButtonStyleBase::AfterApplyColors(colors);
				arrowElement->SetBorderColor(colors.textColor);
				arrowElement->SetBackgroundColor(colors.textColor);
			}

			Win8ScrollArrowButtonStyle::Win8ScrollArrowButtonStyle(common_styles::CommonScrollStyle::Direction direction, bool increaseButton)
				:Win8ButtonStyleBase(Win8ButtonColors::ScrollArrowNormal(), Alignment::Center, Alignment::Center)
			{
				switch(direction)
				{
				case common_styles::CommonScrollStyle::Horizontal:
					if(increaseButton)
					{
						GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildRightArrow(arrowElement));
					}
					else
					{
						GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildLeftArrow(arrowElement));
					}
					break;
				case common_styles::CommonScrollStyle::Vertical:
					if(increaseButton)
					{
						GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildDownArrow(arrowElement));
					}
					else
					{
						GetContainerComposition()->AddChild(common_styles::CommonFragmentBuilder::BuildUpArrow(arrowElement));
					}
					break;
				}
			}

			Win8ScrollArrowButtonStyle::~Win8ScrollArrowButtonStyle()
			{
			}

/***********************************************************************
Win8ScrollStyle
***********************************************************************/

			controls::GuiButton::IStyleController* Win8ScrollStyle::CreateDecreaseButtonStyle(Direction direction)
			{
				Win8ScrollArrowButtonStyle* decreaseButtonStyle=new Win8ScrollArrowButtonStyle(direction, false);
				return decreaseButtonStyle;
			}

			controls::GuiButton::IStyleController* Win8ScrollStyle::CreateIncreaseButtonStyle(Direction direction)
			{
				Win8ScrollArrowButtonStyle* increaseButtonStyle=new Win8ScrollArrowButtonStyle(direction, true);
				return increaseButtonStyle;
			}

			controls::GuiButton::IStyleController* Win8ScrollStyle::CreateHandleButtonStyle(Direction direction)
			{
				Win8ScrollHandleButtonStyle* handleButtonStyle=new Win8ScrollHandleButtonStyle;
				return handleButtonStyle;
			}

			compositions::GuiBoundsComposition* Win8ScrollStyle::InstallBackground(compositions::GuiBoundsComposition* boundsComposition, Direction direction)
			{
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win8GetSystemWindowColor());
					
					boundsComposition->SetOwnedElement(element);
				}

				return boundsComposition;
			}

			Win8ScrollStyle::Win8ScrollStyle(Direction _direction)
				:CommonScrollStyle(_direction)
			{
				BuildStyle(DefaultSize, ArrowSize);
			}

			Win8ScrollStyle::~Win8ScrollStyle()
			{
			}

/***********************************************************************
Win8TrackStyle
***********************************************************************/

			controls::GuiButton::IStyleController* Win8TrackStyle::CreateHandleButtonStyle(Direction direction)
			{
				Win8ButtonStyle* handleButtonStyle=new Win8ButtonStyle;
				return handleButtonStyle;
			}

			void Win8TrackStyle::InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)
			{
				GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
				element->SetColor(Win8GetSystemWindowColor());
				boundsComposition->SetOwnedElement(element);
			}

			void Win8TrackStyle::InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)
			{
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Color(231, 234, 234));
					trackComposition->SetOwnedElement(element);
				}
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					element->SetColor(Color(214, 214, 214));
					
					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetOwnedElement(element);
					composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					trackComposition->AddChild(composition);
				}
			}

			Win8TrackStyle::Win8TrackStyle(Direction _direction)
				:CommonTrackStyle(_direction)
			{
				BuildStyle(TrackThickness, TrackPadding, HandleLong, HandleShort);
			}

			Win8TrackStyle::~Win8TrackStyle()
			{
			}

/***********************************************************************
Win8ProgressBarStyle
***********************************************************************/

			void Win8ProgressBarStyle::UpdateProgressBar()
			{
				vint max=totalSize-pageSize;
				if(position<0)
				{
					progressComposition->SetWidthPageSize(0);
				}
				else if(position>=max)
				{
					progressComposition->SetWidthPageSize(1);
				}
				else
				{
					progressComposition->SetWidthPageSize((double)position/max);
				}
			}

			Win8ProgressBarStyle::Win8ProgressBarStyle()
				:totalSize(1)
				,pageSize(0)
				,position(0)
			{
				{
					boundsComposition=new GuiBoundsComposition;
				}
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Color(230, 230, 230));

					containerComposition=new GuiBoundsComposition;
					containerComposition->SetAlignmentToParent(Margin(1, 1, 1, 1));
					containerComposition->SetOwnedElement(element);
					boundsComposition->AddChild(containerComposition);
				}
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					element->SetColor(Color(188, 188, 188));

					GuiBoundsComposition* borderComposition=new GuiBoundsComposition;
					borderComposition->SetOwnedElement(element);
					borderComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					boundsComposition->AddChild(borderComposition);
				}
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Color(6, 176, 37));

					progressComposition=new GuiPartialViewComposition;
					progressComposition->SetWidthRatio(0);
					progressComposition->SetWidthPageSize(0);
					progressComposition->SetHeightRatio(0);
					progressComposition->SetHeightPageSize(1);
					progressComposition->SetOwnedElement(element);
					containerComposition->AddChild(progressComposition);
				}
			}

			Win8ProgressBarStyle::~Win8ProgressBarStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8ProgressBarStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8ProgressBarStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win8ProgressBarStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8ProgressBarStyle::SetText(const WString& value)
			{
			}

			void Win8ProgressBarStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8ProgressBarStyle::SetVisuallyEnabled(bool value)
			{
			}

			void Win8ProgressBarStyle::SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)
			{
			}

			void Win8ProgressBarStyle::SetTotalSize(vint value)
			{
				totalSize=value;
				UpdateProgressBar();
			}

			void Win8ProgressBarStyle::SetPageSize(vint value)
			{
				pageSize=value;
				UpdateProgressBar();
			}

			void Win8ProgressBarStyle::SetPosition(vint value)
			{
				position=value;
				UpdateProgressBar();
			}

/***********************************************************************
Win8ScrollViewProvider
***********************************************************************/

			Win8ScrollViewProvider::Win8ScrollViewProvider()
			{
			}

			Win8ScrollViewProvider::~Win8ScrollViewProvider()
			{
			}

			void Win8ScrollViewProvider::AssociateStyleController(controls::GuiControl::IStyleController* controller)
			{
			}
			
			void Win8ScrollViewProvider::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8ScrollViewProvider::SetText(const WString& value)
			{
			}

			void Win8ScrollViewProvider::SetFont(const FontProperties& value)
			{
			}

			void Win8ScrollViewProvider::SetVisuallyEnabled(bool value)
			{
			}

			controls::GuiScroll::IStyleController* Win8ScrollViewProvider::CreateHorizontalScrollStyle()
			{
				return new Win8ScrollStyle(Win8ScrollStyle::Horizontal);
			}

			controls::GuiScroll::IStyleController* Win8ScrollViewProvider::CreateVerticalScrollStyle()
			{
				return new Win8ScrollStyle(Win8ScrollStyle::Vertical);
			}

			vint Win8ScrollViewProvider::GetDefaultScrollSize()
			{
				return Win8ScrollStyle::DefaultSize;
			}

			compositions::GuiGraphicsComposition* Win8ScrollViewProvider::InstallBackground(compositions::GuiBoundsComposition* boundsComposition)
			{
				GuiSolidBorderElement* border=GuiSolidBorderElement::Create();
				border->SetColor(Win8GetSystemBorderColor());
				boundsComposition->SetOwnedElement(border);
				boundsComposition->SetInternalMargin(Margin(1, 1, 1, 1));
				
				GuiSolidBackgroundElement* background=GuiSolidBackgroundElement::Create();
				background->SetColor(Win8GetSystemWindowColor());

				GuiBoundsComposition* backgroundComposition=new GuiBoundsComposition;
				boundsComposition->AddChild(backgroundComposition);
				backgroundComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				backgroundComposition->SetOwnedElement(background);

				return boundsComposition;
			}

/***********************************************************************
Win8TextBoxBackground
***********************************************************************/

#define HOST_GETTER_BY_FOCUSABLE_COMPOSITION(STYLE) (style->focusableComposition->GetRelatedGraphicsHost())

			IMPLEMENT_TRANSFERRING_ANIMATION_BASE(Win8TextBoxColors, Win8TextBoxBackground, HOST_GETTER_BY_FOCUSABLE_COMPOSITION)
			{
				colorCurrent=Win8TextBoxColors::Blend(colorBegin, colorEnd, currentPosition, totalLength);
				style->Apply(colorCurrent);
			}

			void Win8TextBoxBackground::UpdateStyle()
			{
				if(!isVisuallyEnabled)
				{
					transferringAnimation->Transfer(Win8TextBoxColors::Disabled());
				}
				else if(isFocused)
				{
					transferringAnimation->Transfer(Win8TextBoxColors::Focused());
				}
				else if(isMouseEnter)
				{
					transferringAnimation->Transfer(Win8TextBoxColors::Active());
				}
				else
				{
					transferringAnimation->Transfer(Win8TextBoxColors::Normal());
				}
			}

			void Win8TextBoxBackground::Apply(const Win8TextBoxColors& colors)
			{
				borderElement->SetColor(colors.borderColor);
				backgroundElement->SetColor(colors.backgroundColor);
			}

			void Win8TextBoxBackground::OnBoundsMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				isMouseEnter=true;
				UpdateStyle();
			}

			void Win8TextBoxBackground::OnBoundsMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				isMouseEnter=false;
				UpdateStyle();
			}

			void Win8TextBoxBackground::OnBoundsGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				isFocused=true;
				UpdateStyle();
			}

			void Win8TextBoxBackground::OnBoundsLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				isFocused=false;
				UpdateStyle();
			}

			Win8TextBoxBackground::Win8TextBoxBackground()
				:backgroundElement(0)
				,borderElement(0)
				,focusableComposition(0)
				,isMouseEnter(false)
				,isFocused(false)
				,isVisuallyEnabled(false)
				,styleController(0)
				,textElement(0)
			{
				transferringAnimation=new TransferringAnimation(this, Win8TextBoxColors::Normal());
			}

			Win8TextBoxBackground::~Win8TextBoxBackground()
			{
				transferringAnimation->Disable();
			}

			void Win8TextBoxBackground::AssociateStyleController(controls::GuiControl::IStyleController* controller)
			{
				styleController=controller;
			}
			
			void Win8TextBoxBackground::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				focusableComposition=value;
				focusableComposition->GetEventReceiver()->mouseEnter.AttachMethod(this, &Win8TextBoxBackground::OnBoundsMouseEnter);
				focusableComposition->GetEventReceiver()->mouseLeave.AttachMethod(this, &Win8TextBoxBackground::OnBoundsMouseLeave);
				focusableComposition->GetEventReceiver()->gotFocus.AttachMethod(this, &Win8TextBoxBackground::OnBoundsGotFocus);
				focusableComposition->GetEventReceiver()->lostFocus.AttachMethod(this, &Win8TextBoxBackground::OnBoundsLostFocus);
			}

			void Win8TextBoxBackground::SetVisuallyEnabled(bool value)
			{
				isVisuallyEnabled=value;
				UpdateStyle();
			}

			compositions::GuiGraphicsComposition* Win8TextBoxBackground::InstallBackground(compositions::GuiBoundsComposition* boundsComposition)
			{
				{
					GuiSolidBackgroundElement* background=GuiSolidBackgroundElement::Create();
					background->SetColor(Color(255, 255, 255));

					GuiBoundsComposition* backgroundComposition=new GuiBoundsComposition;
					boundsComposition->AddChild(backgroundComposition);
					backgroundComposition->SetAlignmentToParent(Margin(1, 1, 1, 1));
					backgroundComposition->SetOwnedElement(background);
				}
				{
					GuiSolidBackgroundElement* background=GuiSolidBackgroundElement::Create();
					background->SetColor(Color(255, 255, 255));

					GuiBoundsComposition* backgroundComposition=new GuiBoundsComposition;
					boundsComposition->AddChild(backgroundComposition);
					backgroundComposition->SetAlignmentToParent(Margin(2, 2, 2, 2));
					backgroundComposition->SetOwnedElement(background);
					backgroundElement=background;
				}
				{
					GuiSolidBorderElement* border=GuiSolidBorderElement::Create();
					border->SetColor(Win8GetSystemBorderColor());
					borderElement=border;

					GuiBoundsComposition* borderComposition=new GuiBoundsComposition;
					boundsComposition->AddChild(borderComposition);
					borderComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					borderComposition->SetOwnedElement(border);
				}
				Apply(Win8TextBoxColors::Normal());
				{
					GuiBoundsComposition* containerComposition=new GuiBoundsComposition;
					boundsComposition->AddChild(containerComposition);
					containerComposition->SetAlignmentToParent(Margin(2, 2, 2, 2));
					return containerComposition;
				}
			}

			void Win8TextBoxBackground::InitializeTextElement(elements::GuiColorizedTextElement* _textElement)
			{
				textElement=_textElement;

				Array<text::ColorEntry> colors;
				colors.Resize(1);
				{
					colors[0]=Win8GetTextBoxTextColor();
				}
				textElement->SetColors(colors);
				textElement->SetCaretColor(Color(0, 0, 0));
			}

/***********************************************************************
Win8MultilineTextBoxProvider
***********************************************************************/

			Win8MultilineTextBoxProvider::Win8MultilineTextBoxProvider()
				:styleController(0)
			{
			}

			Win8MultilineTextBoxProvider::~Win8MultilineTextBoxProvider()
			{
			}

			void Win8MultilineTextBoxProvider::AssociateStyleController(controls::GuiControl::IStyleController* controller)
			{
				styleController=controller;
				background.AssociateStyleController(controller);
			}
			
			void Win8MultilineTextBoxProvider::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				background.SetFocusableComposition(value);
				GuiMultilineTextBox::StyleController* textBoxController=dynamic_cast<GuiMultilineTextBox::StyleController*>(styleController);
				if(textBoxController)
				{
					background.InitializeTextElement(textBoxController->GetTextElement());
				}
			}

			void Win8MultilineTextBoxProvider::SetVisuallyEnabled(bool value)
			{
				background.SetVisuallyEnabled(value);
			}

			compositions::GuiGraphicsComposition* Win8MultilineTextBoxProvider::InstallBackground(compositions::GuiBoundsComposition* boundsComposition)
			{
				return background.InstallBackground(boundsComposition);
			}

/***********************************************************************
Win8SinglelineTextBoxProvider
***********************************************************************/

			Win8SinglelineTextBoxProvider::Win8SinglelineTextBoxProvider()
				:styleController(0)
			{
			}

			Win8SinglelineTextBoxProvider::~Win8SinglelineTextBoxProvider()
			{
			}

			void Win8SinglelineTextBoxProvider::AssociateStyleController(controls::GuiControl::IStyleController* controller)
			{
				styleController=controller;
				background.AssociateStyleController(controller);
			}
			
			void Win8SinglelineTextBoxProvider::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				background.SetFocusableComposition(value);
				GuiSinglelineTextBox::StyleController* textBoxController=dynamic_cast<GuiSinglelineTextBox::StyleController*>(styleController);
				background.InitializeTextElement(textBoxController->GetTextElement());
			}

			void Win8SinglelineTextBoxProvider::SetText(const WString& value)
			{
			}

			void Win8SinglelineTextBoxProvider::SetFont(const FontProperties& value)
			{
			}

			void Win8SinglelineTextBoxProvider::SetVisuallyEnabled(bool value)
			{
				background.SetVisuallyEnabled(value);
			}

			compositions::GuiGraphicsComposition* Win8SinglelineTextBoxProvider::InstallBackground(compositions::GuiBoundsComposition* boundsComposition)
			{
				return background.InstallBackground(boundsComposition);
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win8Styles\GuiWin8StylesCommon.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win8ButtonColors
***********************************************************************/

			void Win8ButtonColors::SetAlphaWithoutText(unsigned char a)
			{
				borderColor.a=a;
				g1.a=a;
				g2.a=a;
			}

			Win8ButtonColors Win8ButtonColors::Blend(const Win8ButtonColors& c1, const Win8ButtonColors& c2, vint ratio, vint total)
			{
				if(ratio<0) ratio=0;
				else if(ratio>total) ratio=total;

				Win8ButtonColors result;
				result.borderColor=BlendColor(c1.borderColor, c2.borderColor, ratio, total);
				result.g1=BlendColor(c1.g1, c2.g1, ratio, total);
				result.g2=BlendColor(c1.g2, c2.g2, ratio, total);
				result.textColor=BlendColor(c1.textColor, c2.textColor, ratio, total);
				result.bullet=BlendColor(c1.bullet, c2.bullet, ratio, total);
				return result;
			}

			//---------------------------------------------------------

			Win8ButtonColors Win8ButtonColors::ButtonNormal()
			{
				Win8ButtonColors colors=
				{
					Color(172, 172, 172),
					Color(239, 239, 239),
					Color(229, 229, 229),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ButtonActive()
			{
				Win8ButtonColors colors=
				{
					Color(126, 180, 234),
					Color(235, 244, 252),
					Color(220, 236, 252),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ButtonPressed()
			{
				Win8ButtonColors colors=
				{
					Color(86, 157, 229),
					Color(218, 236, 252),
					Color(196, 224, 252),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ButtonDisabled()
			{
				Win8ButtonColors colors=
				{
					Color(173, 178, 181),
					Color(252, 252, 252),
					Color(252, 252, 252),
					Win8GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win8ButtonColors Win8ButtonColors::ItemNormal()
			{
				Win8ButtonColors colors=
				{
					Color(112, 192, 231, 0),
					Color(229, 243, 251, 0),
					Color(229, 243, 251, 0),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ItemActive()
			{
				Win8ButtonColors colors=
				{
					Color(112, 192, 231),
					Color(229, 243, 251),
					Color(229, 243, 251),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ItemSelected()
			{
				Win8ButtonColors colors=
				{
					Color(102, 167, 232),
					Color(209, 232, 255),
					Color(209, 232, 255),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ItemDisabled()
			{
				Win8ButtonColors colors=
				{
					Color(112, 192, 231, 0),
					Color(229, 243, 251, 0),
					Color(229, 243, 251, 0),
					Win8GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win8ButtonColors Win8ButtonColors::CheckedNormal(bool selected)
			{
				Win8ButtonColors colors=
				{
					Color(112, 112, 112),
					Color(255, 255, 255),
					Color(255, 255, 255),
					Win8GetSystemTextColor(true),
					Color(0, 0, 0),
				};
				if(!selected)
				{
					colors.bullet.a=0;
				}
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::CheckedActive(bool selected)
			{
				Win8ButtonColors colors=
				{
					Color(51, 153, 255),
					Color(243, 249, 255),
					Color(243, 249, 255),
					Win8GetSystemTextColor(true),
					Color(33, 33, 33),
				};
				if(!selected)
				{
					colors.bullet.a=0;
				}
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::CheckedPressed(bool selected)
			{
				Win8ButtonColors colors=
				{
					Color(0, 124, 222),
					Color(217, 236, 255),
					Color(217, 236, 255),
					Win8GetSystemTextColor(true),
					Color(0, 0, 0),
				};
				if(!selected)
				{
					colors.bullet.a=0;
				}
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::CheckedDisabled(bool selected)
			{
				Win8ButtonColors colors=
				{
					Color(188, 188, 188),
					Color(230, 230, 230),
					Color(230, 230, 230),
					Win8GetSystemTextColor(false),
					Color(112, 112, 112),
				};
				if(!selected)
				{
					colors.bullet.a=0;
				}
				return colors;
			}

			//---------------------------------------------------------

			Win8ButtonColors Win8ButtonColors::ToolstripButtonNormal()
			{
				Win8ButtonColors colors=
				{
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ToolstripButtonActive()
			{
				Win8ButtonColors colors=
				{
					Color(120, 174, 229),
					Color(209, 226, 242),
					Color(209, 226, 242),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ToolstripButtonPressed()
			{
				Win8ButtonColors colors=
				{
					Color(96, 161, 226),
					Color(180, 212, 244),
					Color(180, 212, 244),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ToolstripButtonDisabled()
			{
				Win8ButtonColors colors=
				{
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Win8GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win8ButtonColors Win8ButtonColors::ScrollHandleNormal()
			{
				Win8ButtonColors colors=
				{
					Color(205, 205, 205),
					Color(205, 205, 205),
					Color(205, 205, 205),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ScrollHandleActive()
			{
				Win8ButtonColors colors=
				{
					Color(166, 166, 166),
					Color(166, 166, 166),
					Color(166, 166, 166),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ScrollHandlePressed()
			{
				Win8ButtonColors colors=
				{
					Color(166, 166, 166),
					Color(166, 166, 166),
					Color(166, 166, 166),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ScrollHandleDisabled()
			{
				Win8ButtonColors colors=
				{
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ScrollArrowNormal()
			{
				Win8ButtonColors colors=
				{
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Color(96, 96, 96),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ScrollArrowActive()
			{
				Win8ButtonColors colors=
				{
					Color(218, 218, 218),
					Color(218, 218, 218),
					Color(218, 218, 218),
					Color(0, 0, 0),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ScrollArrowPressed()
			{
				Win8ButtonColors colors=
				{
					Color(96, 96, 96),
					Color(96, 96, 96),
					Color(96, 96, 96),
					Color(255, 255, 255),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::ScrollArrowDisabled()
			{
				Win8ButtonColors colors=
				{
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Win8GetSystemWindowColor(),
					Color(191, 191, 191),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win8ButtonColors Win8ButtonColors::MenuBarButtonNormal()
			{
				Win8ButtonColors colors=
				{
					Color(245, 246, 247),
					Color(245, 246, 247),
					Color(245, 246, 247),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::MenuBarButtonActive()
			{
				Win8ButtonColors colors=
				{
					Color(122, 177, 232),
					Color(213, 231, 248),
					Color(213, 231, 248),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::MenuBarButtonPressed()
			{
				Win8ButtonColors colors=
				{
					Color(98, 163, 229),
					Color(184, 216, 249),
					Color(184, 216, 249),
					Win8GetSystemTextColor(true),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::MenuBarButtonDisabled()
			{
				Win8ButtonColors colors=
				{
					Color(245, 246, 247),
					Color(245, 246, 247),
					Color(245, 246, 247),
					Win8GetSystemTextColor(false),
				};
				return colors;
			}

			//---------------------------------------------------------

			Win8ButtonColors Win8ButtonColors::MenuItemButtonNormal()
			{
				Win8ButtonColors colors=
				{
					Color(240, 240, 240),
					Color(240, 240, 240),
					Color(240, 240, 240),
					Win8GetSystemTextColor(true),
					Win8GetMenuSplitterColor(),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::MenuItemButtonNormalActive()
			{
				Win8ButtonColors colors=
				{
					Color(120, 174, 229),
					Color(209, 226, 242),
					Color(209, 226, 242),
					Win8GetSystemTextColor(true),
					Color(187, 204, 220),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::MenuItemButtonDisabled()
			{
				Win8ButtonColors colors=
				{
					Color(240, 240, 240),
					Color(240, 240, 240),
					Color(240, 240, 240),
					Win8GetSystemTextColor(false),
					Win8GetMenuSplitterColor(),
				};
				return colors;
			}

			Win8ButtonColors Win8ButtonColors::MenuItemButtonDisabledActive()
			{
				Win8ButtonColors colors=
				{
					Color(120, 174, 229),
					Color(209, 226, 242),
					Color(209, 226, 242),
					Win8GetSystemTextColor(false),
					Win8GetMenuSplitterColor(),
				};
				return colors;
			}

/***********************************************************************
Win8ButtonElements
***********************************************************************/

			Win8ButtonElements Win8ButtonElements::Create(Alignment::Type horizontal, Alignment::Type vertical)
			{
				Win8ButtonElements button;
				{
					button.mainComposition=new GuiBoundsComposition;
					button.mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					button.rectBorderElement=element;

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					button.mainComposition->AddChild(composition);
					composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					composition->SetOwnedElement(element);
				}
				{
					GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
					button.backgroundElement=element;
					element->SetDirection(GuiGradientBackgroundElement::Vertical);
					element->SetShape(ElementShape::Rectangle);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					button.backgroundComposition=composition;
					button.mainComposition->AddChild(composition);
					composition->SetAlignmentToParent(Margin(1, 1, 1, 1));
					composition->SetOwnedElement(element);
				}
				{
					Win8CreateSolidLabelElement(button.textElement, button.textComposition, horizontal, vertical);
					button.mainComposition->AddChild(button.textComposition);
				}
				return button;
			}

			void Win8ButtonElements::Apply(const Win8ButtonColors& colors)
			{
				if(rectBorderElement)
				{
					rectBorderElement->SetColor(colors.borderColor);
				}
				backgroundElement->SetColors(colors.g1, colors.g2);
				textElement->SetColor(colors.textColor);
			}

/***********************************************************************
Win8CheckedButtonElements
***********************************************************************/

			Win8CheckedButtonElements Win8CheckedButtonElements::Create(elements::ElementShape::Type shape, bool backgroundVisible)
			{
				const vint checkSize=13;
				const vint checkPadding=2;

				Win8CheckedButtonElements button;
				{
					button.mainComposition=new GuiBoundsComposition;
					button.mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				{
					GuiTableComposition* mainTable=new GuiTableComposition;
					button.mainComposition->AddChild(mainTable);
					if(backgroundVisible)
					{
						GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
						element->SetColor(Win8GetSystemWindowColor());
						mainTable->SetOwnedElement(element);
					}
					mainTable->SetRowsAndColumns(1, 2);
					mainTable->SetAlignmentToParent(Margin(0, 0, 0, 0));
					mainTable->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
					mainTable->SetColumnOption(0, GuiCellOption::AbsoluteOption(checkSize+2*checkPadding));
					mainTable->SetColumnOption(1, GuiCellOption::PercentageOption(1.0));
					
					{
						GuiCellComposition* cell=new GuiCellComposition;
						mainTable->AddChild(cell);
						cell->SetSite(0, 0, 1, 1);

						GuiTableComposition* table=new GuiTableComposition;
						cell->AddChild(table);
						table->SetRowsAndColumns(3, 1);
						table->SetAlignmentToParent(Margin(0, 0, 0, 0));
						table->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
						table->SetRowOption(1, GuiCellOption::MinSizeOption());
						table->SetRowOption(2, GuiCellOption::PercentageOption(0.5));

						{
							GuiCellComposition* checkCell=new GuiCellComposition;
							table->AddChild(checkCell);
							checkCell->SetSite(1, 0, 1, 1);
							{
								GuiBoundsComposition* borderBounds=new GuiBoundsComposition;
								checkCell->AddChild(borderBounds);
								borderBounds->SetAlignmentToParent(Margin(checkPadding, -1, checkPadding, -1));
								borderBounds->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
								{
									GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
									button.bulletBorderElement=element;
									element->SetShape(shape);

									GuiBoundsComposition* bounds=new GuiBoundsComposition;
									borderBounds->AddChild(bounds);
									bounds->SetOwnedElement(element);
									bounds->SetAlignmentToParent(Margin(0, 0, 0, 0));
									bounds->SetBounds(Rect(Point(0, 0), Size(checkSize, checkSize)));
								}
								{
									GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
									button.bulletBackgroundElement=element;
									element->SetShape(shape);
									element->SetDirection(GuiGradientBackgroundElement::Vertical);

									GuiBoundsComposition* bounds=new GuiBoundsComposition;
									borderBounds->AddChild(bounds);
									bounds->SetOwnedElement(element);
									bounds->SetAlignmentToParent(Margin(1, 1, 1, 1));
								}
							}

							button.bulletCheckElement=0;
							button.bulletRadioElement=0;
							if(shape==ElementShape::Rectangle)
							{
								button.bulletCheckElement=GuiSolidLabelElement::Create();
								{
									FontProperties font;
									font.fontFamily=L"Wingdings 2";
									font.size=16;
									font.bold=true;
									button.bulletCheckElement->SetFont(font);
								}
								button.bulletCheckElement->SetText(L"P");
								button.bulletCheckElement->SetAlignments(Alignment::Center, Alignment::Center);

								GuiBoundsComposition* composition=new GuiBoundsComposition;
								composition->SetOwnedElement(button.bulletCheckElement);
								composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
								checkCell->AddChild(composition);
							}
							else
							{
								button.bulletRadioElement=GuiSolidBackgroundElement::Create();
								button.bulletRadioElement->SetShape(ElementShape::Ellipse);

								GuiBoundsComposition* composition=new GuiBoundsComposition;
								composition->SetOwnedElement(button.bulletRadioElement);
								composition->SetAlignmentToParent(Margin(checkPadding+3, 3, checkPadding+3, 3));
								checkCell->AddChild(composition);
							}
						}
					}

					{
						GuiCellComposition* textCell=new GuiCellComposition;
						mainTable->AddChild(textCell);
						textCell->SetSite(0, 1, 1, 1);
						{
							Win8CreateSolidLabelElement(button.textElement, button.textComposition, Alignment::Left, Alignment::Center);
							textCell->AddChild(button.textComposition);
						}
					}
				}
				return button;
			}

			void Win8CheckedButtonElements::Apply(const Win8ButtonColors& colors)
			{
				bulletBorderElement->SetColor(colors.borderColor);
				bulletBackgroundElement->SetColors(colors.g1, colors.g2);
				textElement->SetColor(colors.textColor);
				if(bulletCheckElement)
				{
					bulletCheckElement->SetColor(colors.bullet);
				}
				if(bulletRadioElement)
				{
					bulletRadioElement->SetColor(colors.bullet);
				}
			}

/***********************************************************************
Win8MenuItemButtonElements
***********************************************************************/

			Win8MenuItemButtonElements Win8MenuItemButtonElements::Create()
			{
				Win8MenuItemButtonElements button;
				{
					button.mainComposition=new GuiBoundsComposition;
					button.mainComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				{
					GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
					button.borderElement=element;

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					button.mainComposition->AddChild(composition);
					composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
					composition->SetOwnedElement(element);
				}
				{
					GuiGradientBackgroundElement* element=GuiGradientBackgroundElement::Create();
					button.backgroundElement=element;
					element->SetDirection(GuiGradientBackgroundElement::Vertical);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					button.mainComposition->AddChild(composition);
					composition->SetAlignmentToParent(Margin(1, 1, 1, 1));
					composition->SetOwnedElement(element);
				}
				{
					GuiTableComposition* table=new GuiTableComposition;
					button.mainComposition->AddChild(table);
					table->SetAlignmentToParent(Margin(2, 0, 2, 0));
					table->SetRowsAndColumns(1, 5);

					table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(0, GuiCellOption::AbsoluteOption(24));
					table->SetColumnOption(1, GuiCellOption::AbsoluteOption(1));
					table->SetColumnOption(2, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(3, GuiCellOption::MinSizeOption());
					table->SetColumnOption(4, GuiCellOption::AbsoluteOption(10));
					
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 0, 1, 1);
						button.splitterComposition=cell;

						GuiImageFrameElement* element=GuiImageFrameElement::Create();
						button.imageElement=element;
						element->SetStretch(false);
						element->SetAlignments(Alignment::Center, Alignment::Center);
						cell->SetOwnedElement(element);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 1, 1);
						button.splitterComposition=cell;

						GuiSolidBorderElement* element=GuiSolidBorderElement::Create();
						button.splitterElement=element;
						cell->SetOwnedElement(element);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 2, 1, 1);

						Win8CreateSolidLabelElement(button.textElement, button.textComposition, Alignment::Left, Alignment::Center);
						cell->AddChild(button.textComposition);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 3, 1, 1);

						Win8CreateSolidLabelElement(button.shortcutElement, button.shortcutComposition, Alignment::Right, Alignment::Center);
						cell->AddChild(button.shortcutComposition);
					}
					{
						button.subMenuArrowElement=common_styles::CommonFragmentBuilder::BuildRightArrow();

						GuiCellComposition* cell=new GuiCellComposition;
						button.subMenuArrowComposition=cell;
						cell->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
						table->AddChild(cell);
						cell->SetSite(0, 4, 1, 1);
						cell->SetOwnedElement(button.subMenuArrowElement);
						cell->SetVisible(false);
					}
				}
				return button;
			}

			void Win8MenuItemButtonElements::Apply(const Win8ButtonColors& colors)
			{
				borderElement->SetColor(colors.borderColor);
				backgroundElement->SetColors(colors.g1, colors.g2);
				splitterElement->SetColor(colors.bullet);
				textElement->SetColor(colors.textColor);
				shortcutElement->SetColor(colors.textColor);
				subMenuArrowElement->SetBackgroundColor(colors.textColor);
				subMenuArrowElement->SetBorderColor(colors.textColor);
			}

			void Win8MenuItemButtonElements::SetActive(bool value)
			{
				if(value)
				{
					splitterComposition->SetMargin(Margin(0, 1, 0, 2));
				}
				else
				{
					splitterComposition->SetMargin(Margin(0, 0, 0, 0));
				}
			}

			void Win8MenuItemButtonElements::SetSubMenuExisting(bool value)
			{
				subMenuArrowComposition->SetVisible(value);
			}

/***********************************************************************
Win8TextBoxColors
***********************************************************************/

			Win8TextBoxColors Win8TextBoxColors::Blend(const Win8TextBoxColors& c1, const Win8TextBoxColors& c2, vint ratio, vint total)
			{
				if(ratio<0) ratio=0;
				else if(ratio>total) ratio=total;

				Win8TextBoxColors result;
				result.borderColor=BlendColor(c1.borderColor, c2.borderColor, ratio, total);
				result.backgroundColor=BlendColor(c1.backgroundColor, c2.backgroundColor, ratio, total);
				return result;
			}
			
			Win8TextBoxColors Win8TextBoxColors::Normal()
			{
				Win8TextBoxColors result=
				{
					Color(171, 173, 179),
					Color(255, 255, 255),
				};
				return result;
			}

			Win8TextBoxColors Win8TextBoxColors::Active()
			{
				Win8TextBoxColors result=
				{
					Color(126, 180, 234),
					Color(255, 255, 255),
				};
				return result;
			}

			Win8TextBoxColors Win8TextBoxColors::Focused()
			{
				Win8TextBoxColors result=
				{
					Color(86, 157, 229),
					Color(255, 255, 255),
				};
				return result;
			}

			Win8TextBoxColors Win8TextBoxColors::Disabled()
			{
				Win8TextBoxColors result=
				{
					Color(217, 217, 217),
					Win8GetSystemWindowColor(),
				};
				return result;
			}

/***********************************************************************
Helpers
***********************************************************************/

			Color Win8GetSystemWindowColor()
			{
				return Color(240, 240, 240);
			}

			Color Win8GetSystemBorderColor()
			{
				return Color(171, 173, 179);
			}

			Color Win8GetSystemTextColor(bool enabled)
			{
				return enabled?Color(0, 0, 0):Color(131, 131, 131);
			}

			Color Win8GetMenuBorderColor()
			{
				return Color(151, 151, 151);
			}

			Color Win8GetMenuSplitterColor()
			{
				return Color(215, 215, 215);
			}

			void Win8SetFont(GuiSolidLabelElement* element, GuiBoundsComposition* composition, const FontProperties& fontProperties)
			{
				vint margin=3;
				element->SetFont(fontProperties);
				composition->SetMargin(Margin(margin, margin, margin, margin));
			}

			void Win8CreateSolidLabelElement(GuiSolidLabelElement*& element, GuiBoundsComposition*& composition, Alignment::Type horizontal, Alignment::Type vertical)
			{
				element=GuiSolidLabelElement::Create();
				element->SetAlignments(horizontal, vertical);

				composition=new GuiBoundsComposition;
				composition->SetOwnedElement(element);
				composition->SetMargin(Margin(0, 0, 0, 0));
				composition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				composition->SetAlignmentToParent(Margin(0, 0, 0, 0));
			}

			elements::text::ColorEntry Win8GetTextBoxTextColor()
			{
				elements::text::ColorEntry entry;
				entry.normal.text=Color(0, 0, 0);
				entry.normal.background=Color(0, 0, 0, 0);
				entry.selectedFocused.text=Color(255, 255, 255);
				entry.selectedFocused.background=Color(51, 153, 255);
				entry.selectedUnfocused.text=Color(255, 255, 255);
				entry.selectedUnfocused.background=Color(51, 153, 255);
				return entry;
			}
		}
	}
}

/***********************************************************************
Controls\Styles\Win8Styles\GuiWin8TabStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
		}
	}
}

/***********************************************************************
Controls\Styles\Win8Styles\GuiWin8ToolstripStyles.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace win8
		{
			using namespace collections;
			using namespace elements;
			using namespace compositions;
			using namespace controls;

/***********************************************************************
Win8WindowStyle
***********************************************************************/

			Win8ToolstripToolbarStyle::Win8ToolstripToolbarStyle()
			{
				{
					GuiSolidBackgroundElement* element=GuiSolidBackgroundElement::Create();
					element->SetColor(Win8GetSystemWindowColor());
				
					boundsComposition=new GuiBoundsComposition;
					boundsComposition->SetOwnedElement(element);
					boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				}
				{
					Gui3DSplitterElement* element=Gui3DSplitterElement::Create();
					element->SetColors(Color(160, 160, 160), Color(255, 255, 255));
					element->SetDirection(Gui3DSplitterElement::Horizontal);

					GuiBoundsComposition* composition=new GuiBoundsComposition;
					composition->SetPreferredMinSize(Size(0, 2));
					composition->SetAlignmentToParent(Margin(0, 0, 0, -1));
					composition->SetOwnedElement(element);
					boundsComposition->AddChild(composition);
				}
				{
					containerComposition=new GuiBoundsComposition;
					containerComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					containerComposition->SetAlignmentToParent(Margin(0, 2, 0, 0));
					boundsComposition->AddChild(containerComposition);
				}
			}

			Win8ToolstripToolbarStyle::~Win8ToolstripToolbarStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8ToolstripToolbarStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8ToolstripToolbarStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win8ToolstripToolbarStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8ToolstripToolbarStyle::SetText(const WString& value)
			{
			}

			void Win8ToolstripToolbarStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8ToolstripToolbarStyle::SetVisuallyEnabled(bool value)
			{
			}

/***********************************************************************
Win8ToolstripButtonDropdownStyle
***********************************************************************/

			void Win8ToolstripButtonDropdownStyle::TransferInternal(controls::GuiButton::ControlState value, bool enabled)
			{
				splitterComposition->SetVisible(value!=GuiButton::Normal && enabled);
			}

			Win8ToolstripButtonDropdownStyle::Win8ToolstripButtonDropdownStyle()
				:isVisuallyEnabled(false)
				,controlState(GuiButton::Normal)
			{
				boundsComposition=new GuiBoundsComposition;
				boundsComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				{
					GuiSolidBorderElement* splitterElement=GuiSolidBorderElement::Create();
					splitterElement->SetColor(Color(132, 132, 132));

					splitterComposition=new GuiBoundsComposition;
					splitterComposition->SetAlignmentToParent(Margin(0, 3, -1, 3));
					splitterComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
					splitterComposition->SetOwnedElement(splitterElement);
					splitterComposition->SetPreferredMinSize(Size(1, 0));
					splitterComposition->SetVisible(false);
					boundsComposition->AddChild(splitterComposition);
				}
				{
					containerComposition=new GuiBoundsComposition;
					containerComposition->SetAlignmentToParent(Margin(4, 0, 4, 0));
					containerComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
					boundsComposition->AddChild(containerComposition);
				}
			}

			Win8ToolstripButtonDropdownStyle::~Win8ToolstripButtonDropdownStyle()
			{
			}
				
			compositions::GuiBoundsComposition* Win8ToolstripButtonDropdownStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8ToolstripButtonDropdownStyle::GetContainerComposition()
			{
				return containerComposition;
			}

			void Win8ToolstripButtonDropdownStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8ToolstripButtonDropdownStyle::SetText(const WString& value)
			{
			}

			void Win8ToolstripButtonDropdownStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8ToolstripButtonDropdownStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					TransferInternal(controlState, isVisuallyEnabled);
				}
			}

			void Win8ToolstripButtonDropdownStyle::Transfer(controls::GuiButton::ControlState value)
			{
				if(controlState!=value)
				{
					controlState=value;
					TransferInternal(controlState, isVisuallyEnabled);
				}
			}

/***********************************************************************
Win8ToolstripButtonStyle
***********************************************************************/

			IMPLEMENT_TRANSFERRING_ANIMATION(Win8ButtonColors, Win8ToolstripButtonStyle)
			{
				colorCurrent=Win8ButtonColors::Blend(colorBegin, colorEnd, currentPosition, totalLength);
				style->elements.Apply(colorCurrent);
			}

			void Win8ToolstripButtonStyle::TransferInternal(GuiButton::ControlState value, bool enabled, bool menuOpening)
			{
				Win8ButtonColors targetColor;
				if(enabled)
				{
					if(menuOpening)
					{
						value=GuiButton::Pressed;
					}
					switch(value)
					{
					case GuiButton::Normal:
						targetColor=Win8ButtonColors::ToolstripButtonNormal();
						break;
					case GuiButton::Active:
						targetColor=Win8ButtonColors::ToolstripButtonActive();
						break;
					case GuiButton::Pressed:
						targetColor=Win8ButtonColors::ToolstripButtonPressed();
						break;
					}
				}
				else
				{
					targetColor=Win8ButtonColors::ToolstripButtonDisabled();
				}
				transferringAnimation->Transfer(targetColor);
			}

			Win8ToolstripButtonStyle::Win8ToolstripButtonStyle(ButtonStyle _buttonStyle)
				:controlStyle(GuiButton::Normal)
				,isVisuallyEnabled(true)
				,isOpening(false)
				,buttonStyle(_buttonStyle)
				,subMenuHost(0)
			{
				elements=Win8ButtonElements::Create(Alignment::Center, Alignment::Center);
				elements.Apply(Win8ButtonColors::ToolstripButtonNormal());
				transferringAnimation=new TransferringAnimation(this, Win8ButtonColors::ToolstripButtonNormal());

				elements.textComposition->SetMinSizeLimitation(GuiGraphicsComposition::NoLimit);
				imageElement=GuiImageFrameElement::Create();
				imageComposition=new GuiBoundsComposition;
				imageComposition->SetOwnedElement(imageElement);
				imageComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElement);
				imageComposition->SetAlignmentToParent(Margin(4, 4, 4, 4));

				if(_buttonStyle==CommandButton)
				{
					GetContainerComposition()->AddChild(imageComposition);
				}
				else
				{
					GuiTableComposition* table=new GuiTableComposition;
					table->SetAlignmentToParent(Margin(0, 0, 0, 0));
					table->SetRowsAndColumns(1, 2);
					table->SetRowOption(0, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
					table->SetColumnOption(1, GuiCellOption::MinSizeOption());

					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 0, 1, 1);

						cell->AddChild(imageComposition);
					}
					{
						GuiCellComposition* cell=new GuiCellComposition;
						table->AddChild(cell);
						cell->SetSite(0, 1, 1, 1);
						GuiPolygonElement* arrow=0;
						GuiBoundsComposition* arrowComposition=common_styles::CommonFragmentBuilder::BuildDownArrow(arrow);

						switch(_buttonStyle)
						{
						case DropdownButton:
							{
								arrowComposition->SetAlignmentToParent(Margin(0, 0, 4, 0));
								cell->AddChild(arrowComposition);
							}
							break;
						case SplitButton:
							{

								subMenuHost=new GuiButton(new Win8ToolstripButtonDropdownStyle);
								subMenuHost->GetContainerComposition()->AddChild(arrowComposition);
								subMenuHost->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
								cell->AddChild(subMenuHost->GetBoundsComposition());
							}
							break;
						}
					}
					GetContainerComposition()->AddChild(table);
				}
			}

			Win8ToolstripButtonStyle::~Win8ToolstripButtonStyle()
			{
				transferringAnimation->Disable();
			}

			compositions::GuiBoundsComposition* Win8ToolstripButtonStyle::GetBoundsComposition()
			{
				return elements.mainComposition;
			}

			compositions::GuiGraphicsComposition* Win8ToolstripButtonStyle::GetContainerComposition()
			{
				return elements.mainComposition;
			}

			void Win8ToolstripButtonStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8ToolstripButtonStyle::SetText(const WString& value)
			{
			}

			void Win8ToolstripButtonStyle::SetFont(const FontProperties& value)
			{
				Win8SetFont(elements.textElement, elements.textComposition, value);
			}

			void Win8ToolstripButtonStyle::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					imageElement->SetEnabled(value);
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiMenu::IStyleController* Win8ToolstripButtonStyle::CreateSubMenuStyleController()
			{
				return new Win8MenuStyle;
			}

			void Win8ToolstripButtonStyle::SetSubMenuExisting(bool value)
			{
			}

			void Win8ToolstripButtonStyle::SetSubMenuOpening(bool value)
			{
				if(isOpening!=value)
				{
					isOpening=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

			controls::GuiButton* Win8ToolstripButtonStyle::GetSubMenuHost()
			{
				return subMenuHost;
			}

			void Win8ToolstripButtonStyle::SetImage(Ptr<controls::GuiImageData> value)
			{
				if(value)
				{
					imageElement->SetImage(value->GetImage(), value->GetFrameIndex());
				}
				else
				{
					imageElement->SetImage(0, 0);
				}
			}

			void Win8ToolstripButtonStyle::SetShortcutText(const WString& value)
			{
			}

			compositions::GuiSubComponentMeasurer::IMeasuringSource* Win8ToolstripButtonStyle::GetMeasuringSource()
			{
				return 0;
			}

			void Win8ToolstripButtonStyle::Transfer(controls::GuiButton::ControlState value)
			{
				if(controlStyle!=value)
				{
					controlStyle=value;
					TransferInternal(controlStyle, isVisuallyEnabled, isOpening);
				}
			}

/***********************************************************************
Win8ToolstripSplitterStyle
***********************************************************************/

			Win8ToolstripSplitterStyle::Win8ToolstripSplitterStyle()
			{
				GuiBoundsComposition* bounds=new GuiBoundsComposition;
				bounds->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				boundsComposition=bounds;

				GuiSolidBackgroundElement* backgroundElement=GuiSolidBackgroundElement::Create();
				bounds->SetOwnedElement(backgroundElement);
				backgroundElement->SetColor(Win8GetSystemWindowColor());

				GuiBoundsComposition* splitterComposition=new GuiBoundsComposition;
				bounds->AddChild(splitterComposition);
				splitterComposition->SetPreferredMinSize(Size(1, 0));
				splitterComposition->SetAlignmentToParent(Margin(3, 3, 3, 3));

				GuiSolidBorderElement* splitterElement=GuiSolidBorderElement::Create();
				splitterComposition->SetOwnedElement(splitterElement);
				splitterElement->SetColor(Color(132, 132, 132));
			}

			Win8ToolstripSplitterStyle::~Win8ToolstripSplitterStyle()
			{
			}

			compositions::GuiBoundsComposition* Win8ToolstripSplitterStyle::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* Win8ToolstripSplitterStyle::GetContainerComposition()
			{
				return boundsComposition;
			}

			void Win8ToolstripSplitterStyle::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
			}

			void Win8ToolstripSplitterStyle::SetText(const WString& value)
			{
			}

			void Win8ToolstripSplitterStyle::SetFont(const FontProperties& value)
			{
			}

			void Win8ToolstripSplitterStyle::SetVisuallyEnabled(bool value)
			{
			}
		}
	}
}

/***********************************************************************
Controls\TextEditorPackage\GuiTextColorizer.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace elements::text;
			using namespace compositions;

/***********************************************************************
GuiTextBoxColorizer
***********************************************************************/

			void GuiTextBoxColorizerBase::ColorizerThreadProc(void* argument)
			{
				GuiTextBoxColorizerBase* colorizer=(GuiTextBoxColorizerBase*)argument;
				while(!colorizer->isFinalizing)
				{
					vint lineIndex=-1;
					wchar_t* text=0;
					unsigned __int32* colors=0;
					vint length=0;
					vint lexerState=-1;
					vint contextState=-1;

					{
						SpinLock::Scope scope(*colorizer->elementModifyLock);
						if(colorizer->colorizedLineCount>=colorizer->element->GetLines().GetCount())
						{
							colorizer->isColorizerRunning=false;
							break;
						}

						lineIndex=colorizer->colorizedLineCount++;
						TextLine& line=colorizer->element->GetLines().GetLine(lineIndex);
						length=line.dataLength;
						text=new wchar_t[length+2];
						colors=new unsigned __int32[length+2];
						memcpy(text, line.text, sizeof(wchar_t)*length);
						text[length]=L'\r';
						text[length+1]=L'\n';
						lexerState=lineIndex==0?colorizer->GetLexerStartState():colorizer->element->GetLines().GetLine(lineIndex-1).lexerFinalState;
						contextState=lineIndex==0?colorizer->GetContextStartState():colorizer->element->GetLines().GetLine(lineIndex-1).contextFinalState;
					}

					colorizer->ColorizeLineWithCRLF(lineIndex, text, colors, length+2, lexerState, contextState);

					{
						SpinLock::Scope scope(*colorizer->elementModifyLock);
						if(lineIndex<colorizer->colorizedLineCount && lineIndex<colorizer->element->GetLines().GetCount())
						{
							TextLine& line=colorizer->element->GetLines().GetLine(lineIndex);
							line.lexerFinalState=lexerState;
							line.contextFinalState=contextState;
							for(vint i=0;i<length;i++)
							{
								line.att[i].colorIndex=colors[i];
							}
						}
						delete[] text;
						delete[] colors;
					}
				}
				colorizer->colorizerRunningEvent.Leave();
			}

			void GuiTextBoxColorizerBase::StartColorizer()
			{
				if(!isColorizerRunning)
				{
					isColorizerRunning=true;
					colorizerRunningEvent.Enter();
					ThreadPoolLite::Queue(&GuiTextBoxColorizerBase::ColorizerThreadProc, this);
				}
			}

			void GuiTextBoxColorizerBase::StopColorizer()
			{
				isFinalizing=true;
				colorizerRunningEvent.Enter();
				colorizerRunningEvent.Leave();
				colorizedLineCount=0;
				isFinalizing=false;
			}

			GuiTextBoxColorizerBase::GuiTextBoxColorizerBase()
				:element(0)
				,elementModifyLock(0)
				,colorizedLineCount(0)
				,isColorizerRunning(false)
				,isFinalizing(false)
			{
			}

			GuiTextBoxColorizerBase::~GuiTextBoxColorizerBase()
			{
				StopColorizer();
			}

			void GuiTextBoxColorizerBase::Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock)
			{
				if(_element)
				{
					SpinLock::Scope scope(_elementModifyLock);
					element=_element;
					elementModifyLock=&_elementModifyLock;
					StartColorizer();
				}
			}

			void GuiTextBoxColorizerBase::Detach()
			{
				if(element && elementModifyLock)
				{
					StopColorizer();
					SpinLock::Scope scope(*elementModifyLock);
					element=0;
					elementModifyLock=0;
				}
			}

			void GuiTextBoxColorizerBase::TextEditNotify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)
			{
				if(element && elementModifyLock)
				{
					SpinLock::Scope scope(*elementModifyLock);
					vint line=originalStart.row<originalEnd.row?originalStart.row:originalEnd.row;
					if(colorizedLineCount>line)
					{
						colorizedLineCount=line;
					}
					StartColorizer();
				}
			}

			void GuiTextBoxColorizerBase::RestartColorizer()
			{
				SpinLock::Scope scope(*elementModifyLock);
				colorizedLineCount=0;
				StartColorizer();
			}

/***********************************************************************
GuiTextBoxRegexColorizer
***********************************************************************/

			struct GuiTextBoxRegexColorizerProcData
			{
				GuiTextBoxRegexColorizer*		colorizer;
				vint								lineIndex;
				const wchar_t*					text;
				unsigned __int32*				colors;
				vint								contextState;
			};

			void GuiTextBoxRegexColorizer::ColorizerProc(void* argument, vint start, vint length, vint token)
			{
				GuiTextBoxRegexColorizerProcData& data=*(GuiTextBoxRegexColorizerProcData*)argument;
				data.colorizer->ColorizeTokenContextSensitive(data.lineIndex, data.text, start, length, token, data.contextState);
				for(vint i=0;i<length;i++)
				{
					data.colors[start+i]=(int)token+1;
				}
			}

			GuiTextBoxRegexColorizer::GuiTextBoxRegexColorizer()
			{
				colors.Resize(1);
			}

			GuiTextBoxRegexColorizer::~GuiTextBoxRegexColorizer()
			{
			}

			elements::text::ColorEntry GuiTextBoxRegexColorizer::GetDefaultColor()
			{
				return defaultColor;
			}

			collections::List<WString>& GuiTextBoxRegexColorizer::GetTokenRegexes()
			{
				return tokenRegexes;
			}

			collections::List<elements::text::ColorEntry>& GuiTextBoxRegexColorizer::GetTokenColors()
			{
				return tokenColors;
			}

			collections::List<elements::text::ColorEntry>& GuiTextBoxRegexColorizer::GetExtraTokenColors()
			{
				return extraTokenColors;
			}

			vint GuiTextBoxRegexColorizer::GetExtraTokenIndexStart()
			{
				if(lexer)
				{
					return tokenColors.Count();
				}
				else
				{
					return -1;
				}
			}

			bool GuiTextBoxRegexColorizer::SetDefaultColor(elements::text::ColorEntry value)
			{
				if(lexer)
				{
					return false;
				}
				else
				{
					defaultColor=value;
					return true;
				}
			}

			vint GuiTextBoxRegexColorizer::AddToken(const WString& regex, elements::text::ColorEntry color)
			{
				if(lexer)
				{
					return -1;
				}
				else
				{
					tokenRegexes.Add(regex);
					tokenColors.Add(color);
					return tokenColors.Count()-1;
				}
			}

			vint GuiTextBoxRegexColorizer::AddExtraToken(elements::text::ColorEntry color)
			{
				if(lexer)
				{
					return -1;
				}
				else
				{
					extraTokenColors.Add(color);
					return extraTokenColors.Count()-1;
				}
			}

			bool GuiTextBoxRegexColorizer::Setup()
			{
				if(lexer || tokenRegexes.Count()==0)
				{
					return false;
				}
				else
				{
					lexer=new regex::RegexLexer(tokenRegexes);
					colors.Resize(1+tokenRegexes.Count()+extraTokenColors.Count());
					colors[0]=defaultColor;
					for(vint i=0;i<tokenColors.Count();i++)
					{
						colors[i+1]=tokenColors[i];
					}
					for(vint i=0;i<extraTokenColors.Count();i++)
					{
						colors[i+1+tokenColors.Count()]=extraTokenColors[i];
					}
					colorizer=new regex::RegexLexerColorizer(lexer->Colorize());
					return true;
				}
			}

			void GuiTextBoxRegexColorizer::ColorizeTokenContextSensitive(vint lineIndex, const wchar_t* text, vint start, vint length, vint& token, vint& contextState)
			{
			}

			vint GuiTextBoxRegexColorizer::GetLexerStartState()
			{
				return lexer?colorizer->GetStartState():-1;
			}

			vint GuiTextBoxRegexColorizer::GetContextStartState()
			{
				return 0;
			}

			void GuiTextBoxRegexColorizer::ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, unsigned __int32* colors, vint length, vint& lexerState, vint& contextState)
			{
				if(lexer)
				{
					GuiTextBoxRegexColorizerProcData data;
					data.colorizer=this;
					data.lineIndex=lineIndex;
					data.text=text;
					data.colors=colors;
					data.contextState=contextState;

					memset(colors, 0, sizeof(*colors)*length);
					colorizer->Reset(lexerState);
					colorizer->Colorize(text, length, &GuiTextBoxRegexColorizer::ColorizerProc, &data);

					lexerState=colorizer->GetCurrentState();
					contextState=data.contextState;
				}
				else
				{
					lexerState=-1;
					contextState=-1;
				}
			}

			const GuiTextBoxRegexColorizer::ColorArray& GuiTextBoxRegexColorizer::GetColors()
			{
				return colors;
			}
		}
	}
}

/***********************************************************************
Controls\TextEditorPackage\GuiTextCommonInterface.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace elements::text;
			using namespace compositions;

/***********************************************************************
GuiTextBoxCommonInterface::DefaultCallback
***********************************************************************/

			GuiTextBoxCommonInterface::DefaultCallback::DefaultCallback(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition)
				:textElement(_textElement)
				,textComposition(_textComposition)
			{
			}

			GuiTextBoxCommonInterface::DefaultCallback::~DefaultCallback()
			{
			}

			TextPos GuiTextBoxCommonInterface::DefaultCallback::GetLeftWord(TextPos pos)
			{
				return pos;
			}

			TextPos GuiTextBoxCommonInterface::DefaultCallback::GetRightWord(TextPos pos)
			{
				return pos;
			}

			void GuiTextBoxCommonInterface::DefaultCallback::GetWord(TextPos pos, TextPos& begin, TextPos& end)
			{
				begin=pos;
				end=pos;
			}

			vint GuiTextBoxCommonInterface::DefaultCallback::GetPageRows()
			{
				return textComposition->GetBounds().Height()/textElement->GetLines().GetRowHeight();
			}

			bool GuiTextBoxCommonInterface::DefaultCallback::BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)
			{
				return true;
			}

/***********************************************************************
GuiTextBoxCommonInterface::ShortcutCommand
***********************************************************************/

			GuiTextBoxCommonInterface::ShortcutCommand::ShortcutCommand(bool _ctrl, bool _shift, vint _key, const Func<void()> _action)
				:ctrl(_ctrl)
				,shift(_shift)
				,key(_key)
				,action(_action)
			{
			}

			GuiTextBoxCommonInterface::ShortcutCommand::ShortcutCommand(bool _ctrl, bool _shift, vint _key, const Func<bool()> _action)
				:ctrl(_ctrl)
				,shift(_shift)
				,key(_key)
				,action(Func<void()>(_action))
			{
			}

			GuiTextBoxCommonInterface::ShortcutCommand::~ShortcutCommand()
			{
			}

			bool GuiTextBoxCommonInterface::ShortcutCommand::IsTheRightKey(bool _ctrl, bool _shift, vint _key)
			{
				return _ctrl==ctrl && _shift==shift && _key==key;
			}

			void GuiTextBoxCommonInterface::ShortcutCommand::Execute()
			{
				action();
			}

/***********************************************************************
GuiTextBoxCommonInterface
***********************************************************************/

			void GuiTextBoxCommonInterface::UpdateCaretPoint()
			{
				GuiGraphicsHost* host=textComposition->GetRelatedGraphicsHost();
				if(host)
				{
					Rect caret=textElement->GetLines().GetRectFromTextPos(textElement->GetCaretEnd());
					Point view=textElement->GetViewPosition();
					vint textMargin=callback->GetTextMargin();
					vint x=caret.x1-view.x;
					vint y=caret.y2-view.y;
					host->SetCaretPoint(Point(x, y), textComposition);
				}
			}

			void GuiTextBoxCommonInterface::Move(TextPos pos, bool shift)
			{
				TextPos oldBegin=textElement->GetCaretBegin();
				TextPos oldEnd=textElement->GetCaretEnd();

				pos=textElement->GetLines().Normalize(pos);
				if(!shift)
				{
					textElement->SetCaretBegin(pos);
				}
				textElement->SetCaretEnd(pos);
				if(textControl)
				{
					GuiGraphicsHost* host=textComposition->GetRelatedGraphicsHost();
					if(host)
					{
						if(host->GetFocusedComposition()==textControl->GetFocusableComposition())
						{
							textElement->SetCaretVisible(true);
						}
					}
				}

				Rect bounds=textElement->GetLines().GetRectFromTextPos(pos);
				Rect view=Rect(textElement->GetViewPosition(), textComposition->GetBounds().GetSize());
				Point viewPoint=view.LeftTop();

				if(view.x2>view.x1 && view.y2>view.y1)
				{
					if(bounds.x1<view.x1)
					{
						viewPoint.x=bounds.x1;
					}
					else if(bounds.x2>view.x2)
					{
						viewPoint.x=bounds.x2-view.Width();
					}
					if(bounds.y1<view.y1)
					{
						viewPoint.y=bounds.y1;
					}
					else if(bounds.y2>view.y2)
					{
						viewPoint.y=bounds.y2-view.Height();
					}
				}

				callback->ScrollToView(viewPoint);
				UpdateCaretPoint();

				if(oldBegin!=textElement->GetCaretBegin() || oldEnd!=textElement->GetCaretEnd())
				{
					SelectionChanged.Execute(textControl->GetNotifyEventArguments());
				}
			}

			void GuiTextBoxCommonInterface::Modify(TextPos start, TextPos end, const WString& input)
			{
				if(start>end)
				{
					TextPos temp=start;
					start=end;
					end=temp;
				}
				TextPos originalStart=start;
				TextPos originalEnd=end;
				WString originalText=textElement->GetLines().GetText(start, end);
				WString inputText=input;
				if(callback->BeforeModify(start, end, originalText, inputText))
				{
					{
						SpinLock::Scope scope(elementModifyLock);
						end=textElement->GetLines().Modify(start, end, inputText);
					}
					callback->AfterModify(originalStart, originalEnd, originalText, start, end, inputText);
					for(vint i=0;i<textEditCallbacks.Count();i++)
					{
						textEditCallbacks[i]->TextEditNotify(originalStart, originalEnd, originalText, start, end, inputText);
					}
					Move(end, false);

					textControl->TextChanged.Execute(textControl->GetNotifyEventArguments());
				}
			}

			bool GuiTextBoxCommonInterface::ProcessKey(vint code, bool shift, bool ctrl)
			{
				for(vint i=0;i<shortcutCommands.Count();i++)
				{
					if(shortcutCommands[i]->IsTheRightKey(ctrl, shift, code))
					{
						shortcutCommands[i]->Execute();
						return true;
					}
				}
				TextPos begin=textElement->GetCaretBegin();
				TextPos end=textElement->GetCaretEnd();
				switch(code)
				{
				case VKEY_UP:
					{
						end.row--;
						Move(end, shift);
					}
					return true;
				case VKEY_DOWN:
					{
						end.row++;
						Move(end, shift);
					}
					return true;
				case VKEY_LEFT:
					{
						if(ctrl)
						{
							Move(callback->GetLeftWord(end), shift);
						}
						else
						{
							if(end.column==0)
							{
								if(end.row>0)
								{
									end.row--;
									end=textElement->GetLines().Normalize(end);
									end.column=textElement->GetLines().GetLine(end.row).dataLength;
								}
							}
							else
							{
								end.column--;
							}
							Move(end, shift);
						}
					}
					return true;
				case VKEY_RIGHT:
					{
						if(ctrl)
						{
							Move(callback->GetRightWord(end), shift);
						}
						else
						{
							if(end.column==textElement->GetLines().GetLine(end.row).dataLength)
							{
								if(end.row<textElement->GetLines().GetCount()-1)
								{
									end.row++;
									end.column=0;
								}
							}
							else
							{
								end.column++;
							}
							Move(end, shift);
						}
					}
					return true;
				case VKEY_HOME:
					{
						if(ctrl)
						{
							Move(TextPos(0, 0), shift);
						}
						else
						{
							end.column=0;
							Move(end, shift);
						}
					}
					return true;
				case VKEY_END:
					{
						if(ctrl)
						{
							end.row=textElement->GetLines().GetCount()-1;
						}
						end.column=textElement->GetLines().GetLine(end.row).dataLength;
						Move(end, shift);
					}
					return true;
				case VKEY_PRIOR:
					{
						end.row-=callback->GetPageRows();
						Move(end, shift);
					}
					return true;
				case VKEY_NEXT:
					{
						end.row+=callback->GetPageRows();
						Move(end, shift);
					}
					return true;
				case VKEY_BACK:
					if(!readonly)
					{
						if(ctrl && !shift)
						{
							ProcessKey(VKEY_LEFT, true, true);
							ProcessKey(VKEY_BACK, false, false);
						}
						else if(!ctrl && shift)
						{
							ProcessKey(VKEY_UP, true, false);
							ProcessKey(VKEY_BACK, false, false);
						}
						else
						{
							if(begin==end)
							{
								ProcessKey(VKEY_LEFT, true, false);
							}
							SetSelectionText(L"");
						}
						return true;
					}
					break;
				case VKEY_DELETE:
					if(!readonly)
					{
						if(ctrl && !shift)
						{
							ProcessKey(VKEY_RIGHT, true, true);
							ProcessKey(VKEY_DELETE, false, false);
						}
						else if(!ctrl && shift)
						{
							ProcessKey(VKEY_DOWN, true, false);
							ProcessKey(VKEY_DELETE, false, false);
						}
						else
						{
							if(begin==end)
							{
								ProcessKey(VKEY_RIGHT, true, false);
							}
							SetSelectionText(L"");
						}
						return true;
					}
					break;
				}
				return false;
			}

			void GuiTextBoxCommonInterface::OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				textElement->SetFocused(true);
				textElement->SetCaretVisible(true);
				UpdateCaretPoint();
			}

			void GuiTextBoxCommonInterface::OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				textElement->SetFocused(false);
				textElement->SetCaretVisible(false);
			}

			void GuiTextBoxCommonInterface::OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				textElement->SetCaretVisible(!textElement->GetCaretVisible());
			}

			void GuiTextBoxCommonInterface::OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(textControl->GetVisuallyEnabled() && arguments.compositionSource==arguments.eventSource)
				{
					dragging=true;
					TextPos pos=GetNearestTextPos(Point(arguments.x, arguments.y));
					Move(pos, arguments.shift);
				}
			}

			void GuiTextBoxCommonInterface::OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(textControl->GetVisuallyEnabled() && arguments.compositionSource==arguments.eventSource)
				{
					dragging=false;
				}
			}

			void GuiTextBoxCommonInterface::OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(textControl->GetVisuallyEnabled() && arguments.compositionSource==arguments.eventSource)
				{
					if(dragging)
					{
						TextPos pos=GetNearestTextPos(Point(arguments.x, arguments.y));
						Move(pos, true);
					}
				}
			}

			void GuiTextBoxCommonInterface::OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments)
			{
				if(textControl->GetVisuallyEnabled() && arguments.compositionSource==arguments.eventSource)
				{
					if(ProcessKey(arguments.code, arguments.shift, arguments.ctrl))
					{
						arguments.handled=true;
					}
				}
			}

			void GuiTextBoxCommonInterface::OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments)
			{
				if(textControl->GetVisuallyEnabled() && arguments.compositionSource==arguments.eventSource)
				{
					if(!readonly && arguments.code!=VKEY_ESCAPE && arguments.code!=VKEY_BACK && !arguments.ctrl)
					{
						SetSelectionText(WString(arguments.code));
					}
				}
			}

			void GuiTextBoxCommonInterface::Install(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition, GuiControl* _textControl)
			{
				textElement=_textElement;
				textComposition=_textComposition;
				textControl=_textControl;
				textComposition->SetAssociatedCursor(GetCurrentController()->ResourceService()->GetSystemCursor(INativeCursor::IBeam));
				SelectionChanged.SetAssociatedComposition(textControl->GetBoundsComposition());

				GuiGraphicsComposition* focusableComposition=textControl->GetFocusableComposition();
				focusableComposition->GetEventReceiver()->gotFocus.AttachMethod(this, &GuiTextBoxCommonInterface::OnGotFocus);
				focusableComposition->GetEventReceiver()->lostFocus.AttachMethod(this, &GuiTextBoxCommonInterface::OnLostFocus);
				focusableComposition->GetEventReceiver()->caretNotify.AttachMethod(this, &GuiTextBoxCommonInterface::OnCaretNotify);
				textComposition->GetEventReceiver()->leftButtonDown.AttachMethod(this, &GuiTextBoxCommonInterface::OnLeftButtonDown);
				textComposition->GetEventReceiver()->leftButtonUp.AttachMethod(this, &GuiTextBoxCommonInterface::OnLeftButtonUp);
				textComposition->GetEventReceiver()->mouseMove.AttachMethod(this, &GuiTextBoxCommonInterface::OnMouseMove);
				focusableComposition->GetEventReceiver()->keyDown.AttachMethod(this, &GuiTextBoxCommonInterface::OnKeyDown);
				focusableComposition->GetEventReceiver()->charInput.AttachMethod(this, &GuiTextBoxCommonInterface::OnCharInput);

				for(vint i=0;i<textEditCallbacks.Count();i++)
				{
					textEditCallbacks[i]->Attach(textElement, elementModifyLock);
				}
			}
			
			GuiTextBoxCommonInterface::ICallback* GuiTextBoxCommonInterface::GetCallback()
			{
				return callback;
			}

			void GuiTextBoxCommonInterface::SetCallback(ICallback* value)
			{
				callback=value;
			}

			bool GuiTextBoxCommonInterface::AttachTextEditCallback(Ptr<ICommonTextEditCallback> value)
			{
				if(textEditCallbacks.Contains(value.Obj()))
				{
					return false;
				}
				else
				{
					textEditCallbacks.Add(value);
					if(textElement)
					{
						value->Attach(textElement, elementModifyLock);
					}
					return true;
				}
			}

			bool GuiTextBoxCommonInterface::DetachTextEditCallback(Ptr<ICommonTextEditCallback> value)
			{
				if(textEditCallbacks.Remove(value.Obj()))
				{
					value->Detach();
					return true;
				}
				else
				{
					return false;
				}
			}

			void GuiTextBoxCommonInterface::AddShortcutCommand(Ptr<ShortcutCommand> shortcutCommand)
			{
				shortcutCommands.Add(shortcutCommand);
			}

			elements::GuiColorizedTextElement* GuiTextBoxCommonInterface::GetTextElement()
			{
				return textElement;
			}

			void GuiTextBoxCommonInterface::UnsafeSetText(const WString& value)
			{
				if(textElement)
				{
					TextPos end;
					if(textElement->GetLines().GetCount()>0)
					{
						end.row=textElement->GetLines().GetCount()-1;
						end.column=textElement->GetLines().GetLine(end.row).dataLength;
					}
					Modify(TextPos(), end, value);
				}
			}

			GuiTextBoxCommonInterface::GuiTextBoxCommonInterface()
				:textElement(0)
				,textComposition(0)
				,textControl(0)
				,callback(0)
				,dragging(false)
				,readonly(false)
			{
				undoRedoProcessor=new GuiTextBoxUndoRedoProcessor(this);
				AttachTextEditCallback(undoRedoProcessor);

				AddShortcutCommand(new ShortcutCommand(true, false, 'Z', Func<bool()>(this, &GuiTextBoxCommonInterface::Undo)));
				AddShortcutCommand(new ShortcutCommand(true, false, 'Y', Func<bool()>(this, &GuiTextBoxCommonInterface::Redo)));
				AddShortcutCommand(new ShortcutCommand(true, false, 'A', Func<void()>(this, &GuiTextBoxCommonInterface::SelectAll)));
				AddShortcutCommand(new ShortcutCommand(true, false, 'X', Func<bool()>(this, &GuiTextBoxCommonInterface::Cut)));
				AddShortcutCommand(new ShortcutCommand(true, false, 'C', Func<bool()>(this, &GuiTextBoxCommonInterface::Copy)));
				AddShortcutCommand(new ShortcutCommand(true, false, 'V', Func<bool()>(this, &GuiTextBoxCommonInterface::Paste)));
			}

			GuiTextBoxCommonInterface::~GuiTextBoxCommonInterface()
			{
				if(colorizer)
				{
					DetachTextEditCallback(colorizer);
					colorizer=0;
				}
				if(undoRedoProcessor)
				{
					DetachTextEditCallback(undoRedoProcessor);
					undoRedoProcessor=0;
				}

				for(vint i=0;i<textEditCallbacks.Count();i++)
				{
					textEditCallbacks[i]->Detach();
				}
				textEditCallbacks.Clear();
			}

			//================ clipboard operations

			bool GuiTextBoxCommonInterface::CanCut()
			{
				return !readonly && textElement->GetCaretBegin()!=textElement->GetCaretEnd() && textElement->GetPasswordChar()==L'\0';
			}

			bool GuiTextBoxCommonInterface::CanCopy()
			{
				return textElement->GetCaretBegin()!=textElement->GetCaretEnd() && textElement->GetPasswordChar()==L'\0';
			}

			bool GuiTextBoxCommonInterface::CanPaste()
			{
				return !readonly && GetCurrentController()->ClipboardService()->ContainsText() && textElement->GetPasswordChar()==L'\0';
			}

			bool GuiTextBoxCommonInterface::Cut()
			{
				if(CanCut())
				{
					GetCurrentController()->ClipboardService()->SetText(GetSelectionText());
					SetSelectionText(L"");
					return true;
				}
				else
				{
					return false;
				}
			}

			bool GuiTextBoxCommonInterface::Copy()
			{
				if(CanCopy())
				{
					GetCurrentController()->ClipboardService()->SetText(GetSelectionText());
					return true;
				}
				else
				{
					return false;
				}
			}

			bool GuiTextBoxCommonInterface::Paste()
			{
				if(CanPaste())
				{
					SetSelectionText(GetCurrentController()->ClipboardService()->GetText());
					return true;
				}
				else
				{
					return false;
				}
			}
			
			//================ editing control
			
			bool GuiTextBoxCommonInterface::GetReadonly()
			{
				return readonly;
			}

			void GuiTextBoxCommonInterface::SetReadonly(bool value)
			{
				readonly=value;
			}

			//================ text operations

			void GuiTextBoxCommonInterface::Select(TextPos begin, TextPos end)
			{
				Move(begin, false);
				Move(end, true);
			}

			void GuiTextBoxCommonInterface::SelectAll()
			{
				vint row=textElement->GetLines().GetCount()-1;
				Move(TextPos(0, 0), false);
				Move(TextPos(row, textElement->GetLines().GetLine(row).dataLength), true);
			}

			WString GuiTextBoxCommonInterface::GetSelectionText()
			{
				TextPos selectionBegin=textElement->GetCaretBegin()<textElement->GetCaretEnd()?textElement->GetCaretBegin():textElement->GetCaretEnd();
				TextPos selectionEnd=textElement->GetCaretBegin()>textElement->GetCaretEnd()?textElement->GetCaretBegin():textElement->GetCaretEnd();
				return textElement->GetLines().GetText(selectionBegin, selectionEnd);
			}

			void GuiTextBoxCommonInterface::SetSelectionText(const WString& value)
			{
				Modify(textElement->GetCaretBegin(), textElement->GetCaretEnd(), value);
			}

			WString GuiTextBoxCommonInterface::GetRowText(vint row)
			{
				TextPos start=textElement->GetLines().Normalize(TextPos(row, 0));
				TextPos end=TextPos(start.row, textElement->GetLines().GetLine(start.row).dataLength);
				return GetFragmentText(start, end);
			}

			WString GuiTextBoxCommonInterface::GetFragmentText(TextPos start, TextPos end)
			{
				start=textElement->GetLines().Normalize(start);
				end=textElement->GetLines().Normalize(end);
				return textElement->GetLines().GetText(start, end);
			}

			TextPos GuiTextBoxCommonInterface::GetCaretBegin()
			{
				return textElement->GetCaretBegin();
			}

			TextPos GuiTextBoxCommonInterface::GetCaretEnd()
			{
				return textElement->GetCaretEnd();
			}

			TextPos GuiTextBoxCommonInterface::GetCaretSmall()
			{
				TextPos c1=GetCaretBegin();
				TextPos c2=GetCaretEnd();
				return c1<c2?c1:c2;
			}

			TextPos GuiTextBoxCommonInterface::GetCaretLarge()
			{
				TextPos c1=GetCaretBegin();
				TextPos c2=GetCaretEnd();
				return c1>c2?c1:c2;
			}

			//================ position query
				
			vint GuiTextBoxCommonInterface::GetRowWidth(vint row)
			{
				return textElement->GetLines().GetRowWidth(row);
			}

			vint GuiTextBoxCommonInterface::GetRowHeight()
			{
				return textElement->GetLines().GetRowHeight();
			}

			vint GuiTextBoxCommonInterface::GetMaxWidth()
			{
				return textElement->GetLines().GetMaxWidth();
			}

			vint GuiTextBoxCommonInterface::GetMaxHeight()
			{
				return textElement->GetLines().GetMaxHeight();
			}

			TextPos GuiTextBoxCommonInterface::GetTextPosFromPoint(Point point)
			{
				Point view=textElement->GetViewPosition();
				return textElement->GetLines().GetTextPosFromPoint(Point(point.x+view.x, point.y+view.y));
			}

			Point GuiTextBoxCommonInterface::GetPointFromTextPos(TextPos pos)
			{
				Point view=textElement->GetViewPosition();
				Point result=textElement->GetLines().GetPointFromTextPos(pos);
				return Point(result.x-view.x, result.y-view.y);
			}

			Rect GuiTextBoxCommonInterface::GetRectFromTextPos(TextPos pos)
			{
				Point view=textElement->GetViewPosition();
				Rect result=textElement->GetLines().GetRectFromTextPos(pos);
				return Rect(Point(result.x1-view.x, result.y1-view.y), result.GetSize());
			}

			TextPos GuiTextBoxCommonInterface::GetNearestTextPos(Point point)
			{
				Point viewPosition=textElement->GetViewPosition();
				Point mousePosition=Point(point.x+viewPosition.x, point.y+viewPosition.y);
				TextPos pos=textElement->GetLines().GetTextPosFromPoint(mousePosition);
				if(pos.column<textElement->GetLines().GetLine(pos.row).dataLength)
				{
					Rect rect=textElement->GetLines().GetRectFromTextPos(pos);
					if(abs((int)(rect.x1-mousePosition.x))>=abs((int)(rect.x2-1-mousePosition.x)))
					{
						pos.column++;
					}
				}
				return pos;
			}

			//================ colorizing

			Ptr<GuiTextBoxColorizerBase> GuiTextBoxCommonInterface::GetColorizer()
			{
				return colorizer;
			}

			void GuiTextBoxCommonInterface::SetColorizer(Ptr<GuiTextBoxColorizerBase> value)
			{
				if(colorizer)
				{
					DetachTextEditCallback(colorizer);
				}
				colorizer=value;
				if(colorizer)
				{
					AttachTextEditCallback(colorizer);
					GetTextElement()->SetColors(colorizer->GetColors());
				}
			}

			//================ undo redo control

			bool GuiTextBoxCommonInterface::CanUndo()
			{
				return undoRedoProcessor->CanUndo();
			}

			bool GuiTextBoxCommonInterface::CanRedo()
			{
				return undoRedoProcessor->CanRedo();
			}

			void GuiTextBoxCommonInterface::ClearUndoRedo()
			{
				undoRedoProcessor->ClearUndoRedo();
			}

			bool GuiTextBoxCommonInterface::GetModified()
			{
				return undoRedoProcessor->GetModified();
			}

			void GuiTextBoxCommonInterface::NotifyModificationSaved()
			{
				undoRedoProcessor->NotifyModificationSaved();
			}

			bool GuiTextBoxCommonInterface::Undo()
			{
				return undoRedoProcessor->Undo();
			}

			bool GuiTextBoxCommonInterface::Redo()
			{
				return undoRedoProcessor->Redo();
			}
		}
	}
}

/***********************************************************************
Controls\TextEditorPackage\GuiTextControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace elements::text;
			using namespace compositions;

/***********************************************************************
GuiMultilineTextBox::StyleController
***********************************************************************/

			GuiMultilineTextBox::StyleController::StyleController(GuiScrollView::IStyleProvider* styleProvider)
				:GuiScrollView::StyleController(styleProvider)
				,textElement(0)
				,textComposition(0)
				,textBox(0)
			{
				textElement=GuiColorizedTextElement::Create();

				textComposition=new GuiBoundsComposition;
				textComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				textComposition->SetOwnedElement(textElement);

				GetInternalContainerComposition()->AddChild(textComposition);
			}

			GuiMultilineTextBox::StyleController::~StyleController()
			{
			}

			void GuiMultilineTextBox::StyleController::Initialize(GuiMultilineTextBox* control)
			{
				textBox=control;
			}

			elements::GuiColorizedTextElement* GuiMultilineTextBox::StyleController::GetTextElement()
			{
				return textElement;
			}

			compositions::GuiGraphicsComposition* GuiMultilineTextBox::StyleController::GetTextComposition()
			{
				return textComposition;
			}

			void GuiMultilineTextBox::StyleController::SetViewPosition(Point value)
			{
				textElement->SetViewPosition(value);
			}

			void GuiMultilineTextBox::StyleController::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				GuiScrollView::StyleController::SetFocusableComposition(value);
				textBox->Install(textElement, textComposition, scrollView);
				if(!textBox->GetCallback())
				{
					if(!defaultCallback)
					{
						defaultCallback=new TextElementOperatorCallback(dynamic_cast<GuiMultilineTextBox*>(scrollView));
					}
					textBox->SetCallback(defaultCallback.Obj());
				}
			}

			WString GuiMultilineTextBox::StyleController::GetText()
			{
				return textElement->GetLines().GetText();
			}

			void GuiMultilineTextBox::StyleController::SetText(const WString& value)
			{
				if(textBox)
				{
					textBox->UnsafeSetText(value);
				}
				textElement->SetCaretBegin(TextPos(0, 0));
				textElement->SetCaretEnd(TextPos(0, 0));
				GuiScrollView::StyleController::SetText(value);
			}

			void GuiMultilineTextBox::StyleController::SetFont(const FontProperties& value)
			{
				textElement->SetFont(value);
				GuiScrollView::StyleController::SetFont(value);
			}

			void GuiMultilineTextBox::StyleController::SetVisuallyEnabled(bool value)
			{
				textElement->SetVisuallyEnabled(value);
				GuiScrollView::StyleController::SetVisuallyEnabled(value);
			}

/***********************************************************************
GuiMultilineTextBox::DefaultTextElementOperatorCallback
***********************************************************************/

			GuiMultilineTextBox::TextElementOperatorCallback::TextElementOperatorCallback(GuiMultilineTextBox* _textControl)
				:GuiTextBoxCommonInterface::DefaultCallback(
					dynamic_cast<StyleController*>(_textControl->GetStyleController())->GetTextElement(),
					dynamic_cast<StyleController*>(_textControl->GetStyleController())->GetTextComposition()
					)
				,textControl(_textControl)
				,textController(dynamic_cast<StyleController*>(_textControl->GetStyleController()))
			{
			}

			void GuiMultilineTextBox::TextElementOperatorCallback::AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)
			{
				textControl->CalculateView();
			}
			
			void GuiMultilineTextBox::TextElementOperatorCallback::ScrollToView(Point point)
			{
				point.x+=TextMargin;
				point.y+=TextMargin;
				Point oldPoint(textControl->GetHorizontalScroll()->GetPosition(), textControl->GetVerticalScroll()->GetPosition());
				vint marginX=0;
				vint marginY=0;
				if(oldPoint.x<point.x)
				{
					marginX=TextMargin;
				}
				else if(oldPoint.x>point.x)
				{
					marginX=-TextMargin;
				}
				if(oldPoint.y<point.y)
				{
					marginY=TextMargin;
				}
				else if(oldPoint.y>point.y)
				{
					marginY=-TextMargin;
				}
				textControl->GetHorizontalScroll()->SetPosition(point.x+marginX);
				textControl->GetVerticalScroll()->SetPosition(point.y+marginY);
			}

			vint GuiMultilineTextBox::TextElementOperatorCallback::GetTextMargin()
			{
				return TextMargin;
			}

/***********************************************************************
GuiMultilineTextBox
***********************************************************************/

			void GuiMultilineTextBox::CalculateViewAndSetScroll()
			{
				CalculateView();
				vint smallMove=styleController->GetTextElement()->GetLines().GetRowHeight();
				vint bigMove=smallMove*5;
				styleController->GetHorizontalScroll()->SetSmallMove(smallMove);
				styleController->GetHorizontalScroll()->SetBigMove(bigMove);
				styleController->GetVerticalScroll()->SetSmallMove(smallMove);
				styleController->GetVerticalScroll()->SetBigMove(bigMove);
			}

			void GuiMultilineTextBox::OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)
			{
				CalculateViewAndSetScroll();
				GuiScrollView::OnRenderTargetChanged(renderTarget);
			}

			Size GuiMultilineTextBox::QueryFullSize()
			{
				text::TextLines& lines=styleController->GetTextElement()->GetLines();
				return Size(lines.GetMaxWidth()+TextMargin*2, lines.GetMaxHeight()+TextMargin*2);
			}

			void GuiMultilineTextBox::UpdateView(Rect viewBounds)
			{
				styleController->SetViewPosition(viewBounds.LeftTop()-Size(TextMargin, TextMargin));
			}

			void GuiMultilineTextBox::OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(GetVisuallyEnabled())
				{
					boundsComposition->GetRelatedGraphicsHost()->SetFocus(boundsComposition);
				}
			}

			GuiMultilineTextBox::GuiMultilineTextBox(GuiMultilineTextBox::IStyleProvider* styleProvider)
				:GuiScrollView(new StyleController(styleProvider))
			{
				styleController=dynamic_cast<StyleController*>(GetStyleController());
				styleController->Initialize(this);
				SetFocusableComposition(boundsComposition);

				boundsComposition->GetEventReceiver()->leftButtonDown.AttachMethod(this, &GuiMultilineTextBox::OnBoundsMouseButtonDown);
				boundsComposition->GetEventReceiver()->middleButtonDown.AttachMethod(this, &GuiMultilineTextBox::OnBoundsMouseButtonDown);
				boundsComposition->GetEventReceiver()->rightButtonDown.AttachMethod(this, &GuiMultilineTextBox::OnBoundsMouseButtonDown);
			}

			GuiMultilineTextBox::~GuiMultilineTextBox()
			{
			}

			const WString& GuiMultilineTextBox::GetText()
			{
				text=styleController->GetText();
				return text;
			}

			void GuiMultilineTextBox::SetText(const WString& value)
			{
				text=GetText();
				GuiScrollView::SetText(value);
				CalculateView();
			}

			void GuiMultilineTextBox::SetFont(const FontProperties& value)
			{
				GuiScrollView::SetFont(value);
				CalculateViewAndSetScroll();
			}

/***********************************************************************
GuiSinglelineTextBox::StyleController
***********************************************************************/

			GuiSinglelineTextBox::StyleController::StyleController(IStyleProvider* _styleProvider)
				:styleProvider(_styleProvider)
				,boundsComposition(0)
				,containerComposition(0)
				,textBox(0)
				,textElement(0)
				,textComposition(0)
			{
				boundsComposition=new GuiBoundsComposition;
				containerComposition=styleProvider->InstallBackground(boundsComposition);

				textElement=GuiColorizedTextElement::Create();
				textElement->SetViewPosition(Point(-TextMargin, -TextMargin));

				textCompositionTable=new GuiTableComposition;
				textCompositionTable->SetAlignmentToParent(Margin(0, 0, 0, 0));
				textCompositionTable->SetRowsAndColumns(3, 1);
				textCompositionTable->SetRowOption(0, GuiCellOption::PercentageOption(0.5));
				textCompositionTable->SetRowOption(1, GuiCellOption::AbsoluteOption(0));
				textCompositionTable->SetRowOption(2, GuiCellOption::PercentageOption(0.5));
				textCompositionTable->SetColumnOption(0, GuiCellOption::PercentageOption(1.0));
				containerComposition->AddChild(textCompositionTable);

				textComposition=new GuiCellComposition;
				textComposition->SetOwnedElement(textElement);
				textCompositionTable->AddChild(textComposition);
				textComposition->SetSite(1, 0, 1, 1);

				styleProvider->AssociateStyleController(this);
			}

			GuiSinglelineTextBox::StyleController::~StyleController()
			{
			}

			void GuiSinglelineTextBox::StyleController::SetTextBox(GuiSinglelineTextBox* control)
			{
				textBox=control;
			}

			void GuiSinglelineTextBox::StyleController::RearrangeTextElement()
			{
				textCompositionTable->SetRowOption(1, GuiCellOption::AbsoluteOption(textElement->GetLines().GetRowHeight()+2*TextMargin));
			}

			compositions::GuiBoundsComposition* GuiSinglelineTextBox::StyleController::GetBoundsComposition()
			{
				return boundsComposition;
			}

			compositions::GuiGraphicsComposition* GuiSinglelineTextBox::StyleController::GetContainerComposition()
			{
				return containerComposition;
			}

			void GuiSinglelineTextBox::StyleController::SetFocusableComposition(compositions::GuiGraphicsComposition* value)
			{
				styleProvider->SetFocusableComposition(value);
				textBox->Install(textElement, textComposition, textBox);
				if(!textBox->GetCallback())
				{
					if(!defaultCallback)
					{
						defaultCallback=new TextElementOperatorCallback(textBox);
					}
					textBox->SetCallback(defaultCallback.Obj());
				}
			}

			WString GuiSinglelineTextBox::StyleController::GetText()
			{
				return textElement->GetLines().GetText();
			}

			void GuiSinglelineTextBox::StyleController::SetText(const WString& value)
			{
				if(textBox)
				{
					textBox->UnsafeSetText(value);
				}
				textElement->SetCaretBegin(TextPos(0, 0));
				textElement->SetCaretEnd(TextPos(0, 0));
				styleProvider->SetText(value);
			}

			void GuiSinglelineTextBox::StyleController::SetFont(const FontProperties& value)
			{
				textElement->SetFont(value);
				styleProvider->SetFont(value);
			}

			void GuiSinglelineTextBox::StyleController::SetVisuallyEnabled(bool value)
			{
				textElement->SetVisuallyEnabled(value);
				styleProvider->SetVisuallyEnabled(value);
			}

			elements::GuiColorizedTextElement* GuiSinglelineTextBox::StyleController::GetTextElement()
			{
				return textElement;
			}

			compositions::GuiGraphicsComposition* GuiSinglelineTextBox::StyleController::GetTextComposition()
			{
				return textComposition;
			}

			void GuiSinglelineTextBox::StyleController::SetViewPosition(Point value)
			{
				textElement->SetViewPosition(value);
			}

/***********************************************************************
GuiSinglelineTextBox::DefaultTextElementOperatorCallback
***********************************************************************/

			GuiSinglelineTextBox::TextElementOperatorCallback::TextElementOperatorCallback(GuiSinglelineTextBox* _textControl)
				:GuiTextBoxCommonInterface::DefaultCallback(
					dynamic_cast<StyleController*>(_textControl->GetStyleController())->GetTextElement(),
					dynamic_cast<StyleController*>(_textControl->GetStyleController())->GetTextComposition()
					)
				,textControl(_textControl)
				,textController(dynamic_cast<StyleController*>(_textControl->GetStyleController()))
			{
			}

			bool GuiSinglelineTextBox::TextElementOperatorCallback::BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)
			{
				vint length=inputText.Length();
				const wchar_t* input=inputText.Buffer();
				for(vint i=0;i<length;i++)
				{
					if(*input==0 || *input==L'\r' || *input==L'\n')
					{
						length=i;
						break;
					}
				}
				if(length!=inputText.Length())
				{
					inputText=inputText.Left(length);
				}
				return true;
			}

			void GuiSinglelineTextBox::TextElementOperatorCallback::AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)
			{
			}
			
			void GuiSinglelineTextBox::TextElementOperatorCallback::ScrollToView(Point point)
			{
				vint newX=point.x;
				vint oldX=textElement->GetViewPosition().x;
				vint marginX=0;
				if(oldX<newX)
				{
					marginX=TextMargin;
				}
				else if(oldX>newX)
				{
					marginX=-TextMargin;
				}

				newX+=marginX;
				vint minX=-TextMargin;
				vint maxX=textElement->GetLines().GetMaxWidth()+TextMargin-textComposition->GetBounds().Width();
				if(newX>=maxX)
				{
					newX=maxX-1;
				}
				if(newX<minX)
				{
					newX=minX;
				}
				textElement->SetViewPosition(Point(newX, -TextMargin));
			}

			vint GuiSinglelineTextBox::TextElementOperatorCallback::GetTextMargin()
			{
				return TextMargin;
			}

/***********************************************************************
GuiSinglelineTextBox
***********************************************************************/

			void GuiSinglelineTextBox::OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)
			{
				styleController->RearrangeTextElement();
				GuiControl::OnRenderTargetChanged(renderTarget);
			}

			void GuiSinglelineTextBox::OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments)
			{
				if(GetVisuallyEnabled())
				{
					boundsComposition->GetRelatedGraphicsHost()->SetFocus(boundsComposition);
				}
			}

			GuiSinglelineTextBox::GuiSinglelineTextBox(GuiSinglelineTextBox::IStyleProvider* styleProvider)
				:GuiControl(new StyleController(styleProvider))
			{
				styleController=dynamic_cast<StyleController*>(GetStyleController());
				styleController->SetTextBox(this);
				SetFocusableComposition(boundsComposition);

				boundsComposition->GetEventReceiver()->leftButtonDown.AttachMethod(this, &GuiSinglelineTextBox::OnBoundsMouseButtonDown);
				boundsComposition->GetEventReceiver()->middleButtonDown.AttachMethod(this, &GuiSinglelineTextBox::OnBoundsMouseButtonDown);
				boundsComposition->GetEventReceiver()->rightButtonDown.AttachMethod(this, &GuiSinglelineTextBox::OnBoundsMouseButtonDown);
			}

			GuiSinglelineTextBox::~GuiSinglelineTextBox()
			{
			}

			const WString& GuiSinglelineTextBox::GetText()
			{
				text=styleController->GetText();
				return text;
			}

			void GuiSinglelineTextBox::SetText(const WString& value)
			{
				GuiControl::SetText(value);
			}

			void GuiSinglelineTextBox::SetFont(const FontProperties& value)
			{
				GuiControl::SetFont(value);
				styleController->RearrangeTextElement();
			}

			wchar_t GuiSinglelineTextBox::GetPasswordChar()
			{
				return styleController->GetTextElement()->GetPasswordChar();
			}

			void GuiSinglelineTextBox::SetPasswordChar(wchar_t value)
			{
				styleController->GetTextElement()->SetPasswordChar(value);
			}
		}
	}
}

/***********************************************************************
Controls\TextEditorPackage\GuiTextGeneralOperations.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace elements::text;
			using namespace compositions;
		}
	}
}

/***********************************************************************
Controls\TextEditorPackage\GuiTextUndoRedo.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace elements;
			using namespace elements::text;
			using namespace compositions;

/***********************************************************************
GuiGeneralUndoRedoProcessor
***********************************************************************/

			GuiGeneralUndoRedoProcessor::GuiGeneralUndoRedoProcessor()
				:firstFutureStep(0)
				,savedStep(0)
				,performingUndoRedo(false)
			{
			}

			GuiGeneralUndoRedoProcessor::~GuiGeneralUndoRedoProcessor()
			{
			}

			void GuiGeneralUndoRedoProcessor::PushStep(Ptr<IEditStep> step)
			{
				if(!performingUndoRedo)
				{
					if(firstFutureStep<savedStep)
					{
						savedStep=-1;
					}

					vint count=steps.Count()-firstFutureStep;
					if(count>0)
					{
						steps.RemoveRange(firstFutureStep, count);
					}
				
					steps.Add(step);
					firstFutureStep=steps.Count();
				}
			}

			bool GuiGeneralUndoRedoProcessor::CanUndo()
			{
				return firstFutureStep>0;
			}

			bool GuiGeneralUndoRedoProcessor::CanRedo()
			{
				return steps.Count()>firstFutureStep;
			}

			void GuiGeneralUndoRedoProcessor::ClearUndoRedo()
			{
				if(!performingUndoRedo)
				{
					steps.Clear();
					firstFutureStep=0;
					savedStep=-1;
				}
			}

			bool GuiGeneralUndoRedoProcessor::GetModified()
			{
				return firstFutureStep!=savedStep;
			}

			void GuiGeneralUndoRedoProcessor::NotifyModificationSaved()
			{
				if(!performingUndoRedo)
				{
					savedStep=firstFutureStep;
				}
			}

			bool GuiGeneralUndoRedoProcessor::Undo()
			{
				if(!CanUndo()) return false;
				performingUndoRedo=true;
				firstFutureStep--;
				steps[firstFutureStep]->Undo();
				performingUndoRedo=false;
				return true;
			}

			bool GuiGeneralUndoRedoProcessor::Redo()
			{
				if(!CanRedo()) return false;
				performingUndoRedo=true;
				firstFutureStep++;
				steps[firstFutureStep-1]->Redo();
				performingUndoRedo=false;
				return true;
			}

/***********************************************************************
GuiTextBoxUndoRedoProcessor::EditStep
***********************************************************************/

			void GuiTextBoxUndoRedoProcessor::EditStep::Undo()
			{
				processor->textBoxCommonInterface->Select(inputStart, inputEnd);
				processor->textBoxCommonInterface->SetSelectionText(originalText);
				processor->textBoxCommonInterface->Select(originalStart, originalEnd);
			}

			void GuiTextBoxUndoRedoProcessor::EditStep::Redo()
			{
				processor->textBoxCommonInterface->Select(originalStart, originalEnd);
				processor->textBoxCommonInterface->SetSelectionText(inputText);
				processor->textBoxCommonInterface->Select(inputStart, inputEnd);
			}

/***********************************************************************
GuiTextBoxUndoRedoProcessor
***********************************************************************/

			GuiTextBoxUndoRedoProcessor::GuiTextBoxUndoRedoProcessor(GuiTextBoxCommonInterface* _textBoxCommonInterface)
				:textBoxCommonInterface(_textBoxCommonInterface)
			{
			}

			GuiTextBoxUndoRedoProcessor::~GuiTextBoxUndoRedoProcessor()
			{
			}

			void GuiTextBoxUndoRedoProcessor::Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock)
			{
			}

			void GuiTextBoxUndoRedoProcessor::Detach()
			{
				ClearUndoRedo();
			}

			void GuiTextBoxUndoRedoProcessor::TextEditNotify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)
			{
				Ptr<EditStep> step=new EditStep;
				step->processor=this;
				step->originalStart=originalStart;
				step->originalEnd=originalEnd;
				step->originalText=originalText;
				step->inputStart=inputStart;
				step->inputEnd=inputEnd;
				step->inputText=inputText;
				PushStep(step);
			}
		}
	}
}

/***********************************************************************
Controls\ToolstripPackage\GuiMenuControls.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
IGuiMenuService
***********************************************************************/

			const wchar_t* const IGuiMenuService::Identifier = L"vl::presentation::controls::IGuiMenuService";

			IGuiMenuService::IGuiMenuService()
				:openingMenu(0)
			{
			}

			void IGuiMenuService::MenuItemExecuted()
			{
				if(openingMenu)
				{
					openingMenu->Hide();
				}
				if(GetParentMenuService())
				{
					GetParentMenuService()->MenuItemExecuted();
				}
			}

			GuiMenu* IGuiMenuService::GetOpeningMenu()
			{
				return openingMenu;
			}

			void IGuiMenuService::MenuOpened(GuiMenu* menu)
			{
				if(openingMenu!=menu && openingMenu)
				{
					openingMenu->Hide();
				}
				openingMenu=menu;
			}

			void IGuiMenuService::MenuClosed(GuiMenu* menu)
			{
				if(openingMenu==menu)
				{
					openingMenu=0;
				}
			}

/***********************************************************************
GuiMenu
***********************************************************************/

			IGuiMenuService* GuiMenu::GetParentMenuService()
			{
				return parentMenuService;
			}

			IGuiMenuService::Direction GuiMenu::GetPreferredDirection()
			{
				return IGuiMenuService::Vertical;
			}

			bool GuiMenu::IsActiveState()
			{
				return true;
			}

			bool GuiMenu::IsSubMenuActivatedByMouseDown()
			{
				return false;
			}

			void GuiMenu::MenuItemExecuted()
			{
				IGuiMenuService::MenuItemExecuted();
				Hide();
			}

			void GuiMenu::OnWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(parentMenuService)
				{
					parentMenuService->MenuOpened(this);
				}
			}

			void GuiMenu::MouseClickedOnOtherWindow(GuiWindow* window)
			{
				GuiMenu* targetMenu=dynamic_cast<GuiMenu*>(window);
				if(!targetMenu)
				{
					Hide();
				}
			}

			void GuiMenu::OnWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(parentMenuService)
				{
					parentMenuService->MenuClosed(this);
					GuiMenu* openingSubMenu=GetOpeningMenu();
					if(openingSubMenu)
					{
						openingSubMenu->Hide();
					}
				}
			}

			GuiMenu::GuiMenu(IStyleController* _styleController, GuiControl* _owner)
				:GuiPopup(_styleController)
				,owner(_owner)
				,parentMenuService(0)
			{
				GetNativeWindow()->SetAlwaysPassFocusToParent(true);
				UpdateMenuService();
				WindowOpened.AttachMethod(this, &GuiMenu::OnWindowOpened);
				WindowClosed.AttachMethod(this, &GuiMenu::OnWindowClosed);
			}

			GuiMenu::~GuiMenu()
			{
			}

			void GuiMenu::UpdateMenuService()
			{
				if(owner)
				{
					parentMenuService=owner->QueryService<IGuiMenuService>();
				}
			}

			IDescriptable* GuiMenu::QueryService(const WString& identifier)
			{
				if(identifier==IGuiMenuService::Identifier)
				{
					return (IGuiMenuService*)this;
				}
				else
				{
					return GuiPopup::QueryService(identifier);
				}
			}

/***********************************************************************
GuiMenuBar
***********************************************************************/

			IGuiMenuService* GuiMenuBar::GetParentMenuService()
			{
				return 0;
			}

			IGuiMenuService::Direction GuiMenuBar::GetPreferredDirection()
			{
				return IGuiMenuService::Horizontal;
			}

			bool GuiMenuBar::IsActiveState()
			{
				return GetOpeningMenu()!=0;
			}

			bool GuiMenuBar::IsSubMenuActivatedByMouseDown()
			{
				return true;
			}

			GuiMenuBar::GuiMenuBar(GuiControl::IStyleController* _styleController)
				:GuiControl(_styleController)
			{
			}

			GuiMenuBar::~GuiMenuBar()
			{
			}

			IDescriptable* GuiMenuBar::QueryService(const WString& identifier)
			{
				if(identifier==IGuiMenuService::Identifier)
				{
					return (IGuiMenuService*)this;
				}
				else
				{
					return GuiControl::QueryService(identifier);
				}
			}

/***********************************************************************
GuiMenuButton
***********************************************************************/

			const wchar_t* const GuiMenuButton::MenuItemSubComponentMeasuringCategoryName=L"MenuItem";

			GuiButton* GuiMenuButton::GetSubMenuHost()
			{
				GuiButton* button=styleController->GetSubMenuHost();
				return button?button:this;
			}

			void GuiMenuButton::OpenSubMenuInternal()
			{
				if(!GetSubMenuOpening())
				{
					if(ownerMenuService)
					{
						GuiMenu* openingSiblingMenu=ownerMenuService->GetOpeningMenu();
						if(openingSiblingMenu)
						{
							openingSiblingMenu->Hide();
						}
					}
					SetSubMenuOpening(true);
				}
			}

			void GuiMenuButton::OnParentLineChanged()
			{
				GuiButton::OnParentLineChanged();
				ownerMenuService=QueryService<IGuiMenuService>();
				if(ownerMenuService)
				{
					SetClickOnMouseUp(!ownerMenuService->IsSubMenuActivatedByMouseDown());
				}
				if(subMenu)
				{
					subMenu->UpdateMenuService();
				}
			}

			void GuiMenuButton::OnSubMenuWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				SubMenuOpeningChanged.Execute(GetNotifyEventArguments());
				styleController->SetSubMenuOpening(true);
			}

			void GuiMenuButton::OnSubMenuWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				SubMenuOpeningChanged.Execute(GetNotifyEventArguments());
				styleController->SetSubMenuOpening(false);
			}

			void GuiMenuButton::OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(GetVisuallyEnabled())
				{
					if(ownerMenuService && ownerMenuService->IsActiveState())
					{
						OpenSubMenuInternal();
					}
				}
			}

			void GuiMenuButton::OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(GetSubMenu())
				{
					OpenSubMenuInternal();
				}
				else if(GetVisuallyEnabled())
				{
					if(ownerMenuService)
					{
						ownerMenuService->MenuItemExecuted();
					}
				}
			}

			GuiMenuButton::GuiMenuButton(IStyleController* _styleController)
				:GuiButton(_styleController)
				,styleController(_styleController)
				,subMenu(0)
				,ownedSubMenu(false)
				,ownerMenuService(0)
			{
				SubMenuOpeningChanged.SetAssociatedComposition(boundsComposition);
				ImageChanged.SetAssociatedComposition(boundsComposition);
				ShortcutTextChanged.SetAssociatedComposition(boundsComposition);
				GetSubMenuHost()->Clicked.AttachMethod(this, &GuiMenuButton::OnClicked);
				GetSubMenuHost()->GetEventReceiver()->mouseEnter.AttachMethod(this, &GuiMenuButton::OnMouseEnter);
			}

			GuiMenuButton::~GuiMenuButton()
			{
				if(subMenu && ownedSubMenu)
				{
					delete subMenu;
				}
			}

			Ptr<GuiImageData> GuiMenuButton::GetImage()
			{
				return image;
			}

			void GuiMenuButton::SetImage(Ptr<GuiImageData> value)
			{
				if(image!=value)
				{
					image=value;
					styleController->SetImage(image);
					ImageChanged.Execute(GetNotifyEventArguments());
				}
			}

			const WString& GuiMenuButton::GetShortcutText()
			{
				return shortcutText;
			}

			void GuiMenuButton::SetShortcutText(const WString& value)
			{
				if(shortcutText!=value)
				{
					shortcutText=value;
					styleController->SetShortcutText(shortcutText);
					ShortcutTextChanged.Execute(GetNotifyEventArguments());
				}
			}

			bool GuiMenuButton::IsSubMenuExists()
			{
				return subMenu!=0;
			}

			GuiMenu* GuiMenuButton::GetSubMenu()
			{
				return subMenu;
			}

			void GuiMenuButton::CreateSubMenu(GuiMenu::IStyleController* subMenuStyleController)
			{
				if(!subMenu)
				{
					GuiMenu* newSubMenu=new GuiMenu(subMenuStyleController?subMenuStyleController:styleController->CreateSubMenuStyleController(), this);
					SetSubMenu(newSubMenu, true);
				}
			}

			void GuiMenuButton::SetSubMenu(GuiMenu* value, bool owned)
			{
				if(subMenu)
				{
					if(ownedSubMenu)
					{
						delete subMenu;
					}
				}
				subMenu=value;
				ownedSubMenu=owned;
				if(subMenu)
				{
					subMenu->WindowOpened.AttachMethod(this, &GuiMenuButton::OnSubMenuWindowOpened);
					subMenu->WindowClosed.AttachMethod(this, &GuiMenuButton::OnSubMenuWindowClosed);
				}
				styleController->SetSubMenuExisting(subMenu!=0);
			}

			void GuiMenuButton::DestroySubMenu()
			{
				if(subMenu)
				{
					if(ownedSubMenu)
					{
						delete subMenu;
					}
					subMenu=0;
					ownedSubMenu=false;
					styleController->SetSubMenuExisting(false);
				}
			}

			bool GuiMenuButton::GetOwnedSubMenu()
			{
				return subMenu && ownedSubMenu;
			}

			bool GuiMenuButton::GetSubMenuOpening()
			{
				if(subMenu)
				{
					return subMenu->GetOpening();
				}
				else
				{
					return false;
				}
			}

			void GuiMenuButton::SetSubMenuOpening(bool value)
			{
				if(subMenu)
				{
					if(value)
					{
						subMenu->SetClientSize(preferredMenuClientSize);
						IGuiMenuService::Direction direction=ownerMenuService?ownerMenuService->GetPreferredDirection():IGuiMenuService::Horizontal;
						subMenu->ShowPopup(GetSubMenuHost(), direction==IGuiMenuService::Horizontal);
					}
					else
					{
						subMenu->Close();
					}
				}
			}

			Size GuiMenuButton::GetPreferredMenuClientSize()
			{
				return preferredMenuClientSize;
			}

			void GuiMenuButton::SetPreferredMenuClientSize(Size value)
			{
				preferredMenuClientSize=value;
			}
		}
	}
}

/***********************************************************************
Controls\ToolstripPackage\GuiToolstripCommand.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace compositions;

/***********************************************************************
GuiToolstripCommand
***********************************************************************/

			void GuiToolstripCommand::OnShortcutKeyItemExecuted(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				Executed.ExecuteWithNewSender(arguments, sender);
			}

			void GuiToolstripCommand::InvokeDescriptionChanged()
			{
				GuiEventArgs arguments;
				DescriptionChanged.Execute(arguments);
			}

			GuiToolstripCommand::GuiToolstripCommand()
				:shortcutKeyItem(0)
				,enabled(true)
			{
			}

			GuiToolstripCommand::~GuiToolstripCommand()
			{
			}

			Ptr<GuiImageData> GuiToolstripCommand::GetImage()
			{
				return image;
			}

			void GuiToolstripCommand::SetImage(Ptr<GuiImageData> value)
			{
				if(image!=value)
				{
					image=value;
					InvokeDescriptionChanged();
				}
			}

			const WString& GuiToolstripCommand::GetText()
			{
				return text;
			}

			void GuiToolstripCommand::SetText(const WString& value)
			{
				if(text!=value)
				{
					text=value;
					InvokeDescriptionChanged();
				}
			}

			compositions::IGuiShortcutKeyItem* GuiToolstripCommand::GetShortcut()
			{
				return shortcutKeyItem;
			}

			void GuiToolstripCommand::SetShortcut(compositions::IGuiShortcutKeyItem* value)
			{
				if(shortcutKeyItem!=value)
				{
					if(shortcutKeyItem)
					{
						shortcutKeyItem->Executed.Detach(shortcutKeyItemExecutedHandler);
					}
					shortcutKeyItem=0;
					shortcutKeyItemExecutedHandler=0;
					if(value)
					{
						shortcutKeyItem=value;
						shortcutKeyItemExecutedHandler=shortcutKeyItem->Executed.AttachMethod(this, &GuiToolstripCommand::OnShortcutKeyItemExecuted);
					}
					InvokeDescriptionChanged();
				}
			}

			bool GuiToolstripCommand::GetEnabled()
			{
				return enabled;
			}

			void GuiToolstripCommand::SetEnabled(bool value)
			{
				if(enabled!=value)
				{
					enabled=value;
					InvokeDescriptionChanged();
				}
			}
		}
	}
}

/***********************************************************************
Controls\ToolstripPackage\GuiToolstripMenu.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			using namespace collections;
			using namespace compositions;

/***********************************************************************
GuiToolstripCollection
***********************************************************************/

			void GuiToolstripCollection::InvokeUpdateLayout()
			{
				if(contentCallback)
				{
					contentCallback->UpdateLayout();
				}
			}

			void GuiToolstripCollection::OnInterestingMenuButtonPropertyChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				InvokeUpdateLayout();
			}

			bool GuiToolstripCollection::RemoveAtInternal(vint index, GuiControl* const& control)
			{
				items.RemoveAt(index);
				GuiStackItemComposition* stackItem=stackComposition->GetStackItems().Get(index);

				stackComposition->RemoveChild(stackItem);
				stackItem->RemoveChild(control->GetBoundsComposition());
				delete stackItem;

				if(subComponentMeasurer)
				{
					GuiMenuButton* menuButton=dynamic_cast<GuiMenuButton*>(control);
					if(menuButton)
					{
						GuiSubComponentMeasurer::IMeasuringSource* measuringSource=
							dynamic_cast<GuiMenuButton::IStyleController*>(
								menuButton->GetStyleController()
								)->GetMeasuringSource();
						if(measuringSource)
						{
							subComponentMeasurer->DetachMeasuringSource(measuringSource);
						}
					}
				}
				delete control;
				InvokeUpdateLayout();
				return true;
			}

			bool GuiToolstripCollection::InsertInternal(vint index, GuiControl* const& control)
			{
				items.Insert(index, control);
				GuiStackItemComposition* stackItem=new GuiStackItemComposition;
				control->GetBoundsComposition()->SetAlignmentToParent(Margin(0, 0, 0, 0));
				stackItem->AddChild(control->GetBoundsComposition());
				stackComposition->InsertChild(index, stackItem);

				if(subComponentMeasurer)
				{
					GuiMenuButton* menuButton=dynamic_cast<GuiMenuButton*>(control);
					if(menuButton)
					{
						GuiSubComponentMeasurer::IMeasuringSource* measuringSource=
							dynamic_cast<GuiMenuButton::IStyleController*>(
								menuButton->GetStyleController()
								)->GetMeasuringSource();
						if(measuringSource)
						{
							subComponentMeasurer->AttachMeasuringSource(measuringSource);
						}
						menuButton->TextChanged.AttachMethod(this, &GuiToolstripCollection::OnInterestingMenuButtonPropertyChanged);
						menuButton->ShortcutTextChanged.AttachMethod(this, &GuiToolstripCollection::OnInterestingMenuButtonPropertyChanged);
					}
				}
				InvokeUpdateLayout();
				return true;
			}

			GuiToolstripCollection::GuiToolstripCollection(IContentCallback* _contentCallback, compositions::GuiStackComposition* _stackComposition, Ptr<compositions::GuiSubComponentMeasurer> _subComponentMeasurer)
				:contentCallback(_contentCallback)
				,stackComposition(_stackComposition)
				,subComponentMeasurer(_subComponentMeasurer)
			{
			}

			GuiToolstripCollection::~GuiToolstripCollection()
			{
			}

/***********************************************************************
GuiToolstripBuilder
***********************************************************************/

			GuiToolstripBuilder::GuiToolstripBuilder(Environment _environment, GuiToolstripCollection* _toolstripItems)
				:environment(_environment)
				,toolstripItems(_toolstripItems)
				,previousBuilder(0)
				,theme(0)
				,lastCreatedButton(0)
			{
			}

			GuiToolstripBuilder::~GuiToolstripBuilder()
			{
			}

			GuiToolstripBuilder* GuiToolstripBuilder::Button(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result)
			{
				lastCreatedButton=0;
				switch(environment)
				{
				case Menu:
					lastCreatedButton=new GuiToolstripButton(theme->CreateMenuItemButtonStyle());
					break;
				case MenuBar:
					lastCreatedButton=new GuiToolstripButton(theme->CreateMenuBarButtonStyle());
					break;
				case Toolbar:
					lastCreatedButton=new GuiToolstripButton(theme->CreateToolbarButtonStyle());
					break;
				}
				if(lastCreatedButton)
				{
					lastCreatedButton->SetImage(image);
					lastCreatedButton->SetText(text);
					if(result)
					{
						*result=lastCreatedButton;
					}
					toolstripItems->Add(lastCreatedButton);
				}
				return this;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::Button(GuiToolstripCommand* command, GuiToolstripButton** result)
			{
				lastCreatedButton=0;
				switch(environment)
				{
				case Menu:
					lastCreatedButton=new GuiToolstripButton(theme->CreateMenuItemButtonStyle());
					break;
				case MenuBar:
					lastCreatedButton=new GuiToolstripButton(theme->CreateMenuBarButtonStyle());
					break;
				case Toolbar:
					lastCreatedButton=new GuiToolstripButton(theme->CreateToolbarButtonStyle());
					break;
				}
				if(lastCreatedButton)
				{
					lastCreatedButton->SetCommand(command);
					if(result)
					{
						*result=lastCreatedButton;
					}
					toolstripItems->Add(lastCreatedButton);
				}
				return this;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::DropdownButton(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result)
			{
				lastCreatedButton=0;
				switch(environment)
				{
				case Toolbar:
					lastCreatedButton=new GuiToolstripButton(theme->CreateToolbarDropdownButtonStyle());
					break;
				}
				if(lastCreatedButton)
				{
					lastCreatedButton->SetImage(image);
					lastCreatedButton->SetText(text);
					if(result)
					{
						*result=lastCreatedButton;
					}
					toolstripItems->Add(lastCreatedButton);
				}
				return this;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::DropdownButton(GuiToolstripCommand* command, GuiToolstripButton** result)
			{
				lastCreatedButton=0;
				switch(environment)
				{
				case Toolbar:
					lastCreatedButton=new GuiToolstripButton(theme->CreateToolbarDropdownButtonStyle());
					break;
				}
				if(lastCreatedButton)
				{
					lastCreatedButton->SetCommand(command);
					if(result)
					{
						*result=lastCreatedButton;
					}
					toolstripItems->Add(lastCreatedButton);
				}
				return this;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::SplitButton(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result)
			{
				lastCreatedButton=0;
				switch(environment)
				{
				case Toolbar:
					lastCreatedButton=new GuiToolstripButton(theme->CreateToolbarSplitButtonStyle());
					break;
				}
				if(lastCreatedButton)
				{
					lastCreatedButton->SetImage(image);
					lastCreatedButton->SetText(text);
					if(result)
					{
						*result=lastCreatedButton;
					}
					toolstripItems->Add(lastCreatedButton);
				}
				return this;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::SplitButton(GuiToolstripCommand* command, GuiToolstripButton** result)
			{
				lastCreatedButton=0;
				switch(environment)
				{
				case Toolbar:
					lastCreatedButton=new GuiToolstripButton(theme->CreateToolbarSplitButtonStyle());
					break;
				}
				if(lastCreatedButton)
				{
					lastCreatedButton->SetCommand(command);
					if(result)
					{
						*result=lastCreatedButton;
					}
					toolstripItems->Add(lastCreatedButton);
				}
				return this;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::Splitter()
			{
				lastCreatedButton=0;
				switch(environment)
				{
				case Menu:
					toolstripItems->Add(new GuiControl(theme->CreateMenuSplitterStyle()));
					break;
				case Toolbar:
					toolstripItems->Add(new GuiControl(theme->CreateToolbarSplitterStyle()));
					break;
				}
				return this;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::Control(GuiControl* control)
			{
				toolstripItems->Add(control);
				return this;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::BeginSubMenu()
			{
				if(lastCreatedButton)
				{
					lastCreatedButton->CreateToolstripSubMenu();
					GuiToolstripMenu* menu=lastCreatedButton->GetToolstripSubMenu();
					if(menu)
					{
						menu->GetBuilder()->previousBuilder=this;
						return menu->GetBuilder();
					}
				}
				return 0;
			}

			GuiToolstripBuilder* GuiToolstripBuilder::EndSubMenu()
			{
				return previousBuilder;
			}

/***********************************************************************
GuiToolstripMenu
***********************************************************************/

			void GuiToolstripMenu::UpdateLayout()
			{
				subComponentMeasurer->MeasureAndUpdate(GuiMenuButton::MenuItemSubComponentMeasuringCategoryName, GuiSubComponentMeasurer::Horizontal);
			}

			GuiToolstripMenu::GuiToolstripMenu(IStyleController* _styleController, GuiControl* _owner)
				:GuiMenu(_styleController, _owner)
			{
				stackComposition=new GuiStackComposition;
				stackComposition->SetDirection(GuiStackComposition::Vertical);
				stackComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				stackComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				GetContainerComposition()->AddChild(stackComposition);

				subComponentMeasurer=new GuiSubComponentMeasurer;
				toolstripItems=new GuiToolstripCollection(this, stackComposition, subComponentMeasurer);
				builder=new GuiToolstripBuilder(GuiToolstripBuilder::Menu, toolstripItems.Obj());
			}

			GuiToolstripMenu::~GuiToolstripMenu()
			{
			}

			GuiToolstripCollection& GuiToolstripMenu::GetToolstripItems()
			{
				return *toolstripItems.Obj();
			}

			GuiToolstripBuilder* GuiToolstripMenu::GetBuilder(theme::ITheme* themeObject)
			{
				builder->theme=themeObject?themeObject:theme::GetCurrentTheme();
				return builder.Obj();
			}

/***********************************************************************
GuiToolstripMenuBar
***********************************************************************/
			
			GuiToolstripMenuBar::GuiToolstripMenuBar(IStyleController* _styleController)
				:GuiMenuBar(_styleController)
			{
				stackComposition=new GuiStackComposition;
				stackComposition->SetDirection(GuiStackComposition::Horizontal);
				stackComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				stackComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				GetContainerComposition()->AddChild(stackComposition);

				toolstripItems=new GuiToolstripCollection(0, stackComposition, 0);
				builder=new GuiToolstripBuilder(GuiToolstripBuilder::MenuBar, toolstripItems.Obj());
			}

			GuiToolstripMenuBar::~GuiToolstripMenuBar()
			{
			}

			GuiToolstripCollection& GuiToolstripMenuBar::GetToolstripItems()
			{
				return *toolstripItems.Obj();
			}

			GuiToolstripBuilder* GuiToolstripMenuBar::GetBuilder(theme::ITheme* themeObject)
			{
				builder->theme=themeObject?themeObject:theme::GetCurrentTheme();
				return builder.Obj();
			}

/***********************************************************************
GuiToolstripToolbar
***********************************************************************/
				
			GuiToolstripToolbar::GuiToolstripToolbar(IStyleController* _styleController)
				:GuiControl(_styleController)
			{
				stackComposition=new GuiStackComposition;
				stackComposition->SetDirection(GuiStackComposition::Horizontal);
				stackComposition->SetAlignmentToParent(Margin(0, 0, 0, 0));
				stackComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
				GetContainerComposition()->AddChild(stackComposition);

				toolstripItems=new GuiToolstripCollection(0, stackComposition, 0);
				builder=new GuiToolstripBuilder(GuiToolstripBuilder::Toolbar, toolstripItems.Obj());
			}

			GuiToolstripToolbar::~GuiToolstripToolbar()
			{
			}

			GuiToolstripCollection& GuiToolstripToolbar::GetToolstripItems()
			{
				return *toolstripItems.Obj();
			}

			GuiToolstripBuilder* GuiToolstripToolbar::GetBuilder(theme::ITheme* themeObject)
			{
				builder->theme=themeObject?themeObject:theme::GetCurrentTheme();
				return builder.Obj();
			}

/***********************************************************************
GuiToolstripButton
***********************************************************************/

			void GuiToolstripButton::UpdateCommandContent()
			{
				if(command)
				{
					SetImage(command->GetImage());
					SetText(command->GetText());
					SetEnabled(command->GetEnabled());
					if(command->GetShortcut())
					{
						SetShortcutText(command->GetShortcut()->GetName());
					}
					else
					{
						SetShortcutText(L"");
					}
				}
				else
				{
					SetImage(0);
					SetText(L"");
					SetEnabled(true);
					SetShortcutText(L"");
				}
			}

			void GuiToolstripButton::OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				if(command)
				{
					command->Executed.ExecuteWithNewSender(arguments, sender);
				}
			}

			void GuiToolstripButton::OnCommandDescriptionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
			{
				UpdateCommandContent();
			}

			GuiToolstripButton::GuiToolstripButton(IStyleController* _styleController)
				:GuiMenuButton(_styleController)
				,command(0)
			{
				Clicked.AttachMethod(this, &GuiToolstripButton::OnClicked);
			}

			GuiToolstripButton::~GuiToolstripButton()
			{
			}

			GuiToolstripCommand* GuiToolstripButton::GetCommand()
			{
				return command;
			}

			void GuiToolstripButton::SetCommand(GuiToolstripCommand* value)
			{
				if(command!=value)
				{
					if(command)
					{
						command->DescriptionChanged.Detach(descriptionChangedHandler);
					}
					command=0;
					descriptionChangedHandler=0;
					if(value)
					{
						command=value;
						descriptionChangedHandler=command->DescriptionChanged.AttachMethod(this, &GuiToolstripButton::OnCommandDescriptionChanged);
					}
					UpdateCommandContent();
				}
			}

			GuiToolstripMenu* GuiToolstripButton::GetToolstripSubMenu()
			{
				return dynamic_cast<GuiToolstripMenu*>(GetSubMenu());
			}

			void GuiToolstripButton::CreateToolstripSubMenu(GuiToolstripMenu::IStyleController* subMenuStyleController)
			{
				if(!subMenu)
				{
					GuiToolstripMenu* newSubMenu=new GuiToolstripMenu(subMenuStyleController?subMenuStyleController:styleController->CreateSubMenuStyleController(), this);
					SetSubMenu(newSubMenu, true);
				}
			}
		}
	}
}

/***********************************************************************
GraphicsComposition\GuiGraphicsBasicComposition.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			using namespace collections;
			using namespace controls;
			using namespace elements;

/***********************************************************************
GuiWindowComposition
***********************************************************************/

			GuiWindowComposition::GuiWindowComposition()
				:attachedWindow(0)
			{
			}

			GuiWindowComposition::~GuiWindowComposition()
			{
			}

			INativeWindow* GuiWindowComposition::GetAttachedWindow()
			{
				return attachedWindow;
			}

			void GuiWindowComposition::SetAttachedWindow(INativeWindow* window)
			{
				attachedWindow=window;
				SetRenderTarget(attachedWindow?GetGuiGraphicsResourceManager()->GetRenderTarget(attachedWindow):0);
			}

			Rect GuiWindowComposition::GetBounds()
			{
				return attachedWindow?Rect(Point(0, 0), attachedWindow->GetClientSize()):Rect();
			}

			void GuiWindowComposition::SetMargin(Margin value)
			{
			}

/***********************************************************************
GuiBoundsComposition
***********************************************************************/

			GuiBoundsComposition::GuiBoundsComposition()
			{
				BoundsChanged.SetAssociatedComposition(this);
				ClearAlignmentToParent();
			}

			GuiBoundsComposition::~GuiBoundsComposition()
			{
			}

			Rect GuiBoundsComposition::GetPreferredBounds()
			{
				Rect result=GetBoundsInternal(compositionBounds);
				if(GetParent() && IsAlignedToParent())
				{
					if(alignmentToParent.left>=0)
					{
						vint offset=alignmentToParent.left-result.x1;
						result.x1+=offset;
						result.x2+=offset;
					}
					if(alignmentToParent.top>=0)
					{
						vint offset=alignmentToParent.top-result.y1;
						result.y1+=offset;
						result.y2+=offset;
					}
					if(alignmentToParent.right>=0)
					{
						result.x2+=alignmentToParent.right;
					}
					if(alignmentToParent.bottom>=0)
					{
						result.y2+=alignmentToParent.bottom;
					}
				}
				return result;
			}

			Rect GuiBoundsComposition::GetBounds()
			{
				Rect result=GetPreferredBounds();
				if(GetParent() && IsAlignedToParent())
				{
					Size clientSize=GetParent()->GetClientArea().GetSize();
					if(alignmentToParent.left>=0 && alignmentToParent.right>=0)
					{
						result.x1=alignmentToParent.left;
						result.x2=clientSize.x-alignmentToParent.right;
					}
					else if(alignmentToParent.left>=0)
					{
						vint width=result.Width();
						result.x1=alignmentToParent.left;
						result.x2=result.x1+width;
					}
					else if(alignmentToParent.right>=0)
					{
						vint width=result.Width();
						result.x2=clientSize.x-alignmentToParent.right;
						result.x1=result.x2-width;
					}

					if(alignmentToParent.top>=0 && alignmentToParent.bottom>=0)
					{
						result.y1=alignmentToParent.top;
						result.y2=clientSize.y-alignmentToParent.bottom;
					}
					else if(alignmentToParent.top>=0)
					{
						vint height=result.Height();
						result.y1=alignmentToParent.top;
						result.y2=result.y1+height;
					}
					else if(alignmentToParent.bottom>=0)
					{
						vint height=result.Height();
						result.y2=clientSize.y-alignmentToParent.bottom;
						result.y1=result.y2-height;
					}
				}
				if(previousBounds!=result)
				{
					previousBounds=result;
					BoundsChanged.Execute(GuiEventArgs(this));
				}
				return result;
			}

			void GuiBoundsComposition::SetBounds(Rect value)
			{
				compositionBounds=value;
			}

			void GuiBoundsComposition::ClearAlignmentToParent()
			{
				alignmentToParent=Margin(-1, -1, -1, -1);
			}

			Margin GuiBoundsComposition::GetAlignmentToParent()
			{
				return alignmentToParent;
			}

			void GuiBoundsComposition::SetAlignmentToParent(Margin value)
			{
				alignmentToParent=value;
			}

			bool GuiBoundsComposition::IsAlignedToParent()
			{
				return alignmentToParent!=Margin(-1, -1, -1, -1);
			}
		}
	}
}

/***********************************************************************
GraphicsComposition\GuiGraphicsComposition.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			using namespace collections;
			using namespace controls;
			using namespace elements;

/***********************************************************************
GuiSubComponentMeasurer::MeasuringSource
***********************************************************************/

			GuiSubComponentMeasurer::MeasuringSource::MeasuringSource(const WString& _measuringCategory, GuiGraphicsComposition* _mainComposition)
				:measurer(0)
				,measuringCategory(_measuringCategory)
				,mainComposition(_mainComposition)
			{
			}

			GuiSubComponentMeasurer::MeasuringSource::~MeasuringSource()
			{
			}

			bool GuiSubComponentMeasurer::MeasuringSource::AddSubComponent(const WString& name, GuiGraphicsComposition* composition)
			{
				if(subComponents.Keys().Contains(name))
				{
					return false;
				}
				else
				{
					subComponents.Add(name, composition);
					return true;
				}
			}

			void GuiSubComponentMeasurer::MeasuringSource::AttachMeasurer(GuiSubComponentMeasurer* value)
			{
				measurer=value;
			}

			void GuiSubComponentMeasurer::MeasuringSource::DetachMeasurer(GuiSubComponentMeasurer* value)
			{
				measurer=0;
			}

			GuiSubComponentMeasurer* GuiSubComponentMeasurer::MeasuringSource::GetAttachedMeasurer()
			{
				return measurer;
			}

			WString GuiSubComponentMeasurer::MeasuringSource::GetMeasuringCategory()
			{
				return measuringCategory;
			}

			vint GuiSubComponentMeasurer::MeasuringSource::GetSubComponentCount()
			{
				return subComponents.Count();
			}

			WString GuiSubComponentMeasurer::MeasuringSource::GetSubComponentName(vint index)
			{
				return subComponents.Keys()[index];
			}

			GuiGraphicsComposition* GuiSubComponentMeasurer::MeasuringSource::GetSubComponentComposition(vint index)
			{
				return subComponents.Values().Get(index);
			}

			GuiGraphicsComposition* GuiSubComponentMeasurer::MeasuringSource::GetSubComponentComposition(const WString& name)
			{
				return subComponents[name];
			}

			GuiGraphicsComposition* GuiSubComponentMeasurer::MeasuringSource::GetMainComposition()
			{
				return mainComposition;
			}

			void GuiSubComponentMeasurer::MeasuringSource::SubComponentPreferredMinSizeUpdated()
			{
			}

/***********************************************************************
GuiSubComponentMeasurer
***********************************************************************/

			GuiSubComponentMeasurer::GuiSubComponentMeasurer()
			{
			}

			GuiSubComponentMeasurer::~GuiSubComponentMeasurer()
			{
			}

			bool GuiSubComponentMeasurer::AttachMeasuringSource(IMeasuringSource* value)
			{
				if(!value->GetAttachedMeasurer())
				{
					measuringSources.Add(value);
					value->AttachMeasurer(this);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool GuiSubComponentMeasurer::DetachMeasuringSource(IMeasuringSource* value)
			{
				if(value->GetAttachedMeasurer()==this)
				{
					value->DetachMeasurer(this);
					measuringSources.Remove(value);
					return true;
				}
				else
				{
					return false;
				}
			}

			void GuiSubComponentMeasurer::MeasureAndUpdate(const WString& measuringCategory, Direction direction)
			{
				List<IMeasuringSource*> sources;
				FOREACH(IMeasuringSource*, source, measuringSources)
				{
					if(source->GetMeasuringCategory()==measuringCategory)
					{
						sources.Add(source);
					}
				}

				Dictionary<WString, vint> sizes;
				FOREACH(IMeasuringSource*, source, sources)
				{
					vint count=source->GetSubComponentCount();
					for(vint i=0;i<count;i++)
					{
						WString name=source->GetSubComponentName(i);
						GuiGraphicsComposition* composition=source->GetSubComponentComposition(i);
						composition->SetPreferredMinSize(Size(0, 0));
						Size size=composition->GetPreferredBounds().GetSize();
						vint sizeComponent=direction==Horizontal?size.x:size.y;

						vint index=sizes.Keys().IndexOf(name);
						if(index==-1)
						{
							sizes.Add(name, sizeComponent);
						}
						else if(sizes.Values().Get(index)<sizeComponent)
						{
							sizes.Set(name, sizeComponent);
						}
					}
				}
				FOREACH(IMeasuringSource*, source, sources)
				{
					vint count=source->GetSubComponentCount();
					for(vint i=0;i<count;i++)
					{
						WString name=source->GetSubComponentName(i);
						GuiGraphicsComposition* composition=source->GetSubComponentComposition(i);
						Size size=composition->GetPreferredMinSize();
						(direction==Horizontal?size.x:size.y)=sizes[name];
						composition->SetPreferredMinSize(size);
						source->SubComponentPreferredMinSizeUpdated();
					}
				}
			}
		}
	}
}

/***********************************************************************
GraphicsComposition\GuiGraphicsCompositionBase.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			using namespace collections;
			using namespace controls;
			using namespace elements;

/***********************************************************************
GuiGraphicsComposition
***********************************************************************/

			void GuiGraphicsComposition::OnControlParentChanged(controls::GuiControl* control)
			{
				if(associatedControl && associatedControl!=control)
				{
					if(associatedControl->GetParent())
					{
						associatedControl->GetParent()->OnChildRemoved(associatedControl);
					}
					if(control)
					{
						control->OnChildInserted(associatedControl);
					}
				}
				else
				{
					for(vint i=0;i<children.Count();i++)
					{
						children[i]->OnControlParentChanged(control);
					}
				}
			}

			void GuiGraphicsComposition::OnChildInserted(GuiGraphicsComposition* child)
			{
				child->OnControlParentChanged(GetRelatedControl());
			}

			void GuiGraphicsComposition::OnChildRemoved(GuiGraphicsComposition* child)
			{
				child->OnControlParentChanged(0);
			}

			void GuiGraphicsComposition::OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)
			{
			}

			void GuiGraphicsComposition::OnRenderTargetChanged()
			{
				if(associatedControl)
				{
					associatedControl->OnRenderTargetChanged(renderTarget);
				}
			}

			GuiGraphicsComposition::GuiGraphicsComposition()
				:parent(0)
				,visible(true)
				,minSizeLimitation(NoLimit)
				,renderTarget(0)
				,associatedControl(0)
				,associatedHost(0)
				,associatedCursor(0)
				,associatedHitTestResult(INativeWindowListener::NoDecision)
			{
			}

			GuiGraphicsComposition::~GuiGraphicsComposition()
			{
				for(vint i=0;i<children.Count();i++)
				{
					delete children[i];
				}
			}

			GuiGraphicsComposition* GuiGraphicsComposition::GetParent()
			{
				return parent;
			}

			const GuiGraphicsComposition::CompositionList& GuiGraphicsComposition::Children()
			{
				return children;
			}

			bool GuiGraphicsComposition::AddChild(GuiGraphicsComposition* child)
			{
				return InsertChild(children.Count(), child);
			}

			bool GuiGraphicsComposition::InsertChild(vint index, GuiGraphicsComposition* child)
			{
				if(!child) return false;
				if(child->GetParent()) return false;
				children.Insert(index, child);
				child->parent=this;
				child->SetRenderTarget(renderTarget);
				OnChildInserted(child);
				child->OnParentChanged(0, child->parent);
				return true;
			}

			bool GuiGraphicsComposition::RemoveChild(GuiGraphicsComposition* child)
			{
				if(!child) return false;
				vint index=children.IndexOf(child);
				if(index==-1) return false;
				child->OnParentChanged(child->parent, 0);
				OnChildRemoved(child);
				child->SetRenderTarget(0);
				child->parent=0;
				GuiGraphicsHost* host=GetRelatedGraphicsHost();
				if(host)
				{
					host->DisconnectComposition(child);
				}
				children.RemoveAt(index);
				return true;
			}

			bool GuiGraphicsComposition::MoveChild(GuiGraphicsComposition* child, vint newIndex)
			{
				if(!child) return false;
				vint index=children.IndexOf(child);
				if(index==-1) return false;
				children.RemoveAt(index);
				children.Insert(newIndex, child);
				return true;
			}

			Ptr<IGuiGraphicsElement> GuiGraphicsComposition::GetOwnedElement()
			{
				return ownedElement;
			}

			void GuiGraphicsComposition::SetOwnedElement(Ptr<IGuiGraphicsElement> element)
			{
				if(ownedElement)
				{
					IGuiGraphicsRenderer* renderer=ownedElement->GetRenderer();
					if(renderer)
					{
						renderer->SetRenderTarget(0);
					}
				}
				ownedElement=element;
				if(ownedElement)
				{
					IGuiGraphicsRenderer* renderer=ownedElement->GetRenderer();
					if(renderer)
					{
						renderer->SetRenderTarget(renderTarget);
					}
				}
			}

			bool GuiGraphicsComposition::GetVisible()
			{
				return visible;
			}

			void GuiGraphicsComposition::SetVisible(bool value)
			{
				visible=value;
			}

			GuiGraphicsComposition::MinSizeLimitation GuiGraphicsComposition::GetMinSizeLimitation()
			{
				return minSizeLimitation;
			}

			void GuiGraphicsComposition::SetMinSizeLimitation(MinSizeLimitation value)
			{
				minSizeLimitation=value;
			}

			IGuiGraphicsRenderTarget* GuiGraphicsComposition::GetRenderTarget()
			{
				return renderTarget;
			}

			void GuiGraphicsComposition::SetRenderTarget(IGuiGraphicsRenderTarget* value)
			{
				renderTarget=value;
				if(ownedElement)
				{
					IGuiGraphicsRenderer* renderer=ownedElement->GetRenderer();
					if(renderer)
					{
						renderer->SetRenderTarget(renderTarget);
					}
				}
				for(vint i=0;i<children.Count();i++)
				{
					children[i]->SetRenderTarget(renderTarget);
				}
				OnRenderTargetChanged();
			}

			void GuiGraphicsComposition::Render(Size offset)
			{
				if(visible && renderTarget && !renderTarget->IsClipperCoverWholeTarget())
				{
					Rect bounds=GetBounds();
					bounds.x1+=margin.left;
					bounds.y1+=margin.top;
					bounds.x2-=margin.right;
					bounds.y2-=margin.bottom;

					if(bounds.x1<=bounds.x2 && bounds.y1<=bounds.y2)
					{
						bounds.x1+=offset.x;
						bounds.x2+=offset.x;
						bounds.y1+=offset.y;
						bounds.y2+=offset.y;

						if(ownedElement)
						{
							IGuiGraphicsRenderer* renderer=ownedElement->GetRenderer();
							if(renderer)
							{
								renderer->Render(bounds);
							}
						}
						if(children.Count()>0)
						{
							bounds.x1+=internalMargin.left;
							bounds.y1+=internalMargin.top;
							bounds.x2-=internalMargin.right;
							bounds.y2-=internalMargin.bottom;
							if(bounds.x1<=bounds.x2 && bounds.y1<=bounds.y2)
							{
								offset=bounds.GetSize();
								renderTarget->PushClipper(bounds);
								if(!renderTarget->IsClipperCoverWholeTarget())
								{
									for(vint i=0;i<children.Count();i++)
									{
										children[i]->Render(Size(bounds.x1, bounds.y1));
									}
								}
								renderTarget->PopClipper();
							}
						}
					}
				}
			}

			GuiGraphicsEventReceiver* GuiGraphicsComposition::GetEventReceiver()
			{
				if(!eventReceiver)
				{
					eventReceiver=new GuiGraphicsEventReceiver(this);
				}
				return eventReceiver.Obj();
			}

			bool GuiGraphicsComposition::HasEventReceiver()
			{
				return eventReceiver;
			}

			GuiGraphicsComposition* GuiGraphicsComposition::FindComposition(Point location)
			{
				if(!visible) return 0;
				Rect bounds=GetBounds();
				Rect relativeBounds=Rect(Point(0, 0), bounds.GetSize());
				if(relativeBounds.Contains(location))
				{
					Rect clientArea=GetClientArea();
					for(vint i=children.Count()-1;i>=0;i--)
					{
						GuiGraphicsComposition* child=children[i];
						Rect childBounds=child->GetBounds();
						vint offsetX=childBounds.x1+(clientArea.x1-bounds.x1);
						vint offsetY=childBounds.y1+(clientArea.y1-bounds.y1);
						Point newLocation=location-Size(offsetX, offsetY);
						GuiGraphicsComposition* childResult=child->FindComposition(newLocation);
						if(childResult)
						{
							return childResult;
						}
					}
					return this;
				}
				else
				{
					return 0;
				}
			}

			Rect GuiGraphicsComposition::GetGlobalBounds()
			{
				Rect bounds=GetBounds();
				GuiGraphicsComposition* composition=parent;
				while(composition)
				{
					Rect clientArea=composition->GetClientArea();
					Rect parentBounds=composition->GetBounds();
					bounds.x1+=clientArea.x1;
					bounds.x2+=clientArea.x1;
					bounds.y1+=clientArea.y1;
					bounds.y2+=clientArea.y1;
					composition=composition->parent;
				}
				return bounds;
			}

			controls::GuiControl* GuiGraphicsComposition::GetAssociatedControl()
			{
				return associatedControl;
			}

			void GuiGraphicsComposition::SetAssociatedControl(controls::GuiControl* control)
			{
				if(associatedControl)
				{
					for(vint i=0;i<children.Count();i++)
					{
						children[i]->OnControlParentChanged(0);
					}
				}
				associatedControl=control;
				if(associatedControl)
				{
					for(vint i=0;i<children.Count();i++)
					{
						children[i]->OnControlParentChanged(associatedControl);
					}
				}
			}

			GuiGraphicsHost* GuiGraphicsComposition::GetAssociatedHost()
			{
				return associatedHost;
			}

			void GuiGraphicsComposition::SetAssociatedHost(GuiGraphicsHost* host)
			{
				associatedHost=host;
			}

			INativeCursor* GuiGraphicsComposition::GetAssociatedCursor()
			{
				return associatedCursor;
			}

			void GuiGraphicsComposition::SetAssociatedCursor(INativeCursor* cursor)
			{
				associatedCursor=cursor;
			}

			INativeWindowListener::HitTestResult GuiGraphicsComposition::GetAssociatedHitTestResult()
			{
				return associatedHitTestResult;
			}

			void GuiGraphicsComposition::SetAssociatedHitTestResult(INativeWindowListener::HitTestResult value)
			{
				associatedHitTestResult=value;
			}

			controls::GuiControl* GuiGraphicsComposition::GetRelatedControl()
			{
				GuiGraphicsComposition* composition=this;
				while(composition)
				{
					if(composition->GetAssociatedControl())
					{
						return composition->GetAssociatedControl();
					}
					else
					{
						composition=composition->GetParent();
					}
				}
				return 0;
			}

			GuiGraphicsHost* GuiGraphicsComposition::GetRelatedGraphicsHost()
			{
				GuiGraphicsComposition* composition=this;
				while(composition)
				{
					if(composition->GetAssociatedHost())
					{
						return composition->GetAssociatedHost();
					}
					else
					{
						composition=composition->GetParent();
					}
				}
				return 0;
			}

			controls::GuiControlHost* GuiGraphicsComposition::GetRelatedControlHost()
			{
				GuiGraphicsComposition* composition=this;
				while(composition)
				{
					if(composition->GetAssociatedControl())
					{
						GuiControlHost* controlHost=dynamic_cast<GuiControlHost*>(composition->GetAssociatedControl());
						if(controlHost)
						{
							return controlHost;
						}
					}
					composition=composition->GetParent();
				}
				return 0;
			}

			INativeCursor* GuiGraphicsComposition::GetRelatedCursor()
			{
				GuiGraphicsComposition* composition=this;
				while(composition)
				{
					if(composition->GetAssociatedCursor())
					{
						return composition->GetAssociatedCursor();
					}
					else
					{
						composition=composition->GetParent();
					}
				}
				return 0;
			}

			Margin GuiGraphicsComposition::GetMargin()
			{
				return margin;
			}

			void GuiGraphicsComposition::SetMargin(Margin value)
			{
				margin=value;
			}

			Margin GuiGraphicsComposition::GetInternalMargin()
			{
				return internalMargin;
			}

			void GuiGraphicsComposition::SetInternalMargin(Margin value)
			{
				internalMargin=value;
			}

			Size GuiGraphicsComposition::GetPreferredMinSize()
			{
				return preferredMinSize;
			}

			void GuiGraphicsComposition::SetPreferredMinSize(Size value)
			{
				preferredMinSize=value;
			}

			Rect GuiGraphicsComposition::GetClientArea()
			{
				Rect bounds=GetBounds();
				bounds.x1+=margin.left+internalMargin.left;
				bounds.y1+=margin.top+internalMargin.top;
				bounds.x2-=margin.right+internalMargin.right;
				bounds.y2-=margin.bottom+internalMargin.bottom;
				return bounds;
			}

			void GuiGraphicsComposition::ForceCalculateSizeImmediately()
			{
				for(vint i=0;i<children.Count();i++)
				{
					children[i]->ForceCalculateSizeImmediately();
				}
			}

/***********************************************************************
GuiGraphicsSite
***********************************************************************/

			Rect GuiGraphicsSite::GetBoundsInternal(Rect expectedBounds)
			{
				Size minSize=GetMinPreferredClientSize();
				if(minSize.x<preferredMinSize.x) minSize.x=preferredMinSize.x;
				if(minSize.y<preferredMinSize.y) minSize.y=preferredMinSize.y;

				minSize.x+=margin.left+margin.right+internalMargin.left+internalMargin.right;
				minSize.y+=margin.top+margin.bottom+internalMargin.top+internalMargin.bottom;
				vint w=expectedBounds.Width();
				vint h=expectedBounds.Height();
				if(minSize.x<w) minSize.x=w;
				if(minSize.y<h) minSize.y=h;
				return Rect(expectedBounds.LeftTop(), minSize);
			}

			GuiGraphicsSite::GuiGraphicsSite()
			{
			}

			GuiGraphicsSite::~GuiGraphicsSite()
			{
			}

			bool GuiGraphicsSite::IsSizeAffectParent()
			{
				return true;
			}

			Size GuiGraphicsSite::GetMinPreferredClientSize()
			{
				Size minSize;
				if(minSizeLimitation!=GuiGraphicsComposition::NoLimit)
				{
					if(ownedElement)
					{
						IGuiGraphicsRenderer* renderer=ownedElement->GetRenderer();
						if(renderer)
						{
							minSize=renderer->GetMinSize();
						}
					}
				}
				if(minSizeLimitation==GuiGraphicsComposition::LimitToElementAndChildren)
				{
					vint childCount=Children().Count();
					for(vint i=0;i<childCount;i++)
					{
						GuiGraphicsComposition* child=children[i];
						if(child->IsSizeAffectParent())
						{
							Rect childBounds=child->GetPreferredBounds();
							if(minSize.x<childBounds.x2) minSize.x=childBounds.x2;
							if(minSize.y<childBounds.y2) minSize.y=childBounds.y2;
						}
					}
				}
				return minSize;
			}

			Rect GuiGraphicsSite::GetPreferredBounds()
			{
				return GetBoundsInternal(Rect(Point(0, 0), GetMinPreferredClientSize()));
			}
		}
	}
}

/***********************************************************************
GraphicsComposition\GuiGraphicsEventReceiver.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Event Receiver
***********************************************************************/

			GuiGraphicsEventReceiver::GuiGraphicsEventReceiver(GuiGraphicsComposition* _sender)
				:sender(_sender)
				,leftButtonDown(_sender)
				,leftButtonUp(_sender)
				,leftButtonDoubleClick(_sender)
				,middleButtonDown(_sender)
				,middleButtonUp(_sender)
				,middleButtonDoubleClick(_sender)
				,rightButtonDown(_sender)
				,rightButtonUp(_sender)
				,rightButtonDoubleClick(_sender)
				,horizontalWheel(_sender)
				,verticalWheel(_sender)
				,mouseMove(_sender)
				,mouseEnter(_sender)
				,mouseLeave(_sender)
				,previewKey(_sender)
				,keyDown(_sender)
				,keyUp(_sender)
				,systemKeyDown(_sender)
				,systemKeyUp(_sender)
				,previewCharInput(_sender)
				,charInput(_sender)
				,gotFocus(_sender)
				,lostFocus(_sender)
				,caretNotify(_sender)
			{
			}

			GuiGraphicsEventReceiver::~GuiGraphicsEventReceiver()
			{
			}

			GuiGraphicsComposition* GuiGraphicsEventReceiver::GetAssociatedComposition()
			{
				return sender;
			}
		}
	}
}

/***********************************************************************
GraphicsComposition\GuiGraphicsSpecializedComposition.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
GuiSideAlignedComposition
***********************************************************************/

			GuiSideAlignedComposition::GuiSideAlignedComposition()
				:direction(Top)
				,maxLength(10)
				,maxRatio(1.0)
			{
			}

			GuiSideAlignedComposition::~GuiSideAlignedComposition()
			{
			}

			GuiSideAlignedComposition::Direction GuiSideAlignedComposition::GetDirection()
			{
				return direction;
			}

			void GuiSideAlignedComposition::SetDirection(Direction value)
			{
				direction=value;
			}

			vint GuiSideAlignedComposition::GetMaxLength()
			{
				return maxLength;
			}

			void GuiSideAlignedComposition::SetMaxLength(vint value)
			{
				if(value<0) value=0;
				maxLength=value;
			}

			double GuiSideAlignedComposition::GetMaxRatio()
			{
				return maxRatio;
			}

			void GuiSideAlignedComposition::SetMaxRatio(double value)
			{
				maxRatio=
					value<0?0:
					value>1?1:
					value;
			}

			bool GuiSideAlignedComposition::IsSizeAffectParent()
			{
				return false;
			}

			Rect GuiSideAlignedComposition::GetBounds()
			{
				GuiGraphicsComposition* parent=GetParent();
				if(parent)
				{
					Rect bounds=parent->GetBounds();
					vint w=(vint)(bounds.Width()*maxRatio);
					vint h=(vint)(bounds.Height()*maxRatio);
					if(w>maxLength) w=maxLength;
					if(h>maxLength) h=maxLength;
					switch(direction)
					{
					case Left:
						{
							bounds.x2=bounds.x1+w;
						}
						break;
					case Top:
						{
							bounds.y2=bounds.y1+h;
						}
						break;
					case Right:
						{
							bounds.x1=bounds.x2-w;
						}
						break;
					case Bottom:
						{
							bounds.y1=bounds.y2-h;
						}
						break;
					}
					return bounds;
				}
				return Rect();
			}

/***********************************************************************
GuiPartialViewComposition
***********************************************************************/

			GuiPartialViewComposition::GuiPartialViewComposition()
				:wRatio(0.0)
				,wPageSize(1.0)
				,hRatio(0.0)
				,hPageSize(1.0)
			{
			}

			GuiPartialViewComposition::~GuiPartialViewComposition()
			{
			}

			double GuiPartialViewComposition::GetWidthRatio()
			{
				return wRatio;
			}

			double GuiPartialViewComposition::GetWidthPageSize()
			{
				return wPageSize;
			}

			double GuiPartialViewComposition::GetHeightRatio()
			{
				return hRatio;
			}

			double GuiPartialViewComposition::GetHeightPageSize()
			{
				return hPageSize;
			}

			void GuiPartialViewComposition::SetWidthRatio(double value)
			{
				wRatio=value;
			}

			void GuiPartialViewComposition::SetWidthPageSize(double value)
			{
				wPageSize=value;
			}

			void GuiPartialViewComposition::SetHeightRatio(double value)
			{
				hRatio=value;
			}

			void GuiPartialViewComposition::SetHeightPageSize(double value)
			{
				hPageSize=value;
			}

			bool GuiPartialViewComposition::IsSizeAffectParent()
			{
				return false;
			}

			Rect GuiPartialViewComposition::GetBounds()
			{
				GuiGraphicsComposition* parent=GetParent();
				if(parent)
				{
					Rect bounds=parent->GetBounds();
					vint w=bounds.Width();
					vint h=bounds.Height();
					vint pw=(vint)(wPageSize*w);
					vint ph=(vint)(hPageSize*h);

					vint ow=preferredMinSize.x-pw;
					if(ow<0) ow=0;
					vint oh=preferredMinSize.y-ph;
					if(oh<0) oh=0;

					w-=ow;
					h-=oh;
					pw+=ow;
					ph+=oh;

					return Rect(Point((vint)(wRatio*w), (vint)(hRatio*h)), Size(pw, ph));
				}
				return Rect();
			}
		}
	}
}

/***********************************************************************
GraphicsComposition\GuiGraphicsStackComposition.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
GuiStackComposition
***********************************************************************/

			void GuiStackComposition::UpdateStackItemBounds()
			{
				if(stackItemBounds.Count()!=stackItems.Count())
				{
					stackItemBounds.Resize(stackItems.Count());
				}

				stackItemTotalSize=Size(0, 0);
				vint x=extraMargin.left?extraMargin.left:0;
				vint y=extraMargin.top?extraMargin.top:0;
				switch(direction)
				{
				case GuiStackComposition::Horizontal:
					{
						for(vint i=0;i<stackItems.Count();i++)
						{
							Size itemSize=stackItems[i]->GetMinSize();
							if(i>0) stackItemTotalSize.x+=padding;
							if(stackItemTotalSize.y<itemSize.y) stackItemTotalSize.y=itemSize.y;
							stackItemBounds[i]=Rect(Point(stackItemTotalSize.x+x, y), Size(itemSize.x, 0));
							stackItemTotalSize.x+=itemSize.x;
						}
					}
					break;
				case GuiStackComposition::Vertical:
					{
						for(vint i=0;i<stackItems.Count();i++)
						{
							Size itemSize=stackItems[i]->GetMinSize();
							if(i>0) stackItemTotalSize.y+=padding;
							if(stackItemTotalSize.x<itemSize.x) stackItemTotalSize.x=itemSize.x;
							stackItemBounds[i]=Rect(Point(x, stackItemTotalSize.y+y), Size(0, itemSize.y));
							stackItemTotalSize.y+=itemSize.y;
						}
					}
					break;
				}

				FixStackItemSizes();
			}

			void GuiStackComposition::FixStackItemSizes()
			{
				switch(direction)
				{
				case Horizontal:
					{
						vint y=0;
						if(extraMargin.top>0) y+=extraMargin.top;
						if(extraMargin.bottom>0) y+=extraMargin.bottom;

						for(vint i=0;i<stackItemBounds.Count();i++)
						{
							stackItemBounds[i].y2=stackItemBounds[i].y1+previousBounds.Height()-y;
						}
					}
					break;
				case Vertical:
					{
						vint x=0;
						if(extraMargin.left>0) x+=extraMargin.left;
						if(extraMargin.right>0) x+=extraMargin.right;

						for(vint i=0;i<stackItemBounds.Count();i++)
						{
							stackItemBounds[i].x2=stackItemBounds[i].x1+previousBounds.Width()-x;
						}
					}
					break;
				}
			}

			void GuiStackComposition::OnChildInserted(GuiGraphicsComposition* child)
			{
				GuiBoundsComposition::OnChildInserted(child);
				GuiStackItemComposition* item=dynamic_cast<GuiStackItemComposition*>(child);
				if(item && !stackItems.Contains(item))
				{
					stackItems.Add(item);
				}
			}

			void GuiStackComposition::OnChildRemoved(GuiGraphicsComposition* child)
			{
				GuiBoundsComposition::OnChildRemoved(child);
				GuiStackItemComposition* item=dynamic_cast<GuiStackItemComposition*>(child);
				if(item)
				{
					stackItems.Remove(item);
				}
			}

			GuiStackComposition::GuiStackComposition()
				:direction(Horizontal)
				,padding(0)
			{
			}

			GuiStackComposition::~GuiStackComposition()
			{
			}

			const GuiStackComposition::ItemCompositionList& GuiStackComposition::GetStackItems()
			{
				return stackItems;
			}

			bool GuiStackComposition::InsertStackItem(vint index, GuiStackItemComposition* item)
			{
				index=stackItems.Insert(index, item);
				if(!AddChild(item))
				{
					stackItems.RemoveAt(index);
					return false;
				}
				else
				{
					return true;
				}
			}

			GuiStackComposition::Direction GuiStackComposition::GetDirection()
			{
				return direction;
			}

			void GuiStackComposition::SetDirection(Direction value)
			{
				direction=value;
			}

			vint GuiStackComposition::GetPadding()
			{
				return padding;
			}

			void GuiStackComposition::SetPadding(vint value)
			{
				padding=value;
			}
			
			Size GuiStackComposition::GetMinPreferredClientSize()
			{
				Size minSize=GuiBoundsComposition::GetMinPreferredClientSize();
				UpdateStackItemBounds();
				if(GetMinSizeLimitation()==GuiGraphicsComposition::LimitToElementAndChildren)
				{
					if(minSize.x<stackItemTotalSize.x) minSize.x=stackItemTotalSize.x;
					if(minSize.y<stackItemTotalSize.y) minSize.y=stackItemTotalSize.y;
				}
				vint x=0;
				vint y=0;
				if(extraMargin.left>0) x+=extraMargin.left;
				if(extraMargin.right>0) x+=extraMargin.right;
				if(extraMargin.top>0) y+=extraMargin.top;
				if(extraMargin.bottom>0) y+=extraMargin.bottom;
				return minSize+Size(x, y);
			}

			Rect GuiStackComposition::GetBounds()
			{
				Rect bounds=GuiBoundsComposition::GetBounds();
				previousBounds=bounds;
				FixStackItemSizes();
				return bounds;
			}

			Margin GuiStackComposition::GetExtraMargin()
			{
				return extraMargin;
			}

			void GuiStackComposition::SetExtraMargin(Margin value)
			{
				extraMargin=value;
			}

			bool GuiStackComposition::IsStackItemClipped()
			{
				Rect clientArea=GetClientArea();
				for(vint i=0;i<stackItems.Count();i++)
				{
					Rect stackItemBounds=stackItems[i]->GetBounds();
					switch(direction)
					{
					case Horizontal:
						{
							if(stackItemBounds.Left()<0 || stackItemBounds.Right()>=clientArea.Width())
							{
								return true;
							}
						}
						break;
					case Vertical:
						{
							if(stackItemBounds.Top()<0 || stackItemBounds.Bottom()>=clientArea.Height())
							{
								return true;
							}
						}
						break;
					}
				}
				return false;
			}

/***********************************************************************
GuiStackItemComposition
***********************************************************************/

			void GuiStackItemComposition::OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)
			{
				GuiGraphicsSite::OnParentChanged(oldParent, newParent);
				stackParent=newParent==0?0:dynamic_cast<GuiStackComposition*>(newParent);
			}

			Size GuiStackItemComposition::GetMinSize()
			{
				return GetBoundsInternal(bounds).GetSize();
			}

			GuiStackItemComposition::GuiStackItemComposition()
				:stackParent(0)
			{
				SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
			}

			GuiStackItemComposition::~GuiStackItemComposition()
			{
			}

			bool GuiStackItemComposition::IsSizeAffectParent()
			{
				return false;
			}

			Rect GuiStackItemComposition::GetBounds()
			{
				Rect result=bounds;
				if(stackParent)
				{
					vint index=stackParent->stackItems.IndexOf(this);
					if(index!=-1)
					{
						if(stackParent->stackItemBounds.Count()!=stackParent->stackItems.Count())
						{
							stackParent->UpdateStackItemBounds();
						}
						result=stackParent->stackItemBounds[index];
					}
				}
				result.x1-=extraMargin.left;
				result.y1-=extraMargin.top;
				result.x2+=extraMargin.right;
				result.y2+=extraMargin.bottom;
				return result;
			}

			void GuiStackItemComposition::SetBounds(Rect value)
			{
				bounds=value;
			}

			Margin GuiStackItemComposition::GetExtraMargin()
			{
				return extraMargin;
			}

			void GuiStackItemComposition::SetExtraMargin(Margin value)
			{
				extraMargin=value;
			}
		}
	}
}

/***********************************************************************
GraphicsComposition\GuiGraphicsTableComposition.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			using namespace collections;
			using namespace controls;
			using namespace elements;

/***********************************************************************
GuiTableComposition
***********************************************************************/

			namespace update_cell_bounds_helpers
			{
				vint First(vint a, vint b)
				{
					return a;
				}

				vint Second(vint a, vint b)
				{
					return b;
				}

				vint X(Size s)
				{
					return s.x;
				}

				vint Y(Size s)
				{
					return s.y;
				}

				vint RL(GuiCellComposition* cell)
				{
					return cell->GetRow();
				}

				vint CL(GuiCellComposition* cell)
				{
					return cell->GetColumn();
				}

				vint RS(GuiCellComposition* cell)
				{
					return cell->GetRowSpan();
				}

				vint CS(GuiCellComposition* cell)
				{
					return cell->GetColumnSpan();
				}
			}
			using namespace update_cell_bounds_helpers;

			vint GuiTableComposition::GetSiteIndex(vint _rows, vint _columns, vint _row, vint _column)
			{
				return _row*_columns+_column;
			}

			void GuiTableComposition::SetSitedCell(vint _row, vint _column, GuiCellComposition* cell)
			{
				cellCompositions[GetSiteIndex(rows, columns, _row, _column)]=cell;
			}

			void GuiTableComposition::UpdateCellBoundsInternal(
				collections::Array<vint>& dimSizes,
				vint& dimSize,
				vint& dimSizeWithPercentage,
				collections::Array<GuiCellOption>& dimOptions,
				vint GuiTableComposition::* dim1,
				vint GuiTableComposition::* dim2,
				vint (*getSize)(Size),
				vint (*getLocation)(GuiCellComposition*),
				vint (*getSpan)(GuiCellComposition*),
				vint (*getRow)(vint, vint),
				vint (*getCol)(vint, vint),
				vint maxPass
				)
			{
				for(vint pass=0;pass<maxPass;pass++)
				{
					for(vint i=0;i<this->*dim1;i++)
					{
						GuiCellOption option=dimOptions[i];
						if(pass==0)
						{
							dimSizes[i]=0;
						}
						switch(option.composeType)
						{
						case GuiCellOption::Absolute:
							{
								dimSizes[i]=option.absolute;
							}
							break;
						case GuiCellOption::MinSize:
							{
								for(vint j=0;j<this->*dim2;j++)
								{
									GuiCellComposition* cell=GetSitedCell(getRow(i, j), getCol(i, j));
									if(cell)
									{
										bool accept=false;
										if(pass==0)
										{
											accept=getSpan(cell)==1;
										}
										else
										{
											accept=getLocation(cell)+getSpan(cell)==i+1;
										}
										if(accept)
										{
											vint size=getSize(cell->GetPreferredBounds().GetSize());
											vint span=getSpan(cell);
											for(vint k=1;k<span;k++)
											{
												size-=dimSizes[i-k]+cellPadding;
											}
											if(dimSizes[i]<size)
											{
												dimSizes[i]=size;
											}
										}
									}
								}
							}
							break;
						}
					}
				}
				
				bool percentageExists=false;
				for(vint i=0;i<this->*dim1;i++)
				{
					GuiCellOption option=dimOptions[i];
					if(option.composeType==GuiCellOption::Percentage)
					{
						if(0.001<option.percentage)
						{
							percentageExists=true;
						}
					}
				}

				if(percentageExists)
				{
					for(vint i=0;i<this->*dim1;i++)
					{
						GuiCellOption option=dimOptions[i];
						if(option.composeType==GuiCellOption::Percentage)
						{
							if(0.001<option.percentage)
							{
								for(vint j=0;j<this->*dim2;j++)
								{
									GuiCellComposition* cell=GetSitedCell(getRow(i, j), getCol(i, j));
									if(cell)
									{
										vint size=getSize(cell->GetPreferredBounds().GetSize());
										vint start=getLocation(cell);
										vint span=getSpan(cell);
										size-=(span-1)*cellPadding;
										double totalPercentage=0;

										for(vint k=start;k<start+span;k++)
										{
											if(dimOptions[k].composeType==GuiCellOption::Percentage)
											{
												if(0.001<dimOptions[k].percentage)
												{
													totalPercentage+=dimOptions[k].percentage;
												}
											}
											else
											{
												size-=dimSizes[k];
											}
										}

										size=(vint)ceil(size*option.percentage/totalPercentage);
										if(dimSizes[i]<size)
										{
											dimSizes[i]=size;
										}
									}
								}
							}
						}
					}

					vint percentageTotalSize=0;
					for(vint i=0;i<this->*dim1;i++)
					{
						GuiCellOption option=dimOptions[i];
						if(option.composeType==GuiCellOption::Percentage)
						{
							if(0.001<option.percentage)
							{
								vint size=(vint)ceil(dimSizes[i]/option.percentage);
								if(percentageTotalSize<size)
								{
									percentageTotalSize=size;
								}
							}
						}
					}

					double totalPercentage=0;
					for(vint i=0;i<this->*dim1;i++)
					{
						GuiCellOption option=dimOptions[i];
						if(option.composeType==GuiCellOption::Percentage)
						{
							if(0.001<option.percentage)
							{
								totalPercentage+=option.percentage;
							}
						}
					}
					
					for(vint i=0;i<this->*dim1;i++)
					{
						GuiCellOption option=dimOptions[i];
						if(option.composeType==GuiCellOption::Percentage)
						{
							if(0.001<option.percentage)
							{
								vint size=(vint)ceil(percentageTotalSize*option.percentage/totalPercentage);
								if(dimSizes[i]<size)
								{
									dimSizes[i]=size;
								}
							}
						}
					}
				}

				for(vint i=0;i<this->*dim1;i++)
				{
					if(dimOptions[i].composeType!=GuiCellOption::Percentage)
					{
						dimSize+=dimSizes[i];
					}
					dimSizeWithPercentage+=dimSizes[i];
				}
			}

			void GuiTableComposition::UpdateCellBoundsPercentages(
				collections::Array<vint>& dimSizes,
				vint dimSize,
				vint maxDimSize,
				collections::Array<GuiCellOption>& dimOptions
				)
			{
				if(maxDimSize>dimSize)
				{
					double totalPercentage=0;
					vint percentageCount=0;
					for(vint i=0;i<dimOptions.Count();i++)
					{
						GuiCellOption option=dimOptions[i];
						if(option.composeType==GuiCellOption::Percentage)
						{
							totalPercentage+=option.percentage;
							percentageCount++;
						}
					}
					if(percentageCount>0 && totalPercentage>0.001)
					{
						for(vint i=0;i<dimOptions.Count();i++)
						{
							GuiCellOption option=dimOptions[i];
							if(option.composeType==GuiCellOption::Percentage)
							{
								dimSizes[i]=(vint)((maxDimSize-dimSize)*option.percentage/totalPercentage);
							}
						}
					}
				}
			}

			vint GuiTableComposition::UpdateCellBoundsOffsets(
				collections::Array<vint>& offsets,
				collections::Array<vint>& sizes,
				vint start,
				vint max
				)
			{
				offsets[0]=start;
				for(vint i=1;i<offsets.Count();i++)
				{
					start+=cellPadding+sizes[i-1];
					offsets[i]=start;
				}

				vint last=offsets.Count()-1;
				vint right=offsets[last]+sizes[last];
				return max-right;
			}

			void GuiTableComposition::UpdateCellBoundsInternal()
			{
				Array<vint> rowOffsets, columnOffsets, rowSizes, columnSizes;
				rowOffsets.Resize(rows);
				rowSizes.Resize(rows);
				columnOffsets.Resize(columns);
				columnSizes.Resize(columns);
				{
					vint rowTotal=(rows-1)*cellPadding;
					vint columnTotal=(columns-1)*cellPadding;
					vint rowTotalWithPercentage=rowTotal;
					vint columnTotalWithPercentage=columnTotal;

					UpdateCellBoundsInternal(
						rowSizes,
						rowTotal,
						rowTotalWithPercentage,
						rowOptions,
						&GuiTableComposition::rows,
						&GuiTableComposition::columns,
						&Y,
						&RL,
						&RS,
						&First,
						&Second,
						1
						);
					UpdateCellBoundsInternal(
						columnSizes,
						columnTotal,
						columnTotalWithPercentage,
						columnOptions,
						&GuiTableComposition::columns,
						&GuiTableComposition::rows,
						&X,
						&CL,
						&CS,
						&Second,
						&First,
						1
						);

					Rect area=GetCellArea();
					UpdateCellBoundsPercentages(rowSizes, rowTotal, area.Height(), rowOptions);
					UpdateCellBoundsPercentages(columnSizes, columnTotal, area.Width(), columnOptions);
					rowExtending=UpdateCellBoundsOffsets(rowOffsets, rowSizes, cellPadding, cellPadding+area.Height());
					columnExtending=UpdateCellBoundsOffsets(columnOffsets, columnSizes, cellPadding, cellPadding+area.Width());

					for(vint i=0;i<rows;i++)
					{
						for(vint j=0;j<columns;j++)
						{
							vint index=GetSiteIndex(rows, columns, i, j);
							cellBounds[index]=Rect(Point(columnOffsets[j], rowOffsets[i]), Size(columnSizes[j], rowSizes[i]));
						}
					}
				}
			}

			void GuiTableComposition::UpdateTableContentMinSize()
			{
				Array<vint> rowSizes, columnSizes;
				rowSizes.Resize(rows);
				columnSizes.Resize(columns);
				{
					vint rowTotal=(rows+1)*cellPadding;
					vint columnTotal=(columns+1)*cellPadding;
					vint rowTotalWithPercentage=rowTotal;
					vint columnTotalWithPercentage=columnTotal;

					UpdateCellBoundsInternal(
						rowSizes,
						rowTotal,
						rowTotalWithPercentage,
						rowOptions,
						&GuiTableComposition::rows,
						&GuiTableComposition::columns,
						&Y,
						&RL,
						&RS,
						&First,
						&Second,
						2
						);
					UpdateCellBoundsInternal(
						columnSizes,
						columnTotal,
						columnTotalWithPercentage,
						columnOptions,
						&GuiTableComposition::columns,
						&GuiTableComposition::rows,
						&X,
						&CL,
						&CS,
						&Second,
						&First,
						2
						);
					tableContentMinSize=Size(columnTotalWithPercentage, rowTotalWithPercentage);
				}
				if(previousContentMinSize!=tableContentMinSize)
				{
					previousContentMinSize=tableContentMinSize;
					UpdateCellBoundsInternal();
				}
			}

			void GuiTableComposition::OnRenderTargetChanged()
			{
				if(GetRenderTarget())
				{
					UpdateTableContentMinSize();
				}
			}

			GuiTableComposition::GuiTableComposition()
				:rows(0)
				,columns(0)
				,cellPadding(0)
				,rowExtending(0)
				,columnExtending(0)
			{
				SetRowsAndColumns(1, 1);
			}

			GuiTableComposition::~GuiTableComposition()
			{
			}

			vint GuiTableComposition::GetRows()
			{
				return rows;
			}

			vint GuiTableComposition::GetColumns()
			{
				return columns;
			}

			bool GuiTableComposition::SetRowsAndColumns(vint _rows, vint _columns)
			{
				if(_rows<=0 || _columns<=0) return false;
				rowOptions.Resize(_rows);
				columnOptions.Resize(_columns);
				cellCompositions.Resize(_rows*_columns);
				cellBounds.Resize(_rows*_columns);
				for(vint i=0;i<_rows*_columns;i++)
				{
					cellCompositions[i]=0;
					cellBounds[i]=Rect();
				}
				rows=_rows;
				columns=_columns;
				vint childCount=Children().Count();
				for(vint i=0;i<childCount;i++)
				{
					GuiCellComposition* cell=dynamic_cast<GuiCellComposition*>(Children().Get(i));
					if(cell)
					{
						cell->OnTableRowsAndColumnsChanged();
					}
				}
				UpdateCellBounds();
				return true;
			}

			GuiCellComposition* GuiTableComposition::GetSitedCell(vint _row, vint _column)
			{
				return cellCompositions[GetSiteIndex(rows, columns, _row, _column)];
			}

			GuiCellOption GuiTableComposition::GetRowOption(vint _row)
			{
				return rowOptions[_row];
			}

			void GuiTableComposition::SetRowOption(vint _row, GuiCellOption option)
			{
				rowOptions[_row]=option;
			}

			GuiCellOption GuiTableComposition::GetColumnOption(vint _column)
			{
				return columnOptions[_column];
			}

			void GuiTableComposition::SetColumnOption(vint _column, GuiCellOption option)
			{
				columnOptions[_column]=option;
			}

			vint GuiTableComposition::GetCellPadding()
			{
				return cellPadding;
			}

			void GuiTableComposition::SetCellPadding(vint value)
			{
				if(value<0) value=0;
				cellPadding=value;
			}

			Rect GuiTableComposition::GetCellArea()
			{
				Rect bounds(Point(0, 0), GuiBoundsComposition::GetBounds().GetSize());
				bounds.x1+=margin.left+internalMargin.left+cellPadding;
				bounds.y1+=margin.top+internalMargin.top+cellPadding;
				bounds.x2-=margin.right+internalMargin.right+cellPadding;
				bounds.y2-=margin.bottom+internalMargin.bottom+cellPadding;
				if(bounds.x2<bounds.x1) bounds.x2=bounds.x1;
				if(bounds.y2<bounds.y1) bounds.y2=bounds.y1;
				return bounds;
			}

			void GuiTableComposition::UpdateCellBounds()
			{
				UpdateCellBoundsInternal();
				UpdateTableContentMinSize();
			}

			void GuiTableComposition::ForceCalculateSizeImmediately()
			{
				GuiBoundsComposition::ForceCalculateSizeImmediately();
				UpdateCellBounds();
			}

			Size GuiTableComposition::GetMinPreferredClientSize()
			{
				return tableContentMinSize;
			}

			Rect GuiTableComposition::GetBounds()
			{
				Rect result;
				if(!IsAlignedToParent() && GetMinSizeLimitation()!=GuiGraphicsComposition::NoLimit)
				{
					result=Rect(compositionBounds.LeftTop(), compositionBounds.GetSize()-Size(columnExtending, rowExtending));
				}
				else
				{
					result=GuiBoundsComposition::GetBounds();
				}

				bool cellMinSizeModified=false;
				SortedList<GuiCellComposition*> cells;
				FOREACH(GuiCellComposition*, cell, cellCompositions)
				{
					if(cell && !cells.Contains(cell))
					{
						cells.Add(cell);
						Size newSize=cell->GetPreferredBounds().GetSize();
						if(cell->lastPreferredSize!=newSize)
						{
							cell->lastPreferredSize=newSize;
							cellMinSizeModified=true;
						}
					}
				}

				if(previousBounds!=result || cellMinSizeModified)
				{
					previousBounds=result;
					UpdateCellBounds();
				}
				return result;
			}

/***********************************************************************
GuiCellComposition
***********************************************************************/

			void GuiCellComposition::ClearSitedCells(GuiTableComposition* table)
			{
				if(row!=-1 && column!=-1)
				{
					for(vint r=0;r<rowSpan;r++)
					{
						for(vint c=0;c<columnSpan;c++)
						{
							table->SetSitedCell(row+r, column+c, 0);
						}
					}
				}
			}

			void GuiCellComposition::SetSitedCells(GuiTableComposition* table)
			{
				for(vint r=0;r<rowSpan;r++)
				{
					for(vint c=0;c<columnSpan;c++)
					{
						table->SetSitedCell(row+r, column+c, this);
					}
				}
			}

			void GuiCellComposition::ResetSiteInternal()
			{
				row=-1;
				column=-1;
				rowSpan=1;
				columnSpan=1;
			}

			bool GuiCellComposition::SetSiteInternal(vint _row, vint _column, vint _rowSpan, vint _columnSpan)
			{
				if(!tableParent) return false;
				if(_row<0 || _row>=tableParent->rows || _column<0 || _column>=tableParent->columns) return false;
				if(_rowSpan<1 || _row+_rowSpan>tableParent->rows || _columnSpan<1 || _column+_columnSpan>tableParent->columns) return false;

				for(vint r=0;r<_rowSpan;r++)
				{
					for(vint c=0;c<_columnSpan;c++)
					{
						GuiCellComposition* cell=tableParent->GetSitedCell(_row+r, _column+c);
						if(cell && cell!=this)
						{
							return false;
						}
					}
				}
				ClearSitedCells(tableParent);
				row=_row;
				column=_column;
				rowSpan=_rowSpan;
				columnSpan=_columnSpan;
				SetSitedCells(tableParent);
				return true;
			}

			void GuiCellComposition::OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)
			{
				if(tableParent)
				{
					ClearSitedCells(tableParent);
				}
				tableParent=dynamic_cast<GuiTableComposition*>(newParent);
				if(!tableParent || !SetSiteInternal(row, column, rowSpan, columnSpan))
				{
					ResetSiteInternal();
				}
				if(tableParent)
				{
					tableParent->UpdateCellBounds();
				}
			}

			void GuiCellComposition::OnTableRowsAndColumnsChanged()
			{
				if(!SetSiteInternal(row, column, rowSpan, columnSpan))
				{
					ResetSiteInternal();
				}
			}

			GuiCellComposition::GuiCellComposition()
				:row(-1)
				,column(-1)
				,rowSpan(1)
				,columnSpan(1)
				,tableParent(0)
			{
				SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
			}

			GuiCellComposition::~GuiCellComposition()
			{
			}

			GuiTableComposition* GuiCellComposition::GetTableParent()
			{
				return tableParent;
			}

			vint GuiCellComposition::GetRow()
			{
				return row;
			}

			vint GuiCellComposition::GetRowSpan()
			{
				return rowSpan;
			}

			vint GuiCellComposition::GetColumn()
			{
				return column;
			}

			vint GuiCellComposition::GetColumnSpan()
			{
				return columnSpan;
			}

			bool GuiCellComposition::SetSite(vint _row, vint _column, vint _rowSpan, vint _columnSpan)
			{
				if(SetSiteInternal(_row, _column, _rowSpan, _columnSpan))
				{
					tableParent->UpdateCellBounds();
					return true;
				}
				else
				{
					return false;
				}
			}

			Rect GuiCellComposition::GetBounds()
			{
				if(tableParent && row!=-1 && column!=-1)
				{
					Rect bounds1, bounds2;
					{
						vint index=tableParent->GetSiteIndex(tableParent->rows, tableParent->columns, row, column);
						bounds1=tableParent->cellBounds[index];
					}
					{
						vint index=tableParent->GetSiteIndex(tableParent->rows, tableParent->columns, row+rowSpan-1, column+columnSpan-1);
						bounds2=tableParent->cellBounds[index];
						if(tableParent->GetMinSizeLimitation()==GuiGraphicsComposition::NoLimit)
						{
							if(row+rowSpan==tableParent->rows)
							{
								bounds2.y2+=tableParent->rowExtending;
							}
							if(column+columnSpan==tableParent->columns)
							{
								bounds2.x2+=tableParent->columnExtending;
							}
						}
					}
					return Rect(bounds1.x1, bounds1.y1, bounds2.x2, bounds2.y2);
				}
				else
				{
					return Rect();
				}
			}
		}
	}
}

/***********************************************************************
GraphicsElement\GuiGraphicsElement.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			using namespace collections;

/***********************************************************************
GuiSolidBorderElement
***********************************************************************/

			GuiSolidBorderElement::GuiSolidBorderElement()
				:color(0, 0, 0)
				,shape(ElementShape::Rectangle)
			{
			}

			GuiSolidBorderElement::~GuiSolidBorderElement()
			{
				renderer->Finalize();
			}

			Color GuiSolidBorderElement::GetColor()
			{
				return color;
			}

			void GuiSolidBorderElement::SetColor(Color value)
			{
				if(color!=value)
				{
					color=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}
			
			ElementShape::Type GuiSolidBorderElement::GetShape()
			{
				return shape;
			}

			void GuiSolidBorderElement::SetShape(ElementShape::Type value)
			{
				shape=value;
			}

/***********************************************************************
GuiRoundBorderElement
***********************************************************************/

			GuiRoundBorderElement::GuiRoundBorderElement()
				:color(0, 0, 0)
				,radius(10)
			{
			}

			GuiRoundBorderElement::~GuiRoundBorderElement()
			{
				renderer->Finalize();
			}

			Color GuiRoundBorderElement::GetColor()
			{
				return color;
			}

			void GuiRoundBorderElement::SetColor(Color value)
			{
				if(color!=value)
				{
					color=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			vint GuiRoundBorderElement::GetRadius()
			{
				return radius;
			}

			void GuiRoundBorderElement::SetRadius(vint value)
			{
				if(radius!=value)
				{
					radius=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

/***********************************************************************
Gui3DBorderElement
***********************************************************************/

			Gui3DBorderElement::Gui3DBorderElement()
			{
			}

			Gui3DBorderElement::~Gui3DBorderElement()
			{
				renderer->Finalize();
			}

			Color Gui3DBorderElement::GetColor1()
			{
				return color1;
			}

			Color Gui3DBorderElement::GetColor2()
			{
				return color2;
			}

			void Gui3DBorderElement::SetColors(Color value1, Color value2)
			{
				if(color1!=value1 || color2!=value2)
				{
					color1=value1;
					color2=value2;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

/***********************************************************************
Gui3DSplitterElement
***********************************************************************/

			Gui3DSplitterElement::Gui3DSplitterElement()
				:direction(Horizontal)
			{
			}

			Gui3DSplitterElement::~Gui3DSplitterElement()
			{
				renderer->Finalize();
			}

			Color Gui3DSplitterElement::GetColor1()
			{
				return color1;
			}

			Color Gui3DSplitterElement::GetColor2()
			{
				return color2;
			}

			void Gui3DSplitterElement::SetColors(Color value1, Color value2)
			{
				if(color1!=value1 || color2!=value2)
				{
					color1=value1;
					color2=value2;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			Gui3DSplitterElement::Direction Gui3DSplitterElement::GetDirection()
			{
				return direction;
			}

			void Gui3DSplitterElement::SetDirection(Direction value)
			{
				if(direction!=value)
				{
					direction=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

/***********************************************************************
GuiSolidBackgroundElement
***********************************************************************/

			GuiSolidBackgroundElement::GuiSolidBackgroundElement()
				:color(255, 255, 255)
				,shape(ElementShape::Rectangle)
			{
			}

			GuiSolidBackgroundElement::~GuiSolidBackgroundElement()
			{
				renderer->Finalize();
			}

			Color GuiSolidBackgroundElement::GetColor()
			{
				return color;
			}

			void GuiSolidBackgroundElement::SetColor(Color value)
			{
				if(color!=value)
				{
					color=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}
			
			ElementShape::Type GuiSolidBackgroundElement::GetShape()
			{
				return shape;
			}

			void GuiSolidBackgroundElement::SetShape(ElementShape::Type value)
			{
				shape=value;
			}

/***********************************************************************
GuiGradientBackgroundElement
***********************************************************************/

			GuiGradientBackgroundElement::GuiGradientBackgroundElement()
				:direction(Horizontal)
				,shape(ElementShape::Rectangle)
			{
			}

			GuiGradientBackgroundElement::~GuiGradientBackgroundElement()
			{
				renderer->Finalize();
			}

			Color GuiGradientBackgroundElement::GetColor1()
			{
				return color1;
			}

			Color GuiGradientBackgroundElement::GetColor2()
			{
				return color2;
			}

			void GuiGradientBackgroundElement::SetColors(Color value1, Color value2)
			{
				if(color1!=value1 || color2!=value2)
				{
					color1=value1;
					color2=value2;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			GuiGradientBackgroundElement::Direction GuiGradientBackgroundElement::GetDirection()
			{
				return direction;
			}

			void GuiGradientBackgroundElement::SetDirection(Direction value)
			{
				if(direction!=value)
				{
					direction=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}
			
			ElementShape::Type GuiGradientBackgroundElement::GetShape()
			{
				return shape;
			}

			void GuiGradientBackgroundElement::SetShape(ElementShape::Type value)
			{
				shape=value;
			}

/***********************************************************************
GuiSolidLabelElement
***********************************************************************/

			GuiSolidLabelElement::GuiSolidLabelElement()
				:color(0, 0, 0)
				,hAlignment(Alignment::Left)
				,vAlignment(Alignment::Top)
				,wrapLine(false)
				,ellipse(false)
				,multiline(false)
				,wrapLineHeightCalculation(false)
			{
				fontProperties.fontFamily=L"Lucida Console";
				fontProperties.size=12;
			}

			GuiSolidLabelElement::~GuiSolidLabelElement()
			{
				renderer->Finalize();
			}

			Color GuiSolidLabelElement::GetColor()
			{
				return color;
			}

			void GuiSolidLabelElement::SetColor(Color value)
			{
				if(color!=value)
				{
					color=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			const FontProperties& GuiSolidLabelElement::GetFont()
			{
				return fontProperties;
			}

			void GuiSolidLabelElement::SetFont(const FontProperties& value)
			{
				if(fontProperties!=value)
				{
					fontProperties=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			const WString& GuiSolidLabelElement::GetText()
			{
				return text;
			}

			void GuiSolidLabelElement::SetText(const WString& value)
			{
				if(text!=value)
				{
					text=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			Alignment::Type GuiSolidLabelElement::GetHorizontalAlignment()
			{
				return hAlignment;
			}

			Alignment::Type GuiSolidLabelElement::GetVerticalAlignment()
			{
				return vAlignment;
			}

			void GuiSolidLabelElement::SetAlignments(Alignment::Type horizontal, Alignment::Type vertical)
			{
				if(hAlignment!=horizontal || vAlignment!=vertical)
				{
					hAlignment=horizontal;
					vAlignment=vertical;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			bool GuiSolidLabelElement::GetWrapLine()
			{
				return wrapLine;
			}

			void GuiSolidLabelElement::SetWrapLine(bool value)
			{
				if(wrapLine!=value)
				{
					wrapLine=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			bool GuiSolidLabelElement::GetEllipse()
			{
				return ellipse;
			}

			void GuiSolidLabelElement::SetEllipse(bool value)
			{
				if(ellipse!=value)
				{
					ellipse=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			bool GuiSolidLabelElement::GetMultiline()
			{
				return multiline;
			}

			void GuiSolidLabelElement::SetMultiline(bool value)
			{
				if(multiline!=value)
				{
					multiline=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			bool GuiSolidLabelElement::GetWrapLineHeightCalculation()
			{
				return wrapLineHeightCalculation;
			}

			void GuiSolidLabelElement::SetWrapLineHeightCalculation(bool value)
			{
				if(wrapLineHeightCalculation!=value)
				{
					wrapLineHeightCalculation=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

/***********************************************************************
GuiImageFrameElement
***********************************************************************/

			GuiImageFrameElement::GuiImageFrameElement()
				:frameIndex(0)
				,hAlignment(Alignment::Left)
				,vAlignment(Alignment::Top)
				,stretch(false)
				,enabled(true)
			{
			}

			GuiImageFrameElement::~GuiImageFrameElement()
			{
				renderer->Finalize();
			}

			Ptr<INativeImage> GuiImageFrameElement::GetImage()
			{
				return image;
			}

			vint GuiImageFrameElement::GetFrameIndex()
			{
				return frameIndex;
			}

			void GuiImageFrameElement::SetImage(Ptr<INativeImage> _image, vint _frameIndex)
			{
				if(image!=_image || frameIndex!=_frameIndex)
				{
					if(!_image)
					{
						image=0;
						frameIndex=0;
					}
					else if(0<=_frameIndex && _frameIndex<_image->GetFrameCount())
					{
						image=_image;
						frameIndex=_frameIndex;
					}
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			Alignment::Type GuiImageFrameElement::GetHorizontalAlignment()
			{
				return hAlignment;
			}

			Alignment::Type GuiImageFrameElement::GetVerticalAlignment()
			{
				return vAlignment;
			}

			void GuiImageFrameElement::SetAlignments(Alignment::Type horizontal, Alignment::Type vertical)
			{
				if(hAlignment!=horizontal || vAlignment!=vertical)
				{
					hAlignment=horizontal;
					vAlignment=vertical;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			bool GuiImageFrameElement::GetStretch()
			{
				return stretch;
			}

			void GuiImageFrameElement::SetStretch(bool value)
			{
				if(stretch!=value)
				{
					stretch=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			bool GuiImageFrameElement::GetEnabled()
			{
				return enabled;
			}

			void GuiImageFrameElement::SetEnabled(bool value)
			{
				if(enabled!=value)
				{
					enabled=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

/***********************************************************************
GuiPolygonElement
***********************************************************************/

			GuiPolygonElement::GuiPolygonElement()
			{
			}

			GuiPolygonElement::~GuiPolygonElement()
			{
			}

			Size GuiPolygonElement::GetSize()
			{
				return size;
			}

			void GuiPolygonElement::SetSize(Size value)
			{
				if(size!=value)
				{
					size=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			const Point& GuiPolygonElement::GetPoint(vint index)
			{
				return points[index];
			}

			vint GuiPolygonElement::GetPointCount()
			{
				return points.Count();
			}

			void GuiPolygonElement::SetPoints(const Point* p, vint count)
			{
				points.Resize(count);
				if(count>0)
				{
					memcpy(&points[0], p, sizeof(*p)*count);
				}
				if(renderer)
				{
					renderer->OnElementStateChanged();
				}
			}

			Color GuiPolygonElement::GetBorderColor()
			{
				return borderColor;
			}

			void GuiPolygonElement::SetBorderColor(Color value)
			{
				if(borderColor!=value)
				{
					borderColor=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			Color GuiPolygonElement::GetBackgroundColor()
			{
				return backgroundColor;
			}

			void GuiPolygonElement::SetBackgroundColor(Color value)
			{
				if(backgroundColor!=value)
				{
					backgroundColor=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}
		}
	}
}

/***********************************************************************
GraphicsElement\GuiGraphicsHost.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			using namespace collections;
			using namespace controls;

/***********************************************************************
GuiGraphicsAnimationManager
***********************************************************************/

			GuiGraphicsAnimationManager::GuiGraphicsAnimationManager()
			{
			}

			GuiGraphicsAnimationManager::~GuiGraphicsAnimationManager()
			{
			}

			void GuiGraphicsAnimationManager::AddAnimation(Ptr<IGuiGraphicsAnimation> animation)
			{
				playingAnimations.Add(animation);
			}

			bool GuiGraphicsAnimationManager::HasAnimation()
			{
				return playingAnimations.Count()>0;
			}

			void GuiGraphicsAnimationManager::Play()
			{
				for(vint i=playingAnimations.Count()-1;i>=0;i--)
				{
					Ptr<IGuiGraphicsAnimation> animation=playingAnimations[i];
					vint totalLength=animation->GetTotalLength();
					vint currentPosition=animation->GetCurrentPosition();
					animation->Play(currentPosition, totalLength);
					if(currentPosition>=totalLength)
					{
						playingAnimations.RemoveAt(i);
						animation->Stop();
					}
				}
			}

/***********************************************************************
GuiGraphicsHost
***********************************************************************/

			void GuiGraphicsHost::DisconnectCompositionInternal(GuiGraphicsComposition* composition)
			{
				for(vint i=0;i<composition->Children().Count();i++)
				{
					DisconnectCompositionInternal(composition->Children().Get(i));
				}
				if(mouseCaptureComposition==composition)
				{
					if(nativeWindow)
					{
						nativeWindow->ReleaseCapture();
					}
					mouseCaptureComposition=0;
				}
				if(focusedComposition==composition)
				{
					focusedComposition=0;
				}
				mouseEnterCompositions.Remove(composition);
			}

			void GuiGraphicsHost::MouseCapture(const NativeWindowMouseInfo& info)
			{
				if(nativeWindow && (info.left || info.middle || info.right))
				{
					if(!nativeWindow->IsCapturing())
					{
						nativeWindow->RequireCapture();
						mouseCaptureComposition=windowComposition->FindComposition(Point(info.x, info.y));
					}
				}
			}

			void GuiGraphicsHost::MouseUncapture(const NativeWindowMouseInfo& info)
			{
				if(nativeWindow && !(info.left || info.middle || info.right))
				{
					nativeWindow->ReleaseCapture();
					mouseCaptureComposition=0;
				}
			}

			void GuiGraphicsHost::OnCharInput(const NativeWindowCharInfo& info, GuiGraphicsComposition* composition, GuiCharEvent GuiGraphicsEventReceiver::* eventReceiverEvent)
			{
				List<GuiGraphicsComposition*> compositions;
				while(composition)
				{
					if(composition->HasEventReceiver())
					{
						compositions.Add(composition);
					}
					composition=composition->GetParent();
				}

				GuiCharEventArgs arguments(composition);
				(NativeWindowCharInfo&)arguments=info;

				for(vint i=compositions.Count()-1;i>=0;i--)
				{
					compositions[i]->GetEventReceiver()->previewCharInput.Execute(arguments);
					if(arguments.handled)
					{
						return;
					}
				}

				for(vint i=0;i<compositions.Count();i++)
				{
					(compositions[i]->GetEventReceiver()->*eventReceiverEvent).Execute(arguments);
					if(arguments.handled)
					{
						return;
					}
				}
			}

			void GuiGraphicsHost::OnKeyInput(const NativeWindowKeyInfo& info, GuiGraphicsComposition* composition, GuiKeyEvent GuiGraphicsEventReceiver::* eventReceiverEvent)
			{
				List<GuiGraphicsComposition*> compositions;
				while(composition)
				{
					if(composition->HasEventReceiver())
					{
						compositions.Add(composition);
					}
					composition=composition->GetParent();
				}

				GuiKeyEventArgs arguments(composition);
				(NativeWindowKeyInfo&)arguments=info;

				for(vint i=compositions.Count()-1;i>=0;i--)
				{
					compositions[i]->GetEventReceiver()->previewKey.Execute(arguments);
					if(arguments.handled)
					{
						return;
					}
				}

				for(vint i=0;i<compositions.Count();i++)
				{
					(compositions[i]->GetEventReceiver()->*eventReceiverEvent).Execute(arguments);
					if(arguments.handled)
					{
						return;
					}
				}
			}

			void GuiGraphicsHost::RaiseMouseEvent(GuiMouseEventArgs& arguments, GuiGraphicsComposition* composition, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent)
			{
				arguments.compositionSource=composition;
				arguments.eventSource=0;
				vint x=arguments.x;
				vint y=arguments.y;

				while(composition)
				{
					if(composition->HasEventReceiver())
					{
						if(!arguments.eventSource)
						{
							arguments.eventSource=composition;
						}
						GuiGraphicsEventReceiver* eventReceiver=composition->GetEventReceiver();
						(eventReceiver->*eventReceiverEvent).Execute(arguments);
						if(arguments.handled)
						{
							break;
						}
					}

					GuiGraphicsComposition* parent=composition->GetParent();
					if(parent)
					{
						Rect parentBounds=parent->GetBounds();
						Rect clientArea=parent->GetClientArea();
						Rect childBounds=composition->GetBounds();

						x+=childBounds.x1+(clientArea.x1-parentBounds.x1);
						y+=childBounds.y1+(clientArea.y1-parentBounds.y1);
						arguments.x=x;
						arguments.y=y;
					}
					composition=parent;
				}
			}

			void GuiGraphicsHost::OnMouseInput(const NativeWindowMouseInfo& info, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent)
			{
				GuiGraphicsComposition* composition=0;
				if(mouseCaptureComposition)
				{
					composition=mouseCaptureComposition;
				}
				else
				{
					composition=windowComposition->FindComposition(Point(info.x, info.y));
				}
				if(composition)
				{
					Rect bounds=composition->GetGlobalBounds();
					GuiMouseEventArgs arguments;
					(NativeWindowMouseInfo&)arguments=info;
					arguments.x-=bounds.x1;
					arguments.y-=bounds.y1;
					RaiseMouseEvent(arguments, composition, eventReceiverEvent);
				}
			}

			INativeWindowListener::HitTestResult GuiGraphicsHost::HitTest(Point location)
			{
				Rect bounds=nativeWindow->GetBounds();
				Rect clientBounds=nativeWindow->GetClientBoundsInScreen();
				Point clientLocation(location.x+bounds.x1-clientBounds.x1, location.y+bounds.y1-clientBounds.y1);
				GuiGraphicsComposition* hitComposition=windowComposition->FindComposition(clientLocation);
				while(hitComposition)
				{
					INativeWindowListener::HitTestResult result=hitComposition->GetAssociatedHitTestResult();
					if(result==INativeWindowListener::NoDecision)
					{
						hitComposition=hitComposition->GetParent();
					}
					else
					{
						return result;
					}
				}
				return INativeWindowListener::NoDecision;
			}

			void GuiGraphicsHost::Moving(Rect& bounds, bool fixSizeOnly)
			{
				Rect oldBounds=nativeWindow->GetBounds();
				minSize=windowComposition->GetPreferredBounds().GetSize();
				Size minWindowSize=minSize+(oldBounds.GetSize()-nativeWindow->GetClientSize());
				if(bounds.Width()<minWindowSize.x)
				{
					if(fixSizeOnly)
					{
						if(bounds.Width()<minWindowSize.x)
						{
							bounds.x2=bounds.x1+minWindowSize.x;
						}
					}
					else if(oldBounds.x1!=bounds.x1)
					{
						bounds.x1=oldBounds.x2-minWindowSize.x;
					}
					else if(oldBounds.x2!=bounds.x2)
					{
						bounds.x2=oldBounds.x1+minWindowSize.x;
					}
				}
				if(bounds.Height()<minWindowSize.y)
				{
					if(fixSizeOnly)
					{
						if(bounds.Height()<minWindowSize.y)
						{
							bounds.y2=bounds.y1+minWindowSize.y;
						}
					}
					else if(oldBounds.y1!=bounds.y1)
					{
						bounds.y1=oldBounds.y2-minWindowSize.y;
					}
					else if(oldBounds.y2!=bounds.y2)
					{
						bounds.y2=oldBounds.y1+minWindowSize.y;
					}
				}
			}

			void GuiGraphicsHost::Moved()
			{
				Size size=nativeWindow->GetClientSize();
				if(previousClientSize!=size)
				{
					previousClientSize=size;
					minSize=windowComposition->GetPreferredBounds().GetSize();
					Render();
				}
			}

			void GuiGraphicsHost::LeftButtonDown(const NativeWindowMouseInfo& info)
			{
				MouseCapture(info);
				OnMouseInput(info, &GuiGraphicsEventReceiver::leftButtonDown);
			}

			void GuiGraphicsHost::LeftButtonUp(const NativeWindowMouseInfo& info)
			{
				OnMouseInput(info, &GuiGraphicsEventReceiver::leftButtonUp);
				MouseUncapture(info);
			}

			void GuiGraphicsHost::LeftButtonDoubleClick(const NativeWindowMouseInfo& info)
			{
				LeftButtonDown(info);
				OnMouseInput(info, &GuiGraphicsEventReceiver::leftButtonDoubleClick);
			}

			void GuiGraphicsHost::RightButtonDown(const NativeWindowMouseInfo& info)
			{
				MouseCapture(info);
				OnMouseInput(info, &GuiGraphicsEventReceiver::rightButtonDown);
			}

			void GuiGraphicsHost::RightButtonUp(const NativeWindowMouseInfo& info)
			{
				OnMouseInput(info, &GuiGraphicsEventReceiver::rightButtonUp);
				MouseUncapture(info);
			}

			void GuiGraphicsHost::RightButtonDoubleClick(const NativeWindowMouseInfo& info)
			{
				RightButtonDown(info);
				OnMouseInput(info, &GuiGraphicsEventReceiver::rightButtonDoubleClick);
			}

			void GuiGraphicsHost::MiddleButtonDown(const NativeWindowMouseInfo& info)
			{
				MouseCapture(info);
				OnMouseInput(info, &GuiGraphicsEventReceiver::middleButtonDown);
			}

			void GuiGraphicsHost::MiddleButtonUp(const NativeWindowMouseInfo& info)
			{
				OnMouseInput(info, &GuiGraphicsEventReceiver::middleButtonUp);
				MouseUncapture(info);
			}

			void GuiGraphicsHost::MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)
			{
				MiddleButtonDown(info);
				OnMouseInput(info, &GuiGraphicsEventReceiver::middleButtonDoubleClick);
			}

			void GuiGraphicsHost::HorizontalWheel(const NativeWindowMouseInfo& info)
			{
				OnMouseInput(info, &GuiGraphicsEventReceiver::horizontalWheel);
			}

			void GuiGraphicsHost::VerticalWheel(const NativeWindowMouseInfo& info)
			{
				OnMouseInput(info, &GuiGraphicsEventReceiver::verticalWheel);
			}

			void GuiGraphicsHost::MouseMoving(const NativeWindowMouseInfo& info)
			{
				CompositionList newCompositions;
				{
					GuiGraphicsComposition* composition=windowComposition->FindComposition(Point(info.x, info.y));
					while(composition)
					{
						newCompositions.Insert(0, composition);
						composition=composition->GetParent();
					}
				}

				vint firstDifferentIndex=mouseEnterCompositions.Count();
				for(vint i=0;i<mouseEnterCompositions.Count();i++)
				{
					if(i==newCompositions.Count())
					{
						firstDifferentIndex=newCompositions.Count();
						break;
					}
					if(mouseEnterCompositions[i]!=newCompositions[i])
					{
						firstDifferentIndex=i;
						break;
					}
				}

				for(vint i=mouseEnterCompositions.Count()-1;i>=firstDifferentIndex;i--)
				{
					GuiGraphicsComposition* composition=mouseEnterCompositions[i];
					if(composition->HasEventReceiver())
					{
						composition->GetEventReceiver()->mouseLeave.Execute(GuiEventArgs(composition));
					}
				}

				CopyFrom(mouseEnterCompositions, newCompositions);
				for(vint i=firstDifferentIndex;i<mouseEnterCompositions.Count();i++)
				{
					GuiGraphicsComposition* composition=mouseEnterCompositions[i];
					if(composition->HasEventReceiver())
					{
						composition->GetEventReceiver()->mouseEnter.Execute(GuiEventArgs(composition));
					}
				}

				INativeCursor* cursor=0;
				if(newCompositions.Count()>0)
				{
					cursor=newCompositions[newCompositions.Count()-1]->GetRelatedCursor();
				}
				if(cursor)
				{
					nativeWindow->SetWindowCursor(cursor);
				}
				else
				{
					nativeWindow->SetWindowCursor(GetCurrentController()->ResourceService()->GetDefaultSystemCursor());
				}

				OnMouseInput(info, &GuiGraphicsEventReceiver::mouseMove);
			}

			void GuiGraphicsHost::MouseEntered()
			{
			}

			void GuiGraphicsHost::MouseLeaved()
			{
				for(vint i=mouseEnterCompositions.Count()-1;i>=0;i--)
				{
					GuiGraphicsComposition* composition=mouseEnterCompositions[i];
					if(composition->HasEventReceiver())
					{
						composition->GetEventReceiver()->mouseLeave.Execute(GuiEventArgs(composition));
					}
				}
				mouseEnterCompositions.Clear();
			}

			void GuiGraphicsHost::KeyDown(const NativeWindowKeyInfo& info)
			{
				if(shortcutKeyManager && shortcutKeyManager->Execute(info))
				{
					return;
				}
				if(focusedComposition && focusedComposition->HasEventReceiver())
				{
					OnKeyInput(info, focusedComposition, &GuiGraphicsEventReceiver::keyDown);
				}
			}

			void GuiGraphicsHost::KeyUp(const NativeWindowKeyInfo& info)
			{
				if(focusedComposition && focusedComposition->HasEventReceiver())
				{
					OnKeyInput(info, focusedComposition, &GuiGraphicsEventReceiver::keyUp);
				}
			}

			void GuiGraphicsHost::SysKeyDown(const NativeWindowKeyInfo& info)
			{
				if(focusedComposition && focusedComposition->HasEventReceiver())
				{
					OnKeyInput(info, focusedComposition, &GuiGraphicsEventReceiver::systemKeyDown);
				}
			}

			void GuiGraphicsHost::SysKeyUp(const NativeWindowKeyInfo& info)
			{
				if(focusedComposition && focusedComposition->HasEventReceiver())
				{
					OnKeyInput(info, focusedComposition, &GuiGraphicsEventReceiver::systemKeyUp);
				}
			}

			void GuiGraphicsHost::Char(const NativeWindowCharInfo& info)
			{
				if(focusedComposition && focusedComposition->HasEventReceiver())
				{
					OnCharInput(info, focusedComposition, &GuiGraphicsEventReceiver::charInput);
				}
			}

			void GuiGraphicsHost::GlobalTimer()
			{
				if(animationManager.HasAnimation())
				{
					animationManager.Play();
				}

				DateTime now=DateTime::UtcTime();
				if(now.totalMilliseconds-lastCaretTime>=CaretInterval)
				{
					lastCaretTime=now.totalMilliseconds;
					if(focusedComposition && focusedComposition->HasEventReceiver())
					{
						focusedComposition->GetEventReceiver()->caretNotify.Execute(GuiEventArgs(focusedComposition));
					}
				}
				
				Render();
			}

			GuiGraphicsHost::GuiGraphicsHost()
				:nativeWindow(0)
				,shortcutKeyManager(0)
				,windowComposition(0)
				,focusedComposition(0)
				,mouseCaptureComposition(0)
				,lastCaretTime(0)
			{
				windowComposition=new GuiWindowComposition;
				windowComposition->SetAssociatedHost(this);
				windowComposition->SetMinSizeLimitation(GuiGraphicsComposition::LimitToElementAndChildren);
			}

			GuiGraphicsHost::~GuiGraphicsHost()
			{
				if(shortcutKeyManager)
				{
					delete shortcutKeyManager;
					shortcutKeyManager=0;
				}
				delete windowComposition;
			}

			INativeWindow* GuiGraphicsHost::GetNativeWindow()
			{
				return nativeWindow;
			}

			void GuiGraphicsHost::SetNativeWindow(INativeWindow* _nativeWindow)
			{
				if(nativeWindow!=_nativeWindow)
				{
					if(nativeWindow)
					{
						GetCurrentController()->CallbackService()->UninstallListener(this);
						nativeWindow->UninstallListener(this);
					}
					nativeWindow=_nativeWindow;
					windowComposition->SetAttachedWindow(nativeWindow);
					if(nativeWindow)
					{
						nativeWindow->InstallListener(this);
						GetCurrentController()->CallbackService()->InstallListener(this);
						previousClientSize=nativeWindow->GetClientSize();
						minSize=windowComposition->GetPreferredBounds().GetSize();
						nativeWindow->SetCaretPoint(caretPoint);
					}
				}
			}

			GuiGraphicsComposition* GuiGraphicsHost::GetMainComposition()
			{
				return windowComposition;
			}

			void GuiGraphicsHost::Render()
			{
				if(nativeWindow && nativeWindow->IsVisible())
				{
					windowComposition->GetRenderTarget()->StartRendering();
					windowComposition->Render(Size());
					windowComposition->GetRenderTarget()->StopRendering();
					nativeWindow->RedrawContent();
				}
			}

			IGuiShortcutKeyManager* GuiGraphicsHost::GetShortcutKeyManager()
			{
				return shortcutKeyManager;
			}

			void GuiGraphicsHost::SetShortcutKeyManager(IGuiShortcutKeyManager* value)
			{
				shortcutKeyManager=value;
			}

			bool GuiGraphicsHost::SetFocus(GuiGraphicsComposition* composition)
			{
				if(!composition || composition->GetRelatedGraphicsHost()!=this)
				{
					return false;
				}
				if(focusedComposition && focusedComposition->HasEventReceiver())
				{
					GuiEventArgs arguments;
					arguments.compositionSource=focusedComposition;
					arguments.eventSource=focusedComposition;
					focusedComposition->GetEventReceiver()->lostFocus.Execute(arguments);
				}
				focusedComposition=composition;
				SetCaretPoint(Point(0, 0));
				if(focusedComposition && focusedComposition->HasEventReceiver())
				{
					GuiEventArgs arguments;
					arguments.compositionSource=focusedComposition;
					arguments.eventSource=focusedComposition;
					focusedComposition->GetEventReceiver()->gotFocus.Execute(arguments);
				}
				return true;
			}

			GuiGraphicsComposition* GuiGraphicsHost::GetFocusedComposition()
			{
				return focusedComposition;
			}

			Point GuiGraphicsHost::GetCaretPoint()
			{
				return caretPoint;
			}

			void GuiGraphicsHost::SetCaretPoint(Point value, GuiGraphicsComposition* referenceComposition)
			{
				if(referenceComposition)
				{
					Rect bounds=referenceComposition->GetGlobalBounds();
					value.x+=bounds.x1;
					value.y+=bounds.y1;
				}
				caretPoint=value;
				if(nativeWindow)
				{
					nativeWindow->SetCaretPoint(caretPoint);
				}
			}

			GuiGraphicsAnimationManager* GuiGraphicsHost::GetAnimationManager()
			{
				return &animationManager;
			}

			void GuiGraphicsHost::DisconnectComposition(GuiGraphicsComposition* composition)
			{
				DisconnectCompositionInternal(composition);
			}

/***********************************************************************
GuiTimeBasedAnimation
***********************************************************************/

			GuiTimeBasedAnimation::GuiTimeBasedAnimation(vint totalMilliseconds)
				:startTime(0)
				,length(totalMilliseconds)
			{
				Restart();
			}

			GuiTimeBasedAnimation::~GuiTimeBasedAnimation()
			{
			}

			void GuiTimeBasedAnimation::Restart(vint totalMilliseconds)
			{
				startTime=DateTime::LocalTime().totalMilliseconds;
				if(totalMilliseconds>-1)
				{
					length=totalMilliseconds;
				}
			}

			vint GuiTimeBasedAnimation::GetTotalLength()
			{
				return length;
			}

			vint GuiTimeBasedAnimation::GetCurrentPosition()
			{
				return (vint)(DateTime::LocalTime().totalMilliseconds-startTime);
			}

/***********************************************************************
GuiShortcutKeyItem
***********************************************************************/

			GuiShortcutKeyItem::GuiShortcutKeyItem(GuiShortcutKeyManager* _shortcutKeyManager, bool _ctrl, bool _shift, bool _alt, vint _key)
				:shortcutKeyManager(_shortcutKeyManager)
				,ctrl(_ctrl)
				,shift(_shift)
				,alt(_alt)
				,key(_key)
			{
			}

			GuiShortcutKeyItem::~GuiShortcutKeyItem()
			{
			}

			IGuiShortcutKeyManager* GuiShortcutKeyItem::GetManager()
			{
				return shortcutKeyManager;
			}

			WString GuiShortcutKeyItem::GetName()
			{
				WString name;
				if(ctrl) name+=L"Ctrl+";
				if(shift) name+=L"Shift+";
				if(alt) name+=L"Alt+";
				name+=GetCurrentController()->InputService()->GetKeyName(key);
				return name;
			}

			bool GuiShortcutKeyItem::CanActivate(const NativeWindowKeyInfo& info)
			{
				return
					info.ctrl==ctrl &&
					info.shift==shift &&
					info.alt==alt &&
					info.code==key;
			}

			bool GuiShortcutKeyItem::CanActivate(bool _ctrl, bool _shift, bool _alt, vint _key)
			{
				return
					_ctrl==ctrl &&
					_shift==shift &&
					_alt==alt &&
					_key==key;
			}

/***********************************************************************
GuiShortcutKeyManager
***********************************************************************/

			GuiShortcutKeyManager::GuiShortcutKeyManager()
			{
			}

			GuiShortcutKeyManager::~GuiShortcutKeyManager()
			{
			}

			vint GuiShortcutKeyManager::GetItemCount()
			{
				return shortcutKeyItems.Count();
			}

			IGuiShortcutKeyItem* GuiShortcutKeyManager::GetItem(vint index)
			{
				return shortcutKeyItems[index].Obj();
			}

			bool GuiShortcutKeyManager::Execute(const NativeWindowKeyInfo& info)
			{
				bool executed=false;
				FOREACH(Ptr<GuiShortcutKeyItem>, item, shortcutKeyItems)
				{
					if(item->CanActivate(info))
					{
						GuiEventArgs arguments;
						item->Executed.Execute(arguments);
						executed=true;
					}
				}
				return executed;
			}

			IGuiShortcutKeyItem* GuiShortcutKeyManager::CreateShortcut(bool ctrl, bool shift, bool alt, vint key)
			{
				FOREACH(Ptr<GuiShortcutKeyItem>, item, shortcutKeyItems)
				{
					if(item->CanActivate(ctrl, shift, alt, key))
					{
						return item.Obj();
					}
				}
				Ptr<GuiShortcutKeyItem> item=new GuiShortcutKeyItem(this, ctrl, shift, alt, key);
				shortcutKeyItems.Add(item);
				return item.Obj();
			}

			bool GuiShortcutKeyManager::DestroyShortcut(bool ctrl, bool shift, bool alt, vint key)
			{
				FOREACH(Ptr<GuiShortcutKeyItem>, item, shortcutKeyItems)
				{
					if(item->CanActivate(ctrl, shift, alt, key))
					{
						shortcutKeyItems.Remove(item.Obj());
						return true;
					}
				}
				return false;
			}

			IGuiShortcutKeyItem* GuiShortcutKeyManager::TryGetShortcut(bool ctrl, bool shift, bool alt, vint key)
			{
				FOREACH(Ptr<GuiShortcutKeyItem>, item, shortcutKeyItems)
				{
					if(item->CanActivate(ctrl, shift, alt, key))
					{
						return item.Obj();
					}
				}
				return 0;
			}
		}
	}
}

/***********************************************************************
GraphicsElement\GuiGraphicsResourceManager.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			using namespace collections;

/***********************************************************************
GuiGraphicsResourceManager
***********************************************************************/

			GuiGraphicsResourceManager::GuiGraphicsResourceManager()
			{
			}

			GuiGraphicsResourceManager::~GuiGraphicsResourceManager()
			{
			}

			bool GuiGraphicsResourceManager::RegisterElementFactory(IGuiGraphicsElementFactory* factory)
			{
				if(elementFactories.Keys().Contains(factory->GetElementTypeName()))
				{
					return false;
				}
				else
				{
					elementFactories.Add(factory->GetElementTypeName(), factory);
					return true;
				}
			}

			bool GuiGraphicsResourceManager::RegisterRendererFactory(const WString& elementTypeName, IGuiGraphicsRendererFactory* factory)
			{
				if(rendererFactories.Keys().Contains(elementTypeName))
				{
					return false;
				}
				else
				{
					rendererFactories.Add(elementTypeName, factory);
					return true;
				}
			}

			IGuiGraphicsElementFactory* GuiGraphicsResourceManager::GetElementFactory(const WString& elementTypeName)
			{
				vint index=elementFactories.Keys().IndexOf(elementTypeName);
				return index==-1?0:elementFactories.Values().Get(index).Obj();
			}

			IGuiGraphicsRendererFactory* GuiGraphicsResourceManager::GetRendererFactory(const WString& elementTypeName)
			{
				vint index=rendererFactories.Keys().IndexOf(elementTypeName);
				return index==-1?0:rendererFactories.Values().Get(index).Obj();
			}

			GuiGraphicsResourceManager* guiGraphicsResourceManager=0;

			GuiGraphicsResourceManager* GetGuiGraphicsResourceManager()
			{
				return guiGraphicsResourceManager;
			}

			void SetGuiGraphicsResourceManager(GuiGraphicsResourceManager* resourceManager)
			{
				guiGraphicsResourceManager=resourceManager;
			}

			bool RegisterFactories(IGuiGraphicsElementFactory* elementFactory, IGuiGraphicsRendererFactory* rendererFactory)
			{
				if(guiGraphicsResourceManager && elementFactory && rendererFactory)
				{
					if(guiGraphicsResourceManager->RegisterElementFactory(elementFactory))
					{
						if(guiGraphicsResourceManager->RegisterRendererFactory(elementFactory->GetElementTypeName(), rendererFactory))
						{
							return true;
						}
					}
				}
				return false;
			}
		}
	}
}

/***********************************************************************
GraphicsElement\GuiGraphicsTextElement.cpp
***********************************************************************/

namespace vl
{
	using namespace collections;

	namespace presentation
	{
		namespace elements
		{

			namespace text
			{

/***********************************************************************
text::TextLine
***********************************************************************/

				TextLine::TextLine()
					:text(0)
					,att(0)
					,availableOffsetCount(0)
					,bufferLength(0)
					,dataLength(0)
					,lexerFinalState(-1)
					,contextFinalState(-1)
				{
				}

				TextLine::~TextLine()
				{
				}

				vint TextLine::CalculateBufferLength(vint dataLength)
				{
					if(dataLength<1)dataLength=1;
					vint bufferLength=dataLength-dataLength%BlockSize;
					if(bufferLength<dataLength)
					{
						bufferLength+=BlockSize;
					}
					return bufferLength;
				}

				void TextLine::Initialize()
				{
					Finalize();
					text=new wchar_t[BlockSize];
					att=new CharAtt[BlockSize];
					bufferLength=BlockSize;

					memset(text, 0, sizeof(wchar_t)*bufferLength);
					memset(att, 0, sizeof(CharAtt)*bufferLength);
				}

				void TextLine::Finalize()
				{
					if(text)
					{
						delete[] text;
						text=0;
					}
					if(att)
					{
						delete[] att;
						att=0;
					}
					availableOffsetCount=0;
					bufferLength=0;
					dataLength=0;
				}

				bool TextLine::IsReady()
				{
					return text && att;
				}

				bool TextLine::Modify(vint start, vint count, const wchar_t* input, vint inputCount)
				{
					if(!text || !att || start<0 || count<0 || start+count>dataLength || inputCount<0) return false;

					vint newDataLength=dataLength-count+inputCount;
					vint newBufferLength=CalculateBufferLength(newDataLength);
					if(newBufferLength!=bufferLength)
					{
						wchar_t* newText=new wchar_t[newBufferLength];
						memcpy(newText, text, start*sizeof(wchar_t));
						memcpy(newText+start, input, inputCount*sizeof(wchar_t));
						memcpy(newText+start+inputCount, text+start+count, (dataLength-start-count)*sizeof(wchar_t));

						CharAtt* newAtt=new CharAtt[newBufferLength];
						memcpy(newAtt, att, start*sizeof(CharAtt));
						memset(newAtt+start, 0, inputCount*sizeof(CharAtt));
						memcpy(newAtt+start+inputCount, att+start+count, (dataLength-start-count)*sizeof(CharAtt));

						delete[] text;
						delete[] att;
						text=newText;
						att=newAtt;
					}
					else
					{
						memmove(text+start+inputCount, text+start+count, (dataLength-start-count)*sizeof(wchar_t));
						memmove(att+start+inputCount, att+start+count, (dataLength-start-count)*sizeof(CharAtt));
						memcpy(text+start, input, inputCount*sizeof(wchar_t));
						memset(att+start, 0, inputCount*sizeof(CharAtt));
					}
					dataLength=newDataLength;
					bufferLength=newBufferLength;
					if(availableOffsetCount>start)
					{
						availableOffsetCount=start;
					}

					return true;
				}

				TextLine TextLine::Split(vint index)
				{
					if(index<0 || index>dataLength) return TextLine();
					vint count=dataLength-index;
					TextLine line;
					line.Initialize();
					line.Modify(0, 0, text+index, count);
					memcpy(line.att, att+index, count*sizeof(CharAtt));
					Modify(index, count, L"", 0);
					return line;
				}

				void TextLine::AppendAndFinalize(TextLine& line)
				{
					vint oldDataLength=dataLength;
					Modify(oldDataLength, 0, line.text, line.dataLength);
					memcpy(att+oldDataLength, line.att, line.dataLength*sizeof(CharAtt));
					line.Finalize();
				}

/***********************************************************************
text::CharMeasurer
***********************************************************************/

				CharMeasurer::CharMeasurer(vint _rowHeight)
					:oldRenderTarget(0)
					,rowHeight(_rowHeight)
				{
					memset(widths, 0, sizeof(widths));
				}

				CharMeasurer::~CharMeasurer()
				{
				}

				void CharMeasurer::SetRenderTarget(IGuiGraphicsRenderTarget* value)
				{
					if(oldRenderTarget!=value)
					{
						oldRenderTarget=value;
						rowHeight=GetRowHeightInternal(oldRenderTarget);
						memset(widths, 0, sizeof(widths));
					}
				}

				vint CharMeasurer::MeasureWidth(wchar_t character)
				{
					vint w=widths[character];
					if(w==0)
					{
						widths[character]=w=MeasureWidthInternal(character, oldRenderTarget);
					}
					return w;
				}

				vint CharMeasurer::GetRowHeight()
				{
					return rowHeight;
				}

/***********************************************************************
text::TextLines
***********************************************************************/

				TextLines::TextLines()
					:charMeasurer(0)
					,renderTarget(0)
					,tabWidth(1)
					,tabSpaceCount(4)
					,passwordChar(L'\0')
				{
					TextLine line;
					line.Initialize();
					lines.Add(line);
				}

				TextLines::~TextLines()
				{
					RemoveLines(0, lines.Count());
				}

				//--------------------------------------------------------

				vint TextLines::GetCount()
				{
					return lines.Count();
				}

				TextLine& TextLines::GetLine(vint row)
				{
					return lines[row];
				}

				CharMeasurer* TextLines::GetCharMeasurer()
				{
					return charMeasurer;
				}

				void TextLines::SetCharMeasurer(CharMeasurer* value)
				{
					charMeasurer=value;
					if(charMeasurer) charMeasurer->SetRenderTarget(renderTarget);
					ClearMeasurement();
				}

				IGuiGraphicsRenderTarget* TextLines::GetRenderTarget()
				{
					return renderTarget;
				}

				void TextLines::SetRenderTarget(IGuiGraphicsRenderTarget* value)
				{
					renderTarget=value;
					if(charMeasurer) charMeasurer->SetRenderTarget(renderTarget);
					ClearMeasurement();
				}

				WString TextLines::GetText(TextPos start, TextPos end)
				{
					if(!IsAvailable(start) || !IsAvailable(end) || start>end) return L"";

					if(start.row==end.row)
					{
						return WString(lines[start.row].text+start.column, end.column-start.column);
					}

					vint count=0;
					for(vint i=start.row+1;i<end.row;i++)
					{
						count+=lines[i].dataLength;
					}
					count+=lines[start.row].dataLength-start.column;
					count+=end.column;

					Array<wchar_t> buffer;
					buffer.Resize(count+(end.row-start.row)*2);
					wchar_t* writing=&buffer[0];

					for(vint i=start.row;i<=end.row;i++)
					{
						wchar_t* text=lines[i].text;
						vint chars=0;
						if(i==start.row)
						{
							text+=start.column;
							chars=lines[i].dataLength-start.column;
						}
						else if(i==end.row)
						{
							chars=end.column;
						}
						else
						{
							chars=lines[i].dataLength;
						}

						if(i!=start.row)
						{
							*writing++=L'\r';
							*writing++=L'\n';
						}
						memcpy(writing, text, chars*sizeof(wchar_t));
						writing+=chars;
					}
					return WString(&buffer[0], buffer.Count());
				}

				WString TextLines::GetText()
				{
					return GetText(TextPos(0, 0), TextPos(lines.Count()-1, lines[lines.Count()-1].dataLength));
				}

				void TextLines::SetText(const WString& value)
				{
					Modify(TextPos(0, 0), TextPos(lines.Count()-1, lines[lines.Count()-1].dataLength), value);
				}

				//--------------------------------------------------------

				bool TextLines::RemoveLines(vint start, vint count)
				{
					if(start<0 || count<0 || start+count>lines.Count()) return false;
					for(vint i=start+count-1;i>=start;i--)
					{
						lines[i].Finalize();
					}
					lines.RemoveRange(start, count);
					return true;
				}

				bool TextLines::IsAvailable(TextPos pos)
				{
					return 0<=pos.row && pos.row<lines.Count() && 0<=pos.column && pos.column<=lines[pos.row].dataLength;
				}

				TextPos TextLines::Normalize(TextPos pos)
				{
					if(pos.row<0)
					{
						return TextPos(0, 0);
					}
					else if(pos.row>=lines.Count())
					{
						return TextPos(lines.Count()-1, lines[lines.Count()-1].dataLength);
					}
					else
					{
						TextLine& line=lines[pos.row];
						if(pos.column<0)
						{
							return TextPos(pos.row, 0);
						}
						else if(pos.column>line.dataLength)
						{
							return TextPos(pos.row, line.dataLength);
						}
						else
						{
							return pos;
						}
					}
				}

				TextPos TextLines::Modify(TextPos start, TextPos end, const wchar_t** inputs, vint* inputCounts, vint rows)
				{
					if(!IsAvailable(start) || !IsAvailable(end) || start>end) return TextPos(-1, -1);

					if(rows==1)
					{
						if(start.row==end.row)
						{
							lines[start.row].Modify(start.column, end.column-start.column, inputs[0], inputCounts[0]);
						}
						else
						{
							if(end.row-start.row>1)
							{
								RemoveLines(start.row+1, end.row-start.row-1);
							}
							vint modifyCount=lines[start.row].dataLength-start.column+end.column;
							lines[start.row].AppendAndFinalize(lines[start.row+1]);
							lines.RemoveAt(start.row+1);
							lines[start.row].Modify(start.column, modifyCount, inputs[0], inputCounts[0]);
						}
						return TextPos(start.row, start.column+inputCounts[0]);
					}

					if(start.row==end.row)
					{
						TextLine newLine=lines[start.row].Split(end.column);
						lines.Insert(start.row+1, newLine);
						end=TextPos(start.row+1, 0);
					}

					vint oldMiddleLines=end.row-start.row-1;
					vint newMiddleLines=rows-2;
					if(oldMiddleLines<newMiddleLines)
					{
						for(vint i=oldMiddleLines;i<newMiddleLines;i++)
						{
							TextLine line;
							line.Initialize();
							lines.Insert(end.row, line);
						}
					}
					else if(oldMiddleLines>newMiddleLines)
					{
						RemoveLines(start.row+newMiddleLines+1, oldMiddleLines-newMiddleLines);
					}
					end.row+=newMiddleLines-oldMiddleLines;

					lines[start.row].Modify(start.column, lines[start.row].dataLength-start.column, inputs[0], inputCounts[0]);
					lines[end.row].Modify(0, end.column, inputs[rows-1], inputCounts[rows-1]);
					for(vint i=1;i<rows-1;i++)
					{
						lines[start.row+i].Modify(0, lines[start.row+i].dataLength, inputs[i], inputCounts[i]);
					}
					return TextPos(end.row, inputCounts[rows-1]);
				}

				TextPos TextLines::Modify(TextPos start, TextPos end, const wchar_t* input, vint inputCount)
				{
					List<const wchar_t*> inputs;
					List<vint> inputCounts;
					const wchar_t* previous=input;
					const wchar_t* current=input;

					while(true)
					{
						if(current==input+inputCount)
						{
							inputs.Add(previous);
							inputCounts.Add(current-previous);
							break;
						}
						else if(*current==L'\r' || *current==L'\n')
						{
							inputs.Add(previous);
							inputCounts.Add(current-previous);
							previous=current+(current[1]==L'\n'?2:1);
							current=previous;
						}
						else
						{
							current++;
						}
					}

					return Modify(start, end, &inputs[0], &inputCounts[0], inputs.Count());
				}

				TextPos TextLines::Modify(TextPos start, TextPos end, const wchar_t* input)
				{
					return Modify(start, end, input, wcslen(input));
				}

				TextPos TextLines::Modify(TextPos start, TextPos end, const WString& input)
				{
					return Modify(start, end, input.Buffer(), input.Length());
				}

				void TextLines::Clear()
				{
					RemoveLines(0, lines.Count());
					TextLine line;
					line.Initialize();
					lines.Add(line);
				}

				//--------------------------------------------------------

				void TextLines::ClearMeasurement()
				{
					for(vint i=0;i<lines.Count();i++)
					{
						lines[i].availableOffsetCount=0;
					}
					if(charMeasurer)
					{
						tabWidth=tabSpaceCount*charMeasurer->MeasureWidth(L' ');
					}
					if(tabWidth==0)
					{
						tabWidth=1;
					}
				}

				vint TextLines::GetTabSpaceCount()
				{
					return tabSpaceCount;
				}

				void TextLines::SetTabSpaceCount(vint value)
				{
					if(value<1) value=1;
					if(tabSpaceCount!=value)
					{
						tabSpaceCount=value;
						ClearMeasurement();
					}
				}

				void TextLines::MeasureRow(vint row)
				{
					TextLine& line=lines[row];
					vint offset=0;
					if(line.availableOffsetCount)
					{
						offset=line.att[line.availableOffsetCount-1].rightOffset;
					}
					for(vint i=line.availableOffsetCount;i<line.dataLength;i++)
					{
						CharAtt& att=line.att[i];
						wchar_t c=line.text[i];
						vint width=0;
						if(passwordChar)
						{
							width=charMeasurer->MeasureWidth(passwordChar);
						}
						else if(c==L'\t')
						{
							width=tabWidth-offset%tabWidth;
						}
						else
						{
							width=charMeasurer->MeasureWidth(line.text[i]);
						}
						offset+=width;
						att.rightOffset=(int)offset;
					}
					line.availableOffsetCount=line.dataLength;
				}

				vint TextLines::GetRowWidth(vint row)
				{
					if(row<0 || row>=lines.Count()) return -1;
					TextLine& line=lines[row];
					if(line.dataLength==0)
					{
						return 0;
					}
					else
					{
						MeasureRow(row);
						return line.att[line.dataLength-1].rightOffset;
					}
				}

				vint TextLines::GetRowHeight()
				{
					return charMeasurer->GetRowHeight();
				}

				vint TextLines::GetMaxWidth()
				{
					vint width=0;
					for(vint i=0;i<lines.Count();i++)
					{
						vint rowWidth=GetRowWidth(i);
						if(width<rowWidth)
						{
							width=rowWidth;
						}
					}
					return width;
				}

				vint TextLines::GetMaxHeight()
				{
					return lines.Count()*charMeasurer->GetRowHeight();
				}

				TextPos TextLines::GetTextPosFromPoint(Point point)
				{
					vint h=charMeasurer->GetRowHeight();
					if(point.y<0)
					{
						point.y=0;
					}
					else if(point.y>=h*lines.Count())
					{
						point.y=h*lines.Count()-1;
					}

					vint row=point.y/h;
					if(point.x<0)
					{
						return TextPos(row, 0);
					}
					else if(point.x>=GetRowWidth(row))
					{
						return TextPos(row, lines[row].dataLength);
					}
					TextLine& line=lines[row];

					vint i1=0, i2=line.dataLength;
					vint p1=0, p2=line.att[line.dataLength-1].rightOffset;
					while(i2-i1>1)
					{
						vint i=(i1+i2)/2;
						vint p=i==0?0:line.att[i-1].rightOffset;
						if(point.x<p)
						{
							i2=i;
							p2=p;
						}
						else
						{
							i1=i;
							p1=p;
						}
					}
					return TextPos(row, i1);
				}

				Point TextLines::GetPointFromTextPos(TextPos pos)
				{
					if(IsAvailable(pos))
					{
						vint y=pos.row*charMeasurer->GetRowHeight();
						if(pos.column==0)
						{
							return Point(0, y);
						}
						else
						{
							MeasureRow(pos.row);
							TextLine& line=lines[pos.row];
							return Point(line.att[pos.column-1].rightOffset, y);
						}
					}
					else
					{
						return Point(-1, -1);
					}
				}

				Rect TextLines::GetRectFromTextPos(TextPos pos)
				{
					Point point=GetPointFromTextPos(pos);
					if(point==Point(-1, -1))
					{
						return Rect(-1, -1, -1, -1);
					}
					else
					{
						vint h=charMeasurer->GetRowHeight();
						TextLine& line=lines[pos.row];
						if(pos.column==line.dataLength)
						{
							return Rect(point, Size(h/2, h));
						}
						else
						{
							return Rect(point, Size(line.att[pos.column].rightOffset-point.x, h));
						}
					}
				}

				//--------------------------------------------------------

				wchar_t TextLines::GetPasswordChar()
				{
					return passwordChar;
				}

				void TextLines::SetPasswordChar(wchar_t value)
				{
					passwordChar=value;
					ClearMeasurement();
				}
			}

			using namespace text;

/***********************************************************************
GuiColorizedTextElement
***********************************************************************/

			GuiColorizedTextElement::GuiColorizedTextElement()
				:callback(0)
				,isVisuallyEnabled(true)
				,isFocused(false)
				,caretVisible(false)
			{
			}

			GuiColorizedTextElement::~GuiColorizedTextElement()
			{
				renderer->Finalize();
			}

			text::TextLines& GuiColorizedTextElement::GetLines()
			{
				return lines;
			}

			GuiColorizedTextElement::ICallback* GuiColorizedTextElement::GetCallback()
			{
				return callback;
			}

			void GuiColorizedTextElement::SetCallback(ICallback* value)
			{
				callback=value;
				if(!callback)
				{
					lines.SetCharMeasurer(0);
				}
			}

			const GuiColorizedTextElement::ColorArray& GuiColorizedTextElement::GetColors()
			{
				return colors;
			}

			void GuiColorizedTextElement::SetColors(const ColorArray& value)
			{
				CopyFrom(colors, value);
				if(callback) callback->ColorChanged();
				if(renderer)
				{
					renderer->OnElementStateChanged();
				}
			}

			const FontProperties& GuiColorizedTextElement::GetFont()
			{
				return font;
			}

			void GuiColorizedTextElement::SetFont(const FontProperties& value)
			{
				if(font!=value)
				{
					font=value;
					if(callback)
					{
						callback->FontChanged();
					}
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			wchar_t GuiColorizedTextElement::GetPasswordChar()
			{
				return lines.GetPasswordChar();
			}

			void GuiColorizedTextElement::SetPasswordChar(wchar_t value)
			{
				if(lines.GetPasswordChar()!=value)
				{
					lines.SetPasswordChar(value);
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			Point GuiColorizedTextElement::GetViewPosition()
			{
				return viewPosition;
			}

			void GuiColorizedTextElement::SetViewPosition(Point value)
			{
				if(viewPosition!=value)
				{
					viewPosition=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			bool GuiColorizedTextElement::GetVisuallyEnabled()
			{
				return isVisuallyEnabled;
			}

			void GuiColorizedTextElement::SetVisuallyEnabled(bool value)
			{
				if(isVisuallyEnabled!=value)
				{
					isVisuallyEnabled=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			bool GuiColorizedTextElement::GetFocused()
			{
				return isFocused;
			}

			void GuiColorizedTextElement::SetFocused(bool value)
			{
				if(isFocused!=value)
				{
					isFocused=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

			TextPos GuiColorizedTextElement::GetCaretBegin()
			{
				return caretBegin;
			}

			void GuiColorizedTextElement::SetCaretBegin(TextPos value)
			{
				caretBegin=value;
			}

			TextPos GuiColorizedTextElement::GetCaretEnd()
			{
				return caretEnd;
			}

			void GuiColorizedTextElement::SetCaretEnd(TextPos value)
			{
				caretEnd=value;
			}

			bool GuiColorizedTextElement::GetCaretVisible()
			{
				return caretVisible;
			}

			void GuiColorizedTextElement::SetCaretVisible(bool value)
			{
				caretVisible=value;
			}

			Color GuiColorizedTextElement::GetCaretColor()
			{
				return caretColor;
			}

			void GuiColorizedTextElement::SetCaretColor(Color value)
			{
				if(caretColor!=value)
				{
					caretColor=value;
					if(renderer)
					{
						renderer->OnElementStateChanged();
					}
				}
			}

/***********************************************************************
Visitors
***********************************************************************/

			namespace visitors
			{
				class ExtractTextVisitor : public Object, public DocumentRun::IVisitor
				{
				public:
					WString						text;

					void Visit(DocumentTextRun* run)override
					{
						text=run->text;
					}

					void Visit(DocumentImageRun* run)override
					{
						text=L"[Image]";
					}

					static WString ExtractText(DocumentRun* run)
					{
						ExtractTextVisitor visitor;
						run->Accept(&visitor);
						return visitor.text;
					}
				};

				class SetPropertiesVisitor : public Object, public DocumentRun::IVisitor
				{
				public:
					vint							start;
					vint							length;
					IGuiGraphicsParagraph*		paragraph;

					SetPropertiesVisitor(vint _start, IGuiGraphicsParagraph* _paragraph)
						:start(_start)
						,length(0)
						,paragraph(_paragraph)
					{
					}

					void Visit(DocumentTextRun* run)override
					{
						length=run->text.Length();
						if(length>0)
						{
							paragraph->SetFont(start, length, run->style.fontFamily);
							paragraph->SetSize(start, length, run->style.size);
							paragraph->SetColor(start, length, run->color);
							paragraph->SetStyle(start, length, 
								(IGuiGraphicsParagraph::TextStyle)
								( (run->style.bold?IGuiGraphicsParagraph::Bold:0)
								| (run->style.italic?IGuiGraphicsParagraph::Italic:0)
								| (run->style.underline?IGuiGraphicsParagraph::Underline:0)
								| (run->style.strikeline?IGuiGraphicsParagraph::Strikeline:0)
								));
							start+=length;
						}
					}

					void Visit(DocumentImageRun* run)override
					{
						// [Image]
						length=7;

						IGuiGraphicsParagraph::InlineObjectProperties properties;
						properties.size=run->size;
						properties.baseline=run->baseline;
						properties.breakCondition=IGuiGraphicsParagraph::Alone;

						Ptr<GuiImageFrameElement> element=GuiImageFrameElement::Create();
						element->SetImage(run->image, run->frameIndex);
						element->SetStretch(true);

						paragraph->SetInlineObject(start, length, properties, element);
					}

					static vint SetProperty(vint start, IGuiGraphicsParagraph* paragraph, DocumentRun* run)
					{
						SetPropertiesVisitor visitor(start, paragraph);
						run->Accept(&visitor);
						return visitor.length;
					}
				};
			}
			using namespace visitors;

/***********************************************************************
GuiDocumentElement::GuiDocumentElementRenderer
***********************************************************************/

			void GuiDocumentElement::GuiDocumentElementRenderer::InitializeInternal()
			{
			}

			void GuiDocumentElement::GuiDocumentElementRenderer::FinalizeInternal()
			{
			}

			void GuiDocumentElement::GuiDocumentElementRenderer::RenderTargetChangedInternal(IGuiGraphicsRenderTarget* oldRenderTarget, IGuiGraphicsRenderTarget* newRenderTarget)
			{
				for(vint i=0;i<paragraphCaches.Count();i++)
				{
					text::ParagraphCache* cache=paragraphCaches[i].Obj();
					if(cache)
					{
						cache->graphicsParagraph=0;
					}
				}
			}

			GuiDocumentElement::GuiDocumentElementRenderer::GuiDocumentElementRenderer()
				:paragraphDistance(0)
				,lastMaxWidth(-1)
				,cachedTotalHeight(0)
				,layoutProvider(GetGuiGraphicsResourceManager()->GetLayoutProvider())
			{
			}

			void GuiDocumentElement::GuiDocumentElementRenderer::Render(Rect bounds)
			{
				renderTarget->PushClipper(bounds);
				if(!renderTarget->IsClipperCoverWholeTarget())
				{
					vint maxWidth=bounds.Width();
					Rect clipper=renderTarget->GetClipper();
					vint cx=bounds.Left();
					vint cy=bounds.Top();
					vint y1=clipper.Top()-bounds.Top();
					vint y2=y1+clipper.Height();
					vint y=0;

					for(vint i=0;i<paragraphHeights.Count();i++)
					{
						vint paragraphHeight=paragraphHeights[i];
						if(y+paragraphHeight<=y1)
						{
							y+=paragraphHeight+paragraphDistance;
							continue;
						}
						else if(y>=y2)
						{
							break;
						}
						else
						{
							Ptr<text::DocumentParagraph> paragraph=element->document->paragraphs[i];
							Ptr<text::ParagraphCache> cache=paragraphCaches[i];
							if(!cache)
							{
								cache=new text::ParagraphCache;
								paragraphCaches[i]=cache;

								stream::MemoryStream stream;
								{
									stream::StreamWriter writer(stream);
									FOREACH(Ptr<text::DocumentLine>, line, paragraph->lines)
									{
										FOREACH(Ptr<text::DocumentRun>, run, line->runs)
										{
											WString text=ExtractTextVisitor::ExtractText(run.Obj());
											writer.WriteString(text);
										}
										writer.WriteString(L"\r\n");
									}
								}
								{
									stream.SeekFromBegin(0);
									stream::StreamReader reader(stream);
									cache->fullText=reader.ReadToEnd();
								}
							}

							if(!cache->graphicsParagraph)
							{
								cache->graphicsParagraph=layoutProvider->CreateParagraph(cache->fullText, renderTarget);
								vint start=0;
								FOREACH(Ptr<text::DocumentLine>, line, paragraph->lines)
								{
									FOREACH(Ptr<text::DocumentRun>, run, line->runs)
									{
										vint length=SetPropertiesVisitor::SetProperty(start, cache->graphicsParagraph.Obj(), run.Obj());
										start+=length;
									}
									start+=2;
								}
							}
							if(cache->graphicsParagraph->GetMaxWidth()!=maxWidth)
							{
								cache->graphicsParagraph->SetMaxWidth(maxWidth);
								vint height=cache->graphicsParagraph->GetHeight();
								if(paragraphHeight!=height)
								{
									cachedTotalHeight+=height-paragraphHeight;
									paragraphHeight=height;
									paragraphHeights[i]=paragraphHeight;
								}
							}

							cache->graphicsParagraph->Render(Rect(Point(cx, cy+y), Size(maxWidth, paragraphHeight)));
						}

						y+=paragraphHeight+paragraphDistance;
					}

					lastMaxWidth=maxWidth;
					minSize=Size(0, cachedTotalHeight);
				}
				renderTarget->PopClipper();
			}

			void GuiDocumentElement::GuiDocumentElementRenderer::OnElementStateChanged()
			{
				if(element->document && element->document->paragraphs.Count()>0)
				{
					paragraphDistance=GetCurrentController()->ResourceService()->GetDefaultFont().size;
					vint defaultHeight=paragraphDistance;

					paragraphCaches.Resize(element->document->paragraphs.Count());
					paragraphHeights.Resize(element->document->paragraphs.Count());

					for(vint i=0;i<paragraphHeights.Count();i++)
					{
						paragraphHeights[i]=defaultHeight;
					}
					cachedTotalHeight=paragraphHeights.Count()*defaultHeight+(paragraphHeights.Count()-1)*paragraphDistance;
					minSize=Size(0, cachedTotalHeight);
				}
				else
				{
					paragraphCaches.Resize(0);
					paragraphHeights.Resize(0);
					cachedTotalHeight=0;
					minSize=Size(0, 0);
				}
			}

			void GuiDocumentElement::GuiDocumentElementRenderer::NotifyParagraphUpdated(vint index)
			{
				if(0<=index && index<paragraphCaches.Count())
				{
					Ptr<ParagraphCache> cache=paragraphCaches[index];
					if(cache)
					{
						cache->graphicsParagraph=0;
					}
				}
			}

/***********************************************************************
GuiDocumentElement
***********************************************************************/

			GuiDocumentElement::GuiDocumentElement()
			{
			}

			GuiDocumentElement::~GuiDocumentElement()
			{
			}

			Ptr<text::DocumentModel> GuiDocumentElement::GetDocument()
			{
				return document;
			}

			void GuiDocumentElement::SetDocument(Ptr<text::DocumentModel> value)
			{
				document=value;
				if(renderer)
				{
					renderer->OnElementStateChanged();
				}
			}
			
			void GuiDocumentElement::NotifyParagraphUpdated(vint index)
			{
				Ptr<GuiDocumentElementRenderer> elementRenderer=renderer.Cast<GuiDocumentElementRenderer>();
				if(elementRenderer)
				{
					elementRenderer->NotifyParagraphUpdated(index);
				}
			}
		}
	}
}

/***********************************************************************
GraphicsElement\WindowsDirect2D\GuiGraphicsLayoutProviderWindowsDirect2D.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace elements;
		using namespace collections;

		namespace elements_windows_d2d
		{

/***********************************************************************
WindowsDirect2DElementInlineObject
***********************************************************************/

			class WindowsDirect2DElementInlineObject : public IDWriteInlineObject
			{
			protected:
				vint													counter;
				IGuiGraphicsParagraph::InlineObjectProperties		properties;
				Ptr<IGuiGraphicsElement>							element;
				vint													start;
				vint													length;

			public:
				WindowsDirect2DElementInlineObject(
					const IGuiGraphicsParagraph::InlineObjectProperties& _properties,
					Ptr<IGuiGraphicsElement> _element,
					vint _start,
					vint _length
					)
					:counter(1)
					,properties(_properties)
					,element(_element)
					,start(_start)
					,length(_length)
				{
				}

				~WindowsDirect2DElementInlineObject()
				{
					IGuiGraphicsRenderer* graphicsRenderer=element->GetRenderer();
					if(graphicsRenderer)
					{
						graphicsRenderer->SetRenderTarget(0);
					}
				}

				vint GetStart()
				{
					return start;
				}

				vint GetLength()
				{
					return length;
				}

				HRESULT STDMETHODCALLTYPE QueryInterface( 
					REFIID riid,
					_COM_Outptr_ void __RPC_FAR *__RPC_FAR *ppvObject
					)
				{
					if(ppvObject)
					{
						*ppvObject=NULL;
					}
					return E_NOINTERFACE;
				}

				ULONG STDMETHODCALLTYPE AddRef(void)
				{
					++counter;
					return S_OK;
				}

				ULONG STDMETHODCALLTYPE Release(void)
				{
					if(--counter==0)
					{
						delete this;
					}
					return S_OK;
				}

				STDMETHOD(Draw)(
					_In_opt_ void* clientDrawingContext,
					IDWriteTextRenderer* renderer,
					FLOAT originX,
					FLOAT originY,
					BOOL isSideways,
					BOOL isRightToLeft,
					_In_opt_ IUnknown* clientDrawingEffect
					)override
				{
					IGuiGraphicsRenderer* graphicsRenderer=element->GetRenderer();
					if(graphicsRenderer)
					{
						Rect bounds(Point((vint)originX, (vint)originY), properties.size);
						graphicsRenderer->Render(bounds);
					}
					return S_OK;
				}

				STDMETHOD(GetMetrics)(
					_Out_ DWRITE_INLINE_OBJECT_METRICS* metrics
					)override
				{
					metrics->width=(FLOAT)properties.size.x;
					metrics->height=(FLOAT)properties.size.y;
					metrics->baseline=(FLOAT)(properties.baseline==-1?properties.size.y:properties.baseline);
					metrics->supportsSideways=TRUE;
					return S_OK;
				}

				STDMETHOD(GetOverhangMetrics)(
					_Out_ DWRITE_OVERHANG_METRICS* overhangs
					)override
				{
					overhangs->left=0;
					overhangs->right=0;
					overhangs->top=0;
					overhangs->bottom=0;
					return S_OK;
				}

				STDMETHOD(GetBreakConditions)(
					_Out_ DWRITE_BREAK_CONDITION* breakConditionBefore,
					_Out_ DWRITE_BREAK_CONDITION* breakConditionAfter
					)override
				{
					switch(properties.breakCondition)
					{
					case IGuiGraphicsParagraph::StickToPreviousRun:
						*breakConditionBefore=DWRITE_BREAK_CONDITION_MAY_NOT_BREAK;
						*breakConditionAfter=DWRITE_BREAK_CONDITION_CAN_BREAK;
						break;
					case IGuiGraphicsParagraph::StickToNextRun:
						*breakConditionBefore=DWRITE_BREAK_CONDITION_CAN_BREAK;
						*breakConditionAfter=DWRITE_BREAK_CONDITION_MAY_NOT_BREAK;
						break;
					default:
						*breakConditionBefore=DWRITE_BREAK_CONDITION_CAN_BREAK;
						*breakConditionAfter=DWRITE_BREAK_CONDITION_CAN_BREAK;
					}
					return S_OK;
				}
			};

/***********************************************************************
WindowsDirect2DParagraph
***********************************************************************/

			class WindowsDirect2DParagraph : public Object, public IGuiGraphicsParagraph
			{
				typedef Dictionary<IGuiGraphicsElement*, ComPtr<WindowsDirect2DElementInlineObject>>		InlineElementMap;
			protected:
				IGuiGraphicsLayoutProvider*			provider;
				ID2D1SolidColorBrush*				defaultTextColor;
				IDWriteFactory*						dwriteFactory;
				IWindowsDirect2DRenderTarget*		renderTarget;
				ComPtr<IDWriteTextLayout>			textLayout;
				bool								wrapLine;
				vint									maxWidth;
				List<Color>							usedColors;
				InlineElementMap					inlineElements;

			public:
				WindowsDirect2DParagraph(IGuiGraphicsLayoutProvider* _provider, const WString& _text, IGuiGraphicsRenderTarget* _renderTarget)
					:provider(_provider)
					,dwriteFactory(GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory())
					,renderTarget(dynamic_cast<IWindowsDirect2DRenderTarget*>(_renderTarget))
					,textLayout(0)
					,wrapLine(true)
					,maxWidth(-1)
				{
					FontProperties defaultFont=GetCurrentController()->ResourceService()->GetDefaultFont();
					Direct2DTextFormatPackage* package=GetWindowsDirect2DResourceManager()->CreateDirect2DTextFormat(defaultFont);
					defaultTextColor=renderTarget->CreateDirect2DBrush(Color(0, 0, 0));
					usedColors.Add(Color(0, 0, 0));

					IDWriteTextLayout* rawTextLayout=0;
					HRESULT hr=dwriteFactory->CreateTextLayout(
						_text.Buffer(),
						(int)_text.Length(),
						package->textFormat.Obj(),
						0,
						0,
						&rawTextLayout);
					if(!FAILED(hr))
					{
						textLayout=rawTextLayout;
						textLayout->SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);
					}

					GetWindowsDirect2DResourceManager()->DestroyDirect2DTextFormat(defaultFont);
				}

				~WindowsDirect2DParagraph()
				{
					FOREACH(Color, color, usedColors)
					{
						renderTarget->DestroyDirect2DBrush(color);
					}
				}

				IGuiGraphicsLayoutProvider* GetProvider()override
				{
					return provider;
				}

				IGuiGraphicsRenderTarget* GetRenderTarget()override
				{
					return renderTarget;
				}

				bool GetWrapLine()override
				{
					return wrapLine;
				}

				void SetWrapLine(bool value)override
				{
					if(wrapLine!=value)
					{
						wrapLine=value;
						textLayout->SetWordWrapping(value?DWRITE_WORD_WRAPPING_WRAP:DWRITE_WORD_WRAPPING_NO_WRAP);
					}
				}

				vint GetMaxWidth()override
				{
					return maxWidth;
				}

				void SetMaxWidth(vint value)override
				{
					if(maxWidth!=value)
					{
						maxWidth=value;
						textLayout->SetMaxWidth(value==-1?65536:(FLOAT)value);
					}
				}

				bool SetFont(vint start, vint length, const WString& value)override
				{
					if(length==0) return true;
					DWRITE_TEXT_RANGE range;
					range.startPosition=(int)start;
					range.length=(int)length;
					HRESULT hr=textLayout->SetFontFamilyName(value.Buffer(), range);
					return !FAILED(hr);
				}

				bool SetSize(vint start, vint length, vint value)override
				{
					if(length==0) return true;
					DWRITE_TEXT_RANGE range;
					range.startPosition=(int)start;
					range.length=(int)length;
					HRESULT hr=textLayout->SetFontSize((FLOAT)value, range);
					return !FAILED(hr);
				}

				bool SetStyle(vint start, vint length, TextStyle value)override
				{
					if(length==0) return true;
					DWRITE_TEXT_RANGE range;
					range.startPosition=(int)start;
					range.length=(int)length;
					HRESULT hr=S_OK;

					hr=textLayout->SetFontStyle(value&Italic?DWRITE_FONT_STYLE_ITALIC:DWRITE_FONT_STYLE_NORMAL, range);
					if(FAILED(hr)) return false;
					hr=textLayout->SetFontWeight(value&Bold?DWRITE_FONT_WEIGHT_BOLD:DWRITE_FONT_WEIGHT_NORMAL, range);
					if(FAILED(hr)) return false;
					hr=textLayout->SetUnderline(value&Underline?TRUE:FALSE, range);
					if(FAILED(hr)) return false;
					hr=textLayout->SetStrikethrough(value&Strikeline?TRUE:FALSE, range);
					if(FAILED(hr)) return false;

					return true;
				}

				bool SetColor(vint start, vint length, Color value)override
				{
					if(length==0) return true;
					ID2D1SolidColorBrush* brush=renderTarget->CreateDirect2DBrush(value);
					usedColors.Add(value);

					DWRITE_TEXT_RANGE range;
					range.startPosition=(int)start;
					range.length=(int)length;
					HRESULT hr=textLayout->SetDrawingEffect(brush, range);
					return !FAILED(hr);
				}

				bool SetInlineObject(vint start, vint length, const InlineObjectProperties& properties, Ptr<IGuiGraphicsElement> value)override
				{
					if(inlineElements.Keys().Contains(value.Obj()))
					{
						return false;
					}
					for(vint i=0;i<inlineElements.Count();i++)
					{
						ComPtr<WindowsDirect2DElementInlineObject> inlineObject=inlineElements.Values().Get(i);
						if(start<inlineObject->GetStart()+inlineObject->GetLength() && inlineObject->GetStart()<start+length)
						{
							return false;
						}
					}
					ComPtr<WindowsDirect2DElementInlineObject> inlineObject=new WindowsDirect2DElementInlineObject(properties, value, start, length);
					DWRITE_TEXT_RANGE range;
					range.startPosition=(int)start;
					range.length=(int)length;
					HRESULT hr=textLayout->SetInlineObject(inlineObject.Obj(), range);
					if(!FAILED(hr))
					{
						IGuiGraphicsRenderer* renderer=value->GetRenderer();
						if(renderer)
						{
							renderer->SetRenderTarget(renderTarget);
						}
						inlineElements.Add(value.Obj(), inlineObject);
						return true;
					}
					else
					{
						return false;
					}
				}

				bool ResetInlineObject(vint start, vint length)override
				{
					for(vint i=0;i<inlineElements.Count();i++)
					{
						IGuiGraphicsElement* element=inlineElements.Keys().Get(i);
						ComPtr<WindowsDirect2DElementInlineObject> inlineObject=inlineElements.Values().Get(i);
						if(inlineObject->GetStart()==start && inlineObject->GetLength()==length)
						{
							DWRITE_TEXT_RANGE range;
							range.startPosition=(int)start;
							range.length=(int)length;
							HRESULT hr=textLayout->SetInlineObject(NULL, range);
							if(!FAILED(hr))
							{
								inlineElements.Remove(element);
								return true;
							}
							else
							{
								return false;
							}
						}
					}
					return false;
				}

				vint GetHeight()override
				{
					DWRITE_TEXT_METRICS metrics;
					textLayout->GetMetrics(&metrics);
					return (vint)metrics.height;
				}

				void Render(Rect bounds)override
				{
					renderTarget->GetDirect2DRenderTarget()->DrawTextLayout(
						D2D1::Point2F((FLOAT)bounds.Left(), (FLOAT)bounds.Top()),
						textLayout.Obj(),
						defaultTextColor,
						D2D1_DRAW_TEXT_OPTIONS_NO_SNAP);
				}
			};

/***********************************************************************
WindowsDirect2DLayoutProvider
***********************************************************************/

			Ptr<IGuiGraphicsParagraph> WindowsDirect2DLayoutProvider::CreateParagraph(const WString& text, IGuiGraphicsRenderTarget* renderTarget)
			{
				return new WindowsDirect2DParagraph(this, text, renderTarget);
			}
		}
	}
}

/***********************************************************************
GraphicsElement\WindowsDirect2D\GuiGraphicsRenderersWindowsDirect2D.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace elements_windows_d2d
		{
			using namespace collections;

/***********************************************************************
IMPLEMENT_BRUSH_ELEMENT_RENDERER
***********************************************************************/

#define IMPLEMENT_BRUSH_ELEMENT_RENDERER(TRENDERER)\
			void TRENDERER::InitializeInternal()\
			{\
			}\
			void TRENDERER::FinalizeInternal()\
			{\
				DestroyBrush(renderTarget);\
			}\
			void TRENDERER::RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)\
			{\
				DestroyBrush(oldRenderTarget);\
				CreateBrush(newRenderTarget);\
			}\
			TRENDERER::TRENDERER()\
				:brush(0)\
			{\
			}\
			void TRENDERER::Render(Rect bounds)\

#define IMPLEMENT_BRUSH_ELEMENT_RENDERER_SOLID_COLOR_BRUSH(TRENDERER)\
			void TRENDERER::CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget)\
			{\
				if(_renderTarget)\
				{\
					oldColor=element->GetColor();\
					brush=_renderTarget->CreateDirect2DBrush(oldColor);\
				}\
			}\
			void TRENDERER::DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget)\
			{\
				if(_renderTarget && brush)\
				{\
					_renderTarget->DestroyDirect2DBrush(oldColor);\
					brush=0;\
				}\
			}\
			void TRENDERER::OnElementStateChanged()\
			{\
				if(renderTarget)\
				{\
					Color color=element->GetColor();\
					if(oldColor!=color)\
					{\
						DestroyBrush(renderTarget);\
						CreateBrush(renderTarget);\
					}\
				}\
			}\

#define IMPLEMENT_BRUSH_ELEMENT_RENDERER_LINEAR_GRADIENT_BRUSH(TRENDERER)\
			void TRENDERER::CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget)\
			{\
				if(_renderTarget)\
				{\
					oldColor=Pair<Color, Color>(element->GetColor1(), element->GetColor2());\
					brush=_renderTarget->CreateDirect2DLinearBrush(oldColor.key, oldColor.value);\
				}\
			}\
			void TRENDERER::DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget)\
			{\
				if(_renderTarget && brush)\
				{\
					_renderTarget->DestroyDirect2DLinearBrush(oldColor.key, oldColor.value);\
					brush=0;\
				}\
			}\
			void TRENDERER::OnElementStateChanged()\
			{\
				if(renderTarget)\
				{\
					Pair<Color, Color> color=Pair<Color, Color>(element->GetColor1(), element->GetColor2());\
					if(oldColor!=color)\
					{\
						DestroyBrush(renderTarget);\
						CreateBrush(renderTarget);\
					}\
				}\
			}\

/***********************************************************************
GuiSolidBorderElementRenderer
***********************************************************************/

			IMPLEMENT_BRUSH_ELEMENT_RENDERER_SOLID_COLOR_BRUSH(GuiSolidBorderElementRenderer)
			IMPLEMENT_BRUSH_ELEMENT_RENDERER(GuiSolidBorderElementRenderer)
			{
				ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
				switch(element->GetShape())
				{
				case ElementShape::Rectangle:
					d2dRenderTarget->DrawRectangle(
						D2D1::RectF((FLOAT)bounds.x1+0.5f, (FLOAT)bounds.y1+0.5f, (FLOAT)bounds.x2-0.5f, (FLOAT)bounds.y2-0.5f),
						brush
						);
					break;
				case ElementShape::Ellipse:
					d2dRenderTarget->DrawEllipse(
						D2D1::Ellipse(D2D1::Point2F((bounds.x1+bounds.x2)/2.0f, (bounds.y1+bounds.y2)/2.0f), bounds.Width()/2.0f, bounds.Height()/2.0f),
						brush
						);
					break;
				}
			}

/***********************************************************************
GuiRoundBorderElementRenderer
***********************************************************************/
				
			IMPLEMENT_BRUSH_ELEMENT_RENDERER_SOLID_COLOR_BRUSH(GuiRoundBorderElementRenderer)
			IMPLEMENT_BRUSH_ELEMENT_RENDERER(GuiRoundBorderElementRenderer)
			{
				ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
				d2dRenderTarget->DrawRoundedRectangle(
					D2D1::RoundedRect(
						D2D1::RectF((FLOAT)bounds.x1+0.5f, (FLOAT)bounds.y1+0.5f, (FLOAT)bounds.x2-0.5f, (FLOAT)bounds.y2-0.5f),
						(FLOAT)element->GetRadius(),
						(FLOAT)element->GetRadius()
						),
					brush
					);
			}

/***********************************************************************
Gui3DBorderElementRenderer
***********************************************************************/

			void Gui3DBorderElementRenderer::CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					oldColor1=element->GetColor1();
					oldColor2=element->GetColor2();
					brush1=_renderTarget->CreateDirect2DBrush(oldColor1);
					brush2=_renderTarget->CreateDirect2DBrush(oldColor2);
				}
			}

			void Gui3DBorderElementRenderer::DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					if(brush1)
					{
						_renderTarget->DestroyDirect2DBrush(oldColor1);
						brush1=0;
					}
					if(brush2)
					{
						_renderTarget->DestroyDirect2DBrush(oldColor2);
						brush2=0;
					}
				}
			}

			void Gui3DBorderElementRenderer::InitializeInternal()
			{
			}

			void Gui3DBorderElementRenderer::FinalizeInternal()
			{
				DestroyBrush(renderTarget);
			}

			void Gui3DBorderElementRenderer::RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)
			{
				DestroyBrush(oldRenderTarget);
				CreateBrush(newRenderTarget);
			}

			Gui3DBorderElementRenderer::Gui3DBorderElementRenderer()
				:brush1(0)
				,brush2(0)
			{
			}

			void Gui3DBorderElementRenderer::Render(Rect bounds)
			{
				D2D1_RECT_F rect=D2D1::RectF((FLOAT)bounds.x1+0.5f, (FLOAT)bounds.y1+0.5f, (FLOAT)bounds.x2-0.5f, (FLOAT)bounds.y2-0.5f);
				ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();

				d2dRenderTarget->DrawLine(D2D1::Point2F(rect.left, rect.top), D2D1::Point2F(rect.right, rect.top), brush1);
				d2dRenderTarget->DrawLine(D2D1::Point2F(rect.left, rect.top), D2D1::Point2F(rect.left, rect.bottom), brush1);
				d2dRenderTarget->DrawLine(D2D1::Point2F(rect.right, rect.bottom), D2D1::Point2F(rect.left, rect.bottom), brush2);
				d2dRenderTarget->DrawLine(D2D1::Point2F(rect.right, rect.bottom), D2D1::Point2F(rect.right, rect.top), brush2);
			}

			void Gui3DBorderElementRenderer::OnElementStateChanged()
			{
				if(renderTarget)
				{
					Color color1=element->GetColor1();
					Color color2=element->GetColor2();
					if(oldColor1!=color1 || oldColor2!=color2)
					{
						DestroyBrush(renderTarget);
						CreateBrush(renderTarget);
					}
				}
			}

/***********************************************************************
Gui3DSplitterElementRenderer
***********************************************************************/

			void Gui3DSplitterElementRenderer::CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					oldColor1=element->GetColor1();
					oldColor2=element->GetColor2();
					brush1=_renderTarget->CreateDirect2DBrush(oldColor1);
					brush2=_renderTarget->CreateDirect2DBrush(oldColor2);
				}
			}

			void Gui3DSplitterElementRenderer::DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					if(brush1)
					{
						_renderTarget->DestroyDirect2DBrush(oldColor1);
						brush1=0;
					}
					if(brush2)
					{
						_renderTarget->DestroyDirect2DBrush(oldColor2);
						brush2=0;
					}
				}
			}

			void Gui3DSplitterElementRenderer::InitializeInternal()
			{
			}

			void Gui3DSplitterElementRenderer::FinalizeInternal()
			{
				DestroyBrush(renderTarget);
			}

			void Gui3DSplitterElementRenderer::RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)
			{
				DestroyBrush(oldRenderTarget);
				CreateBrush(newRenderTarget);
			}

			Gui3DSplitterElementRenderer::Gui3DSplitterElementRenderer()
				:brush1(0)
				,brush2(0)
			{
			}

			void Gui3DSplitterElementRenderer::Render(Rect bounds)
			{
				D2D1_POINT_2F p11, p12, p21, p22;
				switch(element->GetDirection())
				{
				case Gui3DSplitterElement::Horizontal:
					{
						vint y=bounds.y1+bounds.Height()/2-1;
						p11=D2D1::Point2F((FLOAT)bounds.x1, (FLOAT)y+0.5f);
						p12=D2D1::Point2F((FLOAT)bounds.x2, (FLOAT)y+0.5f);
						p21=D2D1::Point2F((FLOAT)bounds.x1, (FLOAT)y+1.5f);
						p22=D2D1::Point2F((FLOAT)bounds.x2, (FLOAT)y+1.5f);
					}
					break;
				case Gui3DSplitterElement::Vertical:
					{
						vint x=bounds.x1+bounds.Width()/2-1;
						p11=D2D1::Point2F((FLOAT)x+0.5f, (FLOAT)bounds.y1-0.0f);
						p12=D2D1::Point2F((FLOAT)x+0.5f, (FLOAT)bounds.y2+0.0f);
						p21=D2D1::Point2F((FLOAT)x+1.5f, (FLOAT)bounds.y1-0.0f);
						p22=D2D1::Point2F((FLOAT)x+1.5f, (FLOAT)bounds.y2+0.0f);
					}
					break;
				}
				ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();

				d2dRenderTarget->DrawLine(p11, p12, brush1);
				d2dRenderTarget->DrawLine(p21, p22, brush2);
			}

			void Gui3DSplitterElementRenderer::OnElementStateChanged()
			{
				if(renderTarget)
				{
					Color color1=element->GetColor1();
					Color color2=element->GetColor2();
					if(oldColor1!=color1 || oldColor2!=color2)
					{
						DestroyBrush(renderTarget);
						CreateBrush(renderTarget);
					}
				}
			}

/***********************************************************************
GuiSolidBackgroundElementRenderer
***********************************************************************/
			
			IMPLEMENT_BRUSH_ELEMENT_RENDERER_SOLID_COLOR_BRUSH(GuiSolidBackgroundElementRenderer)
			IMPLEMENT_BRUSH_ELEMENT_RENDERER(GuiSolidBackgroundElementRenderer)
			{
				ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
				switch(element->GetShape())
				{
				case ElementShape::Rectangle:
					d2dRenderTarget->FillRectangle(
						D2D1::RectF((FLOAT)bounds.x1, (FLOAT)bounds.y1, (FLOAT)bounds.x2, (FLOAT)bounds.y2),
						brush
						);
					break;
				case ElementShape::Ellipse:
					d2dRenderTarget->FillEllipse(
						D2D1::Ellipse(D2D1::Point2F((bounds.x1+bounds.x2)/2.0f, (bounds.y1+bounds.y2)/2.0f), bounds.Width()/2.0f, bounds.Height()/2.0f),
						brush
						);
					break;
				}
			}

/***********************************************************************
GuiGradientBackgroundElementRenderer
***********************************************************************/

			IMPLEMENT_BRUSH_ELEMENT_RENDERER_LINEAR_GRADIENT_BRUSH(GuiGradientBackgroundElementRenderer)
			IMPLEMENT_BRUSH_ELEMENT_RENDERER(GuiGradientBackgroundElementRenderer)
			{
				D2D1_POINT_2F points[2];
				switch(element->GetDirection())
				{
				case GuiGradientBackgroundElement::Horizontal:
					{
						points[0].x=(FLOAT)bounds.x1;
						points[0].y=(FLOAT)bounds.y1;
						points[1].x=(FLOAT)bounds.x2;
						points[1].y=(FLOAT)bounds.y1;
					}
					break;
				case GuiGradientBackgroundElement::Vertical:
					{
						points[0].x=(FLOAT)bounds.x1;
						points[0].y=(FLOAT)bounds.y1;
						points[1].x=(FLOAT)bounds.x1;
						points[1].y=(FLOAT)bounds.y2;
					}
					break;
				case GuiGradientBackgroundElement::Slash:
					{
						points[0].x=(FLOAT)bounds.x2;
						points[0].y=(FLOAT)bounds.y1;
						points[1].x=(FLOAT)bounds.x1;
						points[1].y=(FLOAT)bounds.y2;
					}
					break;
				case GuiGradientBackgroundElement::Backslash:
					{
						points[0].x=(FLOAT)bounds.x1;
						points[0].y=(FLOAT)bounds.y1;
						points[1].x=(FLOAT)bounds.x2;
						points[1].y=(FLOAT)bounds.y2;
					}
					break;
				}

				brush->SetStartPoint(points[0]);
				brush->SetEndPoint(points[1]);
				
				ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
				switch(element->GetShape())
				{
				case ElementShape::Rectangle:
					d2dRenderTarget->FillRectangle(
						D2D1::RectF((FLOAT)bounds.x1, (FLOAT)bounds.y1, (FLOAT)bounds.x2, (FLOAT)bounds.y2),
						brush
						);
					break;
				case ElementShape::Ellipse:
					d2dRenderTarget->FillEllipse(
						D2D1::Ellipse(D2D1::Point2F((bounds.x1+bounds.x2)/2.0f, (bounds.y1+bounds.y2)/2.0f), bounds.Width()/2.0f, bounds.Height()/2.0f),
						brush
						);
					break;
				}
			}

/***********************************************************************
GuiSolidLabelElementRenderer
***********************************************************************/

			void GuiSolidLabelElementRenderer::CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					oldColor=element->GetColor();
					brush=_renderTarget->CreateDirect2DBrush(oldColor);
				}
			}

			void GuiSolidLabelElementRenderer::DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget && brush)
				{
					_renderTarget->DestroyDirect2DBrush(oldColor);
					brush=0;
				}
			}

			void GuiSolidLabelElementRenderer::CreateTextFormat(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					IWindowsDirect2DResourceManager* resourceManager=GetWindowsDirect2DResourceManager();
					oldFont=element->GetFont();
					textFormat=resourceManager->CreateDirect2DTextFormat(oldFont);
				}
			}

			void GuiSolidLabelElementRenderer::DestroyTextFormat(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget && textFormat)
				{
					IWindowsDirect2DResourceManager* resourceManager=GetWindowsDirect2DResourceManager();
					resourceManager->DestroyDirect2DTextFormat(oldFont);
					textFormat=0;
				}
			}

			void GuiSolidLabelElementRenderer::CreateTextLayout()
			{
				if(textFormat)
				{
					HRESULT hr=GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory()->CreateTextLayout(
						oldText.Buffer(),
						(int)oldText.Length(),
						textFormat->textFormat.Obj(),
						0,
						0,
						&textLayout);
					if(!FAILED(hr))
					{
						if(oldFont.underline)
						{
							DWRITE_TEXT_RANGE textRange;
							textRange.startPosition=0;
							textRange.length=(int)oldText.Length();
							textLayout->SetUnderline(TRUE, textRange);
						}
						if(oldFont.strikeline)
						{
							DWRITE_TEXT_RANGE textRange;
							textRange.startPosition=0;
							textRange.length=(int)oldText.Length();
							textLayout->SetStrikethrough(TRUE, textRange);
						}
					}
					else
					{
						textLayout=0;
					}
				}
			}

			void GuiSolidLabelElementRenderer::DestroyTextLayout()
			{
				if(textLayout)
				{
					textLayout->Release();
					textLayout=0;
				}
			}

			void GuiSolidLabelElementRenderer::UpdateMinSize()
			{
				float maxWidth=0;
				DestroyTextLayout();
				bool calculateSizeFromTextLayout=false;
				if(renderTarget)
				{
					if(element->GetWrapLine())
					{
						if(element->GetWrapLineHeightCalculation())
						{
							CreateTextLayout();
							if(textLayout)
							{
								maxWidth=textLayout->GetMaxWidth();
								if(oldMaxWidth!=-1)
								{
									textLayout->SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);
									textLayout->SetMaxWidth((float)oldMaxWidth);
								}
								calculateSizeFromTextLayout=true;
							}
						}
					}
					else
					{
						CreateTextLayout();
						if(textLayout)
						{
							maxWidth=textLayout->GetMaxWidth();
							calculateSizeFromTextLayout=true;
						}
					}
				}
				if(calculateSizeFromTextLayout)
				{
					DWRITE_TEXT_METRICS metrics;
					HRESULT hr=textLayout->GetMetrics(&metrics);
					if(!FAILED(hr))
					{
						vint width=0;
						if(!element->GetEllipse() && !element->GetWrapLine() && !element->GetMultiline())
						{
							width=(vint)ceil(metrics.widthIncludingTrailingWhitespace);
						}
						minSize=Size(width, (vint)ceil(metrics.height));
					}
					textLayout->SetMaxWidth(maxWidth);
				}
				else
				{
					minSize=Size();
				}
			}

			void GuiSolidLabelElementRenderer::InitializeInternal()
			{
			}

			void GuiSolidLabelElementRenderer::FinalizeInternal()
			{
				DestroyTextLayout();
				DestroyBrush(renderTarget);
				DestroyTextFormat(renderTarget);
			}

			void GuiSolidLabelElementRenderer::RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)
			{
				DestroyBrush(oldRenderTarget);
				DestroyTextFormat(oldRenderTarget);
				CreateBrush(newRenderTarget);
				CreateTextFormat(newRenderTarget);
				UpdateMinSize();
			}

			GuiSolidLabelElementRenderer::GuiSolidLabelElementRenderer()
				:brush(0)
				,textFormat(0)
				,textLayout(0)
				,oldText(L"")
				,oldMaxWidth(-1)
			{
			}

			void GuiSolidLabelElementRenderer::Render(Rect bounds)
			{
				if(!textLayout)
				{
					CreateTextLayout();
				}

				vint x=0;
				vint y=0;
				switch(element->GetHorizontalAlignment())
				{
				case Alignment::Left:
					x=bounds.Left();
					break;
				case Alignment::Center:
					x=bounds.Left()+(bounds.Width()-minSize.x)/2;
					break;
				case Alignment::Right:
					x=bounds.Right()-minSize.x;
					break;
				}
				switch(element->GetVerticalAlignment())
				{
				case Alignment::Top:
					y=bounds.Top();
					break;
				case Alignment::Center:
					y=bounds.Top()+(bounds.Height()-minSize.y)/2;
					break;
				case Alignment::Bottom:
					y=bounds.Bottom()-minSize.y;
					break;
				}

				renderTarget->SetTextAntialias(oldFont.antialias, oldFont.verticalAntialias);

				if(!element->GetEllipse() && !element->GetMultiline() && !element->GetWrapLine())
				{
					ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
					d2dRenderTarget->DrawTextLayout(
						D2D1::Point2F((FLOAT)x, (FLOAT)y),
						textLayout,
						brush,
						D2D1_DRAW_TEXT_OPTIONS_NO_SNAP
						);
				}
				else
				{
					IDWriteFactory* dwriteFactory=GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory();
					DWRITE_TRIMMING trimming;
					IDWriteInlineObject* inlineObject;
					textLayout->GetTrimming(&trimming, &inlineObject);

					textLayout->SetWordWrapping(element->GetWrapLine()?DWRITE_WORD_WRAPPING_WRAP:DWRITE_WORD_WRAPPING_NO_WRAP);
					if(element->GetEllipse())
					{
						textLayout->SetTrimming(&textFormat->trimming, textFormat->ellipseInlineObject.Obj());
					}
					switch(element->GetHorizontalAlignment())
					{
					case Alignment::Left:
						textLayout->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
						break;
					case Alignment::Center:
						textLayout->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
						break;
					case Alignment::Right:
						textLayout->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_TRAILING);
						break;
					}
					if(!element->GetMultiline() && !element->GetWrapLine())
					{
						switch(element->GetVerticalAlignment())
						{
						case Alignment::Top:
							textLayout->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
							break;
						case Alignment::Center:
							textLayout->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
							break;
						case Alignment::Bottom:
							textLayout->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_FAR);
							break;
						}
					}

					Rect textBounds=bounds;
					if(element->GetEllipse() && !element->GetMultiline() && !element->GetWrapLine())
					{
						textBounds=Rect(Point(textBounds.x1, y), Size(bounds.Width(), minSize.y));
					}

					textLayout->SetMaxWidth((FLOAT)textBounds.Width());
					textLayout->SetMaxHeight((FLOAT)textBounds.Height());

					ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
					d2dRenderTarget->DrawTextLayout(
						D2D1::Point2F((FLOAT)textBounds.Left(), (FLOAT)textBounds.Top()),
						textLayout,
						brush,
						D2D1_DRAW_TEXT_OPTIONS_NO_SNAP
						);

					textLayout->SetTrimming(&trimming, inlineObject);
					if(oldMaxWidth!=textBounds.Width())
					{
						oldMaxWidth=textBounds.Width();
						UpdateMinSize();
					}
				}
			}

			void GuiSolidLabelElementRenderer::OnElementStateChanged()
			{
				if(renderTarget)
				{
					Color color=element->GetColor();
					if(oldColor!=color)
					{
						DestroyBrush(renderTarget);
						CreateBrush(renderTarget);
					}

					FontProperties font=element->GetFont();
					if(oldFont!=font)
					{
						DestroyTextFormat(renderTarget);
						CreateTextFormat(renderTarget);
					}
				}
				oldText=element->GetText();
				UpdateMinSize();
			}

/***********************************************************************
GuiImageFrameElementRenderer
***********************************************************************/

			void GuiImageFrameElementRenderer::UpdateBitmap(IWindowsDirect2DRenderTarget* renderTarget)
			{
				if(renderTarget && element->GetImage())
				{
					INativeImageFrame* frame=element->GetImage()->GetFrame(element->GetFrameIndex());
					bitmap=renderTarget->GetBitmap(frame, element->GetEnabled());
					minSize=frame->GetSize();
				}
				else
				{
					bitmap=0;
					minSize=Size(0, 0);
				}
			}

			void GuiImageFrameElementRenderer::InitializeInternal()
			{
			}

			void GuiImageFrameElementRenderer::FinalizeInternal()
			{
			}

			void GuiImageFrameElementRenderer::RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)
			{
				UpdateBitmap(newRenderTarget);
			}

			GuiImageFrameElementRenderer::GuiImageFrameElementRenderer()
			{
			}

			void GuiImageFrameElementRenderer::Render(Rect bounds)
			{
				if(bitmap)
				{
					ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
					D2D1_RECT_F source=D2D1::RectF(0, 0, (FLOAT)minSize.x, (FLOAT)minSize.y);
					D2D1_RECT_F destination;
					if(element->GetStretch())
					{
						destination=D2D1::RectF((FLOAT)bounds.x1, (FLOAT)bounds.y1, (FLOAT)bounds.x2, (FLOAT)bounds.y2);
					}
					else
					{
						vint x=0;
						vint y=0;
						switch(element->GetHorizontalAlignment())
						{
						case Alignment::Left:
							x=bounds.Left();
							break;
						case Alignment::Center:
							x=bounds.Left()+(bounds.Width()-minSize.x)/2;
							break;
						case Alignment::Right:
							x=bounds.Right()-minSize.x;
							break;
						}
						switch(element->GetVerticalAlignment())
						{
						case Alignment::Top:
							y=bounds.Top();
							break;
						case Alignment::Center:
							y=bounds.Top()+(bounds.Height()-minSize.y)/2;
							break;
						case Alignment::Bottom:
							y=bounds.Bottom()-minSize.y;
							break;
						}
						destination=D2D1::RectF((FLOAT)x, (FLOAT)y, (FLOAT)(x+minSize.x), (FLOAT)(y+minSize.y));
					}
					if(element->GetImage()->GetFormat()==INativeImage::Gif &&  element->GetFrameIndex()>0)
					{
						vint max=element->GetFrameIndex();
						for(vint i=0;i<=max;i++)
						{
							ComPtr<ID2D1Bitmap> frameBitmap=renderTarget->GetBitmap(element->GetImage()->GetFrame(i), element->GetEnabled());
							d2dRenderTarget->DrawBitmap(frameBitmap.Obj(), destination, 1.0f, D2D1_BITMAP_INTERPOLATION_MODE_LINEAR, source);
						}
					}
					else
					{
						d2dRenderTarget->DrawBitmap(bitmap.Obj(), destination, 1.0f, D2D1_BITMAP_INTERPOLATION_MODE_LINEAR, source);
					}
				}
			}

			void GuiImageFrameElementRenderer::OnElementStateChanged()
			{
				UpdateBitmap(renderTarget);
			}

/***********************************************************************
GuiPolygonElementRenderer
***********************************************************************/

			void GuiPolygonElementRenderer::CreateGeometry()
			{
				oldPoints.Resize(element->GetPointCount());
				if(oldPoints.Count()>0)
				{
					memcpy(&oldPoints[0], &element->GetPoint(0), sizeof(Point)*element->GetPointCount());
				}
				if(oldPoints.Count()>=3)
				{
					ID2D1PathGeometry* pg=0;
					GetWindowsDirect2DObjectProvider()->GetDirect2DFactory()->CreatePathGeometry(&pg);
					if(pg)
					{
						geometry=pg;
						FillGeometry(Point(0, 0));
					}
				}
			}

			void GuiPolygonElementRenderer::DestroyGeometry()
			{
				if(geometry)
				{
					geometry=0;
				}
			}

			void GuiPolygonElementRenderer::FillGeometry(Point offset)
			{
				if(geometry)
				{
					ID2D1GeometrySink* pgs=0;
					geometry->Open(&pgs);
					if(pgs)
					{
						D2D1_POINT_2F p;
						p.x=(FLOAT)(oldPoints[0].x+offset.x)+0.5f;
						p.y=(FLOAT)(oldPoints[0].y+offset.y)+0.5f;
						pgs->BeginFigure(p, D2D1_FIGURE_BEGIN_FILLED);
						for(vint i=1;i<oldPoints.Count();i++)
						{
							p.x=(FLOAT)(oldPoints[i].x+offset.x)+0.5f;
							p.y=(FLOAT)(oldPoints[i].y+offset.y)+0.5f;
							pgs->AddLine(p);
						}
						pgs->EndFigure(D2D1_FIGURE_END_CLOSED);
						pgs->Close();
						pgs->Release();
					}
				}
			}

			void GuiPolygonElementRenderer::RecreateResource(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)
			{
				if(oldRenderTarget==newRenderTarget)
				{
					if(oldRenderTarget)
					{
						if(oldBorderColor!=element->GetBorderColor())
						{
							oldRenderTarget->DestroyDirect2DBrush(oldBorderColor);
							oldBorderColor=element->GetBorderColor();
							borderBrush=newRenderTarget->CreateDirect2DBrush(oldBorderColor);
						}
						if(oldBackgroundColor!=element->GetBackgroundColor())
						{
							oldRenderTarget->DestroyDirect2DBrush(oldBackgroundColor);
							oldBackgroundColor=element->GetBackgroundColor();
							backgroundBrush=newRenderTarget->CreateDirect2DBrush(oldBackgroundColor);
						}
					}
				}
				else
				{
					if(oldRenderTarget)
					{
						oldRenderTarget->DestroyDirect2DBrush(oldBorderColor);
						oldRenderTarget->DestroyDirect2DBrush(oldBackgroundColor);
					}
					if(newRenderTarget)
					{
						oldBorderColor=element->GetBorderColor();
						oldBackgroundColor=element->GetBackgroundColor();
						borderBrush=newRenderTarget->CreateDirect2DBrush(oldBorderColor);
						backgroundBrush=newRenderTarget->CreateDirect2DBrush(oldBackgroundColor);
					}
				}
			}

			void GuiPolygonElementRenderer::InitializeInternal()
			{
				oldBorderColor=element->GetBorderColor();
				oldBackgroundColor=element->GetBackgroundColor();
				RecreateResource(0, renderTarget);
				CreateGeometry();
			}

			void GuiPolygonElementRenderer::FinalizeInternal()
			{
				DestroyGeometry();
				RecreateResource(renderTarget, 0);
			}

			void GuiPolygonElementRenderer::RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)
			{
				RecreateResource(oldRenderTarget, newRenderTarget);
			}

			GuiPolygonElementRenderer::GuiPolygonElementRenderer()
				:borderBrush(0)
				,backgroundBrush(0)
				,geometry(0)
			{
			}

			void GuiPolygonElementRenderer::Render(Rect bounds)
			{
				if(renderTarget && geometry)
				{
					ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
					vint offsetX=(bounds.Width()-minSize.x)/2+bounds.x1;
					vint offsetY=(bounds.Height()-minSize.y)/2+bounds.y1;

					D2D1_MATRIX_3X2_F oldT, newT;
					d2dRenderTarget->GetTransform(&oldT);
					newT=D2D1::Matrix3x2F::Translation((FLOAT)offsetX, (FLOAT)offsetY);
					d2dRenderTarget->SetTransform(&newT);

					d2dRenderTarget->FillGeometry(geometry.Obj(), backgroundBrush);
					d2dRenderTarget->DrawGeometry(geometry.Obj(), borderBrush);
					d2dRenderTarget->SetTransform(&oldT);
				}
			}

			void GuiPolygonElementRenderer::OnElementStateChanged()
			{
				minSize=element->GetSize();
				RecreateResource(renderTarget, renderTarget);

				bool polygonModified=false;
				if(oldPoints.Count()!=element->GetPointCount())
				{
					polygonModified=true;
				}
				else
				{
					for(vint i=0;i<oldPoints.Count();i++)
					{
						if(oldPoints[i]!=element->GetPoint(i))
						{
							polygonModified=true;
							break;
						}
					}
				}
				if(polygonModified)
				{
					DestroyGeometry();
					CreateGeometry();
				}
			}

/***********************************************************************
GuiColorizedTextElementRenderer
***********************************************************************/

			void GuiColorizedTextElementRenderer::CreateTextBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					colors.Resize(element->GetColors().Count());
					for(vint i=0;i<colors.Count();i++)
					{
						text::ColorEntry entry=element->GetColors().Get(i);
						ColorEntryResource newEntry;

						newEntry.normal.text=entry.normal.text;
						newEntry.normal.textBrush=_renderTarget->CreateDirect2DBrush(newEntry.normal.text);
						newEntry.normal.background=entry.normal.background;
						newEntry.normal.backgroundBrush=_renderTarget->CreateDirect2DBrush(newEntry.normal.background);
						newEntry.selectedFocused.text=entry.selectedFocused.text;
						newEntry.selectedFocused.textBrush=_renderTarget->CreateDirect2DBrush(newEntry.selectedFocused.text);
						newEntry.selectedFocused.background=entry.selectedFocused.background;
						newEntry.selectedFocused.backgroundBrush=_renderTarget->CreateDirect2DBrush(newEntry.selectedFocused.background);
						newEntry.selectedUnfocused.text=entry.selectedUnfocused.text;
						newEntry.selectedUnfocused.textBrush=_renderTarget->CreateDirect2DBrush(newEntry.selectedUnfocused.text);
						newEntry.selectedUnfocused.background=entry.selectedUnfocused.background;
						newEntry.selectedUnfocused.backgroundBrush=_renderTarget->CreateDirect2DBrush(newEntry.selectedUnfocused.background);
						colors[i]=newEntry;
					}
				}
			}

			void GuiColorizedTextElementRenderer::DestroyTextBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					for(vint i=0;i<colors.Count();i++)
					{
						_renderTarget->DestroyDirect2DBrush(colors[i].normal.text);
						_renderTarget->DestroyDirect2DBrush(colors[i].normal.background);
						_renderTarget->DestroyDirect2DBrush(colors[i].selectedFocused.text);
						_renderTarget->DestroyDirect2DBrush(colors[i].selectedFocused.background);
						_renderTarget->DestroyDirect2DBrush(colors[i].selectedUnfocused.text);
						_renderTarget->DestroyDirect2DBrush(colors[i].selectedUnfocused.background);
					}
					colors.Resize(0);
				}
			}

			void GuiColorizedTextElementRenderer::CreateCaretBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					oldCaretColor=element->GetCaretColor();
					caretBrush=_renderTarget->CreateDirect2DBrush(oldCaretColor);
				}
			}

			void GuiColorizedTextElementRenderer::DestroyCaretBrush(IWindowsDirect2DRenderTarget* _renderTarget)
			{
				if(_renderTarget)
				{
					if(caretBrush)
					{
						_renderTarget->DestroyDirect2DBrush(oldCaretColor);
						caretBrush=0;
					}
				}
			}

			void GuiColorizedTextElementRenderer::ColorChanged()
			{
				DestroyTextBrush(renderTarget);
				CreateTextBrush(renderTarget);
			}

			void GuiColorizedTextElementRenderer::FontChanged()
			{
				IWindowsDirect2DResourceManager* resourceManager=GetWindowsDirect2DResourceManager();
				if(textFormat)
				{
					resourceManager->DestroyDirect2DTextFormat(oldFont);
					resourceManager->DestroyDirect2DCharMeasurer(oldFont);
				}
				oldFont=element->GetFont();
				textFormat=resourceManager->CreateDirect2DTextFormat(oldFont);
				element->GetLines().SetCharMeasurer(resourceManager->CreateDirect2DCharMeasurer(oldFont).Obj());
			}

			text::CharMeasurer* GuiColorizedTextElementRenderer::GetCharMeasurer()
			{
				return 0;
			}

			void GuiColorizedTextElementRenderer::InitializeInternal()
			{
				textFormat=0;
				caretBrush=0;
				element->SetCallback(this);
			}

			void GuiColorizedTextElementRenderer::FinalizeInternal()
			{
				DestroyTextBrush(renderTarget);
				DestroyCaretBrush(renderTarget);

				IWindowsDirect2DResourceManager* resourceManager=GetWindowsDirect2DResourceManager();
				if(textFormat)
				{
					resourceManager->DestroyDirect2DTextFormat(oldFont);
					resourceManager->DestroyDirect2DCharMeasurer(oldFont);
				}
			}

			void GuiColorizedTextElementRenderer::RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)
			{
				DestroyTextBrush(oldRenderTarget);
				DestroyCaretBrush(oldRenderTarget);
				CreateTextBrush(newRenderTarget);
				CreateCaretBrush(newRenderTarget);
				element->GetLines().SetRenderTarget(newRenderTarget);
			}

			void GuiColorizedTextElementRenderer::Render(Rect bounds)
			{
				if(renderTarget)
				{
					ID2D1RenderTarget* d2dRenderTarget=renderTarget->GetDirect2DRenderTarget();
					wchar_t passwordChar=element->GetPasswordChar();
					Point viewPosition=element->GetViewPosition();
					Rect viewBounds(viewPosition, bounds.GetSize());
					vint startRow=element->GetLines().GetTextPosFromPoint(Point(viewBounds.x1, viewBounds.y1)).row;
					vint endRow=element->GetLines().GetTextPosFromPoint(Point(viewBounds.x2, viewBounds.y2)).row;
					TextPos selectionBegin=element->GetCaretBegin()<element->GetCaretEnd()?element->GetCaretBegin():element->GetCaretEnd();
					TextPos selectionEnd=element->GetCaretBegin()>element->GetCaretEnd()?element->GetCaretBegin():element->GetCaretEnd();
					bool focused=element->GetFocused();
					
					renderTarget->SetTextAntialias(oldFont.antialias, oldFont.verticalAntialias);

					for(vint row=startRow;row<=endRow;row++)
					{
						Rect startRect=element->GetLines().GetRectFromTextPos(TextPos(row, 0));
						Point startPoint=startRect.LeftTop();
						vint startColumn=element->GetLines().GetTextPosFromPoint(Point(viewBounds.x1, startPoint.y)).column;
						vint endColumn=element->GetLines().GetTextPosFromPoint(Point(viewBounds.x2, startPoint.y)).column;
						text::TextLine& line=element->GetLines().GetLine(row);

						vint x=startColumn==0?0:line.att[startColumn-1].rightOffset;
						for(vint column=startColumn; column<=endColumn; column++)
						{
							bool inSelection=false;
							if(selectionBegin.row==selectionEnd.row)
							{
								inSelection=(row==selectionBegin.row && selectionBegin.column<=column && column<selectionEnd.column);
							}
							else if(row==selectionBegin.row)
							{
								inSelection=selectionBegin.column<=column;
							}
							else if(row==selectionEnd.row)
							{
								inSelection=column<selectionEnd.column;
							}
							else
							{
								inSelection=selectionBegin.row<row && row<selectionEnd.row;
							}
							
							bool crlf=column==line.dataLength;
							vint colorIndex=crlf?0:line.att[column].colorIndex;
							if(colorIndex>=colors.Count())
							{
								colorIndex=0;
							}
							ColorItemResource& color=
								!inSelection?colors[colorIndex].normal:
								focused?colors[colorIndex].selectedFocused:
								colors[colorIndex].selectedUnfocused;
							vint x2=crlf?x+startRect.Height()/2:line.att[column].rightOffset;
							vint tx=x-viewPosition.x+bounds.x1;
							vint ty=startPoint.y-viewPosition.y+bounds.y1;
							
							if(color.background.a>0)
							{
								d2dRenderTarget->FillRectangle(D2D1::RectF((FLOAT)tx, (FLOAT)ty, (FLOAT)(tx+(x2-x)), (FLOAT)(ty+startRect.Height())), color.backgroundBrush);
							}
							if(!crlf)
							{
								d2dRenderTarget->DrawText(
									(passwordChar?&passwordChar:&line.text[column]),
									1,
									textFormat->textFormat.Obj(),
									D2D1::RectF((FLOAT)tx, (FLOAT)ty, (FLOAT)tx+1, (FLOAT)ty+1),
									color.textBrush,
									D2D1_DRAW_TEXT_OPTIONS_NO_SNAP,
									DWRITE_MEASURING_MODE_GDI_NATURAL
									);
							}
							x=x2;
						}
					}

					if(element->GetCaretVisible() && element->GetLines().IsAvailable(element->GetCaretEnd()))
					{
						Point caretPoint=element->GetLines().GetPointFromTextPos(element->GetCaretEnd());
						vint height=element->GetLines().GetRowHeight();
						Point p1(caretPoint.x-viewPosition.x+bounds.x1, caretPoint.y-viewPosition.y+bounds.y1+1);
						Point p2(caretPoint.x-viewPosition.x+bounds.x1, caretPoint.y+height-viewPosition.y+bounds.y1-1);
						d2dRenderTarget->DrawLine(
							D2D1::Point2F((FLOAT)p1.x+0.5f, (FLOAT)p1.y),
							D2D1::Point2F((FLOAT)p2.x+0.5f, (FLOAT)p2.y),
							caretBrush
							);
						d2dRenderTarget->DrawLine(
							D2D1::Point2F((FLOAT)p1.x-0.5f, (FLOAT)p1.y),
							D2D1::Point2F((FLOAT)p2.x-0.5f, (FLOAT)p2.y),
							caretBrush
							);
					}
				}
			}

			void GuiColorizedTextElementRenderer::OnElementStateChanged()
			{
				if(renderTarget)
				{
					Color caretColor=element->GetCaretColor();
					if(oldCaretColor!=caretColor)
					{
						DestroyCaretBrush(renderTarget);
						CreateCaretBrush(renderTarget);
					}
				}
			}

/***********************************************************************
GuiDirect2DElementRenderer
***********************************************************************/

			void GuiDirect2DElementRenderer::InitializeInternal()
			{
			}

			void GuiDirect2DElementRenderer::FinalizeInternal()
			{
			}

			void GuiDirect2DElementRenderer::RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget)
			{
				IDWriteFactory* fdw=GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory();
				ID2D1Factory* fd2d=GetWindowsDirect2DObjectProvider()->GetDirect2DFactory();
				if(oldRenderTarget)
				{
					GuiDirect2DElementEventArgs arguments(element, oldRenderTarget->GetDirect2DRenderTarget(), fdw, fd2d, Rect());
					element->BeforeRenderTargetChanged.Execute(arguments);
				}
				if(newRenderTarget)
				{
					GuiDirect2DElementEventArgs arguments(element, newRenderTarget->GetDirect2DRenderTarget(), fdw, fd2d, Rect());
					element->AfterRenderTargetChanged.Execute(arguments);
				}
			}

			GuiDirect2DElementRenderer::GuiDirect2DElementRenderer()
			{
			}

			GuiDirect2DElementRenderer::~GuiDirect2DElementRenderer()
			{
			}
			
			void GuiDirect2DElementRenderer::Render(Rect bounds)
			{
				if(renderTarget)
				{
					IDWriteFactory* fdw=GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory();
					ID2D1Factory* fd2d=GetWindowsDirect2DObjectProvider()->GetDirect2DFactory();
					renderTarget->PushClipper(bounds);
					if(!renderTarget->IsClipperCoverWholeTarget())
					{
						ID2D1RenderTarget* rt=renderTarget->GetDirect2DRenderTarget();
						GuiDirect2DElementEventArgs arguments(element, rt, fdw, fd2d, bounds);
						element->Rendering.Execute(arguments);
					}
					renderTarget->PopClipper();
				}
			}

			void GuiDirect2DElementRenderer::OnElementStateChanged()
			{
			}
		}
	}
}

/***********************************************************************
GraphicsElement\WindowsDirect2D\GuiGraphicsWindowsDirect2D.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
GuiDirect2DElement
***********************************************************************/

			GuiDirect2DElement::GuiDirect2DElement()
			{
			}

			GuiDirect2DElement::~GuiDirect2DElement()
			{
			}
		}

		namespace elements_windows_d2d
		{
			using namespace elements;
			using namespace collections;

			D2D1::ColorF GetD2DColor(Color color)
			{
				return D2D1::ColorF(color.r/255.0f, color.g/255.0f, color.b/255.0f, color.a/255.0f);
			}

/***********************************************************************
CachedResourceAllocator
***********************************************************************/

			class CachedSolidBrushAllocator
			{
				DEFINE_CACHED_RESOURCE_ALLOCATOR(Color, ComPtr<ID2D1SolidColorBrush>)

				IWindowsDirect2DRenderTarget*	guiRenderTarget;
			public:
				CachedSolidBrushAllocator()
					:guiRenderTarget(0)
				{
				}

				void SetRenderTarget(IWindowsDirect2DRenderTarget* _guiRenderTarget)
				{
					guiRenderTarget=_guiRenderTarget;
				}

				ComPtr<ID2D1SolidColorBrush> CreateInternal(Color color)
				{
					ID2D1SolidColorBrush* brush=0;
					ID2D1RenderTarget* renderTarget=guiRenderTarget->GetDirect2DRenderTarget();
					HRESULT hr=renderTarget->CreateSolidColorBrush(GetD2DColor(color), &brush);
					if(!FAILED(hr))
					{
						return brush;
					}
					else
					{
						return 0;
					}
				}
			};

			class CachedLinearBrushAllocator
			{
				typedef Pair<Color, Color> ColorPair;
				DEFINE_CACHED_RESOURCE_ALLOCATOR(ColorPair, ComPtr<ID2D1LinearGradientBrush>)

				IWindowsDirect2DRenderTarget*	guiRenderTarget;
			public:
				CachedLinearBrushAllocator()
					:guiRenderTarget(0)
				{
				}

				void SetRenderTarget(IWindowsDirect2DRenderTarget* _guiRenderTarget)
				{
					guiRenderTarget=_guiRenderTarget;
				}

				ComPtr<ID2D1LinearGradientBrush> CreateInternal(ColorPair colors)
				{
					ID2D1RenderTarget* renderTarget=guiRenderTarget->GetDirect2DRenderTarget();
					ID2D1GradientStopCollection* stopCollection=0;
					{
						D2D1_GRADIENT_STOP stops[2];
						stops[0].color=GetD2DColor(colors.key);
						stops[0].position=0.0f;
						stops[1].color=GetD2DColor(colors.value);
						stops[1].position=1.0f;

						HRESULT hr=renderTarget->CreateGradientStopCollection(
							stops,
							2,
							D2D1_GAMMA_2_2,
							D2D1_EXTEND_MODE_CLAMP,
							&stopCollection);
						if(FAILED(hr)) return 0;
					}

					ID2D1LinearGradientBrush* brush=0;
					{
						D2D1_POINT_2F points[2]={{0, 0}, {0, 0}};
						HRESULT hr=renderTarget->CreateLinearGradientBrush(
							D2D1::LinearGradientBrushProperties(points[0], points[1]),
							stopCollection,
							&brush);
						stopCollection->Release();
						if(FAILED(hr)) return 0;
					}
					return brush;
				}
			};

			class CachedTextFormatAllocator
			{
			private:
				DEFINE_CACHED_RESOURCE_ALLOCATOR(FontProperties, Ptr<Direct2DTextFormatPackage>)
			public:

				static ComPtr<IDWriteTextFormat> CreateDirect2DFont(const FontProperties& fontProperties)
				{
					IDWriteFactory* dwriteFactory=GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory();
					IDWriteTextFormat* format=0;
					HRESULT hr=dwriteFactory->CreateTextFormat(
						fontProperties.fontFamily.Buffer(),
						NULL,
						(fontProperties.bold?DWRITE_FONT_WEIGHT_BOLD:DWRITE_FONT_WEIGHT_NORMAL),
						(fontProperties.italic?DWRITE_FONT_STYLE_ITALIC:DWRITE_FONT_STYLE_NORMAL),
						DWRITE_FONT_STRETCH_NORMAL,
						(FLOAT)fontProperties.size,
						L"",
						&format);
					if(!FAILED(hr))
					{
						format->SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP);
						return format;
					}
					else
					{
						return 0;
					}
				}

				Ptr<Direct2DTextFormatPackage> CreateInternal(const FontProperties& fontProperties)
				{
					Ptr<Direct2DTextFormatPackage> textFormat=new Direct2DTextFormatPackage;
					textFormat->textFormat=CreateDirect2DFont(fontProperties);
					textFormat->trimming.granularity=DWRITE_TRIMMING_GRANULARITY_CHARACTER;
					textFormat->trimming.delimiter=0;
					textFormat->trimming.delimiterCount=0;

					IDWriteInlineObject* ellipseInlineObject=0;
					GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory()->CreateEllipsisTrimmingSign(textFormat->textFormat.Obj(), &ellipseInlineObject);
					textFormat->ellipseInlineObject=ellipseInlineObject;
					return textFormat;
				}
			};

			class CachedCharMeasurerAllocator
			{
				DEFINE_CACHED_RESOURCE_ALLOCATOR(FontProperties, Ptr<text::CharMeasurer>)

			protected:
				class Direct2DCharMeasurer : public text::CharMeasurer
				{
				protected:
					ComPtr<IDWriteTextFormat>		font;
					vint								size;

					Size MeasureInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)
					{
						Size charSize(0, 0);
						IDWriteTextLayout* textLayout=0;
						HRESULT hr=GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory()->CreateTextLayout(
							&character,
							1,
							font.Obj(),
							0,
							0,
							&textLayout);
						if(!FAILED(hr))
						{
							DWRITE_TEXT_METRICS metrics;
							hr=textLayout->GetMetrics(&metrics);
							if(!FAILED(hr))
							{
								charSize=Size((vint)ceil(metrics.widthIncludingTrailingWhitespace), (vint)ceil(metrics.height));
							}
							textLayout->Release();
						}
						return charSize;
					}

					vint MeasureWidthInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)
					{
						return MeasureInternal(character, renderTarget).x;
					}

					vint GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)
					{
						return MeasureInternal(L' ', renderTarget).y;
					}
				public:
					Direct2DCharMeasurer(ComPtr<IDWriteTextFormat> _font, vint _size)
						:text::CharMeasurer(_size)
						,size(_size)
						,font(_font)
					{
					}
				};
			public:
				Ptr<text::CharMeasurer> CreateInternal(const FontProperties& value)
				{
					return new Direct2DCharMeasurer(CachedTextFormatAllocator::CreateDirect2DFont(value), value.size);
				}
			};

/***********************************************************************
WindowsDirect2DRenderTarget
***********************************************************************/

			class WindowsDirect2DImageFrameCache : public Object, public INativeImageFrameCache
			{
			protected:
				IWindowsDirect2DRenderTarget*	renderTarget;
				INativeImageFrame*				cachedFrame;
				ComPtr<ID2D1Bitmap>				bitmap;
				ComPtr<ID2D1Bitmap>				disabledBitmap;
			public:
				WindowsDirect2DImageFrameCache(IWindowsDirect2DRenderTarget* _renderTarget)
					:renderTarget(_renderTarget)
				{
				}

				~WindowsDirect2DImageFrameCache()
				{
				}

				void OnAttach(INativeImageFrame* frame)override
				{
					cachedFrame=frame;
 					ID2D1Bitmap* d2dBitmap=0;
					HRESULT hr=renderTarget->GetDirect2DRenderTarget()->CreateBitmapFromWicBitmap(
						GetWindowsDirect2DObjectProvider()->GetWICBitmap(frame),
						&d2dBitmap
						);
					if(SUCCEEDED(hr))
					{
						bitmap=d2dBitmap;
					}
				}
				
				void OnDetach(INativeImageFrame* frame)override
				{
					renderTarget->DestroyBitmapCache(cachedFrame);
				}

				INativeImageFrame* GetFrame()
				{
					return cachedFrame;
				}

				ComPtr<ID2D1Bitmap> GetBitmap(bool enabled)
				{
					if(enabled)
					{
						return bitmap;
					}
					else
					{
						if(!disabledBitmap)
						{
							IWICBitmap* frameBitmap=GetWindowsDirect2DObjectProvider()->GetWICBitmap(cachedFrame);
 							ID2D1Bitmap* d2dBitmap=0;
							HRESULT hr=renderTarget->GetDirect2DRenderTarget()->CreateBitmapFromWicBitmap(
								frameBitmap,
								&d2dBitmap
								);
							if(SUCCEEDED(hr))
							{
								disabledBitmap=d2dBitmap;

								WICRect rect;
								rect.X=0;
								rect.Y=0;
								rect.Width=bitmap->GetPixelSize().width;
								rect.Height=bitmap->GetPixelSize().height;
								BYTE* buffer=new BYTE[rect.Width*rect.Height*4];
								hr=frameBitmap->CopyPixels(&rect, rect.Width*4, rect.Width*rect.Height*4, buffer);
								if(SUCCEEDED(hr))
								{
									vint count=rect.Width*rect.Height;
									BYTE* read=buffer;
									for(vint i=0;i<count;i++)
									{
										BYTE g=(read[0]+read[1]+read[2])/6+read[3]/2;
										read[0]=g;
										read[1]=g;
										read[2]=g;
										read+=4;
									}
									D2D1_RECT_U d2dRect;
									d2dRect.left=0;
									d2dRect.top=0;
									d2dRect.right=rect.Width;
									d2dRect.bottom=rect.Height;
									d2dBitmap->CopyFromMemory(&d2dRect, buffer, rect.Width*4);
								}
								delete[] buffer;
							}
						}
						return disabledBitmap;
					}
				}
			};

			class WindowsDirect2DRenderTarget : public Object, public IWindowsDirect2DRenderTarget
			{
				typedef SortedList<Ptr<WindowsDirect2DImageFrameCache>> ImageCacheList;
			protected:
				INativeWindow*					window;
				ID2D1RenderTarget*				d2dRenderTarget;
				List<Rect>						clippers;
				vint								clipperCoverWholeTargetCounter;

				CachedSolidBrushAllocator		solidBrushes;
				CachedLinearBrushAllocator		linearBrushes;
				ImageCacheList					imageCaches;

				ComPtr<IDWriteRenderingParams>	noAntialiasParams;
				ComPtr<IDWriteRenderingParams>	horizontalAntialiasParams;
				ComPtr<IDWriteRenderingParams>	bidirectionalAntialiasParams;

				ComPtr<IDWriteRenderingParams> CreateRenderingParams(DWRITE_RENDERING_MODE renderingMode, IDWriteRenderingParams* defaultParams, IDWriteFactory* dwriteFactory)
				{
					IDWriteRenderingParams* renderingParams=0;
					FLOAT gamma=defaultParams->GetGamma();
					FLOAT enhancedContrast=defaultParams->GetEnhancedContrast();
					FLOAT clearTypeLevel=defaultParams->GetClearTypeLevel();
					DWRITE_PIXEL_GEOMETRY pixelGeometry=defaultParams->GetPixelGeometry();
					HRESULT hr=dwriteFactory->CreateCustomRenderingParams(
						gamma,
						enhancedContrast,
						clearTypeLevel,
						pixelGeometry,
						renderingMode,
						&renderingParams);
					if(!FAILED(hr))
					{
						return renderingParams;
					}
					else
					{
						return 0;
					}
				}
			public:
				WindowsDirect2DRenderTarget(INativeWindow* _window)
					:window(_window)
					,d2dRenderTarget(0)
					,clipperCoverWholeTargetCounter(0)
				{
					solidBrushes.SetRenderTarget(this);
					linearBrushes.SetRenderTarget(this);

					IDWriteFactory* dwriteFactory=GetWindowsDirect2DObjectProvider()->GetDirectWriteFactory();
					IDWriteRenderingParams* defaultParams=0;
					HRESULT hr=dwriteFactory->CreateRenderingParams(&defaultParams);
					if(!FAILED(hr))
					{
						noAntialiasParams=CreateRenderingParams(DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL, defaultParams, dwriteFactory);
						horizontalAntialiasParams=CreateRenderingParams(DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL, defaultParams, dwriteFactory);
						bidirectionalAntialiasParams=CreateRenderingParams(DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC, defaultParams, dwriteFactory);
						defaultParams->Release();
					}
				}

				~WindowsDirect2DRenderTarget()
				{
					while(imageCaches.Count())
					{
						Ptr<WindowsDirect2DImageFrameCache> cache=imageCaches[imageCaches.Count()-1];
						cache->GetFrame()->RemoveCache(this);
					}
				}

				ID2D1RenderTarget* GetDirect2DRenderTarget()override
				{
					return d2dRenderTarget?d2dRenderTarget:GetWindowsDirect2DObjectProvider()->GetNativeWindowDirect2DRenderTarget(window);
				}

				ComPtr<ID2D1Bitmap> GetBitmap(INativeImageFrame* frame, bool enabled)override
				{
					Ptr<INativeImageFrameCache> cache=frame->GetCache(this);
					if(cache)
					{
						return cache.Cast<WindowsDirect2DImageFrameCache>()->GetBitmap(enabled);
					}
					else
					{
						Ptr<WindowsDirect2DImageFrameCache> d2dCache=new WindowsDirect2DImageFrameCache(this);
						if(frame->SetCache(this, d2dCache))
						{
							imageCaches.Add(d2dCache);
							return d2dCache->GetBitmap(enabled);
						}
						else
						{
							return 0;
						}
					}
				}

				void DestroyBitmapCache(INativeImageFrame* frame)override
				{
					WindowsDirect2DImageFrameCache* cache=frame->GetCache(this).Cast<WindowsDirect2DImageFrameCache>().Obj();
					imageCaches.Remove(cache);
				}

				void SetTextAntialias(bool antialias, bool verticalAntialias)override
				{
					ComPtr<IDWriteRenderingParams> params;
					if(!antialias)
					{
						params=noAntialiasParams;
					}
					else if(!verticalAntialias)
					{
						params=horizontalAntialiasParams;
					}
					else
					{
						params=bidirectionalAntialiasParams;
					}
					if(params && d2dRenderTarget)
					{
						d2dRenderTarget->SetTextRenderingParams(params.Obj());
					}
				}

				void StartRendering()override
				{
					d2dRenderTarget=GetWindowsDirect2DObjectProvider()->GetNativeWindowDirect2DRenderTarget(window);
					d2dRenderTarget->BeginDraw();
					d2dRenderTarget->Clear(D2D1::ColorF(D2D1::ColorF::Black));
				}

				void StopRendering()override
				{
					d2dRenderTarget->EndDraw();
					d2dRenderTarget=0;
				}

				void PushClipper(Rect clipper)override
				{
					if(clipperCoverWholeTargetCounter>0)
					{
						clipperCoverWholeTargetCounter++;
					}
					else
					{
						Rect previousClipper=GetClipper();
						Rect currentClipper;

						currentClipper.x1=(previousClipper.x1>clipper.x1?previousClipper.x1:clipper.x1);
						currentClipper.y1=(previousClipper.y1>clipper.y1?previousClipper.y1:clipper.y1);
						currentClipper.x2=(previousClipper.x2<clipper.x2?previousClipper.x2:clipper.x2);
						currentClipper.y2=(previousClipper.y2<clipper.y2?previousClipper.y2:clipper.y2);

						if(currentClipper.x1<currentClipper.x2 && currentClipper.y1<currentClipper.y2)
						{
							clippers.Add(currentClipper);
							d2dRenderTarget->PushAxisAlignedClip(
								D2D1::RectF((FLOAT)currentClipper.x1, (FLOAT)currentClipper.y1, (FLOAT)currentClipper.x2, (FLOAT)currentClipper.y2),
								D2D1_ANTIALIAS_MODE_PER_PRIMITIVE
								);
						}
						else
						{
							clipperCoverWholeTargetCounter++;
						}
					}
				}

				void PopClipper()override
				{
					if(clippers.Count()>0)
					{
						if(clipperCoverWholeTargetCounter>0)
						{
							clipperCoverWholeTargetCounter--;
						}
						else
						{
							clippers.RemoveAt(clippers.Count()-1);
							d2dRenderTarget->PopAxisAlignedClip();
						}
					}
				}

				Rect GetClipper()override
				{
					if(clippers.Count()==0)
					{
						return Rect(Point(0, 0), window->GetClientSize());
					}
					else
					{
						return clippers[clippers.Count()-1];
					}
				}

				bool IsClipperCoverWholeTarget()override
				{
					return clipperCoverWholeTargetCounter>0;
				}

				ID2D1SolidColorBrush* CreateDirect2DBrush(Color color)override
				{
					return solidBrushes.Create(color).Obj();
				}

				void DestroyDirect2DBrush(Color color)override
				{
					solidBrushes.Destroy(color);
				}

				ID2D1LinearGradientBrush* CreateDirect2DLinearBrush(Color c1, Color c2)override
				{
					return linearBrushes.Create(Pair<Color, Color>(c1, c2)).Obj();
				}

				void DestroyDirect2DLinearBrush(Color c1, Color c2)override
				{
					linearBrushes.Destroy(Pair<Color, Color>(c1, c2));
				}
			};

/***********************************************************************
WindowsGDIResourceManager
***********************************************************************/

			class WindowsDirect2DResourceManager : public GuiGraphicsResourceManager, public IWindowsDirect2DResourceManager, public INativeControllerListener
			{
			protected:
				SortedList<Ptr<WindowsDirect2DRenderTarget>>		renderTargets;
				Ptr<WindowsDirect2DLayoutProvider>					layoutProvider;

				CachedTextFormatAllocator							textFormats;
				CachedCharMeasurerAllocator							charMeasurers;
			public:
				WindowsDirect2DResourceManager()
				{
					layoutProvider=new WindowsDirect2DLayoutProvider;
				}

				IGuiGraphicsRenderTarget* GetRenderTarget(INativeWindow* window)override
				{
					return GetWindowsDirect2DObjectProvider()->GetBindedRenderTarget(window);
				}

				IGuiGraphicsLayoutProvider* GetLayoutProvider()override
				{
					return layoutProvider.Obj();
				}

				void NativeWindowCreated(INativeWindow* window)override
				{
					WindowsDirect2DRenderTarget* renderTarget=new WindowsDirect2DRenderTarget(window);
					renderTargets.Add(renderTarget);
					GetWindowsDirect2DObjectProvider()->SetBindedRenderTarget(window, renderTarget);
				}

				void NativeWindowDestroying(INativeWindow* window)override
				{
					WindowsDirect2DRenderTarget* renderTarget=dynamic_cast<WindowsDirect2DRenderTarget*>(GetWindowsDirect2DObjectProvider()->GetBindedRenderTarget(window));
					GetWindowsDirect2DObjectProvider()->SetBindedRenderTarget(window, 0);
					renderTargets.Remove(renderTarget);
				}

				Direct2DTextFormatPackage* CreateDirect2DTextFormat(const FontProperties& fontProperties)override
				{
					return textFormats.Create(fontProperties).Obj();
				}

				void DestroyDirect2DTextFormat(const FontProperties& fontProperties)override
				{
					textFormats.Destroy(fontProperties);
				}

				Ptr<elements::text::CharMeasurer> CreateDirect2DCharMeasurer(const FontProperties& fontProperties)override
				{
					return charMeasurers.Create(fontProperties);
				}

				void DestroyDirect2DCharMeasurer(const FontProperties& fontProperties)override
				{
					charMeasurers.Destroy(fontProperties);
				}
			};
		}

		namespace elements_windows_d2d
		{
			IWindowsDirect2DResourceManager* windowsDirect2DResourceManager=0;

			IWindowsDirect2DResourceManager* GetWindowsDirect2DResourceManager()
			{
				return windowsDirect2DResourceManager;
			}

			void SetWindowsDirect2DResourceManager(IWindowsDirect2DResourceManager* resourceManager)
			{
				windowsDirect2DResourceManager=resourceManager;
			}

/***********************************************************************
OS Supporting
***********************************************************************/

			IWindowsDirect2DObjectProvider* windowsDirect2DObjectProvider=0;

			IWindowsDirect2DObjectProvider* GetWindowsDirect2DObjectProvider()
			{
				return windowsDirect2DObjectProvider;
			}

			void SetWindowsDirect2DObjectProvider(IWindowsDirect2DObjectProvider* provider)
			{
				windowsDirect2DObjectProvider=provider;
			}
		}
	}
}

/***********************************************************************
NativeMain
***********************************************************************/

using namespace vl::presentation;
using namespace vl::presentation::elements;

void RendererMainDirect2D()
{
	elements_windows_d2d::WindowsDirect2DResourceManager resourceManager;
	SetGuiGraphicsResourceManager(&resourceManager);
	elements_windows_d2d::SetWindowsDirect2DResourceManager(&resourceManager);
	GetCurrentController()->CallbackService()->InstallListener(&resourceManager);

	elements_windows_d2d::GuiSolidBorderElementRenderer::Register();
	elements_windows_d2d::GuiRoundBorderElementRenderer::Register();
	elements_windows_d2d::Gui3DBorderElementRenderer::Register();
	elements_windows_d2d::Gui3DSplitterElementRenderer::Register();
	elements_windows_d2d::GuiSolidBackgroundElementRenderer::Register();
	elements_windows_d2d::GuiGradientBackgroundElementRenderer::Register();
	elements_windows_d2d::GuiSolidLabelElementRenderer::Register();
	elements_windows_d2d::GuiImageFrameElementRenderer::Register();
	elements_windows_d2d::GuiPolygonElementRenderer::Register();
	elements_windows_d2d::GuiColorizedTextElementRenderer::Register();
	elements_windows_d2d::GuiDirect2DElementRenderer::Register();
	elements::GuiDocumentElement::GuiDocumentElementRenderer::Register();

	GuiApplicationMain();
	elements_windows_d2d::SetWindowsDirect2DResourceManager(0);
	SetGuiGraphicsResourceManager(0);
}

/***********************************************************************
GraphicsElement\WindowsGDI\GuiGraphicsLayoutProviderWindowsGDI.cpp
***********************************************************************/
#include <usp10.h>

#pragma comment(lib, "usp10.lib")

bool operator==(const SCRIPT_ITEM&, const SCRIPT_ITEM&){return false;}
bool operator!=(const SCRIPT_ITEM&, const SCRIPT_ITEM&){return false;}

bool operator==(const SCRIPT_VISATTR&, const SCRIPT_VISATTR&){return false;}
bool operator!=(const SCRIPT_VISATTR&, const SCRIPT_VISATTR&){return false;}

bool operator==(const GOFFSET&, const GOFFSET&){return false;}
bool operator!=(const GOFFSET&, const GOFFSET&){return false;}

bool operator==(const SCRIPT_LOGATTR&, const SCRIPT_LOGATTR&){return false;}
bool operator!=(const SCRIPT_LOGATTR&, const SCRIPT_LOGATTR&){return false;}

namespace vl
{
	namespace presentation
	{
		using namespace elements;
		using namespace collections;
		using namespace windows;
		using namespace regex;

		namespace elements_windows_gdi
		{

/***********************************************************************
Uniscribe Operations (UniscribeFragment)
***********************************************************************/

			struct UniscribeFragment
			{
				FontProperties									fontStyle;
				Color											fontColor;
				WString											text;
				Ptr<WinFont>									fontObject;

				Ptr<IGuiGraphicsElement>						element;
				IGuiGraphicsParagraph::InlineObjectProperties	inlineObjectProperties;
				List<Ptr<UniscribeFragment>>					cachedTextFragment;

				WString GetFingerprint()
				{
					return fontStyle.fontFamily+L"#"
						+itow(fontStyle.size)+L"#"
						+(fontStyle.bold?L"B":L"N")+L"#"
						+(fontStyle.italic?L"I":L"N")+L"#"
						+(fontStyle.underline?L"U":L"N")+L"#"
						+(fontStyle.strikeline?L"S":L"N")+L"#"
						;
				}

				Ptr<UniscribeFragment> Copy()
				{
					Ptr<UniscribeFragment> fragment=new UniscribeFragment;
					fragment->fontStyle=fontStyle;
					fragment->fontColor=fontColor;
					fragment->text=text;
					fragment->fontObject=fontObject;
					return fragment;
				}
			};

/***********************************************************************
Uniscribe Operations (UniscribeGlyphData)
***********************************************************************/

			struct UniscribeGlyphData
			{
				Array<WORD>					glyphs;
				Array<SCRIPT_VISATTR>		glyphVisattrs;
				Array<int>					glyphAdvances;
				Array<GOFFSET>				glyphOffsets;
				Array<WORD>					charCluster;
				ABC							runAbc;
				SCRIPT_ANALYSIS				sa;

				UniscribeGlyphData()
				{
					ClearUniscribeData(0, 0);
				}

				void ClearUniscribeData(vint glyphCount, vint length)
				{
					glyphs.Resize(glyphCount);
					glyphVisattrs.Resize(glyphCount);
					glyphAdvances.Resize(glyphCount);
					glyphOffsets.Resize(glyphCount);
					charCluster.Resize(length);
					memset(&runAbc, 0, sizeof(runAbc));
					memset(&sa, 0, sizeof(sa));
				}
			
				bool BuildUniscribeData(WinDC* dc, SCRIPT_ITEM* scriptItem, SCRIPT_CACHE& scriptCache, const wchar_t* runText, vint length)
				{
					vint glyphCount=glyphs.Count();
					bool resizeGlyphData=false;
					if(glyphCount==0)
					{
						glyphCount=(vint)(1.5*length+16);
						resizeGlyphData=true;
					}
					sa=scriptItem->a;
					{
						// generate shape information
						WinDC* dcParameter=0;
						if(resizeGlyphData)
						{
							glyphs.Resize(glyphCount);
							glyphVisattrs.Resize(glyphCount);
							charCluster.Resize(length);
						}

						while(true)
						{
							int availableGlyphCount=0;
							HRESULT hr=ScriptShape(
								(dcParameter?dcParameter->GetHandle():NULL),
								&scriptCache,
								runText,
								(int)length,
								(int)glyphCount,
								&sa,
								&glyphs[0],
								&charCluster[0],
								&glyphVisattrs[0],
								&availableGlyphCount
								);
							if(hr==0)
							{
								glyphCount=availableGlyphCount;
								break;
							}
							else if(hr==E_PENDING)
							{
								dcParameter=dc;
							}
							else if(hr==E_OUTOFMEMORY)
							{
								if(resizeGlyphData)
								{
									glyphCount+=length;
								}
								else
								{
									goto BUILD_UNISCRIBE_DATA_FAILED;
								}
							}
							else if(hr==USP_E_SCRIPT_NOT_IN_FONT)
							{
								if(sa.eScript==SCRIPT_UNDEFINED)
								{
									goto BUILD_UNISCRIBE_DATA_FAILED;
								}
								else
								{
									sa.eScript=SCRIPT_UNDEFINED;
								}
							}
							else
							{
								goto BUILD_UNISCRIBE_DATA_FAILED;
							}
						}
						if(resizeGlyphData)
						{
							glyphs.Resize(glyphCount);
							glyphVisattrs.Resize(glyphCount);
						}
					}
					{
						// generate place information
						WinDC* dcParameter=0;
						if(resizeGlyphData)
						{
							glyphAdvances.Resize(glyphCount);
							glyphOffsets.Resize(glyphCount);
						}
						while(true)
						{
							HRESULT hr=ScriptPlace(
								(dcParameter?dcParameter->GetHandle():NULL),
								&scriptCache,
								&glyphs[0],
								(int)glyphCount,
								&glyphVisattrs[0],
								&sa,
								&glyphAdvances[0],
								&glyphOffsets[0],
								&runAbc
								);
							if(hr==0)
							{
								break;
							}
							else if(hr==E_PENDING)
							{
								dcParameter=dc;
							}
							else
							{
								goto BUILD_UNISCRIBE_DATA_FAILED;
							}
						}
					}

					return true;
		BUILD_UNISCRIBE_DATA_FAILED:
					return false;
				}
			};

/***********************************************************************
Uniscribe Operations (UniscribeRun)
***********************************************************************/

			class UniscribeRun : public Object
			{
			public:
				struct RunFragmentBounds
				{
					vint							start;
					vint							length;
					Rect						bounds;

					bool operator==(const RunFragmentBounds&){return false;}
					bool operator!=(const RunFragmentBounds&){return false;}
				};

				UniscribeFragment*				documentFragment;
				SCRIPT_ITEM*					scriptItem;
				vint								start;
				vint								length;
				const wchar_t*					runText;
				List<RunFragmentBounds>			fragmentBounds;

				UniscribeRun()
					:documentFragment(0)
					,scriptItem(0)
					,start(0)
					,length(0)
				{
				}

				~UniscribeRun()
				{
				}

				virtual bool					BuildUniscribeData(WinDC* dc)=0;
				virtual vint						SumWidth(vint charStart, vint charLength)=0;
				virtual vint						SumHeight()=0;
				virtual void					SearchForLineBreak(vint tempStart, vint maxWidth, bool firstRun, vint& charLength, vint& charAdvances)=0;
				virtual void					Render(WinDC* dc, vint fragmentBoundsIndex, vint offsetX, vint offsetY)=0;
			};

/***********************************************************************
Uniscribe Operations (UniscribeTextRun)
***********************************************************************/

			class UniscribeTextRun : public UniscribeRun
			{
			public:
				SCRIPT_CACHE					scriptCache;
				Array<SCRIPT_LOGATTR>			charLogattrs;
				vint								advance;
				UniscribeGlyphData				wholeGlyph;

				UniscribeTextRun()
					:scriptCache(0)
					,advance(0)
				{
				}

				~UniscribeTextRun()
				{
					ClearUniscribeData();
				}

				void ClearUniscribeData()
				{
					if(scriptCache)
					{
						ScriptFreeCache(&scriptCache);
						scriptCache=0;
					}
					charLogattrs.Resize(0);
					advance=0;
					wholeGlyph.ClearUniscribeData(0, 0);
				}

				void SearchGlyphCluster(vint charStart, vint charLength, vint& cluster, vint& nextCluster)
				{
					cluster=wholeGlyph.charCluster[charStart];
					nextCluster
						=charStart+charLength==length
						?wholeGlyph.glyphs.Count()
						:wholeGlyph.charCluster[charStart+charLength];
				}

				bool BuildUniscribeData(WinDC* dc)override
				{
					ClearUniscribeData();
					{
						// generate break information
						charLogattrs.Resize(length);

						HRESULT hr=ScriptBreak(
							runText,
							(int)length,
							&scriptItem->a,
							&charLogattrs[0]
							);
						if(hr!=0)
						{
							goto BUILD_UNISCRIBE_DATA_FAILED;
						}
					}

					dc->SetFont(documentFragment->fontObject);
					if(!wholeGlyph.BuildUniscribeData(dc, scriptItem, scriptCache, runText, length))
					{
						goto BUILD_UNISCRIBE_DATA_FAILED;
					}
					advance=wholeGlyph.runAbc.abcA+wholeGlyph.runAbc.abcB+wholeGlyph.runAbc.abcC;

					return true;
		BUILD_UNISCRIBE_DATA_FAILED:
					ClearUniscribeData();
					return false;
				}

				vint SumWidth(vint charStart, vint charLength)override
				{
					vint cluster=0;
					vint nextCluster=0;
					SearchGlyphCluster(charStart, charLength, cluster, nextCluster);
					vint width=0;
					for(vint i=cluster;i<nextCluster;i++)
					{
						width+=wholeGlyph.glyphAdvances[i];
					}
					return width;
				}

				vint SumHeight()override
				{
					return documentFragment->fontStyle.size;
				}

				void SearchForLineBreak(vint tempStart, vint maxWidth, bool firstRun, vint& charLength, vint& charAdvances)override
				{
					vint width=0;
					charLength=0;
					charAdvances=0;
					for(vint i=tempStart;i<=length;)
					{
						if(i==length || charLogattrs[i].fSoftBreak==TRUE)
						{
							if(width<=maxWidth || (firstRun && charLength==0))
							{
								charLength=i-tempStart;
								charAdvances=width;
							}
							else
							{
								return;
							}
						}
						if(i==length) break;

						vint cluster=wholeGlyph.charCluster[i];
						vint clusterLength=1;
						while(i+clusterLength<length)
						{
							if(wholeGlyph.charCluster[i+clusterLength]==cluster)
							{
								clusterLength++;
							}
							else
							{
								break;
							}
						}

						vint nextCluster
							=i+clusterLength==length
							?wholeGlyph.glyphs.Count()
							:wholeGlyph.charCluster[i+clusterLength];
						for(vint j=cluster;j<nextCluster;j++)
						{
							width+=wholeGlyph.glyphAdvances[j];
						}
						i+=clusterLength;
					}
				}

				void Render(WinDC* dc, vint fragmentBoundsIndex, vint offsetX, vint offsetY)override
				{
					Color fontColor=documentFragment->fontColor;
					dc->SetFont(documentFragment->fontObject);
					dc->SetTextColor(RGB(fontColor.r, fontColor.g, fontColor.b));

					RunFragmentBounds fragment=fragmentBounds[fragmentBoundsIndex];
					RECT rect;
					rect.left=(int)(fragment.bounds.Left()+offsetX);
					rect.top=(int)(fragment.bounds.Top()+offsetY);
					rect.right=(int)(fragment.bounds.Right()+offsetX);
					rect.bottom=(int)(fragment.bounds.Bottom()+offsetY);
			
					vint cluster=0;
					vint nextCluster=0;
					SearchGlyphCluster(fragment.start, fragment.length, cluster, nextCluster);

					HRESULT hr=ScriptTextOut(
						dc->GetHandle(),
						&scriptCache,
						rect.left,
						rect.top,
						0,
						&rect,
						&wholeGlyph.sa,
						NULL,
						0,
						&wholeGlyph.glyphs[cluster],
						(int)(nextCluster-cluster),
						&wholeGlyph.glyphAdvances[cluster],
						NULL,
						&wholeGlyph.glyphOffsets[cluster]
						);
				}
			};

/***********************************************************************
Uniscribe Operations (UniscribeElementRun)
***********************************************************************/

			class UniscribeElementRun : public UniscribeRun
			{
			public:
				Ptr<IGuiGraphicsElement>						element;
				IGuiGraphicsParagraph::InlineObjectProperties	properties;

				UniscribeElementRun()
				{
				}

				~UniscribeElementRun()
				{
				}

				bool BuildUniscribeData(WinDC* dc)override
				{
					return true;
				}

				vint SumWidth(vint charStart, vint charLength)override
				{
					return properties.size.x;
				}

				vint SumHeight()override
				{
					return properties.size.y;
				}

				void SearchForLineBreak(vint tempStart, vint maxWidth, bool firstRun, vint& charLength, vint& charAdvances)override
				{
					charLength=length-tempStart;
					charAdvances=properties.size.x;
				}

				void Render(WinDC* dc, vint fragmentBoundsIndex, vint offsetX, vint offsetY)override
				{
					Rect bounds=fragmentBounds[fragmentBoundsIndex].bounds;
					bounds.x1+=offsetX;
					bounds.x2+=offsetX;
					bounds.y1+=offsetY;
					bounds.y2+=offsetY;
					IGuiGraphicsRenderer* renderer=element->GetRenderer();
					if(renderer)
					{
						renderer->Render(bounds);
					}
				}
			};

/***********************************************************************
Uniscribe Operations (UniscribeLine)
***********************************************************************/

			class UniscribeLine : public Object
			{
			public:
				List<Ptr<UniscribeFragment>>	documentFragments;

				WString							lineText;
				Array<SCRIPT_ITEM>				scriptItems;
				List<Ptr<UniscribeRun>>			scriptRuns;
				Array<int>						runVisualToLogical;
				Array<int>						runLogicalToVisual;
				Rect							bounds;

				void CLearUniscribeData()
				{
					scriptItems.Resize(0);
					scriptRuns.Clear();
					runVisualToLogical.Resize(0);
					runLogicalToVisual.Resize(0);
				}

				bool BuildUniscribeData(WinDC* dc)
				{
					lineText=L"";
					CLearUniscribeData();
					vint current=0;
					FOREACH(Ptr<UniscribeFragment>, fragment, documentFragments)
					{
						lineText+=fragment->text;
						current+=fragment->text.Length();
					}

					if(lineText!=L"")
					{
						{
							SCRIPT_DIGITSUBSTITUTE sds={0};
							ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
							SCRIPT_CONTROL sc={0};
							SCRIPT_STATE ss={0};
							ScriptApplyDigitSubstitution(&sds, &sc, &ss);

							// itemize a line
							scriptItems.Resize(lineText.Length()+2);
							int scriptItemCount=0;
							HRESULT hr=ScriptItemize(
								lineText.Buffer(),
								(int)lineText.Length(),
								(int)(scriptItems.Count()-1),
								&sc,
								&ss,
								&scriptItems[0],
								&scriptItemCount
								);
							if(hr!=0)
							{
								goto BUILD_UNISCRIBE_DATA_FAILED;
							}
							scriptItems.Resize(scriptItemCount+1);
						}
						{
							// use item and document fragment information to produce runs
							// one item is constructed by one or more runs
							// characters in each run contains the same style
							vint fragmentIndex=0;
							vint fragmentStart=0;
							for(vint i=0;i<scriptItems.Count()-1;i++)
							{
								SCRIPT_ITEM* scriptItem=&scriptItems[i];
								vint start=scriptItem[0].iCharPos;
								vint length=scriptItem[1].iCharPos-scriptItem[0].iCharPos;
								vint currentStart=start;

								while(currentStart<start+length)
								{
									UniscribeFragment* fragment=0;
									vint itemRemainLength=length-(currentStart-start);
									vint fragmentRemainLength=0;
									while(true)
									{
										fragment=documentFragments[fragmentIndex].Obj();
										fragmentRemainLength=fragment->text.Length()-(currentStart-fragmentStart);
										if(fragmentRemainLength<=0)
										{
											fragmentStart+=fragment->text.Length();
											fragmentIndex++;
										}
										else
										{
											break;
										}
									}
									vint shortLength=itemRemainLength<fragmentRemainLength?itemRemainLength:fragmentRemainLength;
									bool skip=false;
									{
										vint elementCurrent=0;
										FOREACH(Ptr<UniscribeFragment>, elementFragment, documentFragments)
										{
											vint elementLength=elementFragment->text.Length();
											if(elementFragment->element)
											{
												if(elementCurrent<=currentStart && currentStart+shortLength<=elementCurrent+elementLength)
												{
													if(elementCurrent==currentStart)
													{
														Ptr<UniscribeElementRun> run=new UniscribeElementRun;
														run->documentFragment=fragment;
														run->scriptItem=scriptItem;
														run->start=currentStart;
														run->length=elementLength;
														run->runText=lineText.Buffer()+currentStart;
														run->element=elementFragment->element;
														run->properties=elementFragment->inlineObjectProperties;
														scriptRuns.Add(run);
													}
													skip=true;
													break;
												}
											}
											elementCurrent+=elementLength;
										}
									}
									if(!skip)
									{
										Ptr<UniscribeTextRun> run=new UniscribeTextRun;
										run->documentFragment=fragment;
										run->scriptItem=scriptItem;
										run->start=currentStart;
										run->length=shortLength;
										run->runText=lineText.Buffer()+currentStart;
										scriptRuns.Add(run);
									}
									currentStart+=shortLength;
								}
							}

							// for each run, generate shape information
							FOREACH(Ptr<UniscribeRun>, run, scriptRuns)
							{
								if(!run->BuildUniscribeData(dc))
								{
									goto BUILD_UNISCRIBE_DATA_FAILED;
								}
							}

							// layout runs if there are RTL text
							Array<BYTE> levels(scriptRuns.Count());
							runVisualToLogical.Resize(scriptRuns.Count());
							runLogicalToVisual.Resize(scriptRuns.Count());
							for(vint i=0;i<scriptRuns.Count();i++)
							{
								levels[i]=scriptRuns[i]->scriptItem->a.s.uBidiLevel;
							}
							ScriptLayout((int)levels.Count(), &levels[0], &runVisualToLogical[0], &runLogicalToVisual[0]);
						}
					}
					return true;
		BUILD_UNISCRIBE_DATA_FAILED:
					CLearUniscribeData();
					return false;
				}

				void Render(WinDC* dc, vint offsetX, vint offsetY)
				{
					FOREACH(Ptr<UniscribeRun>, run, scriptRuns)
					{
						for(vint i=0;i<run->fragmentBounds.Count();i++)
						{
							run->Render(dc, i, offsetX, offsetY);
						}
					}
				}
			};

/***********************************************************************
Uniscribe Operations (UniscribeParagraph)
***********************************************************************/

			class UniscribeParagraph : public Object
			{
			public:
				List<Ptr<UniscribeFragment>>	documentFragments;
				bool							built;

				List<Ptr<UniscribeLine>>		lines;
				vint								lastAvailableWidth;
				Rect							bounds;

				UniscribeParagraph()
					:lastAvailableWidth(-1)
					,built(false)
				{
				}

				~UniscribeParagraph()
				{
					ClearUniscribeData();
				}

				void ClearUniscribeData()
				{
					FOREACH(Ptr<UniscribeFragment>, fragment, documentFragments)
					{
						GetWindowsGDIResourceManager()->DestroyGdiFont(fragment->fontStyle);
						fragment->fontObject=0;
					}
					lines.Clear();
					lastAvailableWidth=-1;
				}

				void BuildUniscribeData(WinDC* dc)
				{
					if(!built)
					{
						built=true;
						ClearUniscribeData();
						Dictionary<WString, Ptr<WinFont>> fonts;
						FOREACH(Ptr<UniscribeFragment>, fragment, documentFragments)
						{
							if(!fragment->fontObject)
							{
								WString fragmentFingerPrint=fragment->GetFingerprint();
								vint index=fonts.Keys().IndexOf(fragmentFingerPrint);
								if(index==-1)
								{
									fragment->fontObject=GetWindowsGDIResourceManager()->CreateGdiFont(fragment->fontStyle);
									fonts.Add(fragmentFingerPrint, fragment->fontObject);
								}
								else
								{
									fragment->fontObject=fonts.Values().Get(index);
								}
							}
						}
						{
							Regex regexLine(L"\r\n");
							Ptr<UniscribeLine> line;
							FOREACH(Ptr<UniscribeFragment>, fragment, documentFragments)
							{
								if(fragment->element)
								{
									if(!line)
									{
										line=new UniscribeLine;
										lines.Add(line);
									}
									line->documentFragments.Add(fragment);
								}
								else
								{
									RegexMatch::List textLines;
									regexLine.Split(fragment->text, true, textLines);

									for(vint i=0;i<textLines.Count();i++)
									{
										WString text=textLines[i]->Result().Value();
										if(i>0)
										{
											line=0;
										}
										if(!line)
										{
											line=new UniscribeLine;
											lines.Add(line);
										}

										if(textLines.Count()==1)
										{
											line->documentFragments.Add(fragment);
										}
										else
										{
											Ptr<UniscribeFragment> runFragment=fragment->Copy();
											runFragment->text=text;
											line->documentFragments.Add(runFragment);
										}
									}
								}
							}
						}

						FOREACH(Ptr<UniscribeLine>, line, lines)
						{
							line->BuildUniscribeData(dc);
						}
					}
				}

				void Layout(vint availableWidth)
				{
					if(lastAvailableWidth==availableWidth)
					{
						return;
					}
					lastAvailableWidth=availableWidth;

					vint cx=0;
					vint cy=0;
					FOREACH(Ptr<UniscribeLine>, line, lines)
					{
						if(line->scriptRuns.Count()==0)
						{
							// if this line doesn't contains any run, skip and render a blank line
							vint height=line->documentFragments[0]->fontStyle.size;
							line->bounds=Rect(Point(cx, cy), Size(0, height));
							cy+=height;
						}
						else
						{
							FOREACH(Ptr<UniscribeRun>, run, line->scriptRuns)
							{
								run->fragmentBounds.Clear();
							}

							// render this line into linces with auto line wrapping
							vint startRun=0;
							vint startRunOffset=0;
							vint lastRun=0;
							vint lastRunOffset=0;
							vint currentWidth=0;

							while(startRun<line->scriptRuns.Count())
							{
								vint currentWidth=0;
								bool firstRun=true;
								// search for a range to fit in the given width
								for(vint i=startRun;i<line->scriptRuns.Count();i++)
								{
									vint charLength=0;
									vint charAdvances=0;
									UniscribeRun* run=line->scriptRuns[line->runVisualToLogical[i]].Obj();
									run->SearchForLineBreak(lastRunOffset, availableWidth-currentWidth, firstRun, charLength, charAdvances);
									firstRun=false;

									if(charLength==run->length-lastRunOffset)
									{
										lastRun=i+1;
										lastRunOffset=0;
										currentWidth+=charAdvances;
									}
									else
									{
										lastRun=i;
										lastRunOffset=lastRunOffset+charLength;
										break;
									}
								}

								// if the range is empty, than this should be the end of line, ignore it
								if(startRun<lastRun || (startRun==lastRun && startRunOffset<lastRunOffset))
								{
									// calculate the max line height in this range;
									vint maxHeight=0;
									for(vint i=startRun;i<=lastRun && i<line->scriptRuns.Count();i++)
									{
										if(i==lastRun && lastRunOffset==0)
										{
											break;
										}
										vint size=line->scriptRuns[line->runVisualToLogical[i]]->SumHeight();
										if(maxHeight<size)
										{
											maxHeight=size;
										}
									}

									// render all runs inside this range
									for(vint i=startRun;i<=lastRun && i<line->scriptRuns.Count();i++)
									{
										UniscribeRun* run=line->scriptRuns[line->runVisualToLogical[i]].Obj();
										vint start=i==startRun?startRunOffset:0;
										vint end=i==lastRun?lastRunOffset:run->length;
										vint length=end-start;

										UniscribeRun::RunFragmentBounds fragmentBounds;
										fragmentBounds.start=start;
										fragmentBounds.length=length;
										fragmentBounds.bounds=Rect(
											Point(cx, cy+maxHeight-run->SumHeight()),
											Size(run->SumWidth(start, length), run->SumHeight())
											);
										run->fragmentBounds.Add(fragmentBounds);

										cx+=run->SumWidth(start, length);
									}

									cx=0;
									cy+=(vint)(maxHeight*1.5);
								}

								startRun=lastRun;
								startRunOffset=lastRunOffset;
							}

							// calculate line bounds
							vint minX=0;
							vint minY=0;
							vint maxX=0;
							vint maxY=0;
							FOREACH(Ptr<UniscribeRun>, run, line->scriptRuns)
							{
								FOREACH(UniscribeRun::RunFragmentBounds, fragmentBounds, run->fragmentBounds)
								{
									Rect bounds=fragmentBounds.bounds;
									if(minX>bounds.Left()) minX=bounds.Left();
									if(minY>bounds.Top()) minX=bounds.Top();
									if(maxX<bounds.Right()) maxX=bounds.Right();
									if(maxY<bounds.Bottom()) maxY=bounds.Bottom();
								}
							}
							line->bounds=Rect(minX, minY, maxX, maxY);
						}
					}

					// calculate paragraph bounds
					vint minX=0;
					vint minY=0;
					vint maxX=0;
					vint maxY=0;
					FOREACH(Ptr<UniscribeLine>, line, lines)
					{
						Rect bounds=line->bounds;
						if(minX>bounds.Left()) minX=bounds.Left();
						if(minY>bounds.Top()) minX=bounds.Top();
						if(maxX<bounds.Right()) maxX=bounds.Right();
						if(maxY<bounds.Bottom()) maxY=bounds.Bottom();
					}
					bounds=Rect(minX, minY, maxX, maxY);
				}

				void Render(WinDC* dc, vint offsetX, vint offsetY)
				{
					FOREACH(Ptr<UniscribeLine>, line, lines)
					{
						line->Render(dc, offsetX, offsetY);
					}
				}

				//-------------------------------------------------------------------------

				void SearchFragment(vint start, vint length, vint& fs, vint& ss, vint& fe, vint& se)
				{
					fs=-1;
					ss=-1;
					fe=-1;
					se=-1;
					vint current=0;
					for(vint i=0;i<documentFragments.Count();i++)
					{
						vint fragmentLength=documentFragments[i]->text.Length();
						if(current<=start && start<current+fragmentLength)
						{
							fs=i;
							ss=start-current;
						}
						if(current<=start+length && start+length<=current+fragmentLength)
						{
							fe=i;
							se=start+length-current;
						}
						if(fs!=-1 && fe!=-1)
						{
							break;
						}
						current+=fragmentLength;
					}
				}

				bool CutFragment(vint fs, vint ss, vint fe, vint se, vint& f1, vint& f2)
				{
					f1=-1;
					f2=-1;
					for(vint i=fs;i<=fe;i++)
					{
						if(documentFragments[i]->element)
						{
							return false;
						}
					}
					if(fs==fe)
					{
						Ptr<UniscribeFragment> fragment=documentFragments[fs];
						vint length=fragment->text.Length();
						if(ss==0)
						{
							if(se==length)
							{
								f1=f2=fs;
							}
							else
							{
								f1=f2=fs;
								Ptr<UniscribeFragment> rightFragment=fragment->Copy();

								fragment->text=fragment->text.Sub(0, se);

								rightFragment->text=rightFragment->text.Sub(se, length-se);
								documentFragments.Insert(fs+1, rightFragment);
							}
						}
						else
						{
							if(se==length)
							{
								f1=fs+1;
								f2=fs+1;
								Ptr<UniscribeFragment> leftFragment=fragment->Copy();

								leftFragment->text=leftFragment->text.Sub(0, ss);
								documentFragments.Insert(fs, leftFragment);
								
								fragment->text=fragment->text.Sub(ss, length-ss);
							}
							else
							{
								f1=fs+1;
								f2=fs+1;
								Ptr<UniscribeFragment> leftFragment=fragment->Copy();
								Ptr<UniscribeFragment> rightFragment=fragment->Copy();

								leftFragment->text=leftFragment->text.Sub(0, ss);
								documentFragments.Insert(fs, leftFragment);
								
								fragment->text=fragment->text.Sub(ss, se-ss);

								rightFragment->text=rightFragment->text.Sub(se, length-se);
								documentFragments.Insert(fs+2, rightFragment);
							}
						}
					}
					else
					{
						Ptr<UniscribeFragment> fragmentStart=documentFragments[fs];
						Ptr<UniscribeFragment> fragmentEnd=documentFragments[fe];
						if(ss==0)
						{
							f1=fs;
						}
						else
						{
							f1=fs+1;
							fe++;
							vint length=fragmentStart->text.Length();
							Ptr<UniscribeFragment> leftFragment=fragmentStart->Copy();

							leftFragment->text=leftFragment->text.Sub(0, ss);
							documentFragments.Insert(fs, leftFragment);
								
							fragmentStart->text=fragmentStart->text.Sub(ss, length-ss);
						}
						if(se==fragmentEnd->text.Length())
						{
							f2=fe;
						}
						else
						{
							f2=fe;
							fe++;
							vint length=fragmentEnd->text.Length();
							Ptr<UniscribeFragment> rightFragment=fragmentEnd->Copy();

							fragmentEnd->text=fragmentEnd->text.Sub(0, se);

							rightFragment->text=rightFragment->text.Sub(se, length-se);
							documentFragments.Insert(fe, rightFragment);
						}
					}
					return true;
				}

				bool SetFont(vint start, vint length, const WString& value)
				{
					vint fs, ss, fe, se, f1, f2;
					SearchFragment(start, length, fs, ss, fe, se);
					if(CutFragment(fs, ss, fe, se, f1, f2))
					{
						for(vint i=f1;i<=f2;i++)
						{
							documentFragments[i]->fontStyle.fontFamily=value;
						}
						built=false;
						return true;
					}
					else
					{
						return false;
					}
				}

				bool SetSize(vint start, vint length, vint value)
				{
					vint fs, ss, fe, se, f1, f2;
					SearchFragment(start, length, fs, ss, fe, se);
					if(CutFragment(fs, ss, fe, se, f1, f2))
					{
						for(vint i=f1;i<=f2;i++)
						{
							documentFragments[i]->fontStyle.size=value;
						}
						built=false;
						return true;
					}
					else
					{
						return false;
					}
				}

				bool SetStyle(vint start, vint length, bool bold, bool italic, bool underline, bool strikeline)
				{
					vint fs, ss, fe, se, f1, f2;
					SearchFragment(start, length, fs, ss, fe, se);
					if(CutFragment(fs, ss, fe, se, f1, f2))
					{
						for(vint i=f1;i<=f2;i++)
						{
							documentFragments[i]->fontStyle.bold=bold;
							documentFragments[i]->fontStyle.italic=italic;
							documentFragments[i]->fontStyle.underline=underline;
							documentFragments[i]->fontStyle.strikeline=strikeline;
						}
						built=false;
						return true;
					}
					else
					{
						return false;
					}
				}

				bool SetColor(vint start, vint length, Color value)
				{
					vint fs, ss, fe, se, f1, f2;
					SearchFragment(start, length, fs, ss, fe, se);
					if(CutFragment(fs, ss, fe, se, f1, f2))
					{
						for(vint i=f1;i<=f2;i++)
						{
							documentFragments[i]->fontColor=value;
						}
						built=false;
						return true;
					}
					else
					{
						return false;
					}
				}

				bool SetInlineObject(vint start, vint length, const IGuiGraphicsParagraph::InlineObjectProperties& properties, Ptr<IGuiGraphicsElement> value)
				{
					vint fs, ss, fe, se, f1, f2;
					SearchFragment(start, length, fs, ss, fe, se);
					if(CutFragment(fs, ss, fe, se, f1, f2))
					{
						Ptr<UniscribeFragment> elementFragment=new UniscribeFragment;
						for(vint i=f1;i<=f2;i++)
						{
							elementFragment->text+=documentFragments[f1]->text;
							elementFragment->cachedTextFragment.Add(documentFragments[f1]);
							documentFragments.RemoveAt(f1);
						}
						elementFragment->inlineObjectProperties=properties;
						elementFragment->element=value;
						documentFragments.Insert(f1, elementFragment);
						built=false;
						return true;
					}
					else
					{
						return false;
					}
				}

				Ptr<IGuiGraphicsElement> ResetInlineObject(vint start, vint length)
				{
					vint fs, ss, fe, se;
					SearchFragment(start, length, fs, ss, fe, se);
					Ptr<UniscribeFragment> fragment=documentFragments[fs];
					if(fs==fe && ss==0 && se==fragment->text.Length() && fragment->element)
					{
						documentFragments.RemoveAt(fs);
						for(vint i=0;i<fragment->cachedTextFragment.Count();i++)
						{
							documentFragments.Insert(fs+i, fragment->cachedTextFragment[i]);
						}
						built=false;
						return fragment->element;
					}
					return 0;
				}
			};

/***********************************************************************
WindowsGDIParagraph
***********************************************************************/

			class WindowsGDIParagraph : public Object, public IGuiGraphicsParagraph
			{
			protected:
				IGuiGraphicsLayoutProvider*			provider;
				Ptr<UniscribeParagraph>				paragraph;
				WString								text;
				IWindowsGDIRenderTarget*			renderTarget;

			public:
				WindowsGDIParagraph(IGuiGraphicsLayoutProvider* _provider, const WString& _text, IGuiGraphicsRenderTarget* _renderTarget)
					:provider(_provider)
					,text(_text)
					,renderTarget(dynamic_cast<IWindowsGDIRenderTarget*>(_renderTarget))
				{
					paragraph=new UniscribeParagraph;
					{
						Ptr<UniscribeFragment> fragment=new UniscribeFragment;
						fragment->text=_text;
						fragment->fontColor=Color(0, 0, 0);
						fragment->fontStyle=GetCurrentController()->ResourceService()->GetDefaultFont();
						paragraph->documentFragments.Add(fragment);
					}
				}

				~WindowsGDIParagraph()
				{
				}

				IGuiGraphicsLayoutProvider* GetProvider()override
				{
					return provider;
				}

				IGuiGraphicsRenderTarget* GetRenderTarget()override
				{
					return renderTarget;
				}

				bool GetWrapLine()override
				{
					return true;
				}

				void SetWrapLine(bool value)override
				{
				}

				vint GetMaxWidth()override
				{
					return paragraph->lastAvailableWidth;
				}

				void SetMaxWidth(vint value)override
				{
					paragraph->BuildUniscribeData(renderTarget->GetDC());
					paragraph->Layout(value);
				}

				bool SetFont(vint start, vint length, const WString& value)override
				{
					if(length==0) return true;
					if(0<=start && start<text.Length() && length>=0 && 0<=start+length && start+length<=text.Length())
					{
						return paragraph->SetFont(start, length, value);
					}
					else
					{
						return false;
					}
				}

				bool SetSize(vint start, vint length, vint value)override
				{
					if(length==0) return true;
					if(0<=start && start<text.Length() && length>=0 && 0<=start+length && start+length<=text.Length())
					{
						return paragraph->SetSize(start, length, value);
					}
					else
					{
						return false;
					}
				}

				bool SetStyle(vint start, vint length, TextStyle value)override
				{
					if(length==0) return true;
					if(0<=start && start<text.Length() && length>=0 && 0<=start+length && start+length<=text.Length())
					{
						return paragraph->SetStyle(start, length, (value&Bold)!=0, (value&Italic)!=0, (value&Underline)!=0, (value&Strikeline)!=0);
					}
					else
					{
						return false;
					}
				}

				bool SetColor(vint start, vint length, Color value)override
				{
					if(length==0) return true;
					if(0<=start && start<text.Length() && length>=0 && 0<=start+length && start+length<=text.Length())
					{
						return paragraph->SetColor(start, length, value);
					}
					else
					{
						return false;
					}
				}

				bool SetInlineObject(vint start, vint length, const InlineObjectProperties& properties, Ptr<IGuiGraphicsElement> value)override
				{
					if(length==0) return true;
					if(0<=start && start<text.Length() && length>=0 && 0<=start+length && start+length<=text.Length())
					{
						if(paragraph->SetInlineObject(start, length, properties, value))
						{
							IGuiGraphicsRenderer* renderer=value->GetRenderer();
							if(renderer)
							{
								renderer->SetRenderTarget(renderTarget);
							}
							return true;
						}
					}
					return false;
				}

				bool ResetInlineObject(vint start, vint length)override
				{
					if(length==0) return true;
					if(0<=start && start<text.Length() && length>=0 && 0<=start+length && start+length<=text.Length())
					{
						if(Ptr<IGuiGraphicsElement> element=paragraph->ResetInlineObject(start, length))
						{
							IGuiGraphicsRenderer* renderer=element->GetRenderer();
							if(renderer)
							{
								renderer->SetRenderTarget(0);
							}
							return true;
						}
					}
					return false;
				}

				vint GetHeight()override
				{
					paragraph->BuildUniscribeData(renderTarget->GetDC());
					if(paragraph->lastAvailableWidth==-1)
					{
						paragraph->Layout(65536);
					}
					return paragraph->bounds.Height();
				}

				void Render(Rect bounds)override
				{
					paragraph->Render(renderTarget->GetDC(), bounds.Left(), bounds.Top());
				}
			};

/***********************************************************************
WindowsGDILayoutProvider
***********************************************************************/

			Ptr<IGuiGraphicsParagraph> WindowsGDILayoutProvider::CreateParagraph(const WString& text, IGuiGraphicsRenderTarget* renderTarget)
			{
				return new WindowsGDIParagraph(this, text, renderTarget);
			}
		}
	}
}

/***********************************************************************
GraphicsElement\WindowsGDI\GuiGraphicsRenderersWindowsGDI.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace elements_windows_gdi
		{
			using namespace windows;
			using namespace collections;

/***********************************************************************
GuiSolidBorderElementRenderer
***********************************************************************/

			void GuiSolidBorderElementRenderer::InitializeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				oldColor=element->GetColor();
				pen=resourceManager->CreateGdiPen(oldColor);
				brush=resourceManager->CreateGdiBrush(Color(0, 0, 0, 0));
			}

			void GuiSolidBorderElementRenderer::FinalizeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				resourceManager->DestroyGdiPen(oldColor);
				resourceManager->DestroyGdiBrush(Color(0, 0, 0, 0));
			}

			void GuiSolidBorderElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			void GuiSolidBorderElementRenderer::Render(Rect bounds)
			{
				if(oldColor.a>0)
				{
					renderTarget->GetDC()->SetBrush(brush);
					renderTarget->GetDC()->SetPen(pen);
					switch(element->GetShape())
					{
					case ElementShape::Rectangle:
						renderTarget->GetDC()->Rectangle(bounds.Left(), bounds.Top(), bounds.Right()-1, bounds.Bottom()-1);
						break;
					case ElementShape::Ellipse:
						renderTarget->GetDC()->Ellipse(bounds.Left(), bounds.Top(), bounds.Right()-1, bounds.Bottom()-1);
						break;
					}
				}
			}

			void GuiSolidBorderElementRenderer::OnElementStateChanged()
			{
				Color color=element->GetColor();
				if(oldColor!=color)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiPen(oldColor);
					oldColor=color;
					pen=resourceManager->CreateGdiPen(oldColor);
				}
			}

/***********************************************************************
GuiRoundBorderElementRenderer
***********************************************************************/

			void GuiRoundBorderElementRenderer::InitializeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				oldColor=element->GetColor();
				pen=resourceManager->CreateGdiPen(oldColor);
				brush=resourceManager->CreateGdiBrush(Color(0, 0, 0, 0));
			}

			void GuiRoundBorderElementRenderer::FinalizeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				resourceManager->DestroyGdiPen(oldColor);
				resourceManager->DestroyGdiBrush(Color(0, 0, 0, 0));
			}

			void GuiRoundBorderElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			void GuiRoundBorderElementRenderer::Render(Rect bounds)
			{
				if(oldColor.a>0)
				{
					vint ellipse=element->GetRadius()*2;
					renderTarget->GetDC()->SetBrush(brush);
					renderTarget->GetDC()->SetPen(pen);
					renderTarget->GetDC()->RoundRect(bounds.Left(), bounds.Top(), bounds.Right()-1, bounds.Bottom()-1, ellipse, ellipse);
				}
			}

			void GuiRoundBorderElementRenderer::OnElementStateChanged()
			{
				Color color=element->GetColor();
				if(oldColor!=color)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiPen(oldColor);
					oldColor=color;
					pen=resourceManager->CreateGdiPen(oldColor);
				}
			}

/***********************************************************************
Gui3DBorderElementRenderer
***********************************************************************/

			void Gui3DBorderElementRenderer::InitializeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				oldColor1=element->GetColor1();
				oldColor2=element->GetColor2();
				pen1=resourceManager->CreateGdiPen(oldColor1);
				pen2=resourceManager->CreateGdiPen(oldColor2);
			}

			void Gui3DBorderElementRenderer::FinalizeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				resourceManager->DestroyGdiPen(oldColor1);
				resourceManager->DestroyGdiPen(oldColor2);
			}

			void Gui3DBorderElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			void Gui3DBorderElementRenderer::Render(Rect bounds)
			{
				if(oldColor1.a>0)
				{
					renderTarget->GetDC()->SetPen(pen1);
					renderTarget->GetDC()->MoveTo(bounds.x1, bounds.y1);
					renderTarget->GetDC()->LineTo(bounds.x2, bounds.y1);
					renderTarget->GetDC()->MoveTo(bounds.x1, bounds.y1);
					renderTarget->GetDC()->LineTo(bounds.x1, bounds.y2);
				}
				if(oldColor2.a>0)
				{
					renderTarget->GetDC()->SetPen(pen2);
					renderTarget->GetDC()->MoveTo(bounds.x2-1, bounds.y2-1);
					renderTarget->GetDC()->LineTo(bounds.x1, bounds.y2-1);
					renderTarget->GetDC()->MoveTo(bounds.x2-1, bounds.y2-1);
					renderTarget->GetDC()->LineTo(bounds.x2-1, bounds.y1);
				}
			}

			void Gui3DBorderElementRenderer::OnElementStateChanged()
			{
				Color color1=element->GetColor1();
				if(oldColor1!=color1)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiPen(oldColor1);
					oldColor1=color1;
					pen1=resourceManager->CreateGdiPen(oldColor1);
				}

				Color color2=element->GetColor2();
				if(oldColor2!=color2)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiPen(oldColor2);
					oldColor2=color2;
					pen2=resourceManager->CreateGdiPen(oldColor2);
				}
			}

/***********************************************************************
Gui3DSplitterElementRenderer
***********************************************************************/

			void Gui3DSplitterElementRenderer::InitializeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				oldColor1=element->GetColor1();
				oldColor2=element->GetColor2();
				pen1=resourceManager->CreateGdiPen(oldColor1);
				pen2=resourceManager->CreateGdiPen(oldColor2);
			}

			void Gui3DSplitterElementRenderer::FinalizeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				resourceManager->DestroyGdiPen(oldColor1);
				resourceManager->DestroyGdiPen(oldColor2);
			}

			void Gui3DSplitterElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			void Gui3DSplitterElementRenderer::Render(Rect bounds)
			{
				Point p11, p12, p21, p22;
				switch(element->GetDirection())
				{
				case Gui3DSplitterElement::Horizontal:
					{
						vint y=bounds.y1+bounds.Height()/2-1;
						p11=Point(bounds.x1, y);
						p12=Point(bounds.x2, y);
						p21=Point(bounds.x1, y+1);
						p22=Point(bounds.x2, y+1);
					}
					break;
				case Gui3DSplitterElement::Vertical:
					{
						vint x=bounds.x1+bounds.Width()/2-1;
						p11=Point(x, bounds.y1);
						p12=Point(x, bounds.y2);
						p21=Point(x+1, bounds.y1);
						p22=Point(x+1, bounds.y2);
					}
					break;
				}
				if(oldColor1.a>0)
				{
					renderTarget->GetDC()->SetPen(pen1);
					renderTarget->GetDC()->MoveTo(p11.x, p11.y);
					renderTarget->GetDC()->LineTo(p12.x, p12.y);
				}
				if(oldColor2.a>0)
				{
					renderTarget->GetDC()->SetPen(pen2);
					renderTarget->GetDC()->MoveTo(p21.x, p21.y);
					renderTarget->GetDC()->LineTo(p22.x, p22.y);
				}
			}

			void Gui3DSplitterElementRenderer::OnElementStateChanged()
			{
				Color color1=element->GetColor1();
				if(oldColor1!=color1)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiPen(oldColor1);
					oldColor1=color1;
					pen1=resourceManager->CreateGdiPen(oldColor1);
				}

				Color color2=element->GetColor2();
				if(oldColor2!=color2)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiPen(oldColor2);
					oldColor2=color2;
					pen2=resourceManager->CreateGdiPen(oldColor2);
				}
			}

/***********************************************************************
GuiSolidBackgroundElementRenderer
***********************************************************************/

			void GuiSolidBackgroundElementRenderer::InitializeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				oldColor=element->GetColor();
				pen=resourceManager->CreateGdiPen(oldColor);
				brush=resourceManager->CreateGdiBrush(oldColor);
			}

			void GuiSolidBackgroundElementRenderer::FinalizeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				resourceManager->DestroyGdiPen(oldColor);
				resourceManager->DestroyGdiBrush(oldColor);
			}

			void GuiSolidBackgroundElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			void GuiSolidBackgroundElementRenderer::Render(Rect bounds)
			{
				if(oldColor.a>0)
				{
					renderTarget->GetDC()->SetPen(pen);
					renderTarget->GetDC()->SetBrush(brush);
					switch(element->GetShape())
					{
					case ElementShape::Rectangle:
						renderTarget->GetDC()->FillRect(bounds.Left(), bounds.Top(), bounds.Right(), bounds.Bottom());
						break;
					case ElementShape::Ellipse:
						renderTarget->GetDC()->Ellipse(bounds.Left(), bounds.Top(), bounds.Right()-1, bounds.Bottom()-1);
						break;
					}
				}
			}

			void GuiSolidBackgroundElementRenderer::OnElementStateChanged()
			{
				Color color=element->GetColor();
				if(oldColor!=color)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiPen(oldColor);
					resourceManager->DestroyGdiBrush(oldColor);
					oldColor=color;
					pen=resourceManager->CreateGdiPen(oldColor);
					brush=resourceManager->CreateGdiBrush(oldColor);
				}
			}

/***********************************************************************
GuiGradientBackgroundElementRenderer
***********************************************************************/

			void GuiGradientBackgroundElementRenderer::InitializeInternal()
			{
			}

			void GuiGradientBackgroundElementRenderer::FinalizeInternal()
			{
			}

			void GuiGradientBackgroundElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			void GuiGradientBackgroundElementRenderer::Render(Rect bounds)
			{
				Color color1=element->GetColor1();
				Color color2=element->GetColor2();
				if(color1.a>0 || color2.a>0)
				{
					TRIVERTEX vertices[4];
					GRADIENT_TRIANGLE triangles[2];

					vertices[0].x=(int)bounds.x1;
					vertices[0].y=(int)bounds.y1;
					vertices[1].x=(int)bounds.x1;
					vertices[1].y=(int)bounds.y2;
					vertices[2].x=(int)bounds.x2;
					vertices[2].y=(int)bounds.y2;
					vertices[3].x=(int)bounds.x2;
					vertices[3].y=(int)bounds.y1;

					triangles[0].Vertex1=0;
					triangles[0].Vertex2=1;
					triangles[0].Vertex3=2;
					triangles[1].Vertex1=0;
					triangles[1].Vertex2=2;
					triangles[1].Vertex3=3;

					if(element->GetDirection()==GuiGradientBackgroundElement::Horizontal)
					{
						vertices[0].Red=color1.r<<8;
						vertices[0].Green=color1.g<<8;
						vertices[0].Blue=color1.b<<8;
						vertices[0].Alpha=0xFF00;
						
						vertices[1].Red=color1.r<<8;
						vertices[1].Green=color1.g<<8;
						vertices[1].Blue=color1.b<<8;
						vertices[1].Alpha=0xFF00;
						
						vertices[2].Red=color2.r<<8;
						vertices[2].Green=color2.g<<8;
						vertices[2].Blue=color2.b<<8;
						vertices[2].Alpha=0xFF00;
						
						vertices[3].Red=color2.r<<8;
						vertices[3].Green=color2.g<<8;
						vertices[3].Blue=color2.b<<8;
						vertices[3].Alpha=0xFF00;
					}
					else
					{
						vertices[0].Red=color1.r<<8;
						vertices[0].Green=color1.g<<8;
						vertices[0].Blue=color1.b<<8;
						vertices[0].Alpha=0xFF00;
						
						vertices[1].Red=color2.r<<8;
						vertices[1].Green=color2.g<<8;
						vertices[1].Blue=color2.b<<8;
						vertices[1].Alpha=0xFF00;
						
						vertices[2].Red=color2.r<<8;
						vertices[2].Green=color2.g<<8;
						vertices[2].Blue=color2.b<<8;
						vertices[2].Alpha=0xFF00;
						
						vertices[3].Red=color1.r<<8;
						vertices[3].Green=color1.g<<8;
						vertices[3].Blue=color1.b<<8;
						vertices[3].Alpha=0xFF00;
					}
					
					switch(element->GetShape())
					{
					case ElementShape::Rectangle:
						{
							renderTarget->GetDC()->GradientTriangle(vertices, 6, triangles, 2);
						}
						break;
					case ElementShape::Ellipse:
						{
							Ptr<WinRegion> ellipseRegion=new WinRegion(bounds.x1, bounds.y1, bounds.x2+1, bounds.y2+1, false);
							Ptr<WinRegion> oldRegion=renderTarget->GetDC()->GetClipRegion();
							Ptr<WinRegion> newRegion=new WinRegion(oldRegion, ellipseRegion, RGN_AND);
							renderTarget->GetDC()->ClipRegion(newRegion);
							renderTarget->GetDC()->GradientTriangle(vertices, 6, triangles, 2);
							renderTarget->GetDC()->ClipRegion(oldRegion);
						}
						break;
					}
				}
			}

			void GuiGradientBackgroundElementRenderer::OnElementStateChanged()
			{
			}

/***********************************************************************
GuiSolidLabelElementRenderer
***********************************************************************/

			void GuiSolidLabelElementRenderer::UpdateMinSize()
			{
				if(renderTarget)
				{
					renderTarget->GetDC()->SetFont(font);
					SIZE size={0};
					const WString& text=element->GetText();
					if(element->GetWrapLine())
					{
						if(element->GetWrapLineHeightCalculation())
						{
							if(oldMaxWidth==-1 || text.Length()==0)
							{
								size=renderTarget->GetDC()->MeasureBuffer(L" ");
							}
							else
							{
								size=renderTarget->GetDC()->MeasureWrapLineString(text, oldMaxWidth);
							}
						}
					}
					else
					{
						size=text.Length()==0
							?renderTarget->GetDC()->MeasureBuffer(L" ")
							:renderTarget->GetDC()->MeasureString(text)
							;
					}
					minSize=Size((element->GetEllipse()?0:size.cx), size.cy);
				}
				else
				{
					minSize=Size();
				}
			}

			void GuiSolidLabelElementRenderer::InitializeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				oldFont=element->GetFont();
				font=resourceManager->CreateGdiFont(oldFont);
			}

			void GuiSolidLabelElementRenderer::FinalizeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				resourceManager->DestroyGdiFont(oldFont);
			}

			void GuiSolidLabelElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
				UpdateMinSize();
			}

			GuiSolidLabelElementRenderer::GuiSolidLabelElementRenderer()
				:oldMaxWidth(-1)
			{
			}

			void GuiSolidLabelElementRenderer::Render(Rect bounds)
			{
				Color color=element->GetColor();
				if(color.a>0)
				{
					renderTarget->GetDC()->SetFont(font);
					renderTarget->GetDC()->SetTextColor(RGB(color.r, color.g, color.b));

					UINT format=DT_NOPREFIX;
					RECT rect;
					rect.left=(int)bounds.Left();
					rect.top=(int)bounds.Top();
					rect.right=(int)bounds.Right();
					rect.bottom=(int)bounds.Bottom();

					if(element->GetMultiline() || element->GetWrapLine())
					{
						format|=DT_EDITCONTROL;
					}
					else
					{
						format|=DT_SINGLELINE;
						switch(element->GetVerticalAlignment())
						{
						case Alignment::Top:
							format|=DT_TOP;
							break;
						case Alignment::Center:
							format|=DT_VCENTER;
							break;
						case Alignment::Bottom:
							format|=DT_BOTTOM;
							break;
						}
					}

					switch(element->GetHorizontalAlignment())
					{
					case Alignment::Left:
						format|=DT_LEFT;
						break;
					case Alignment::Center:
						format|=DT_CENTER;
						break;
					case Alignment::Right:
						format|=DT_RIGHT;
						break;
					}

					if(element->GetWrapLine())
					{
						format|=DT_WORDBREAK;
					}
					if(element->GetEllipse())
					{
						format|=DT_END_ELLIPSIS;
					}
					renderTarget->GetDC()->DrawString(rect, element->GetText(), format);
					if(oldMaxWidth!=bounds.Width())
					{
						oldMaxWidth=bounds.Width();
						UpdateMinSize();
					}
				}
			}

			void GuiSolidLabelElementRenderer::OnElementStateChanged()
			{
				FontProperties fontProperties=element->GetFont();
				if(oldFont!=fontProperties)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiFont(oldFont);
					oldFont=fontProperties;
					font=resourceManager->CreateGdiFont(oldFont);
				}
				UpdateMinSize();
			}

/***********************************************************************
GuiImageFrameElementRenderer
***********************************************************************/

			void GuiImageFrameElementRenderer::UpdateBitmap()
			{
				if(element->GetImage())
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					INativeImageFrame* frame=element->GetImage()->GetFrame(element->GetFrameIndex());
					bitmap=resourceManager->GetBitmap(frame, element->GetEnabled());
					minSize=frame->GetSize();
				}
				else
				{
					bitmap=0;
					minSize=Size(0, 0);
				}
			}

			void GuiImageFrameElementRenderer::InitializeInternal()
			{
				UpdateBitmap();
			}

			void GuiImageFrameElementRenderer::FinalizeInternal()
			{
			}

			void GuiImageFrameElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			GuiImageFrameElementRenderer::GuiImageFrameElementRenderer()
			{
			}

			void GuiImageFrameElementRenderer::Render(Rect bounds)
			{
				if(bitmap)
				{
					WinDC* dc=renderTarget->GetDC();
					Rect source(0, 0, minSize.x, minSize.y);
					Rect destination;
					if(element->GetStretch())
					{
						destination=Rect(bounds.x1, bounds.y1, bounds.x2, bounds.y2);
					}
					else
					{
						vint x=0;
						vint y=0;
						switch(element->GetHorizontalAlignment())
						{
						case Alignment::Left:
							x=bounds.Left();
							break;
						case Alignment::Center:
							x=bounds.Left()+(bounds.Width()-minSize.x)/2;
							break;
						case Alignment::Right:
							x=bounds.Right()-minSize.x;
							break;
						}
						switch(element->GetVerticalAlignment())
						{
						case Alignment::Top:
							y=bounds.Top();
							break;
						case Alignment::Center:
							y=bounds.Top()+(bounds.Height()-minSize.y)/2;
							break;
						case Alignment::Bottom:
							y=bounds.Bottom()-minSize.y;
							break;
						}
						destination=Rect(x, y, x+minSize.x, y+minSize.y);
					}
					if(element->GetImage()->GetFormat()==INativeImage::Gif &&  element->GetFrameIndex()>0)
					{
						IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
						vint max=element->GetFrameIndex();
						for(vint i=0;i<=max;i++)
						{
							Ptr<WinBitmap> frameBitmap=resourceManager->GetBitmap(element->GetImage()->GetFrame(i), element->GetEnabled());
							dc->Draw(
								destination.Left(), destination.Top(), destination.Width(), destination.Height(),
								frameBitmap,
								source.Left(), source.Top(), source.Width(), source.Height()
								);
						}
					}
					else
					{
						dc->Draw(
							destination.Left(), destination.Top(), destination.Width(), destination.Height(),
							bitmap,
							source.Left(), source.Top(), source.Width(), source.Height()
							);
					}
				}
			}

			void GuiImageFrameElementRenderer::OnElementStateChanged()
			{
				UpdateBitmap();
			}

/***********************************************************************
GuiPolygonElementRenderer
***********************************************************************/

			void GuiPolygonElementRenderer::InitializeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				pen=resourceManager->CreateGdiPen(oldPenColor);
				brush=resourceManager->CreateGdiBrush(oldBrushColor);
			}

			void GuiPolygonElementRenderer::FinalizeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				resourceManager->DestroyGdiPen(oldPenColor);
				resourceManager->DestroyGdiBrush(oldBrushColor);
			}

			void GuiPolygonElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			GuiPolygonElementRenderer::GuiPolygonElementRenderer()
				:points(0)
				,pointCount(0)
				,oldPenColor(0, 0, 0, 0)
				,oldBrushColor(0, 0, 0, 0)
			{
			}

			GuiPolygonElementRenderer::~GuiPolygonElementRenderer()
			{
				if(points) delete[] points;
			}

			void GuiPolygonElementRenderer::Render(Rect bounds)
			{
				if(pointCount>=3 && (oldPenColor.a || oldBrushColor.a))
				{
					vint offsetX=(bounds.Width()-minSize.x)/2+bounds.x1;
					vint offsetY=(bounds.Height()-minSize.y)/2+bounds.y1;
					for(vint i=0;i<pointCount;i++)
					{
						points[i].x+=(int)offsetX;
						points[i].y+=(int)offsetY;
					}
					renderTarget->GetDC()->SetPen(pen);
					renderTarget->GetDC()->SetBrush(brush);
					renderTarget->GetDC()->PolyGon(points, pointCount);
					for(vint i=0;i<pointCount;i++)
					{
						points[i].x-=(int)offsetX;
						points[i].y-=(int)offsetY;
					}
				}
			}

			void GuiPolygonElementRenderer::OnElementStateChanged()
			{
				minSize=element->GetSize();
				{
					if(points)
					{
						delete[] points;
						points=0;
					}
					pointCount=element->GetPointCount();
					if(pointCount>0)
					{
						points=new POINT[pointCount];
						for(vint i=0;i<pointCount;i++)
						{
							Point p=element->GetPoint(i);
							points[i].x=(int)p.x;
							points[i].y=(int)p.y;
						}
					}
				}

				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				if(oldPenColor!=element->GetBorderColor() || !pen)
				{
					resourceManager->DestroyGdiPen(oldPenColor);
					oldPenColor=element->GetBorderColor();
					pen=resourceManager->CreateGdiPen(oldPenColor);
				}
				if(oldBrushColor!=element->GetBackgroundColor() || !brush)
				{
					resourceManager->DestroyGdiPen(oldBrushColor);
					oldBrushColor=element->GetBackgroundColor();
					brush=resourceManager->CreateGdiBrush(oldBrushColor);
				}
			}

/***********************************************************************
GuiColorizedTextElementRenderer
***********************************************************************/

			void GuiColorizedTextElementRenderer::DestroyColors()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				for(vint i=0;i<colors.Count();i++)
				{
					resourceManager->DestroyGdiBrush(colors[i].normal.background);
					resourceManager->DestroyGdiBrush(colors[i].selectedFocused.background);
					resourceManager->DestroyGdiBrush(colors[i].selectedUnfocused.background);
				}
			}

			void GuiColorizedTextElementRenderer::ColorChanged()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				ColorArray newColors;
				newColors.Resize(element->GetColors().Count());
				for(vint i=0;i<newColors.Count();i++)
				{
					text::ColorEntry entry=element->GetColors().Get(i);
					ColorEntryResource newEntry;

					newEntry.normal.text=entry.normal.text;
					newEntry.normal.background=entry.normal.background;
					newEntry.normal.backgroundBrush=resourceManager->CreateGdiBrush(newEntry.normal.background);
					newEntry.selectedFocused.text=entry.selectedFocused.text;
					newEntry.selectedFocused.background=entry.selectedFocused.background;
					newEntry.selectedFocused.backgroundBrush=resourceManager->CreateGdiBrush(newEntry.selectedFocused.background);
					newEntry.selectedUnfocused.text=entry.selectedUnfocused.text;
					newEntry.selectedUnfocused.background=entry.selectedUnfocused.background;
					newEntry.selectedUnfocused.backgroundBrush=resourceManager->CreateGdiBrush(newEntry.selectedUnfocused.background);
					newColors[i]=newEntry;
				}

				DestroyColors();
				CopyFrom(colors, newColors);
			}

			void GuiColorizedTextElementRenderer::FontChanged()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				if(font)
				{
					element->GetLines().SetCharMeasurer(0);
					resourceManager->DestroyGdiFont(oldFont);
					resourceManager->DestroyCharMeasurer(oldFont);
					font=0;
				}
				oldFont=element->GetFont();
				font=resourceManager->CreateGdiFont(oldFont);
				element->GetLines().SetCharMeasurer(resourceManager->CreateCharMeasurer(oldFont).Obj());
			}

			void GuiColorizedTextElementRenderer::InitializeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				element->SetCallback(this);
				oldCaretColor=element->GetCaretColor();
				caretPen=resourceManager->CreateGdiPen(oldCaretColor);
			}

			void GuiColorizedTextElementRenderer::FinalizeInternal()
			{
				IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
				if(font)
				{
					resourceManager->DestroyGdiFont(oldFont);
					resourceManager->DestroyCharMeasurer(oldFont);
				}
				resourceManager->DestroyGdiPen(oldCaretColor);
				DestroyColors();
			}

			void GuiColorizedTextElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
				element->GetLines().SetRenderTarget(newRenderTarget);
			}

			void GuiColorizedTextElementRenderer::Render(Rect bounds)
			{
				if(renderTarget)
				{
					WinDC* dc=renderTarget->GetDC();
					dc->SetFont(font);
					
					wchar_t passwordChar=element->GetPasswordChar();
					Point viewPosition=element->GetViewPosition();
					Rect viewBounds(viewPosition, bounds.GetSize());
					vint startRow=element->GetLines().GetTextPosFromPoint(Point(viewBounds.x1, viewBounds.y1)).row;
					vint endRow=element->GetLines().GetTextPosFromPoint(Point(viewBounds.x2, viewBounds.y2)).row;
					TextPos selectionBegin=element->GetCaretBegin()<element->GetCaretEnd()?element->GetCaretBegin():element->GetCaretEnd();
					TextPos selectionEnd=element->GetCaretBegin()>element->GetCaretEnd()?element->GetCaretBegin():element->GetCaretEnd();
					bool focused=element->GetFocused();
					Ptr<windows::WinBrush> lastBrush=0;

					for(vint row=startRow;row<=endRow;row++)
					{
						Rect startRect=element->GetLines().GetRectFromTextPos(TextPos(row, 0));
						Point startPoint=startRect.LeftTop();
						vint startColumn=element->GetLines().GetTextPosFromPoint(Point(viewBounds.x1, startPoint.y)).column;
						vint endColumn=element->GetLines().GetTextPosFromPoint(Point(viewBounds.x2, startPoint.y)).column;
						text::TextLine& line=element->GetLines().GetLine(row);

						vint x=startColumn==0?0:line.att[startColumn-1].rightOffset;
						for(vint column=startColumn; column<=endColumn; column++)
						{
							bool inSelection=false;
							if(selectionBegin.row==selectionEnd.row)
							{
								inSelection=(row==selectionBegin.row && selectionBegin.column<=column && column<selectionEnd.column);
							}
							else if(row==selectionBegin.row)
							{
								inSelection=selectionBegin.column<=column;
							}
							else if(row==selectionEnd.row)
							{
								inSelection=column<selectionEnd.column;
							}
							else
							{
								inSelection=selectionBegin.row<row && row<selectionEnd.row;
							}
							
							bool crlf=column==line.dataLength;
							vint colorIndex=crlf?0:line.att[column].colorIndex;
							if(colorIndex>=colors.Count())
							{
								colorIndex=0;
							}
							ColorItemResource& color=
								!inSelection?colors[colorIndex].normal:
								focused?colors[colorIndex].selectedFocused:
								colors[colorIndex].selectedUnfocused;
							vint x2=crlf?x+startRect.Height()/2:line.att[column].rightOffset;
							vint tx=x-viewPosition.x+bounds.x1;
							vint ty=startPoint.y-viewPosition.y+bounds.y1;
							
							if(color.background.a)
							{
								if(lastBrush!=color.backgroundBrush)
								{
									lastBrush=color.backgroundBrush;
									dc->SetBrush(lastBrush);
								}
								dc->FillRect(tx, ty, tx+(x2-x), ty+startRect.Height());
							}
							if(!crlf)
							{
								if(color.text.a)
								{
									dc->SetTextColor(RGB(color.text.r, color.text.g, color.text.b));
									dc->DrawBuffer(tx, ty, (passwordChar?&passwordChar:&line.text[column]), 1);
								}
							}
							x=x2;
						}
					}

					if(element->GetCaretVisible() && element->GetLines().IsAvailable(element->GetCaretEnd()))
					{
						Point caretPoint=element->GetLines().GetPointFromTextPos(element->GetCaretEnd());
						vint height=element->GetLines().GetRowHeight();
						dc->SetPen(caretPen);
						dc->MoveTo(caretPoint.x-viewPosition.x+bounds.x1, caretPoint.y-viewPosition.y+bounds.y1+1);
						dc->LineTo(caretPoint.x-viewPosition.x+bounds.x1, caretPoint.y+height-viewPosition.y+bounds.y1-1);
						dc->MoveTo(caretPoint.x-1-viewPosition.x+bounds.x1, caretPoint.y-viewPosition.y+bounds.y1+1);
						dc->LineTo(caretPoint.x-1-viewPosition.x+bounds.x1, caretPoint.y+height-viewPosition.y+bounds.y1-1);
					}
				}
			}

			void GuiColorizedTextElementRenderer::OnElementStateChanged()
			{
				Color caretColor=element->GetCaretColor();
				if(oldCaretColor!=caretColor)
				{
					IWindowsGDIResourceManager* resourceManager=GetWindowsGDIResourceManager();
					resourceManager->DestroyGdiPen(oldCaretColor);
					oldCaretColor=caretColor;
					caretPen=resourceManager->CreateGdiPen(oldCaretColor);
				}
			}

/***********************************************************************
GuiGDIElementRenderer
***********************************************************************/

			void GuiGDIElementRenderer::InitializeInternal()
			{
			}

			void GuiGDIElementRenderer::FinalizeInternal()
			{
			}

			void GuiGDIElementRenderer::RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget)
			{
			}

			GuiGDIElementRenderer::GuiGDIElementRenderer()
			{
			}

			GuiGDIElementRenderer::~GuiGDIElementRenderer()
			{
			}
			
			void GuiGDIElementRenderer::Render(Rect bounds)
			{
				if(renderTarget)
				{
					renderTarget->PushClipper(bounds);
					if(!renderTarget->IsClipperCoverWholeTarget())
					{
						WinDC* dc=renderTarget->GetDC();
						GuiGDIElementEventArgs arguments(element, dc, bounds);
						element->Rendering.Execute(arguments);
					}
					renderTarget->PopClipper();
				}
			}

			void GuiGDIElementRenderer::OnElementStateChanged()
			{
			}
		}
	}
}

/***********************************************************************
GraphicsElement\WindowsGDI\GuiGraphicsWindowsGDI.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
GuiGDIElement
***********************************************************************/

			GuiGDIElement::GuiGDIElement()
			{
			}

			GuiGDIElement::~GuiGDIElement()
			{
			}
		}

		namespace elements_windows_gdi
		{
			using namespace windows;
			using namespace elements;
			using namespace collections;

/***********************************************************************
WindowsGDIRenderTarget
***********************************************************************/

			class WindowsGDIRenderTarget : public Object, public IWindowsGDIRenderTarget
			{
			protected:
				INativeWindow*				window;
				WinDC*						dc;
				List<Rect>					clippers;
				vint							clipperCoverWholeTargetCounter;

				void ApplyClipper()
				{
					if(clipperCoverWholeTargetCounter==0)
					{
						if(clippers.Count()==0)
						{
							dc->RemoveClip();
						}
						else
						{
							Rect clipper=GetClipper();
							dc->ClipRegion(new WinRegion(clipper.Left(), clipper.Top(), clipper.Right(), clipper.Bottom(), true));
						}
					}
				}
			public:
				WindowsGDIRenderTarget(INativeWindow* _window)
					:window(_window)
					,dc(0)
					,clipperCoverWholeTargetCounter(0)
				{
				}

				WinDC* GetDC()override
				{
					return dc?dc:GetWindowsGDIObjectProvider()->GetNativeWindowDC(window);
				}

				void StartRendering()override
				{
					dc=GetWindowsGDIObjectProvider()->GetNativeWindowDC(window);
				}

				void StopRendering()override
				{
					dc=0;
				}

				void PushClipper(Rect clipper)override
				{
					if(clipperCoverWholeTargetCounter>0)
					{
						clipperCoverWholeTargetCounter++;
					}
					else
					{
						Rect previousClipper=GetClipper();
						Rect currentClipper;

						currentClipper.x1=(previousClipper.x1>clipper.x1?previousClipper.x1:clipper.x1);
						currentClipper.y1=(previousClipper.y1>clipper.y1?previousClipper.y1:clipper.y1);
						currentClipper.x2=(previousClipper.x2<clipper.x2?previousClipper.x2:clipper.x2);
						currentClipper.y2=(previousClipper.y2<clipper.y2?previousClipper.y2:clipper.y2);

						if(currentClipper.x1<currentClipper.x2 && currentClipper.y1<currentClipper.y2)
						{
							clippers.Add(currentClipper);
						}
						else
						{
							clipperCoverWholeTargetCounter++;
						}
					}
					ApplyClipper();
				}

				void PopClipper()override
				{
					if(clippers.Count()>0)
					{
						if(clipperCoverWholeTargetCounter>0)
						{
							clipperCoverWholeTargetCounter--;
						}
						else
						{
							clippers.RemoveAt(clippers.Count()-1);
						}
						ApplyClipper();
					}
				}

				Rect GetClipper()override
				{
					if(clippers.Count()==0)
					{
						return Rect(Point(0, 0), window->GetClientSize());
					}
					else
					{
						return clippers[clippers.Count()-1];
					}
				}

				bool IsClipperCoverWholeTarget()override
				{
					return clipperCoverWholeTargetCounter>0;
				}
			};

/***********************************************************************
CachedResourceAllocator
***********************************************************************/

			class CachedPenAllocator
			{
				DEFINE_CACHED_RESOURCE_ALLOCATOR(Color, Ptr<WinPen>)
			public:
				Ptr<WinPen> CreateInternal(Color color)
				{
					return new WinPen(PS_SOLID, 1, RGB(color.r, color.g, color.b));
				}
			};

			class CachedBrushAllocator
			{
				DEFINE_CACHED_RESOURCE_ALLOCATOR(Color, Ptr<WinBrush>)
			public:
				Ptr<WinBrush> CreateInternal(Color color)
				{
					return color.a==0?new WinBrush:new WinBrush(RGB(color.r, color.g, color.b));
				}
			};

			class CachedFontAllocator
			{
				DEFINE_CACHED_RESOURCE_ALLOCATOR(FontProperties, Ptr<WinFont>)
			public:
				static Ptr<WinFont> CreateGdiFont(const FontProperties& value)
				{
					vint size=value.size<0?value.size:-value.size;
					return new WinFont(value.fontFamily, size, 0, 0, 0, (value.bold?FW_BOLD:FW_NORMAL), value.italic, value.underline, value.strikeline, value.antialias);
				}

				Ptr<WinFont> CreateInternal(const FontProperties& value)
				{
					return CreateGdiFont(value);
				}
			};

			class CachedCharMeasurerAllocator
			{
				DEFINE_CACHED_RESOURCE_ALLOCATOR(FontProperties, Ptr<text::CharMeasurer>)

			protected:
				class GdiCharMeasurer : public text::CharMeasurer
				{
				protected:
					Ptr<WinFont>			font;
					vint						size;

					Size MeasureInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)
					{
						if(renderTarget)
						{
							WindowsGDIRenderTarget* gdiRenderTarget=dynamic_cast<WindowsGDIRenderTarget*>(renderTarget);
							WinDC* dc=gdiRenderTarget->GetDC();
							dc->SetFont(font);
							SIZE size=dc->MeasureBuffer(&character, 1, -1);
							return Size(size.cx, size.cy);
						}
						else
						{
							return Size(0, 0);
						}
					}

					vint MeasureWidthInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)
					{
						return MeasureInternal(character, renderTarget).x;
					}

					vint GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)
					{
						if(renderTarget)
						{
							return MeasureInternal(L' ', renderTarget).y;
						}
						else
						{
							return size;
						}
					}
				public:
					GdiCharMeasurer(Ptr<WinFont> _font, vint _size)
						:text::CharMeasurer(_size)
						,size(_size)
						,font(_font)
					{
					}
				};
			public:
				Ptr<text::CharMeasurer> CreateInternal(const FontProperties& value)
				{
					return new GdiCharMeasurer(CachedFontAllocator::CreateGdiFont(value), value.size);
				}
			};

/***********************************************************************
WindowsGDIResourceManager
***********************************************************************/

			class WindowsGDIImageFrameCache : public Object, public INativeImageFrameCache
			{
			protected:
				IWindowsGDIResourceManager*			resourceManager;
				INativeImageFrame*					cachedFrame;
				Ptr<WinBitmap>						bitmap;
				Ptr<WinBitmap>						disabledBitmap;
			public:
				WindowsGDIImageFrameCache(IWindowsGDIResourceManager* _resourceManager)
					:resourceManager(_resourceManager)
				{
				}

				~WindowsGDIImageFrameCache()
				{
				}

				void OnAttach(INativeImageFrame* frame)override
				{
					cachedFrame=frame;
					Size size=frame->GetSize();
					bitmap=new WinBitmap(size.x, size.y, WinBitmap::vbb32Bits, true);

					IWICBitmap* wicBitmap=GetWindowsGDIObjectProvider()->GetWICBitmap(frame);
					WICRect rect;
					rect.X=0;
					rect.Y=0;
					rect.Width=(int)size.x;
					rect.Height=(int)size.y;
					wicBitmap->CopyPixels(&rect, (int)bitmap->GetLineBytes(), (int)(bitmap->GetLineBytes()*size.y), (BYTE*)bitmap->GetScanLines()[0]);

					bitmap->BuildAlphaChannel(false);
				}
				
				void OnDetach(INativeImageFrame* frame)override
				{
					resourceManager->DestroyBitmapCache(cachedFrame);
				}

				INativeImageFrame* GetFrame()
				{
					return cachedFrame;
				}

				Ptr<WinBitmap> GetBitmap(bool enabled)
				{
					if(enabled)
					{
						return bitmap;
					}
					else
					{
						if(!disabledBitmap)
						{
							vint w=bitmap->GetWidth();
							vint h=bitmap->GetHeight();
							disabledBitmap=new WinBitmap(w, h, WinBitmap::vbb32Bits, true);
							for(vint y=0;y<h;y++)
							{
								BYTE* read=bitmap->GetScanLines()[y];
								BYTE* write=disabledBitmap->GetScanLines()[y];
								for(vint x=0;x<w;x++)
								{
									BYTE g=(read[0]+read[1]+read[2])/6+read[3]/2;
									write[0]=g;
									write[1]=g;
									write[2]=g;
									write[3]=read[3];
									read+=4;
									write+=4;
								}
							}
							disabledBitmap->BuildAlphaChannel(false);
						}
						return disabledBitmap;
					}
				}
			};

			class WindowsGDIResourceManager : public GuiGraphicsResourceManager, public IWindowsGDIResourceManager, public INativeControllerListener
			{
				typedef SortedList<Ptr<WindowsGDIImageFrameCache>> ImageCacheList;
			protected:
				SortedList<Ptr<WindowsGDIRenderTarget>>		renderTargets;
				Ptr<WindowsGDILayoutProvider>				layoutProvider;
				CachedPenAllocator							pens;
				CachedBrushAllocator						brushes;
				CachedFontAllocator							fonts;
				CachedCharMeasurerAllocator					charMeasurers;
				ImageCacheList								imageCaches;
			public:
				WindowsGDIResourceManager()
				{
					layoutProvider=new WindowsGDILayoutProvider;
				}

				IGuiGraphicsRenderTarget* GetRenderTarget(INativeWindow* window)override
				{
					return GetWindowsGDIObjectProvider()->GetBindedRenderTarget(window);
				}

				IGuiGraphicsLayoutProvider* GetLayoutProvider()override
				{
					return layoutProvider.Obj();
				}

				void NativeWindowCreated(INativeWindow* window)override
				{
					WindowsGDIRenderTarget* renderTarget=new WindowsGDIRenderTarget(window);
					renderTargets.Add(renderTarget);
					GetWindowsGDIObjectProvider()->SetBindedRenderTarget(window, renderTarget);
				}

				void NativeWindowDestroying(INativeWindow* window)override
				{
					WindowsGDIRenderTarget* renderTarget=dynamic_cast<WindowsGDIRenderTarget*>(GetWindowsGDIObjectProvider()->GetBindedRenderTarget(window));
					GetWindowsGDIObjectProvider()->SetBindedRenderTarget(window, 0);
					renderTargets.Remove(renderTarget);
				}

				Ptr<windows::WinPen> CreateGdiPen(Color color)override
				{
					return pens.Create(color);
				}

				void DestroyGdiPen(Color color)override
				{
					pens.Destroy(color);
				}

				Ptr<windows::WinBrush> CreateGdiBrush(Color color)override
				{
					return brushes.Create(color);
				}

				void DestroyGdiBrush(Color color)override
				{
					brushes.Destroy(color);
				}

				Ptr<windows::WinFont> CreateGdiFont(const FontProperties& fontProperties)override
				{
					return fonts.Create(fontProperties);
				}

				void DestroyGdiFont(const FontProperties& fontProperties)override
				{
					fonts.Destroy(fontProperties);
				}

				Ptr<elements::text::CharMeasurer> CreateCharMeasurer(const FontProperties& fontProperties)override
				{
					return charMeasurers.Create(fontProperties);
				}

				void DestroyCharMeasurer(const FontProperties& fontProperties)override
				{
					charMeasurers.Destroy(fontProperties);
				}

				Ptr<windows::WinBitmap> GetBitmap(INativeImageFrame* frame, bool enabled)override
				{
					Ptr<INativeImageFrameCache> cache=frame->GetCache(this);
					if(cache)
					{
						return cache.Cast<WindowsGDIImageFrameCache>()->GetBitmap(enabled);
					}
					else
					{
						WindowsGDIImageFrameCache* gdiCache=new WindowsGDIImageFrameCache(this);
						if(frame->SetCache(this, gdiCache))
						{
							return gdiCache->GetBitmap(enabled);
						}
						else
						{
							return 0;
						}
					}
				}

				void DestroyBitmapCache(INativeImageFrame* frame)override
				{
					WindowsGDIImageFrameCache* cache=frame->GetCache(this).Cast<WindowsGDIImageFrameCache>().Obj();
					imageCaches.Remove(cache);
				}
			};
		}

		namespace elements_windows_gdi
		{
			IWindowsGDIResourceManager* windowsGDIResourceManager=0;

			IWindowsGDIResourceManager* GetWindowsGDIResourceManager()
			{
				return windowsGDIResourceManager;
			}

			void SetWindowsGDIResourceManager(IWindowsGDIResourceManager* resourceManager)
			{
				windowsGDIResourceManager=resourceManager;
			}

/***********************************************************************
OS Supporting
***********************************************************************/

			IWindowsGDIObjectProvider* windowsGDIObjectProvider=0;

			IWindowsGDIObjectProvider* GetWindowsGDIObjectProvider()
			{
				return windowsGDIObjectProvider;
			}

			void SetWindowsGDIObjectProvider(IWindowsGDIObjectProvider* provider)
			{
				windowsGDIObjectProvider=provider;
			}
		}
	}
}

/***********************************************************************
NativeMain
***********************************************************************/

using namespace vl::presentation;
using namespace vl::presentation::elements;

void RendererMainGDI()
{
	elements_windows_gdi::WindowsGDIResourceManager resourceManager;
	SetGuiGraphicsResourceManager(&resourceManager);
	elements_windows_gdi::SetWindowsGDIResourceManager(&resourceManager);
	GetCurrentController()->CallbackService()->InstallListener(&resourceManager);

	elements_windows_gdi::GuiSolidBorderElementRenderer::Register();
	elements_windows_gdi::GuiRoundBorderElementRenderer::Register();
	elements_windows_gdi::Gui3DBorderElementRenderer::Register();
	elements_windows_gdi::Gui3DSplitterElementRenderer::Register();
	elements_windows_gdi::GuiSolidBackgroundElementRenderer::Register();
	elements_windows_gdi::GuiGradientBackgroundElementRenderer::Register();
	elements_windows_gdi::GuiSolidLabelElementRenderer::Register();
	elements_windows_gdi::GuiImageFrameElementRenderer::Register();
	elements_windows_gdi::GuiPolygonElementRenderer::Register();
	elements_windows_gdi::GuiColorizedTextElementRenderer::Register();
	elements_windows_gdi::GuiGDIElementRenderer::Register();
	elements::GuiDocumentElement::GuiDocumentElementRenderer::Register();

	GuiApplicationMain();
	elements_windows_gdi::SetWindowsGDIResourceManager(0);
	SetGuiGraphicsResourceManager(0);
}

/***********************************************************************
NativeWindow\GuiNativeWindow.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{

/***********************************************************************
INativeWindowListener
***********************************************************************/

		INativeWindowListener::HitTestResult INativeWindowListener::HitTest(Point location)
		{
			return INativeWindowListener::NoDecision;
		}

		void INativeWindowListener::Moving(Rect& bounds, bool fixSizeOnly)
		{
		}

		void INativeWindowListener::Moved()
		{
		}

		void INativeWindowListener::Enabled()
		{
		}

		void INativeWindowListener::Disabled()
		{
		}

		void INativeWindowListener::GotFocus()
		{
		}

		void INativeWindowListener::LostFocus()
		{
		}

		void INativeWindowListener::Activated()
		{
		}

		void INativeWindowListener::Deactivated()
		{
		}

		void INativeWindowListener::Opened()
		{
		}

		void INativeWindowListener::Closing(bool& cancel)
		{
		}

		void INativeWindowListener::Closed()
		{
		}

		void INativeWindowListener::Paint()
		{
		}

		void INativeWindowListener::Destroying()
		{
		}

		void INativeWindowListener::Destroyed()
		{
		}

		void INativeWindowListener::LeftButtonDown(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::LeftButtonUp(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::LeftButtonDoubleClick(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::RightButtonDown(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::RightButtonUp(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::RightButtonDoubleClick(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::MiddleButtonDown(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::MiddleButtonUp(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::HorizontalWheel(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::VerticalWheel(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::MouseMoving(const NativeWindowMouseInfo& info)
		{
		}

		void INativeWindowListener::MouseEntered()
		{
		}

		void INativeWindowListener::MouseLeaved()
		{
		}

		void INativeWindowListener::KeyDown(const NativeWindowKeyInfo& info)
		{
		}

		void INativeWindowListener::KeyUp(const NativeWindowKeyInfo& info)
		{
		}

		void INativeWindowListener::SysKeyDown(const NativeWindowKeyInfo& info)
		{
		}

		void INativeWindowListener::SysKeyUp(const NativeWindowKeyInfo& info)
		{
		}

		void INativeWindowListener::Char(const NativeWindowCharInfo& info)
		{
		}

/***********************************************************************
INativeControllerListener
***********************************************************************/

		void INativeControllerListener::LeftButtonDown(Point position)
		{
		}

		void INativeControllerListener::LeftButtonUp(Point position)
		{
		}

		void INativeControllerListener::RightButtonDown(Point position)
		{
		}

		void INativeControllerListener::RightButtonUp(Point position)
		{
		}

		void INativeControllerListener::MouseMoving(Point position)
		{
		}

		void INativeControllerListener::GlobalTimer()
		{
		}

		void INativeControllerListener::ClipboardUpdated()
		{
		}

		void INativeControllerListener::NativeWindowCreated(INativeWindow* window)
		{
		}

		void INativeControllerListener::NativeWindowDestroying(INativeWindow* window)
		{
		}

/***********************************************************************
Native Window Provider
***********************************************************************/

		INativeController* currentController=0;

		INativeController* GetCurrentController()
		{
			return currentController;
		}

		void SetCurrentController(INativeController* controller)
		{
			currentController=controller;
		}
	}
}

/***********************************************************************
NativeWindow\Windows\Direct2D\WinDirect2DApplication.cpp
***********************************************************************/
#pragma comment(lib, "d2d1.lib")
#pragma comment(lib, "dwrite.lib")


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			using namespace vl::collections;

			class Direct2DWindowsNativeWindowListener : public Object, public INativeWindowListener
			{
			protected:
				ID2D1Factory*					d2dFactory;
				ComPtr<ID2D1HwndRenderTarget>	d2dRenderTarget;
				INativeWindow*					window;
				Size							previousSize;

				void RebuildCanvas(Size size)
				{
					if(size.x==0) size.x=1;
					if(size.y==0) size.y=1;
					if(!d2dRenderTarget)
					{
						ID2D1HwndRenderTarget* renderTarget=0;
						IWindowsForm* form=GetWindowsForm(window);
						HRESULT hr=d2dFactory->CreateHwndRenderTarget(
							D2D1::RenderTargetProperties(),
							D2D1::HwndRenderTargetProperties(
								form->GetWindowHandle(),
								D2D1::SizeU((int)size.x, (int)size.y)
								),
							&renderTarget
							);
						if(!FAILED(hr))
						{
							d2dRenderTarget=renderTarget;
							d2dRenderTarget->SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE);
						}
					}
					else if(previousSize!=size)
					{
						d2dRenderTarget->Resize(D2D1::SizeU((int)size.x, (int)size.y));
					}
					previousSize=size;
				}
			public:
				Direct2DWindowsNativeWindowListener(INativeWindow* _window, ID2D1Factory* _d2dFactory)
					:window(_window)
					,d2dFactory(_d2dFactory)
					,d2dRenderTarget(0)
				{
				}

				void Moved()
				{
					RebuildCanvas(window->GetClientSize());
				}

				void Paint()
				{
				}

				ID2D1RenderTarget* GetDirect2DRenderTarget()
				{
					if(!d2dRenderTarget) Moved();
					return d2dRenderTarget.Obj();
				}
			};

			class Direct2DWindowsNativeControllerListener : public Object, public INativeControllerListener
			{
			public:
				Dictionary<INativeWindow*, Ptr<Direct2DWindowsNativeWindowListener>>		nativeWindowListeners;
				ComPtr<ID2D1Factory>														d2dFactory;
				ComPtr<IDWriteFactory>														dwrite;

				Direct2DWindowsNativeControllerListener()
				{
					{
						ID2D1Factory* factory=0;
						HRESULT hr=D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &factory);
						if(!FAILED(hr))
						{
							d2dFactory=factory;
						}
					}
					{
						IDWriteFactory* factory=0;
						HRESULT hr=DWriteCreateFactory(DWRITE_FACTORY_TYPE_ISOLATED, __uuidof(IDWriteFactory), reinterpret_cast<IUnknown**>(&factory));
						if(!FAILED(hr))
						{
							dwrite=factory;
						}
					}
				}

				void NativeWindowCreated(INativeWindow* window)
				{
					Ptr<Direct2DWindowsNativeWindowListener> listener=new Direct2DWindowsNativeWindowListener(window, d2dFactory.Obj());
					window->InstallListener(listener.Obj());
					nativeWindowListeners.Add(window, listener);
				}

				void NativeWindowDestroying(INativeWindow* window)
				{
					Ptr<Direct2DWindowsNativeWindowListener> listener=nativeWindowListeners[window];
					nativeWindowListeners.Remove(window);
					window->UninstallListener(listener.Obj());
				}
			};

			Direct2DWindowsNativeControllerListener* direct2DListener=0;

			ID2D1RenderTarget* GetNativeWindowDirect2DRenderTarget(INativeWindow* window)
			{
				vint index=direct2DListener->nativeWindowListeners.Keys().IndexOf(window);
				return index==-1?0:direct2DListener->nativeWindowListeners.Values().Get(index)->GetDirect2DRenderTarget();
			}

			ID2D1Factory* GetDirect2DFactory()
			{
				return direct2DListener->d2dFactory.Obj();
			}

			IDWriteFactory* GetDirectWriteFactory()
			{
				return direct2DListener->dwrite.Obj();
			}
		}

		namespace elements_windows_d2d
		{
/***********************************************************************
OS Supporting
***********************************************************************/

			class WinDirect2DApplicationDirect2DObjectProvider : public IWindowsDirect2DObjectProvider
			{
			public:
				ID2D1RenderTarget* GetNativeWindowDirect2DRenderTarget(INativeWindow* window)
				{
					return vl::presentation::windows::GetNativeWindowDirect2DRenderTarget(window);
				}

				ID2D1Factory* GetDirect2DFactory()
				{
					return vl::presentation::windows::GetDirect2DFactory();
				}

				IDWriteFactory* GetDirectWriteFactory()
				{
					return vl::presentation::windows::GetDirectWriteFactory();
				}

				IWindowsDirect2DRenderTarget* GetBindedRenderTarget(INativeWindow* window)
				{
					return dynamic_cast<IWindowsDirect2DRenderTarget*>(vl::presentation::windows::GetWindowsForm(window)->GetGraphicsHandler());
				}

				void SetBindedRenderTarget(INativeWindow* window, IWindowsDirect2DRenderTarget* renderTarget)
				{
					vl::presentation::windows::GetWindowsForm(window)->SetGraphicsHandler(renderTarget);
				}

				IWICImagingFactory* GetWICImagingFactory()
				{
					return vl::presentation::windows::GetWICImagingFactory();
				}

				IWICBitmap* GetWICBitmap(INativeImageFrame* frame)
				{
					return vl::presentation::windows::GetWICBitmap(frame);
				}
			};
		}
	}
}

using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::windows;
using namespace vl::presentation::elements_windows_d2d;

int WinMainDirect2D(HINSTANCE hInstance, void(*RendererMain)())
{
	CoInitializeEx(NULL, COINIT_MULTITHREADED);
	// create controller
	INativeController* controller=CreateWindowsNativeController(hInstance);
	SetCurrentController(controller);
	{
		// install listener
		Direct2DWindowsNativeControllerListener listener;
		controller->CallbackService()->InstallListener(&listener);
		direct2DListener=&listener;
		// main
		RendererMain();
		// uninstall listener
		direct2DListener=0;
		controller->CallbackService()->UninstallListener(&listener);
	}
	// destroy controller
	DestroyWindowsNativeController(controller);
	return 0;
}

int SetupWindowsDirect2DRenderer()
{
	HINSTANCE hInstance=(HINSTANCE)GetModuleHandle(NULL);
	WinDirect2DApplicationDirect2DObjectProvider objectProvider;
	SetWindowsDirect2DObjectProvider(&objectProvider);
	return WinMainDirect2D(hInstance, &RendererMainDirect2D);
}

/***********************************************************************
NativeWindow\Windows\GDI\WinGDI.cpp
***********************************************************************/

#pragma comment(lib, "Msimg32.lib")

namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/*********************************************************************************************************
WinRegion
*********************************************************************************************************/

		bool IsEqual(WinRegion::Ptr Region1, WinRegion::Ptr Region2)
		{
			return EqualRgn(Region1->GetHandle(), Region2->GetHandle())!=0;
		}

		WinRegion::WinRegion(vint Left, vint Top, vint Right, vint Bottom, bool Rectangle)
		{
			if(Rectangle)
			{
				FHandle=CreateRectRgn((int)Left, (int)Top, (int)Right, (int)Bottom);
			}
			else
			{
				FHandle=CreateEllipticRgn((int)Left, (int)Top, (int)Right, (int)Bottom);
			}
		}

		WinRegion::WinRegion(RECT Rect, bool Rectangle)
		{
			if(Rectangle)
			{
				FHandle=CreateRectRgnIndirect(&Rect);
			}
			else
			{
				FHandle=CreateEllipticRgnIndirect(&Rect);
			}
		}

		WinRegion::WinRegion(vint Left, vint Top, vint Right, vint Bottom, vint EllipseWidth, vint EllipseHeight)
		{
			FHandle=CreateRoundRectRgn((int)Left, (int)Top, (int)Right, (int)Bottom, (int)EllipseWidth, (int)EllipseHeight);
		}

		WinRegion::WinRegion(POINT* Points, vint Count, bool Alternate)
		{
			FHandle=CreatePolygonRgn(Points, (int)Count, Alternate?ALTERNATE:WINDING);
		}

		WinRegion::WinRegion(WinRegion::Ptr Region)
		{
			FHandle=CreateRectRgn(0, 0, 1, 1);
			CombineRgn(FHandle, Region->GetHandle(), Region->GetHandle(), RGN_COPY);
		}

		WinRegion::WinRegion(WinRegion::Ptr Region1, WinRegion::Ptr Region2, vint CombineMode)
		{
			FHandle=CreateRectRgn(0, 0, 1, 1);
			CombineRgn(FHandle, Region1->GetHandle(), Region2->GetHandle(), (int)CombineMode);
		}

		WinRegion::WinRegion(HRGN RegionHandle)
		{
			FHandle=RegionHandle;
		}

		WinRegion::~WinRegion()
		{
			DeleteObject(FHandle);
		}

		HRGN WinRegion::GetHandle()
		{
			return FHandle;
		}

		bool WinRegion::ContainPoint(POINT Point)
		{
			return PtInRegion(FHandle, Point.x, Point.y)!=0;
		}

		bool WinRegion::ContainRect(RECT Rect)
		{
			return RectInRegion(FHandle, &Rect)!=0;
		}

		RECT WinRegion::GetBoundRect()
		{
			RECT Rect={0, 0, 0, 0};
			GetRgnBox(FHandle, &Rect);
			return Rect;
		}

		void WinRegion::Move(vint OffsetX, vint OffsetY)
		{
			OffsetRgn(FHandle, (int)OffsetX, (int)OffsetY);
		}

/*********************************************************************************************************
WinTransform
*********************************************************************************************************/
	
		WinTransform::WinTransform(XFORM Transform)
		{
			FTransform=Transform;
		}

		WinTransform::WinTransform(const WinTransform& Transform)
		{
			FTransform=Transform.FTransform;
		}

		WinTransform& WinTransform::operator=(const WinTransform& Transform)
		{
			FTransform=Transform.FTransform;
			return *this;
		}

		WinTransform WinTransform::operator*(const WinTransform& Transform)
		{
			XFORM Result;
			CombineTransform(&Result, GetHandle(), Transform.GetHandle());
			return Result;
		}

		const XFORM* WinTransform::GetHandle()const
		{
			return &FTransform;
		}

		/*------------------------------------------------------------------------------*/

		WinTransform WinTransform::Translate(float OffsetX, float OffsetY)
		{
			XFORM Transform;
			Transform.eM11=1.0f;
			Transform.eM12=0.0f;
			Transform.eM21=0.0f;
			Transform.eM22=1.0f;
			Transform.eDx=OffsetX;
			Transform.eDy=OffsetY;
			return Transform;
		}

		WinTransform WinTransform::Scale(float ScaleX, float ScaleY)
		{
			XFORM Transform;
			Transform.eM11=ScaleX;
			Transform.eM12=0.0f;
			Transform.eM21=0.0f;
			Transform.eM22=ScaleY;
			Transform.eDx=0.0f;
			Transform.eDy=0.0f;
			return Transform;
		}

		WinTransform WinTransform::Rotate(float Angle)
		{
			XFORM Transform;
			Transform.eM11=cos(Angle);
			Transform.eM12=sin(Angle);
			Transform.eM21=-sin(Angle);
			Transform.eM22=cos(Angle);
			Transform.eDx=0.0f;
			Transform.eDy=0.0f;
			return Transform;
		}

		WinTransform WinTransform::Rotate(float Cos, float Sin)
		{
			XFORM Transform;
			Transform.eM11=Cos;
			Transform.eM12=Sin;
			Transform.eM21=-Sin;
			Transform.eM22=Cos;
			Transform.eDx=0.0f;
			Transform.eDy=0.0f;
			return Transform;
		}

		WinTransform WinTransform::ReflectX()
		{
			XFORM Transform;
			Transform.eM11=1.0f;
			Transform.eM12=0.0f;
			Transform.eM21=0.0f;
			Transform.eM22=-1.0f;
			Transform.eDx=0.0f;
			Transform.eDy=0.0f;
			return Transform;
		}

		WinTransform WinTransform::ReflectY()
		{
			XFORM Transform;
			Transform.eM11=-1.0f;
			Transform.eM12=0.0f;
			Transform.eM21=0.0f;
			Transform.eM22=1.0f;
			Transform.eDx=0.0f;
			Transform.eDy=0.0f;
			return Transform;
		}

		WinTransform WinTransform::Reflect(float VectorX, float VectorY)
		{
			float Len=sqrt(VectorX*VectorX+VectorY*VectorY);
			float Cos=VectorX/Len;
			float Sin=VectorY/Len;

			return Rotate(Cos, -Sin)*ReflectX()*Rotate(Cos, Sin);
		}

		WinTransform WinTransform::Reflect(float OriginX, float OriginY, float VectorX, float VectorY)
		{
			float Len=sqrt(VectorX*VectorX+VectorY*VectorY);
			float Cos=VectorX/Len;
			float Sin=VectorY/Len;

			return Translate(-OriginX, -OriginY)*Rotate(Cos, -Sin)*ReflectX()*Rotate(Cos, Sin)*Translate(OriginX, OriginY);
		}

		WinTransform WinTransform::AxisV(float Xx, float Xy, float Yx, float Yy)
		{
			XFORM Transform;
			Transform.eM11=Xx;
			Transform.eM12=Xy;
			Transform.eM21=Yx;
			Transform.eM22=Yy;
			Transform.eDx=0.0f;
			Transform.eDy=0.0f;
			return Transform;
		}

		WinTransform WinTransform::AxisA(float AngleX, float LenX, float AngleY, float LenY)
		{
			XFORM Transform;
			Transform.eM11=cos(AngleX)*LenX;
			Transform.eM12=sin(AngleX)*LenX;
			Transform.eM21=cos(AngleY)*LenY;
			Transform.eM22=sin(AngleY)*LenY;
			Transform.eDx=0.0f;
			Transform.eDy=0.0f;
			return Transform;
		}

/*********************************************************************************************************
WinMetaFileBuilder
*********************************************************************************************************/

		void WinMetaFileBuilder::Create(vint Width, vint Height)
		{
			HDC hdcRef=GetDC(NULL);
			vint iWidthMM = GetDeviceCaps(hdcRef, HORZSIZE); 
			vint iHeightMM = GetDeviceCaps(hdcRef, VERTSIZE); 
			vint iWidthPels = GetDeviceCaps(hdcRef, HORZRES); 
			vint iHeightPels = GetDeviceCaps(hdcRef, VERTRES); 
			ReleaseDC(NULL, hdcRef);

			RECT Rect;
			Rect.left=0;
			Rect.top=0;
			Rect.right = (int)((Width*iWidthMM*100)/iWidthPels);
			Rect.bottom = (int)((Height*iHeightMM*100)/iHeightPels);

			HDC Handle=CreateEnhMetaFile(NULL, NULL, &Rect, L"VczhLibrary++GDI\0Enhanced Meta File\0");
			FDC->Initialize(Handle);

			FWidth=Width;
			FHeight=Height;
		}

		void WinMetaFileBuilder::Draw(HENHMETAFILE Handle)
		{
			RECT Rect;
			Rect.left=0;
			Rect.top=0;
			Rect.right=(int)FWidth;
			Rect.bottom=(int)FHeight;
			PlayEnhMetaFile(FDC->GetHandle(), Handle, &Rect);
		}

		void WinMetaFileBuilder::Destroy()
		{
			DeleteEnhMetaFile(CloseEnhMetaFile(FDC->GetHandle()));
		}

		WinMetaFileBuilder::WinMetaFileBuilder(vint Width, vint Height)
		{
			FDC=new WinProxyDC();
			Create(Width, Height);
		}

		WinMetaFileBuilder::~WinMetaFileBuilder()
		{
			Destroy();
			delete FDC;
		}

		void WinMetaFileBuilder::LoadFrom(WinMetaFile* File)
		{
			Destroy();
			Create(File->GetWidth(), File->GetHeight());
			Draw(File->GetHandle());
		}

		void WinMetaFileBuilder::SaveTo(WinMetaFile* File)
		{
			HENHMETAFILE Handle=CloseEnhMetaFile(FDC->GetHandle());
			if(File->FHandle)
			{
				DeleteEnhMetaFile(File->FHandle);
			}
			File->FHandle=Handle;
			File->FWidth=FWidth;
			File->FHeight=FHeight;
			Create(FWidth, FHeight);
			Draw(Handle);
		}

		void WinMetaFileBuilder::LoadFrom(WString FileName)
		{
			WinMetaFile File(FileName);
			Destroy();
			Create(File.GetWidth(), File.GetHeight());
			Draw(File.GetHandle());
		}

		void WinMetaFileBuilder::SaveTo(WString FileName)
		{
			HENHMETAFILE Handle=CloseEnhMetaFile(FDC->GetHandle());
			HENHMETAFILE NewHandle=CopyEnhMetaFile(Handle, FileName.Buffer());
			DeleteEnhMetaFile(NewHandle);
			Create(FWidth, FHeight);
			Draw(Handle);
			DeleteEnhMetaFile(Handle);
		}

		WinDC* WinMetaFileBuilder::GetWinDC()
		{
			return FDC;
		}

		vint WinMetaFileBuilder::GetWidth()
		{
			return FWidth;
		}

		vint WinMetaFileBuilder::GetHeight()
		{
			return FHeight;
		}

/*********************************************************************************************************
WinMetaFile
*********************************************************************************************************/

		WinMetaFile::WinMetaFile(WString FileName)
		{
			FHandle=GetEnhMetaFile(FileName.Buffer());
			ENHMETAHEADER Header;
			GetEnhMetaFileHeader(FHandle, sizeof(Header), &Header);
			FWidth=(Header.rclFrame.right-Header.rclFrame.left)*Header.szlDevice.cx/(Header.szlMillimeters.cx*100);
			FHeight=(Header.rclFrame.bottom-Header.rclFrame.top)*Header.szlDevice.cy/(Header.szlMillimeters.cy*100);
		}

		WinMetaFile::WinMetaFile(WinMetaFileBuilder* Builder)
		{
			FHandle=NULL;
			Builder->SaveTo(this);
		}

		WinMetaFile::~WinMetaFile()
		{
			DeleteEnhMetaFile(FHandle);
		}

		HENHMETAFILE WinMetaFile::GetHandle()
		{
			return FHandle;
		}

		vint WinMetaFile::GetWidth()
		{
			return FWidth;
		}

		vint WinMetaFile::GetHeight()
		{
			return FHeight;
		}

/*********************************************************************************************************
WinBitmap
*********************************************************************************************************/

		vint WinBitmap::GetBitsFromBB(BitmapBits BB)
		{
			switch(BB)
			{
			case vbb32Bits:
				return 32;
			case vbb24Bits:
				return 24;
			default:
				return 1;
			}
		}

		vint WinBitmap::GetLineBytes(vint Width, BitmapBits BB)
		{
			vint Bits=GetBitsFromBB(BB);
			vint LineBits=Width*Bits;
			vint AlignBits=sizeof(DWORD)*8;
			LineBits+=(AlignBits-LineBits%AlignBits)%AlignBits;
			return LineBits/8;
		}

		void WinBitmap::FillBitmapInfoHeader(vint Width, vint Height, BitmapBits Bits, BITMAPINFOHEADER* Header)
		{
			Header->biSize=sizeof(BITMAPINFOHEADER);
			Header->biWidth=(int)Width;
			Header->biHeight=-(int)Height;
			Header->biPlanes=1;
			Header->biBitCount=(int)GetBitsFromBB(Bits);
			Header->biCompression=BI_RGB;
			Header->biSizeImage=0;
			Header->biXPelsPerMeter=0;
			Header->biYPelsPerMeter=0;
			Header->biClrUsed=(Bits==vbb2Bits?2:0);
			Header->biClrImportant=0;
		}

		HBITMAP WinBitmap::CreateDDB(vint Width, vint Height, BitmapBits Bits)
		{
			if(Bits==vbb2Bits)
			{
				return CreateBitmap((int)Width, (int)Height, 2, (int)GetBitsFromBB(Bits), NULL);
			}
			else
			{
				WinBitmap Bitmap(1, 1, Bits, true);
				return CreateCompatibleBitmap(Bitmap.GetWinDC()->GetHandle(), (int)Width, (int)Height);
			}
		}

		HBITMAP WinBitmap::CreateDIB(vint Width, vint Height, BitmapBits Bits, BYTE**& ScanLines)
		{
			BITMAPINFO* Info=(BITMAPINFO*)malloc(sizeof(BITMAPINFOHEADER)+2*sizeof(RGBQUAD));
			FillBitmapInfoHeader(Width, Height, Bits, &Info->bmiHeader);
			Info->bmiColors[0].rgbBlue=0;
			Info->bmiColors[0].rgbGreen=0;
			Info->bmiColors[0].rgbRed=0;
			Info->bmiColors[0].rgbReserved=0;
			Info->bmiColors[1].rgbBlue=255;
			Info->bmiColors[1].rgbGreen=255;
			Info->bmiColors[1].rgbRed=255;
			Info->bmiColors[1].rgbReserved=255;

			BYTE* FirstLine=0;
			HBITMAP Handle=CreateDIBSection(FDC->GetHandle(), Info, DIB_RGB_COLORS, (void**)&FirstLine, NULL, 0);
			ScanLines=new BYTE*[Height];
			vint LineBytes=GetLineBytes(Width, Bits);
			for(vint i=0;i<Height;i++)
			{
				ScanLines[i]=FirstLine+LineBytes*i;
			}
			free(Info);
			return Handle;
		}

		void WinBitmap::Constructor(vint Width, vint Height, BitmapBits Bits, bool DIBSections)
		{
			FDC=new WinImageDC();
			if(DIBSections)
			{
				FHandle=CreateDIB(Width, Height, Bits, FScanLines);
			}
			else
			{
				FHandle=CreateDDB(Width, Height, Bits);
				FScanLines=0;
			}
			FWidth=Width;
			FHeight=Height;
			FBits=Bits;
			FAlphaChannelBuilt=false;
			HGDIOBJ Object=SelectObject(FDC->GetHandle(), FHandle);
			if(Object)
			{
				DeleteObject(Object);
			}
		}
	
		WinBitmap::WinBitmap(vint Width, vint Height, BitmapBits Bits, bool DIBSections)
		{
			Constructor(Width, Height, Bits, DIBSections);
		}

		WinBitmap::WinBitmap(WString FileName, bool Use32Bits, bool DIBSections)
		{
			FBits=Use32Bits?vbb32Bits:vbb24Bits;
		
			HBITMAP	TempBmp=(HBITMAP)LoadImage(NULL, FileName.Buffer(), IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
			HDC		TempDC=CreateCompatibleDC(NULL);
			BITMAP	TempRec;

			GetObject(TempBmp, sizeof(BITMAP), &TempRec);
			DeleteObject(SelectObject(TempDC, TempBmp));

			Constructor(TempRec.bmWidth, TempRec.bmHeight, FBits, DIBSections);
			BitBlt(FDC->GetHandle(), 0, 0, TempRec.bmWidth, TempRec.bmHeight, TempDC, 0, 0, SRCCOPY);

			DeleteObject(TempDC);
			DeleteObject(TempBmp);
		}

		WinBitmap::~WinBitmap()
		{
			if(FScanLines)
			{
				delete[] FScanLines;
			}
			if(FHandle)
			{
				DeleteObject(FHandle);
			}
			delete FDC;
		}

		void WinBitmap::SaveToFile(WString FileName)
		{
			if(FScanLines)
			{
				BITMAPFILEHEADER Header1;
				BITMAPV5HEADER Header2;
				{
					Header1.bfType='M'*256+'B';
					Header1.bfSize=(int)(sizeof(Header1)+sizeof(Header2)+GetLineBytes()*FHeight);
					Header1.bfReserved1=0;
					Header1.bfReserved2=0;
					Header1.bfOffBits=sizeof(Header2)+sizeof(Header1);
				}
				{
					memset(&Header2, 0, sizeof(Header2));
					Header2.bV5Size=sizeof(Header2);
					Header2.bV5Width=(int)FWidth;
					Header2.bV5Height=-(int)FHeight;
					Header2.bV5Planes=1;
					Header2.bV5BitCount=(int)GetBitsFromBB(FBits);
					Header2.bV5Compression=BI_RGB;
					Header2.bV5CSType=LCS_sRGB;
					Header2.bV5Intent=LCS_GM_GRAPHICS;
				}
				stream::FileStream Output(FileName, stream::FileStream::WriteOnly);
				Output.Write(&Header1, sizeof(Header1));
				Output.Write(&Header2, sizeof(Header2));
				for(vint i=0;i<FHeight;i++)
				{
					Output.Write(FScanLines[i], GetLineBytes());
				}
			}
			else
			{
				WinBitmap Temp(FWidth, FHeight, FBits, true);
				Temp.GetWinDC()->Copy(0, 0, FWidth, FHeight, FDC, 0, 0);
				Temp.SaveToFile(FileName);
			}
		}

		WinDC* WinBitmap::GetWinDC()
		{
			return FDC;
		}

		vint WinBitmap::GetWidth()
		{
			return FWidth;
		}

		vint WinBitmap::GetHeight()
		{
			return FHeight;
		}

		vint WinBitmap::GetLineBytes()
		{
			return GetLineBytes(FWidth, FBits);
		}

		BYTE** WinBitmap::GetScanLines()
		{
			return FScanLines;
		}

		HBITMAP WinBitmap::GetBitmap()
		{
			return FHandle;
		}

		WinBitmap::BitmapBits WinBitmap::GetBitmapBits()
		{
			return FBits;
		}
	
		void WinBitmap::FillCompatibleHeader(BITMAPINFOHEADER* Header)
		{
			FillBitmapInfoHeader(FWidth, FHeight, FBits, Header);
		}

		bool WinBitmap::CanBuildAlphaChannel()
		{
			return FScanLines!=0 && FBits==vbb32Bits;
		}

		bool WinBitmap::IsAlphaChannelBuilt()
		{
			return FAlphaChannelBuilt;
		}

		void WinBitmap::BuildAlphaChannel(bool autoPremultiply)
		{
			if(CanBuildAlphaChannel() && !FAlphaChannelBuilt)
			{
				FAlphaChannelBuilt=true;
				if(autoPremultiply)
				{
					for(vint i=0;i<FHeight;i++)
					{
						BYTE* Colors=FScanLines[i];
						vint j=FWidth;
						while(j--)
						{
							BYTE Alpha=Colors[3];
							Colors[0]=Colors[0]*Alpha/255;
							Colors[1]=Colors[1]*Alpha/255;
							Colors[2]=Colors[2]*Alpha/255;
							Colors+=4;
						}
					}
				}
			}
		}

		void WinBitmap::GenerateTrans(COLORREF Color)
		{
			if(CanBuildAlphaChannel() && !FAlphaChannelBuilt)
			{
				for(vint i=0;i<FHeight;i++)
				{
					COLORREF* Colors=(COLORREF*)FScanLines[i];
					vint j=FWidth;
					while(j--)
					{
						COLORREF Dest=*Colors & 0x00FFFFFF;
						*Colors = Dest | (0xFF000000 * (Dest!=Color));
						Colors++;
					}
				}
			}
		}

		void WinBitmap::GenerateAlpha(BYTE Alpha)
		{
			if(CanBuildAlphaChannel() && !FAlphaChannelBuilt)
			{
				for(vint i=0;i<FHeight;i++)
				{
					BYTE* Colors=FScanLines[i];
					vint j=FWidth;
					while(j--)
					{
						Colors[3]=Alpha;
						Colors+=4;
					}
				}
			}
		}

		void WinBitmap::GenerateTransAlpha(COLORREF Color, BYTE Alpha)
		{
			if(CanBuildAlphaChannel() && !FAlphaChannelBuilt)
			{
				COLORREF A=Alpha<<24;
				for(vint i=0;i<FHeight;i++)
				{
					COLORREF* Colors=(COLORREF*)FScanLines[i];
					vint j=FWidth;
					while(j--)
					{
						COLORREF Dest=*Colors & 0x00FFFFFF;
						*Colors = Dest | (A * (Dest!=Color));
						Colors++;
					}
				}
			}
		}

		void WinBitmap::GenerateLuminance()
		{
			if(CanBuildAlphaChannel() && !FAlphaChannelBuilt)
			{
				for(vint i=0;i<FHeight;i++)
				{
					COLORREF* Colors=(COLORREF*)FScanLines[i];
					vint j=FWidth;
					while(j--)
					{
						COLORREF Dest=*Colors & 0x00FFFFFF;
						*Colors = Dest | ((GetRValue(Dest)*77 + GetGValue(Dest)*151 + GetBValue(Dest)*28) & 0x0000FF00)<<16;
						Colors++;
					}
				}
			}
		}

		void WinBitmap::GenerateGrayLevel()
		{
			if(CanBuildAlphaChannel() && !FAlphaChannelBuilt)
			{
				for(vint i=0;i<FHeight;i++)
				{
					COLORREF* Colors=(COLORREF*)FScanLines[i];
					vint j=FWidth;
					while(j--)
					{
						COLORREF Dest=*Colors & 0x00FFFFFF;
						*Colors = Dest | ((GetRValue(Dest)+GetGValue(Dest)+GetBValue(Dest))/3)<<24;
						Colors++;
					}
				}
			}
		}

		void WinBitmap::Generate(BYTE(*Function)(COLORREF))
		{
			if(CanBuildAlphaChannel() && !FAlphaChannelBuilt)
			{
				for(vint i=0;i<FHeight;i++)
				{
					COLORREF* Colors=(COLORREF*)FScanLines[i];
					vint j=FWidth;
					while(j--)
					{
						COLORREF Dest= *Colors & 0x00FFFFFF;
						*Colors = Dest | Function(Dest)<<24;
						Colors++;
					}
				}
			}
		}
			
/*********************************************************************************************************
WinBrush
*********************************************************************************************************/

		WinBrush::WinBrush()
		{
			FDIBMemory=0;
			LOGBRUSH lb;
			lb.lbColor=0;
			lb.lbStyle=BS_NULL;
			lb.lbHatch=0;
			FHandle=CreateBrushIndirect(&lb);
		}

		WinBrush::WinBrush(COLORREF Color)
		{
			FDIBMemory=0;
			FHandle=CreateSolidBrush(Color);
		}

		WinBrush::WinBrush(vint Hatch, COLORREF Color)
		{
			FDIBMemory=0;
			FHandle=CreateHatchBrush((int)Hatch, Color);
		}

		WinBrush::WinBrush(WinBitmap::Ptr DIB)
		{
			WinBitmap Temp(DIB->GetWidth(), DIB->GetHeight(), WinBitmap::vbb24Bits, true);
			Temp.GetWinDC()->Draw(0, 0, DIB);
			vint HeaderSize=sizeof(BITMAPINFOHEADER);
			FDIBMemory=new unsigned char[HeaderSize+Temp.GetHeight()*Temp.GetLineBytes()];
			Temp.FillCompatibleHeader((BITMAPINFOHEADER*)FDIBMemory);
			memcpy(FDIBMemory+HeaderSize, Temp.GetScanLines()[0], Temp.GetHeight()*Temp.GetLineBytes());

			FHandle=CreateDIBPatternBrushPt(FDIBMemory, DIB_RGB_COLORS);
			DWORD Error=GetLastError();
		}

		WinBrush::~WinBrush()
		{
			DeleteObject(FHandle);
			if(FDIBMemory)
			{
				delete[] FDIBMemory;
			}
		}

		HBRUSH WinBrush::GetHandle()
		{
			return FHandle;
		}

/*********************************************************************************************************
WinPen
*********************************************************************************************************/

		WinPen::WinPen(vint Style, vint Width, COLORREF Color)
		{
			FDIBMemory=0;
			FHandle=CreatePen((int)Style, (int)Width, (int)Color);
		}

		WinPen::WinPen(vint Style, vint EndCap, vint Join, vint Width, COLORREF Color)
		{
			FDIBMemory=0;
			LOGBRUSH Brush;
			Brush.lbColor=Color;
			Brush.lbStyle=BS_SOLID;
			Brush.lbHatch=0;
			FHandle=ExtCreatePen((int)(PS_GEOMETRIC|Style|EndCap|Join), (int)Width, &Brush, 0, 0);
		}

		WinPen::WinPen(vint Style, vint EndCap, vint Join, vint Hatch, vint Width, COLORREF Color)
		{
			FDIBMemory=0;
			LOGBRUSH Brush;
			Brush.lbColor=Color;
			Brush.lbStyle=BS_HATCHED;
			Brush.lbHatch=Hatch;
			FHandle=ExtCreatePen((int)(PS_GEOMETRIC|Style|EndCap|Join), (int)Width, &Brush, 0, 0);
		}

		WinPen::WinPen(WinBitmap::Ptr DIB, vint Style, vint EndCap, vint Join, vint Width)
		{
			WinBitmap Temp(DIB->GetWidth(), DIB->GetHeight(), WinBitmap::vbb24Bits, true);
			Temp.GetWinDC()->Draw(0, 0, DIB);
			vint HeaderSize=sizeof(BITMAPINFOHEADER);
			FDIBMemory=new unsigned char[HeaderSize+Temp.GetHeight()*Temp.GetLineBytes()];
			Temp.FillCompatibleHeader((BITMAPINFOHEADER*)FDIBMemory);
			memcpy(FDIBMemory+HeaderSize, Temp.GetScanLines()[0], Temp.GetHeight()*Temp.GetLineBytes());
		
			LOGBRUSH Brush;
			Brush.lbColor=RGB(0, 0, 0);
			Brush.lbStyle=BS_DIBPATTERNPT;
			Brush.lbHatch=(LONG)FDIBMemory;
			FHandle=ExtCreatePen((int)(PS_GEOMETRIC|Style|EndCap|Join), (int)Width, &Brush, 0, 0);
		}

		WinPen::~WinPen()
		{
			DeleteObject(FHandle);
			if(FDIBMemory)
			{
				delete[] FDIBMemory;
			}
		}

		HPEN WinPen::GetHandle()
		{
			return FHandle;
		}

/*********************************************************************************************************
WinFont
*********************************************************************************************************/

		WinFont::WinFont(WString Name, vint Height, vint Width, vint Escapement, vint Orientation, vint Weight, bool Italic, bool Underline, bool StrikeOut, bool Antialise)
		{
			FFontInfo.lfHeight=(int)Height;
			FFontInfo.lfWidth=(int)Width;
			FFontInfo.lfEscapement=(int)Escapement;
			FFontInfo.lfOrientation=(int)Orientation;
			FFontInfo.lfWeight=(int)Weight;
			FFontInfo.lfItalic=Italic?TRUE:FALSE;
			FFontInfo.lfUnderline=Underline?TRUE:FALSE;
			FFontInfo.lfStrikeOut=StrikeOut?TRUE:FALSE;
			FFontInfo.lfCharSet=DEFAULT_CHARSET;
			FFontInfo.lfOutPrecision=OUT_DEFAULT_PRECIS;
			FFontInfo.lfClipPrecision=CLIP_DEFAULT_PRECIS;
			FFontInfo.lfQuality=Antialise?CLEARTYPE_QUALITY:NONANTIALIASED_QUALITY;
			FFontInfo.lfPitchAndFamily=DEFAULT_PITCH | FF_DONTCARE;
			wcsncpy_s(FFontInfo.lfFaceName, sizeof(FFontInfo.lfFaceName)/sizeof(*FFontInfo.lfFaceName), Name.Buffer(), LF_FACESIZE-1);
			FHandle=CreateFontIndirect(&FFontInfo);
		}

		WinFont::WinFont(LOGFONT* FontInfo)
		{
			FFontInfo=*FontInfo;
			FHandle=CreateFontIndirect(&FFontInfo);
		}

		WinFont::~WinFont()
		{
			DeleteObject(FHandle);
		}

		HFONT WinFont::GetHandle()
		{
			return FHandle;
		}

		LOGFONT* WinFont::GetInfo()
		{
			return &FFontInfo;
		}

/*********************************************************************************************************
IWinResourceService
*********************************************************************************************************/

		WinBrush::Ptr CreateDefaultBrush()
		{
			return new WinBrush(RGB(255, 255, 255));
		}

		WinPen::Ptr CreateDefaultPen()
		{
			return new WinPen(PS_SOLID, 0, RGB(0, 0, 0));
		}

		WinFont::Ptr CreateDefaultFont()
		{
			NONCLIENTMETRICS NonClientMetrics;
			NonClientMetrics.cbSize=sizeof(NONCLIENTMETRICS);
			SystemParametersInfo(SPI_GETNONCLIENTMETRICS, NonClientMetrics.cbSize, &NonClientMetrics, 0);
			if(!*NonClientMetrics.lfMessageFont.lfFaceName)
			{
				NonClientMetrics.cbSize=sizeof(NONCLIENTMETRICS)-sizeof(NonClientMetrics.iPaddedBorderWidth);
				SystemParametersInfo(SPI_GETNONCLIENTMETRICS, NonClientMetrics.cbSize, &NonClientMetrics, 0);
			}
			return new WinFont(&NonClientMetrics.lfMessageFont);
		}

		class DefaultResourceService : public Object, public IWinResourceService
		{
		public:
			static IWinResourceService* _DefaultResourceService;

			WinPen::Ptr GetDefaultPen()
			{
				return CreateDefaultPen();
			}

			WinBrush::Ptr GetDefaultBrush()
			{
				return CreateDefaultBrush();
			}

			WinFont::Ptr GetDefaultFont()
			{
				return CreateDefaultFont();
			}
		} _DRS;
		IWinResourceService* DefaultResourceService::_DefaultResourceService=&_DRS;

		IWinResourceService* GetDefaultResourceService()
		{
			return DefaultResourceService::_DefaultResourceService;
		}

		void SetDefaultResourceService(IWinResourceService* Service)
		{
			DefaultResourceService::_DefaultResourceService=Service;
		}

/*********************************************************************************************************
WinDC
*********************************************************************************************************/

		void WinDC::Init()
		{
			FPen=GetDefaultResourceService()->GetDefaultPen();
			FOldPen=(HPEN)SelectObject(FHandle, FPen->GetHandle());

			FBrush=GetDefaultResourceService()->GetDefaultBrush();
			FOldBrush=(HBRUSH)SelectObject(FHandle, FBrush->GetHandle());

			FFont=GetDefaultResourceService()->GetDefaultFont();
			FOldFont=(HFONT)SelectObject(FHandle, FFont->GetHandle());

			SetGraphicsMode(FHandle, GM_ADVANCED);
		}

		WinDC::WinDC()
		{
			FHandle=0;
			FOldPen=0;
			FOldBrush=0;
			FOldFont=0;
		}

		WinDC::~WinDC()
		{
			SelectObject(FHandle, FOldFont);
			SelectObject(FHandle, FOldBrush);
			SelectObject(FHandle, FOldPen);
		}

		HDC WinDC::GetHandle()
		{
			return FHandle;
		}

		WinPen::Ptr WinDC::GetPen()
		{
			return FPen;
		}

		WinBrush::Ptr WinDC::GetBrush()
		{
			return FBrush;
		}

		WinFont::Ptr WinDC::GetFont()
		{
			return FFont;
		}

		void WinDC::SetPen(WinPen::Ptr Pen)
		{
			SelectObject(FHandle, Pen->GetHandle());
			FPen=Pen;
		}

		void WinDC::SetBrush(WinBrush::Ptr Brush)
		{
			SelectObject(FHandle, Brush->GetHandle());
			FBrush=Brush;
		}

		void WinDC::SetFont(WinFont::Ptr Font)
		{
			SelectObject(FHandle, Font->GetHandle());
			FFont=Font;
		}

		COLORREF WinDC::GetBackColor()
		{
			return GetBkColor(FHandle);
		}

		void WinDC::SetBackColor(COLORREF Color)
		{
			SetBkColor(FHandle, Color);
		}

		COLORREF WinDC::GetTextColor()
		{
			return ::GetTextColor(FHandle);
		}

		void WinDC::SetTextColor(COLORREF Color)
		{
			::SetTextColor(FHandle, Color);
		}

		bool WinDC::GetBackTransparent()
		{
			return GetBkMode(FHandle)==TRANSPARENT;
		}

		void WinDC::SetBackTransparent(bool Transparent)
		{
			SetBkMode(FHandle, Transparent?TRANSPARENT:OPAQUE);
		}

		POINT WinDC::GetBrushOrigin()
		{
			POINT Point;
			GetBrushOrgEx(FHandle, &Point);
			return Point;
		}

		void WinDC::SetBrushOrigin(POINT Point)
		{
			SetBrushOrgEx(FHandle, Point.x, Point.y, NULL);
		}

		/*------------------------------------------------------------------------------*/

		void WinDC::DrawBuffer(vint X, vint Y, const wchar_t* Text, vint CharCount)
		{
			TextOut(FHandle, (int)X, (int)Y, Text, (int)CharCount);
		}

		void WinDC::DrawBuffer(vint X, vint Y, const wchar_t* Text, vint CharCount, vint TabWidth, vint TabOriginX)
		{
			int realTabWidth=(int)TabWidth;
			TabbedTextOut(FHandle, (int)X, (int)Y, Text, (int)CharCount, 1, &realTabWidth, (int)TabOriginX);
		}

		void WinDC::DrawBuffer(RECT Rect, const wchar_t* Text, vint CharCount, UINT Format)
		{
			DrawText(FHandle, Text, (int)CharCount, &Rect, Format);
		}

		void WinDC::DrawString(vint X, vint Y, WString Text)
		{
			DrawBuffer(X, Y, Text.Buffer(), Text.Length());
		}

		void WinDC::DrawString(vint X, vint Y, WString Text, vint TabWidth, vint TabOriginX)
		{
			DrawBuffer(X, Y, Text.Buffer(), Text.Length(), TabWidth, TabOriginX);
		}

		void WinDC::DrawString(RECT Rect, WString Text, UINT Format)
		{
			DrawBuffer(Rect, Text.Buffer(), Text.Length(), Format);
		}

		SIZE WinDC::MeasureString(WString Text, vint TabSize)
		{
			return MeasureBuffer(Text.Buffer(), Text.Length(), TabSize);
		}

		SIZE WinDC::MeasureBuffer(const wchar_t* Text, vint CharCount, vint TabSize)
		{
			SIZE Size;
			if(TabSize==-1)
			{
				GetTextExtentPoint32(FHandle, Text, (int)CharCount, &Size);
			}
			else
			{
				int realTabSize=(int)TabSize;
				DWORD Result=GetTabbedTextExtent(FHandle, Text, (int)CharCount, 1, &realTabSize);
				Size.cx=LOWORD(Result);
				Size.cy=HIWORD(Result);
			}
			return Size;
		}

		SIZE WinDC::MeasureBuffer(const wchar_t* Text, vint TabSize)
		{
			return MeasureBuffer(Text, wcslen(Text), TabSize);
		}

		SIZE WinDC::MeasureWrapLineString(WString Text, vint MaxWidth)
		{
			return MeasureWrapLineBuffer(Text.Buffer(), Text.Length(), MaxWidth);
		}

		SIZE WinDC::MeasureWrapLineBuffer(const wchar_t* Text, vint CharCount, vint MaxWidth)
		{
			SIZE size = {0};
			vint lineCount=0;
			const wchar_t* reading=Text;
			INT* dx=new INT[CharCount];
			while(*reading)
			{
				INT fit=0;
				GetTextExtentExPoint(FHandle, reading, (int)(CharCount-(reading-Text)), (int)MaxWidth, &fit, dx, &size);
				reading+=fit;
				lineCount++;
			}
			delete dx;
			size.cx=0;
			size.cy*=(int)lineCount;
			return size;
		}

		SIZE WinDC::MeasureWrapLineBuffer(const wchar_t* Text, vint MaxWidth)
		{
			return MeasureWrapLineBuffer(Text, wcslen(Text), MaxWidth);
		}

		void WinDC::FillRegion(WinRegion::Ptr Region)
		{
			FillRgn(FHandle, Region->GetHandle(), FBrush->GetHandle());
		}

		void WinDC::FrameRegion(WinRegion::Ptr Region, vint BlockWidth, vint BlockHeight)
		{
			FrameRgn(FHandle, Region->GetHandle(), FBrush->GetHandle(), (int)BlockWidth, (int)BlockHeight);
		}

		void WinDC::MoveTo(vint X, vint Y)
		{
			::MoveToEx(FHandle, (int)X, (int)Y, NULL);
		}

		void WinDC::LineTo(vint X, vint Y)
		{
			::LineTo(FHandle, (int)X, (int)Y);
		}

		void WinDC::Rectangle(vint Left, vint Top, vint Right, vint Bottom)
		{
			::Rectangle(FHandle, (int)Left, (int)Top, (int)Right, (int)Bottom);
		}

		void WinDC::Rectangle(RECT Rect)
		{
			::Rectangle(FHandle, Rect.left, Rect.top, Rect.right, Rect.bottom);
		}

		void WinDC::FocusRectangle(vint Left, vint Top, vint Right, vint Bottom)
		{
			RECT Rect;
			Rect.left=(int)Left;
			Rect.top=(int)Top;
			Rect.right=(int)Right;
			Rect.bottom=(int)Bottom;
			::DrawFocusRect(FHandle, &Rect);
		}

		void WinDC::FocusRectangle(RECT Rect)
		{
			::DrawFocusRect(FHandle, &Rect);
		}

		void WinDC::FillRect(vint Left, vint Top, vint Right, vint Bottom)
		{
			RECT Rect;
			Rect.left=(int)Left;
			Rect.top=(int)Top;
			Rect.right=(int)Right;
			Rect.bottom=(int)Bottom;
			::FillRect(FHandle, &Rect, FBrush->GetHandle());
		}

		void WinDC::FillRect(RECT Rect)
		{
			::FillRect(FHandle, &Rect, FBrush->GetHandle());
		}

		void WinDC::Ellipse(vint Left, vint Top, vint Right, vint Bottom)
		{
			::Ellipse(FHandle, (int)Left, (int)Top, (int)Right, (int)Bottom);
		}

		void WinDC::Ellipse(RECT Rect)
		{
			::Ellipse(FHandle, Rect.left, Rect.top, Rect.right, Rect.bottom);
		}

		void WinDC::RoundRect(vint Left, vint Top, vint Right, vint Bottom, vint EllipseWidth, vint EllipseHeight)
		{
			::RoundRect(FHandle, (int)Left, (int)Top, (int)Right, (int)Bottom, (int)EllipseWidth, (int)EllipseHeight);
		}

		void WinDC::RoundRect(RECT Rect, vint EllipseWidth, vint EllipseHeight)
		{
			::RoundRect(FHandle, (int)Rect.left, (int)Rect.top, (int)Rect.right, (int)Rect.bottom, (int)EllipseWidth, (int)EllipseHeight);
		}

		void WinDC::PolyLine(const POINT* Points, vint Count)
		{
			::Polyline(FHandle, Points, (int)Count);
		}

		void WinDC::PolyLineTo(const POINT* Points, vint Count)
		{
			::PolylineTo(FHandle, Points, (int)Count);
		}

		void WinDC::PolyGon(const POINT* Points, vint Count)
		{
			::Polygon(FHandle, Points, (int)Count);
		}

		void WinDC::PolyBezier(const POINT* Points, vint Count)
		{
			::PolyBezier(FHandle, Points, (int)Count);
		}

		void WinDC::PolyBezierTo(const POINT* Points, vint Count)
		{
			::PolyBezierTo(FHandle, Points, (int)Count);
		}

		void WinDC::PolyDraw(const POINT* Points, const BYTE* Actions, vint PointCount)
		{
			::PolyDraw(FHandle, Points, Actions, (int)PointCount);
		}

		void WinDC::Arc(RECT Bound, POINT Start, POINT End)
		{
			::Arc(FHandle, Bound.left, Bound.top, Bound.right, Bound.bottom, Start.x, Start.y, End.x, End.y);
		}

		void WinDC::Arc(vint Left, vint Top, vint Right, vint Bottom, vint StartX, vint StartY, vint EndX, vint EndY)
		{
			::Arc(FHandle, (int)Left, (int)Top, (int)Right, (int)Bottom, (int)StartX, (int)StartY, (int)EndX, (int)EndY);
		}

		void WinDC::ArcTo(RECT Bound, POINT Start, POINT End)
		{
			::ArcTo(FHandle, (int)Bound.left, (int)Bound.top, (int)Bound.right, (int)Bound.bottom, (int)Start.x, (int)Start.y, (int)End.x, (int)End.y);
		}

		void WinDC::ArcTo(vint Left, vint Top, vint Right, vint Bottom, vint StartX, vint StartY, vint EndX, vint EndY)
		{
			::ArcTo(FHandle, (int)Left, (int)Top, (int)Right, (int)Bottom, (int)StartX, (int)StartY, (int)EndX, (int)EndY);
		}

		void WinDC::AngleArc(vint X, vint Y, vint Radius, float StartAngle, float SweepAngle)
		{
			::AngleArc(FHandle, (int)X, (int)Y, (int)Radius, StartAngle, SweepAngle);
		}

		void WinDC::AngleArc(vint X, vint Y, vint Radius, double StartAngle, double SweepAngle)
		{
			::AngleArc(FHandle, (int)X, (int)Y, (int)Radius, (float)StartAngle, (float)SweepAngle);
		}

		void WinDC::Chord(RECT Bound, POINT Start, POINT End)
		{
			::Chord(FHandle, (int)Bound.left, (int)Bound.top, (int)Bound.right, (int)Bound.bottom, (int)Start.x, (int)Start.y, (int)End.x, (int)End.y);
		}

		void WinDC::Chord(vint Left, vint Top, vint Right, vint Bottom, vint StartX, vint StartY, vint EndX, vint EndY)
		{
			::Chord(FHandle, (int)Left, (int)Top, (int)Right, (int)Bottom, (int)StartX, (int)StartY, (int)EndX, (int)EndY);
		}

		void WinDC::Pie(RECT Bound, POINT Start, POINT End)
		{
			::Pie(FHandle, (int)Bound.left, (int)Bound.top, (int)Bound.right, (int)Bound.bottom, (int)Start.x, (int)Start.y, (int)End.x, (int)End.y);
		}

		void WinDC::Pie(vint Left, vint Top, vint Right, vint Bottom, vint StartX, vint StartY, vint EndX, vint EndY)
		{
			::Pie(FHandle, (int)Left, (int)Top, (int)Right, (int)Bottom, (int)StartX, (int)StartY, (int)EndX, (int)EndY);
		}

		void WinDC::GradientTriangle(TRIVERTEX* Vertices, vint VerticesCount, GRADIENT_TRIANGLE* Triangles, vint TriangleCount)
		{
			GradientFill(FHandle, Vertices, (int)VerticesCount, Triangles, (int)TriangleCount, GRADIENT_FILL_TRIANGLE);
		}

		/*------------------------------------------------------------------------------*/

		void WinDC::BeginPath()
		{
			::BeginPath(FHandle);
		}

		void WinDC::EndPath()
		{
			::EndPath(FHandle);
		}

		void WinDC::ClosePath()
		{
			::CloseFigure(FHandle);
		}

		void WinDC::WidenPath()
		{
			::WidenPath(FHandle);
		}

		void WinDC::DiscardPath()
		{
			::AbortPath(FHandle);
		}

		void WinDC::DrawPath()
		{
			::StrokePath(FHandle);
		}

		void WinDC::FillPath()
		{
			::FillPath(FHandle);
		}

		void WinDC::DrawAndFillPath()
		{
			::StrokeAndFillPath(FHandle);
		}

		WinRegion::Ptr WinDC::RegionFromPath()
		{
			return new WinRegion(::PathToRegion(FHandle));
		}
	
		/*------------------------------------------------------------------------------*/

		bool WinDC::PointInClip(POINT Point)
		{
			return PtVisible(FHandle, Point.x, Point.y)==TRUE;
		}

		bool WinDC::RectInClip(RECT Rect)
		{
			return RectVisible(FHandle, &Rect)==TRUE;
		}

		void WinDC::ClipPath(vint CombineMode)
		{
			SelectClipPath(FHandle, (int)CombineMode);
		}

		void WinDC::ClipRegion(WinRegion::Ptr Region)
		{
			SelectClipRgn(FHandle, Region->GetHandle());
		}

		void WinDC::RemoveClip()
		{
			SelectClipRgn(FHandle, NULL);
		}

		void WinDC::MoveClip(vint OffsetX, vint OffsetY)
		{
			OffsetClipRgn(FHandle, (int)OffsetX, (int)OffsetY);
		}

		void WinDC::CombineClip(WinRegion::Ptr Region, vint CombineMode)
		{
			ExtSelectClipRgn(FHandle, Region->GetHandle(), (int)CombineMode);
		}

		void WinDC::IntersetClipRect(RECT Rect)
		{
			::IntersectClipRect(FHandle, Rect.left, Rect.top, Rect.right, Rect.bottom);
		}

		void WinDC::ExcludeClipRect(RECT Rect)
		{
			::ExcludeClipRect(FHandle, Rect.left, Rect.top, Rect.right, Rect.bottom);
		}

		WinRegion::Ptr WinDC::GetClipRegion()
		{
			HRGN Handle=CreateRectRgn(0, 0, 1, 1);
			GetClipRgn(FHandle, Handle);
			return new WinRegion(Handle);
		}

		RECT WinDC::GetClipBoundRect()
		{
			RECT Rect;
			GetClipBox(FHandle, &Rect);
			return Rect;
		}

		/*------------------------------------------------------------------------------*/

		WinTransform WinDC::GetTransform()
		{
			XFORM Transform;
			GetWorldTransform(FHandle, &Transform);
			return Transform;
		}

		void WinDC::SetTransform(const WinTransform& Transform)
		{
			SetWorldTransform(FHandle, Transform.GetHandle());
		}

		/*------------------------------------------------------------------------------*/

		void WinDC::Copy(vint dstX, vint dstY, vint dstW, vint dstH, WinDC* Source, vint srcX, vint srcY, DWORD DrawROP)
		{
			HDC SourceHandle=Source?Source->GetHandle():0;
			BitBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, SourceHandle, (int)srcX, (int)srcY, (int)DrawROP);
		}

		void WinDC::Copy(RECT dstRect, WinDC* Source, POINT srcPos, DWORD DrawROP)
		{
			HDC SourceHandle=Source?Source->GetHandle():0;
			BitBlt(FHandle, dstRect.left, dstRect.top, dstRect.right-dstRect.left, dstRect.bottom-dstRect.top, SourceHandle, srcPos.x, srcPos.y, DrawROP);
		}

		void WinDC::Copy(vint dstX, vint dstY, vint dstW, vint dstH, WinDC* Source, vint srcX, vint srcY , vint srcW, vint srcH, DWORD DrawROP)
		{
			HDC SourceHandle=Source?Source->GetHandle():0;
			StretchBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, SourceHandle, (int)srcX, (int)srcY, (int)srcW, (int)srcH, (int)DrawROP);
		}

		void WinDC::Copy(RECT dstRect, WinDC* Source, RECT srcRect, DWORD DrawROP)
		{
			HDC SourceHandle=Source?Source->GetHandle():0;
			StretchBlt(	FHandle		, dstRect.left, dstRect.top, dstRect.right-dstRect.left, dstRect.bottom-dstRect.top, 
						SourceHandle, srcRect.left, srcRect.top, srcRect.right-srcRect.left, srcRect.bottom-srcRect.top, 
						DrawROP);
		}

		void WinDC::Copy(POINT UpperLeft, POINT UpperRight, POINT LowerLeft, WinDC* Source, vint srcX, vint srcY, vint srcW, vint srcH)
		{
			POINT Pt[3];
			Pt[0]=UpperLeft;
			Pt[1]=UpperRight;
			Pt[2]=LowerLeft;
			PlgBlt(FHandle, Pt, Source->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, 0, 0, 0);
		}

		void WinDC::Copy(POINT UpperLeft, POINT UpperRight, POINT LowerLeft, WinDC*Source, RECT srcRect)
		{
			POINT Pt[3];
			Pt[0]=UpperLeft;
			Pt[1]=UpperRight;
			Pt[2]=LowerLeft;
			PlgBlt(FHandle, Pt, Source->GetHandle(), srcRect.left, srcRect.top, srcRect.right-srcRect.left, srcRect.bottom-srcRect.top, 0, 0, 0);
		}

		void WinDC::CopyTrans(vint dstX, vint dstY, vint dstW, vint dstH, WinDC* Source, vint srcX, vint srcY , vint srcW, vint srcH, COLORREF Color)
		{
			TransparentBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Source->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Color);
		}

		void WinDC::CopyTrans(RECT dstRect, WinDC* Source, RECT srcRect, COLORREF Color)
		{
			TransparentBlt(	FHandle				, dstRect.left, dstRect.top, dstRect.right-dstRect.left, dstRect.bottom-dstRect.top, 
							Source->GetHandle()	, srcRect.left, srcRect.top, srcRect.right-srcRect.left, srcRect.bottom-srcRect.top, 
							Color);
		}

		/*------------------------------------------------------------------------------*/

		void WinDC::Draw(vint dstX, vint dstY, WinMetaFile* MetaFile)
		{
			Draw(dstX, dstY, MetaFile->GetWidth(), MetaFile->GetHeight(), MetaFile);
		}

		void WinDC::Draw(POINT Pos, WinMetaFile* MetaFile)
		{
			Draw(Pos.x, Pos.y, MetaFile->GetWidth(), MetaFile->GetHeight(), MetaFile);
		}

		void WinDC::Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinMetaFile* MetaFile)
		{
			RECT Rect;
			Rect.left=(int)dstX;
			Rect.top=(int)dstY;
			Rect.right=(int)(dstX+dstW);
			Rect.bottom=(int)(dstY+dstH);
			Draw(Rect, MetaFile);
		}

		void WinDC::Draw(RECT Rect, WinMetaFile* MetaFile)
		{
			PlayEnhMetaFile(FHandle, MetaFile->GetHandle(), &Rect);
		}

		/*------------------------------------------------------------------------------*/

		void WinDC::Draw(vint dstX, vint dstY, WinBitmap::Ptr Bitmap)
		{
			vint dstW=Bitmap->GetWidth();
			vint dstH=Bitmap->GetHeight();
			vint srcX=0;
			vint srcY=0;
			if(!Bitmap->IsAlphaChannelBuilt())
			{
				BitBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, SRCCOPY);
			}
			else
			{
				vint srcW=dstW;
				vint srcH=dstH;
				BLENDFUNCTION Blend;
				Blend.BlendOp=AC_SRC_OVER;
				Blend.BlendFlags=0;
				Blend.SourceConstantAlpha=255;
				Blend.AlphaFormat=AC_SRC_ALPHA;
				AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
			}
		}

		void WinDC::Draw(POINT Pos, WinBitmap::Ptr Bitmap)
		{
			vint dstX=Pos.x;
			vint dstY=Pos.y;
			vint dstW=Bitmap->GetWidth();
			vint dstH=Bitmap->GetHeight();
			vint srcX=0;
			vint srcY=0;
			if(!Bitmap->IsAlphaChannelBuilt())
			{
				BitBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, SRCCOPY);
			}
			else
			{
				vint srcW=dstW;
				vint srcH=dstH;
				BLENDFUNCTION Blend;
				Blend.BlendOp=AC_SRC_OVER;
				Blend.BlendFlags=0;
				Blend.SourceConstantAlpha=255;
				Blend.AlphaFormat=AC_SRC_ALPHA;
				AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
			}
		}

		void WinDC::Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap)
		{
			vint srcX=0;
			vint srcY=0;
			vint srcW=Bitmap->GetWidth();
			vint srcH=Bitmap->GetHeight();
			if(!Bitmap->IsAlphaChannelBuilt())
			{
				StretchBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, SRCCOPY);
			}
			else
			{
				BLENDFUNCTION Blend;
				Blend.BlendOp=AC_SRC_OVER;
				Blend.BlendFlags=0;
				Blend.SourceConstantAlpha=255;
				Blend.AlphaFormat=AC_SRC_ALPHA;
				AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
			}
		}

		void WinDC::Draw(RECT Rect, WinBitmap::Ptr Bitmap)
		{
			vint dstX=Rect.left;
			vint dstY=Rect.top;
			vint dstW=Rect.right-Rect.left;
			vint dstH=Rect.bottom-Rect.top;
			vint srcX=0;
			vint srcY=0;
			vint srcW=Bitmap->GetWidth();
			vint srcH=Bitmap->GetHeight();
			if(!Bitmap->IsAlphaChannelBuilt())
			{
				StretchBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, SRCCOPY);
			}
			else
			{
				BLENDFUNCTION Blend;
				Blend.BlendOp=AC_SRC_OVER;
				Blend.BlendFlags=0;
				Blend.SourceConstantAlpha=255;
				Blend.AlphaFormat=AC_SRC_ALPHA;
				AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
			}
		}

		void WinDC::Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, vint srcX, vint srcY)
		{
			if(!Bitmap->IsAlphaChannelBuilt())
			{
				BitBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, SRCCOPY);
			}
			else
			{
				vint srcW=dstW;
				vint srcH=dstH;
				BLENDFUNCTION Blend;
				Blend.BlendOp=AC_SRC_OVER;
				Blend.BlendFlags=0;
				Blend.SourceConstantAlpha=255;
				Blend.AlphaFormat=AC_SRC_ALPHA;
				AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
			}
		}

		void WinDC::Draw(RECT Rect, WinBitmap::Ptr Bitmap, POINT Pos)
		{
			vint dstX=Rect.left;
			vint dstY=Rect.top;
			vint dstW=Rect.right-Rect.left;
			vint dstH=Rect.bottom-Rect.top;
			vint srcX=Pos.x;
			vint srcY=Pos.y;
			if(!Bitmap->IsAlphaChannelBuilt())
			{
				BitBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, SRCCOPY);
			}
			else
			{
				vint srcW=dstW;
				vint srcH=dstH;
				BLENDFUNCTION Blend;
				Blend.BlendOp=AC_SRC_OVER;
				Blend.BlendFlags=0;
				Blend.SourceConstantAlpha=255;
				Blend.AlphaFormat=AC_SRC_ALPHA;
				AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
			}
		}

		void WinDC::Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, vint srcX, vint srcY, vint srcW, vint srcH)
		{
			if(!Bitmap->IsAlphaChannelBuilt())
			{
				StretchBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, SRCCOPY);
			}
			else
			{
				BLENDFUNCTION Blend;
				Blend.BlendOp=AC_SRC_OVER;
				Blend.BlendFlags=0;
				Blend.SourceConstantAlpha=255;
				Blend.AlphaFormat=AC_SRC_ALPHA;
				AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
			}
		}

		void WinDC::Draw(RECT dstRect, WinBitmap::Ptr Bitmap, RECT srcRect)
		{
			vint dstX=dstRect.left;
			vint dstY=dstRect.top;
			vint dstW=dstRect.right-dstRect.left;
			vint dstH=dstRect.bottom-dstRect.top;
			vint srcX=srcRect.left;
			vint srcY=srcRect.top;
			vint srcW=srcRect.right-srcRect.left;
			vint srcH=srcRect.bottom-srcRect.top;
			if(!Bitmap->IsAlphaChannelBuilt())
			{
				StretchBlt(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, SRCCOPY);
			}
			else
			{
				BLENDFUNCTION Blend;
				Blend.BlendOp=AC_SRC_OVER;
				Blend.BlendFlags=0;
				Blend.SourceConstantAlpha=255;
				Blend.AlphaFormat=AC_SRC_ALPHA;
				AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
			}
		}

		/*------------------------------------------------------------------------------*/

		void WinDC::Draw(vint dstX, vint dstY, WinBitmap::Ptr Bitmap, unsigned char Alpha)
		{
			vint dstW=Bitmap->GetWidth();
			vint dstH=Bitmap->GetHeight();
			vint srcX=0;
			vint srcY=0;
			vint srcW=dstW;
			vint srcH=dstH;

			BLENDFUNCTION Blend;
			Blend.BlendOp=AC_SRC_OVER;
			Blend.BlendFlags=0;
			Blend.SourceConstantAlpha=Alpha;
			Blend.AlphaFormat=Bitmap->IsAlphaChannelBuilt()?AC_SRC_ALPHA:0;
			AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
		}

		void WinDC::Draw(POINT Pos, WinBitmap::Ptr Bitmap, unsigned char Alpha)
		{
			vint dstX=Pos.x;
			vint dstY=Pos.y;
			vint dstW=Bitmap->GetWidth();
			vint dstH=Bitmap->GetHeight();
			vint srcX=0;
			vint srcY=0;
			vint srcW=dstW;
			vint srcH=dstH;

			BLENDFUNCTION Blend;
			Blend.BlendOp=AC_SRC_OVER;
			Blend.BlendFlags=0;
			Blend.SourceConstantAlpha=Alpha;
			Blend.AlphaFormat=Bitmap->IsAlphaChannelBuilt()?AC_SRC_ALPHA:0;
			AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
		}

		void WinDC::Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, unsigned char Alpha)
		{
			vint srcX=0;
			vint srcY=0;
			vint srcW=Bitmap->GetWidth();
			vint srcH=Bitmap->GetHeight();

			BLENDFUNCTION Blend;
			Blend.BlendOp=AC_SRC_OVER;
			Blend.BlendFlags=0;
			Blend.SourceConstantAlpha=Alpha;
			Blend.AlphaFormat=Bitmap->IsAlphaChannelBuilt()?AC_SRC_ALPHA:0;
			AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
		}

		void WinDC::Draw(RECT Rect, WinBitmap::Ptr Bitmap, unsigned char Alpha)
		{
			vint dstX=Rect.left;
			vint dstY=Rect.top;
			vint dstW=Rect.right-Rect.left;
			vint dstH=Rect.bottom-Rect.top;
			vint srcX=0;
			vint srcY=0;
			vint srcW=Bitmap->GetWidth();
			vint srcH=Bitmap->GetHeight();

			BLENDFUNCTION Blend;
			Blend.BlendOp=AC_SRC_OVER;
			Blend.BlendFlags=0;
			Blend.SourceConstantAlpha=Alpha;
			Blend.AlphaFormat=Bitmap->IsAlphaChannelBuilt()?AC_SRC_ALPHA:0;
			AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
		}

		void WinDC::Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, vint srcX, vint srcY, unsigned char Alpha)
		{
			vint srcW=dstW;
			vint srcH=dstH;

			BLENDFUNCTION Blend;
			Blend.BlendOp=AC_SRC_OVER;
			Blend.BlendFlags=0;
			Blend.SourceConstantAlpha=Alpha;
			Blend.AlphaFormat=Bitmap->IsAlphaChannelBuilt()?AC_SRC_ALPHA:0;
			AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
		}

		void WinDC::Draw(RECT Rect, WinBitmap::Ptr Bitmap, POINT Pos, unsigned char Alpha)
		{
			vint dstX=Rect.left;
			vint dstY=Rect.top;
			vint dstW=Rect.right-Rect.left;
			vint dstH=Rect.bottom-Rect.top;
			vint srcX=Pos.x;
			vint srcY=Pos.y;
			vint srcW=dstW;
			vint srcH=dstH;

			BLENDFUNCTION Blend;
			Blend.BlendOp=AC_SRC_OVER;
			Blend.BlendFlags=0;
			Blend.SourceConstantAlpha=Alpha;
			Blend.AlphaFormat=Bitmap->IsAlphaChannelBuilt()?AC_SRC_ALPHA:0;
			AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
		}

		void WinDC::Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, vint srcX, vint srcY, vint srcW, vint srcH, unsigned char Alpha)
		{
			BLENDFUNCTION Blend;
			Blend.BlendOp=AC_SRC_OVER;
			Blend.BlendFlags=0;
			Blend.SourceConstantAlpha=Alpha;
			Blend.AlphaFormat=Bitmap->IsAlphaChannelBuilt()?AC_SRC_ALPHA:0;
			AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
		}

		void WinDC::Draw(RECT dstRect, WinBitmap::Ptr Bitmap, RECT srcRect, unsigned char Alpha)
		{
			vint dstX=dstRect.left;
			vint dstY=dstRect.top;
			vint dstW=dstRect.right-dstRect.left;
			vint dstH=dstRect.bottom-dstRect.top;
			vint srcX=srcRect.left;
			vint srcY=srcRect.top;
			vint srcW=srcRect.right-srcRect.left;
			vint srcH=srcRect.bottom-srcRect.top;

			BLENDFUNCTION Blend;
			Blend.BlendOp=AC_SRC_OVER;
			Blend.BlendFlags=0;
			Blend.SourceConstantAlpha=Alpha;
			Blend.AlphaFormat=Bitmap->IsAlphaChannelBuilt()?AC_SRC_ALPHA:0;
			AlphaBlend(FHandle, (int)dstX, (int)dstY, (int)dstW, (int)dstH, Bitmap->GetWinDC()->GetHandle(), (int)srcX, (int)srcY, (int)srcW, (int)srcH, Blend);
		}

/*********************************************************************************************************
WinControlDC
*********************************************************************************************************/

		WinControlDC::WinControlDC(HWND Handle)
		{
			FControlHandle=Handle;
			FHandle=GetDC(FControlHandle);
			Init();
		}

		WinControlDC::~WinControlDC()
		{
			ReleaseDC(FControlHandle, FHandle);
		}

/*********************************************************************************************************
WinProxyDC
*********************************************************************************************************/

		WinProxyDC::WinProxyDC()
		{
			FHandle=NULL;
		}

		WinProxyDC::~WinProxyDC()
		{
		}

		void WinProxyDC::Initialize(HDC Handle)
		{
			FHandle=Handle;
			Init();
		}

/*********************************************************************************************************
WinImageDC
*********************************************************************************************************/

		WinImageDC::WinImageDC()
		{
			FHandle=CreateCompatibleDC(NULL);
			Init();
		}

		WinImageDC::~WinImageDC()
		{
			DeleteDC(FHandle);
		}

		}
	}
}

/***********************************************************************
NativeWindow\Windows\GDI\WinGDIApplication.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			using namespace vl::collections;

			class GdiWindowsNativeWindowListener : public Object, public INativeWindowListener
			{
			protected:
				Ptr<WinBitmap>					buffer;
				INativeWindow*					window;

				vint DetermineBufferLength(vint minSize, vint minBound, vint maxBound, vint currentSize)
				{
					if(currentSize<minSize || currentSize>maxBound)
					{
						return minBound;
					}
					else
					{
						return currentSize;
					}
				}

				Size CalculateBufferSize()
				{
					Size windowSize=window->GetClientSize();
					Size minBounds(windowSize.x*5/4, windowSize.y*5/4);
					Size maxBounds(windowSize.x*3/2, windowSize.y*3/2);
					Size currentSize=buffer?Size(buffer->GetWidth(), buffer->GetHeight()):Size(0, 0);
					vint newWidth=DetermineBufferLength(windowSize.x, minBounds.x, maxBounds.x, currentSize.x);
					vint newHeight=DetermineBufferLength(windowSize.y, minBounds.y, maxBounds.y, currentSize.y);
					return Size(newWidth, newHeight);
				}

				void RebuildCanvas(Size size)
				{
					if(size.x<256)size.x=256;
					if(size.y<256)size.y=256;
					if(buffer)
					{
						if(buffer->GetWidth()!=size.x || buffer->GetHeight()!=size.y)
						{
							buffer=0;
						}
					}
					if(!buffer)
					{
						buffer=new WinBitmap(size.x, size.y, WinBitmap::vbb32Bits, true);
						buffer->GetWinDC()->SetBackTransparent(true);
					}
				}
			public:
				GdiWindowsNativeWindowListener(INativeWindow* _window)
					:window(_window)
				{
				}

				void Moved()
				{
					RebuildCanvas(CalculateBufferSize());
				}

				void Paint()
				{
					IWindowsForm* form=GetWindowsForm(window);
					WinControlDC controlDC(form->GetWindowHandle());
					controlDC.Draw(0, 0, buffer);
				}

				WinDC* GetWinDC()
				{
					if(!buffer) Moved();
					return buffer->GetWinDC();
				}
			};

			class GdiWindowsNativeControllerListener : public Object, public INativeControllerListener
			{
			public:
				Dictionary<INativeWindow*, Ptr<GdiWindowsNativeWindowListener>>		nativeWindowListeners;

				void NativeWindowCreated(INativeWindow* window)
				{
					Ptr<GdiWindowsNativeWindowListener> listener=new GdiWindowsNativeWindowListener(window);
					window->InstallListener(listener.Obj());
					nativeWindowListeners.Add(window, listener);
				}

				void NativeWindowDestroying(INativeWindow* window)
				{
					Ptr<GdiWindowsNativeWindowListener> listener=nativeWindowListeners[window];
					nativeWindowListeners.Remove(window);
					window->UninstallListener(listener.Obj());
				}
			};

			GdiWindowsNativeControllerListener* gdiListener=0;

			WinDC* GetNativeWindowDC(INativeWindow* window)
			{
				vint index=gdiListener->nativeWindowListeners.Keys().IndexOf(window);
				return index==-1?0:gdiListener->nativeWindowListeners.Values().Get(index)->GetWinDC();
			}

			HDC GetNativeWindowHDC(INativeWindow* window)
			{
				WinDC* dc=GetNativeWindowDC(window);
				return dc?dc->GetHandle():NULL;
			}
		}

		namespace elements_windows_gdi
		{
/***********************************************************************
OS Supporting
***********************************************************************/

			class WinDirect2DApplicationGDIObjectProvider : public IWindowsGDIObjectProvider
			{
			public:
				windows::WinDC* GetNativeWindowDC(INativeWindow* window)
				{
					return vl::presentation::windows::GetNativeWindowDC(window);
				}

				IWindowsGDIRenderTarget* GetBindedRenderTarget(INativeWindow* window)
				{
					return dynamic_cast<IWindowsGDIRenderTarget*>(vl::presentation::windows::GetWindowsForm(window)->GetGraphicsHandler());
				}

				void SetBindedRenderTarget(INativeWindow* window, IWindowsGDIRenderTarget* renderTarget)
				{
					vl::presentation::windows::GetWindowsForm(window)->SetGraphicsHandler(renderTarget);
				}

				IWICImagingFactory* GetWICImagingFactory()
				{
					return vl::presentation::windows::GetWICImagingFactory();
				}

				IWICBitmap* GetWICBitmap(INativeImageFrame* frame)
				{
					return vl::presentation::windows::GetWICBitmap(frame);
				}
			};
		}
	}
}

using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::windows;
using namespace vl::presentation::elements_windows_gdi;

int WinMainGDI(HINSTANCE hInstance, void(*RendererMain)())
{
	CoInitializeEx(NULL, COINIT_MULTITHREADED);
	// create controller
	INativeController* controller=CreateWindowsNativeController(hInstance);
	SetCurrentController(controller);
	{
		// install listener
		GdiWindowsNativeControllerListener listener;
		controller->CallbackService()->InstallListener(&listener);
		gdiListener=&listener;
		// main
		RendererMain();
		// uninstall listener
		gdiListener=0;
		controller->CallbackService()->UninstallListener(&listener);
	}
	// destroy controller
	DestroyWindowsNativeController(controller);
	return 0;
}

int SetupWindowsGDIRenderer()
{
	HINSTANCE hInstance=(HINSTANCE)GetModuleHandle(NULL);
	WinDirect2DApplicationGDIObjectProvider objectProvider;
	SetWindowsGDIObjectProvider(&objectProvider);
	return WinMainGDI(hInstance, &RendererMainGDI);
}

/***********************************************************************
NativeWindow\Windows\ServicesImpl\WindowsAsyncService.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			using namespace collections;

/***********************************************************************
WindowsAsyncService::TaskItem
***********************************************************************/

			WindowsAsyncService::TaskItem::TaskItem()
				:semaphore(0)
				,proc(0)
				,argument(0)
			{
			}

			WindowsAsyncService::TaskItem::TaskItem(Semaphore* _semaphore, INativeAsyncService::AsyncTaskProc* _proc, void* _argument)
				:semaphore(_semaphore)
				,proc(_proc)
				,argument(_argument)
			{
			}

			WindowsAsyncService::TaskItem::~TaskItem()
			{
			}

/***********************************************************************
WindowsAsyncService
***********************************************************************/

			WindowsAsyncService::WindowsAsyncService()
				:mainThreadId(Thread::GetCurrentThreadId())
			{
			}

			WindowsAsyncService::~WindowsAsyncService()
			{
			}

			void WindowsAsyncService::ExecuteAsyncTasks()
			{
				Array<TaskItem> items;
				{
					SpinLock::Scope scope(taskListLock);
					CopyFrom(items, taskItems);
					taskItems.RemoveRange(0, items.Count());
				}
				for(vint i=0;i<items.Count();i++)
				{
					TaskItem taskItem=items[i];
					taskItem.proc(taskItem.argument);
					if(taskItem.semaphore)
					{
						taskItem.semaphore->Release();
					}
				}
			}

			bool WindowsAsyncService::IsInMainThread()
			{
				return Thread::GetCurrentThreadId()==mainThreadId;
			}

			void WindowsAsyncService::InvokeAsync(INativeAsyncService::AsyncTaskProc* proc, void* argument)
			{
				ThreadPoolLite::Queue(proc, argument);
			}

			void WindowsAsyncService::InvokeInMainThread(INativeAsyncService::AsyncTaskProc* proc, void* argument)
			{
				SpinLock::Scope scope(taskListLock);
				TaskItem item(0, proc, argument);
				taskItems.Add(item);
			}

			bool WindowsAsyncService::InvokeInMainThreadAndWait(INativeAsyncService::AsyncTaskProc* proc, void* argument, vint milliseconds)
			{
				Semaphore semaphore;
				semaphore.Create(0, 1);
				{
					SpinLock::Scope scope(taskListLock);
					TaskItem item(&semaphore, proc, argument);
					taskItems.Add(item);
				}
				if(milliseconds<0)
				{
					return semaphore.Wait();
				}
				else
				{
					return semaphore.WaitForTime(milliseconds);
				}
			}
		}
	}
}

/***********************************************************************
NativeWindow\Windows\ServicesImpl\WindowsCallbackService.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/***********************************************************************
WindowsCallbackService
***********************************************************************/

			WindowsCallbackService::WindowsCallbackService()
			{
			}

			bool WindowsCallbackService::InstallListener(INativeControllerListener* listener)
			{
				if(listeners.Contains(listener))
				{
					return false;
				}
				else
				{
					listeners.Add(listener);
					return true;
				}
			}

			bool WindowsCallbackService::UninstallListener(INativeControllerListener* listener)
			{
				if(listeners.Contains(listener))
				{
					listeners.Remove(listener);
					return true;
				}
				else
				{
					return false;
				}
			}

			void WindowsCallbackService::InvokeMouseHook(WPARAM message, Point location)
			{
				switch(message)
				{
				case WM_LBUTTONDOWN:
					{
						for(vint i=0;i<listeners.Count();i++)
						{
							listeners[i]->LeftButtonDown(location);
						}
					}
					break;
				case WM_LBUTTONUP:
					{
						for(vint i=0;i<listeners.Count();i++)
						{
							listeners[i]->LeftButtonUp(location);
						}
					}
					break;
				case WM_RBUTTONDOWN:
					{
						for(vint i=0;i<listeners.Count();i++)
						{
							listeners[i]->RightButtonDown(location);
						}
					}
					break;
				case WM_RBUTTONUP:
					{
						for(vint i=0;i<listeners.Count();i++)
						{
							listeners[i]->RightButtonUp(location);
						}
					}
					break;
				case WM_MOUSEMOVE:
					{
						for(vint i=0;i<listeners.Count();i++)
						{
							listeners[i]->MouseMoving(location);
						}
					}
					break;
				}
			}

			void WindowsCallbackService::InvokeGlobalTimer()
			{
				for(vint i=0;i<listeners.Count();i++)
				{
					listeners[i]->GlobalTimer();
				}
			}

			void WindowsCallbackService::InvokeClipboardUpdated()
			{
				for(vint i=0;i<listeners.Count();i++)
				{
					listeners[i]->ClipboardUpdated();
				}
			}

			void WindowsCallbackService::InvokeNativeWindowCreated(INativeWindow* window)
			{
				for(vint i=0;i<listeners.Count();i++)
				{
					listeners[i]->NativeWindowCreated(window);
				}
			}

			void WindowsCallbackService::InvokeNativeWindowDestroyed(INativeWindow* window)
			{
				for(vint i=0;i<listeners.Count();i++)
				{
					listeners[i]->NativeWindowDestroying(window);
				}
			}
		}
	}
}

/***********************************************************************
NativeWindow\Windows\ServicesImpl\WindowsClipboardService.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/***********************************************************************
WindowsClipboardService
***********************************************************************/

			WindowsClipboardService::WindowsClipboardService()
				:ownerHandle(NULL)
			{
			}

			void WindowsClipboardService::SetOwnerHandle(HWND handle)
			{
				HWND oldHandle=ownerHandle;
				ownerHandle=handle;
				if(handle==NULL)
				{
					RemoveClipboardFormatListener(oldHandle);
				}
				else
				{
					AddClipboardFormatListener(ownerHandle);
				}
			}

			bool WindowsClipboardService::ContainsText()
			{
				if(OpenClipboard(ownerHandle))
				{
					UINT format=0;
					bool contains=false;
					while(format=EnumClipboardFormats(format))
					{
						if(format==CF_TEXT || format==CF_UNICODETEXT)
						{
							contains=true;
							break;
						}
					}
					CloseClipboard();
					return contains;
				}
				return false;
			}

			WString WindowsClipboardService::GetText()
			{
				if(OpenClipboard(ownerHandle))
				{
					WString result;
					HANDLE handle=GetClipboardData(CF_UNICODETEXT);
					if(handle!=0)
					{
						wchar_t* buffer=(wchar_t*)GlobalLock(handle);
						result=buffer;
						GlobalUnlock(handle);
					}
					CloseClipboard();
					return result;
				}
				return L"";
			}

			bool WindowsClipboardService::SetText(const WString& value)
			{
				if(OpenClipboard(ownerHandle))
				{
					EmptyClipboard();
					vint size=(value.Length()+1)*sizeof(wchar_t);
					HGLOBAL data=GlobalAlloc(GMEM_MOVEABLE, size);
					wchar_t* buffer=(wchar_t*)GlobalLock(data);
					memcpy(buffer, value.Buffer(), size);
					GlobalUnlock(data);
					SetClipboardData(CF_UNICODETEXT, data);
					CloseClipboard();
					return true;
				}
				return false;
			}
		}
	}
}

/***********************************************************************
NativeWindow\Windows\ServicesImpl\WindowsDialogService.cpp
***********************************************************************/
#include <Vfw.h>

#pragma comment(lib, "Vfw32.lib")

namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			using namespace collections;

/***********************************************************************
WindowsDialogService
***********************************************************************/

			WindowsDialogService::WindowsDialogService(HandleRetriver _handleRetriver)
				:handleRetriver(_handleRetriver)
			{
			}

			INativeDialogService::MessageBoxButtonsOutput WindowsDialogService::ShowMessageBox(
				INativeWindow* window,
				const WString& text,
				const WString& title,
				MessageBoxButtonsInput buttons,
				MessageBoxDefaultButton defaultButton,
				MessageBoxIcons icon,
				MessageBoxModalOptions modal)
			{
				WString realTitle=title;
				if(title==L"" && window!=0)
				{
					realTitle=window->GetTitle();
				}
				HWND hWnd=handleRetriver(window);
				LPCTSTR lpText=text.Buffer();
				LPCTSTR lpCaption=realTitle.Buffer();
				UINT uType=0;
				
#define MAP(A, B) case A: uType|=(B); break
				switch(buttons)
				{
					MAP(DisplayOK, MB_OK);
					MAP(DisplayOKCancel, MB_OKCANCEL);
					MAP(DisplayYesNo, MB_YESNO);
					MAP(DisplayYesNoCancel, MB_YESNOCANCEL);
					MAP(DisplayRetryCancel, MB_RETRYCANCEL);
					MAP(DisplayAbortRetryIgnore, MB_ABORTRETRYIGNORE);
					MAP(DisplayCancelTryAgainContinue, MB_CANCELTRYCONTINUE);
				}
				switch(defaultButton)
				{
					MAP(DefaultFirst, MB_DEFBUTTON1);
					MAP(DefaultSecond, MB_DEFBUTTON2);
					MAP(DefaultThird, MB_DEFBUTTON3);
				}
				switch(icon)
				{
					MAP(IconError, MB_ICONERROR);
					MAP(IconQuestion, MB_ICONQUESTION);
					MAP(IconWarning, MB_ICONWARNING);
					MAP(IconInformation, MB_ICONINFORMATION);
				}
				switch(modal)
				{
					MAP(ModalWindow, MB_APPLMODAL);
					MAP(ModalSystem, MB_SYSTEMMODAL);
					MAP(ModalTask, MB_TASKMODAL);
				}
#undef MAP

				vint result=MessageBox(hWnd, lpText, lpCaption, uType);
				switch(result)
				{
				case IDABORT: return SelectAbort;
				case IDCANCEL: return SelectCancel;
				case IDCONTINUE: return SelectContinue;
				case IDIGNORE: return SelectIgnore;
				case IDNO: return SelectNo;
				case IDOK: return SelectOK;
				case IDRETRY: return SelectRetry;
				case IDTRYAGAIN: return SelectTryAgain;
				case IDYES: return SelectYes;
				default: return SelectOK;
				}
			}

			bool WindowsDialogService::ShowColorDialog(INativeWindow* window, Color& selection, bool selected, ColorDialogCustomColorOptions customColorOptions, Color* customColors)
			{
				CHOOSECOLOR chooseColor;
				ZeroMemory(&chooseColor, sizeof(chooseColor));
				COLORREF customColorsBuffer[16]={0};
				if(customColors)
				{
					for(vint i=0;i<sizeof(customColorsBuffer)/sizeof(*customColorsBuffer);i++)
					{
						customColorsBuffer[i]=RGB(customColors[i].r, customColors[i].g, customColors[i].b);
					}
				}

				chooseColor.lStructSize=sizeof(chooseColor);
				chooseColor.hwndOwner=handleRetriver(window);
				chooseColor.rgbResult=RGB(selection.r, selection.g, selection.b);
				chooseColor.lpCustColors=customColorsBuffer;
				chooseColor.Flags=CC_ANYCOLOR;
				
#define MAP(A, B) case A: chooseColor.Flags|=(B); break
				switch(customColorOptions)
				{
					MAP(CustomColorDisabled, CC_PREVENTFULLOPEN);
					MAP(CustomColorOpened, CC_FULLOPEN);
				}
#undef MAP
				if(selected)
				{
					chooseColor.Flags|=CC_RGBINIT;
				}

				BOOL result=ChooseColor(&chooseColor);
				if(result)
				{
					selection=Color(GetRValue(chooseColor.rgbResult), GetGValue(chooseColor.rgbResult), GetBValue(chooseColor.rgbResult));
					if(customColors)
					{
						for(vint i=0;i<sizeof(customColorsBuffer)/sizeof(*customColorsBuffer);i++)
						{
							COLORREF color=customColorsBuffer[i];
							customColors[i]=Color(GetRValue(color), GetGValue(color), GetBValue(color));
						}
					}
				}
				return result!=FALSE;
			}

			bool WindowsDialogService::ShowFontDialog(INativeWindow* window, FontProperties& selectionFont, Color& selectionColor, bool selected, bool showEffect, bool forceFontExist)
			{
				LOGFONT logFont;
				ZeroMemory(&logFont, sizeof(logFont));
				logFont.lfHeight=-(int)selectionFont.size;
				logFont.lfWeight=selectionFont.bold?FW_BOLD:FW_REGULAR;
				logFont.lfItalic=selectionFont.italic?TRUE:FALSE;
				logFont.lfUnderline=selectionFont.underline?TRUE:FALSE;
				logFont.lfStrikeOut=selectionFont.strikeline?TRUE:FALSE;
				wcscpy_s(logFont.lfFaceName, selectionFont.fontFamily.Buffer());

				CHOOSEFONT chooseFont;
				ZeroMemory(&chooseFont, sizeof(chooseFont));
				chooseFont.lStructSize=sizeof(chooseFont);
				chooseFont.hwndOwner=handleRetriver(window);
				chooseFont.lpLogFont=&logFont;
				chooseFont.iPointSize=0;
				chooseFont.Flags=(showEffect?CF_EFFECTS:0) | (forceFontExist?CF_FORCEFONTEXIST:0) | (selected?CF_INITTOLOGFONTSTRUCT:0);
				chooseFont.rgbColors=RGB(selectionColor.r, selectionColor.g, selectionColor.b);

				BOOL result=ChooseFont(&chooseFont);
				if(result)
				{
					selectionFont.fontFamily=logFont.lfFaceName;
					selectionFont.bold=logFont.lfWeight>FW_REGULAR;
					selectionFont.italic=logFont.lfItalic!=FALSE;
					selectionFont.underline=logFont.lfUnderline!=FALSE;
					selectionFont.strikeline=logFont.lfStrikeOut!=FALSE;
					selectionFont.size=-logFont.lfHeight;

					selectionColor=Color(GetRValue(chooseFont.rgbColors), GetGValue(chooseFont.rgbColors), GetBValue(chooseFont.rgbColors));
				}
				return result!=FALSE;
			}

			bool WindowsDialogService::ShowFileDialog(INativeWindow* window, collections::List<WString>& selectionFileNames, vint& selectionFilterIndex, FileDialogTypes dialogType, const WString& title, const WString& initialFileName, const WString& initialDirectory, const WString& defaultExtension, const WString& filter, FileDialogOptions options)
			{
				Array<wchar_t> fileNamesBuffer(65536>initialFileName.Length()+1?65536:initialFileName.Length()+1);
				wcscpy_s(&fileNamesBuffer[0], fileNamesBuffer.Count(), initialFileName.Buffer());

				OPENFILENAME ofn;
				ZeroMemory(&ofn, sizeof(ofn));
				ofn.lStructSize=sizeof(ofn);
				ofn.hwndOwner=handleRetriver(window);
				ofn.hInstance=NULL;
				ofn.lpstrCustomFilter=NULL;
				ofn.nMaxCustFilter=0;
				ofn.nFilterIndex=(int)selectionFilterIndex+1;
				ofn.lpstrFile=&fileNamesBuffer[0];
				ofn.nMaxFile=(int)fileNamesBuffer.Count();
				ofn.lpstrFileTitle=NULL;
				ofn.nMaxFileTitle=0;
				ofn.lpstrInitialDir=initialDirectory==L""?NULL:initialDirectory.Buffer();
				ofn.lpstrTitle=title==L""?NULL:title.Buffer();
				ofn.lpstrDefExt=defaultExtension==L""?NULL:defaultExtension.Buffer();

				List<vint> filterSeparators;
				for(vint i=0;i<filter.Length();i++)
				{
					if(filter[i]==L'|')
					{
						filterSeparators.Add(i);
					}
				}
				if(filterSeparators.Count()%2==1)
				{
					filterSeparators.Add(filter.Length());
				}

				Array<wchar_t> filterBuffer(filter.Length()+2);
				vint index=0;
				for(vint i=0;i<filterSeparators.Count();i++)
				{
					vint end=filterSeparators[i];
					wcsncpy_s(&filterBuffer[index], filterBuffer.Count()-index, filter.Buffer()+index, end-index);
					filterBuffer[end]=0;
					index=end+1;
				}
				filterBuffer[index]=0;
				ofn.lpstrFilter=&filterBuffer[0];

				ofn.Flags=OFN_ENABLESIZING | OFN_EXPLORER | OFN_LONGNAMES;
				if(options&FileDialogAllowMultipleSelection)	ofn.Flags|=OFN_ALLOWMULTISELECT;
				if(options&FileDialogFileMustExist)				ofn.Flags|=OFN_FILEMUSTEXIST;
				if(!(options&FileDialogShowReadOnlyCheckBox))	ofn.Flags|=OFN_HIDEREADONLY;
				if(!(options&FileDialogDereferenceLinks))		ofn.Flags|=OFN_NODEREFERENCELINKS;
				if(!(options&FileDialogShowNetworkButton))		ofn.Flags|=OFN_NONETWORKBUTTON;
				if(options&FileDialogPromptCreateFile)			ofn.Flags|=OFN_CREATEPROMPT;
				if(options&FileDialogPromptOverwriteFile)		ofn.Flags|=OFN_OVERWRITEPROMPT;
				if(options&FileDialogDirectoryMustExist)		ofn.Flags|=OFN_PATHMUSTEXIST;
				if(!(options&FileDialogAddToRecent))			ofn.Flags|=OFN_DONTADDTORECENT;

				BOOL result=FALSE;
				switch(dialogType)
				{
				case FileDialogOpen:
					result=GetOpenFileName(&ofn);
					break;
				case FileDialogOpenPreview:
					result=GetOpenFileNamePreview(&ofn);
					break;
				case FileDialogSave:
					result=GetSaveFileName(&ofn);
					break;
				case FileDialogSavePreview:
					result=GetSaveFileNamePreview(&ofn);
					break;
				}
				if(result)
				{
					selectionFilterIndex=ofn.nFilterIndex-1;
					selectionFileNames.Clear();
					if(options&FileDialogAllowMultipleSelection)
					{
						const wchar_t* reading=&fileNamesBuffer[0];
						WString directory=reading;
						reading+=directory.Length()+1;
						while(*reading)
						{
							WString fileName=reading;
							reading+=fileName.Length()+1;
							selectionFileNames.Add(directory+L"\\"+fileName);
						}
						if(selectionFileNames.Count()==0)
						{
							selectionFileNames.Add(directory);
						}
					}
					else
					{
						selectionFileNames.Add(&fileNamesBuffer[0]);
					}
				}
				return result!=FALSE;
			}
		}
	}
}

/***********************************************************************
NativeWindow\Windows\ServicesImpl\WindowsImageService.cpp
***********************************************************************/

#include <Shlwapi.h>

#pragma comment(lib, "WindowsCodecs.lib")

namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			using namespace collections;

/***********************************************************************
WindowsImageFrame
***********************************************************************/

			void WindowsImageFrame::Initialize(IWICBitmapSource* bitmapSource)
			{
				IWICImagingFactory* factory=GetWICImagingFactory();
				ComPtr<IWICFormatConverter> converter;
				{
					IWICFormatConverter* formatConverter=0;
					HRESULT hr=factory->CreateFormatConverter(&formatConverter);
					if(SUCCEEDED(hr))
					{
						converter=formatConverter;
						converter->Initialize(
							bitmapSource,
							GUID_WICPixelFormat32bppPBGRA,
							WICBitmapDitherTypeNone,
							NULL,
							0.0f,
							WICBitmapPaletteTypeCustom);
					}
				}

				IWICBitmap* bitmap=0;
				IWICBitmapSource* convertedBitmapSource=0;
				if(converter)
				{
					convertedBitmapSource=converter.Obj();
				}
				else
				{
					convertedBitmapSource=bitmapSource;
				}
				HRESULT hr=factory->CreateBitmapFromSource(convertedBitmapSource, WICBitmapCacheOnLoad, &bitmap);
				if(SUCCEEDED(hr))
				{
					frameBitmap=bitmap;
				}
			}

			WindowsImageFrame::WindowsImageFrame(INativeImage* _image, IWICBitmapFrameDecode* frameDecode)
				:image(_image)
			{
				Initialize(frameDecode);
			}

			WindowsImageFrame::WindowsImageFrame(INativeImage* _image, IWICBitmap* sourceBitmap)
				:image(_image)
			{
				Initialize(sourceBitmap);
			}

			WindowsImageFrame::~WindowsImageFrame()
			{
				for(vint i=0;i<caches.Count();i++)
				{
					caches.Values().Get(i)->OnDetach(this);
				}
			}

			INativeImage* WindowsImageFrame::GetImage()
			{
				return image;
			}

			Size WindowsImageFrame::GetSize()
			{
				UINT width=0;
				UINT height=0;
				frameBitmap->GetSize(&width, &height);
				return Size(width, height);
			}

			bool WindowsImageFrame::SetCache(void* key, Ptr<INativeImageFrameCache> cache)
			{
				vint index=caches.Keys().IndexOf(key);
				if(index!=-1)
				{
					return false;
				}
				caches.Add(key, cache);
				cache->OnAttach(this);
				return true;
			}

			Ptr<INativeImageFrameCache> WindowsImageFrame::GetCache(void* key)
			{
				vint index=caches.Keys().IndexOf(key);
				return index==-1?0:caches.Values().Get(index);
			}

			Ptr<INativeImageFrameCache> WindowsImageFrame::RemoveCache(void* key)
			{
				vint index=caches.Keys().IndexOf(key);
				if(index==-1)
				{
					return 0;
				}
				Ptr<INativeImageFrameCache> cache=caches.Values().Get(index);
				cache->OnDetach(this);
				caches.Remove(key);
				return cache;
			}

			IWICBitmap* WindowsImageFrame::GetFrameBitmap()
			{
				return frameBitmap.Obj();
			}

/***********************************************************************
WindowsImage
***********************************************************************/

			WindowsImage::WindowsImage(INativeImageService* _imageService, IWICBitmapDecoder* _bitmapDecoder)
				:imageService(_imageService)
				,bitmapDecoder(_bitmapDecoder)
			{
				UINT count=0;
				bitmapDecoder->GetFrameCount(&count);
				frames.Resize(count);
			}

			WindowsImage::~WindowsImage()
			{
			}

			INativeImageService* WindowsImage::GetImageService()
			{
				return imageService;
			}

			INativeImage::FormatType WindowsImage::GetFormat()
			{
				GUID formatGUID;
				HRESULT hr=bitmapDecoder->GetContainerFormat(&formatGUID);
				if(SUCCEEDED(hr))
				{
					if(formatGUID==GUID_ContainerFormatBmp)
					{
						return INativeImage::Bmp;
					}
					else if(formatGUID==GUID_ContainerFormatPng)
					{
						return INativeImage::Png;
					}
					else if(formatGUID==GUID_ContainerFormatGif)
					{
						return INativeImage::Gif;
					}
					else if(formatGUID==GUID_ContainerFormatJpeg)
					{
						return INativeImage::Jpeg;
					}
					else if(formatGUID==GUID_ContainerFormatIco)
					{
						return INativeImage::Icon;
					}
					else if(formatGUID==GUID_ContainerFormatTiff)
					{
						return INativeImage::Tiff;
					}
					else if(formatGUID==GUID_ContainerFormatWmp)
					{
						return INativeImage::Wmp;
					}
				}
				return INativeImage::Unknown;
			}

			vint WindowsImage::GetFrameCount()
			{
				return frames.Count();
			}

			INativeImageFrame* WindowsImage::GetFrame(vint index)
			{
				if(0<=index && index<GetFrameCount())
				{
					Ptr<WindowsImageFrame>& frame=frames[index];
					if(!frame)
					{
						IWICBitmapFrameDecode* frameDecode=0;
						HRESULT hr=bitmapDecoder->GetFrame((int)index, &frameDecode);
						if(SUCCEEDED(hr))
						{
							frame=new WindowsImageFrame(this, frameDecode);
							frameDecode->Release();
						}
					}
					return frame.Obj();
				}
				else
				{
					return 0;
				}
			}

/***********************************************************************
WindowsBitmapImage
***********************************************************************/

			WindowsBitmapImage::WindowsBitmapImage(INativeImageService* _imageService, IWICBitmap* sourceBitmap, FormatType _formatType)
				:imageService(_imageService)
				,formatType(_formatType)
			{
				frame=new WindowsImageFrame(this, sourceBitmap);
			}

			WindowsBitmapImage::~WindowsBitmapImage()
			{
			}

			INativeImageService* WindowsBitmapImage::GetImageService()
			{
				return imageService;
			}

			INativeImage::FormatType WindowsBitmapImage::GetFormat()
			{
				return formatType;
			}

			vint WindowsBitmapImage::GetFrameCount()
			{
				return 1;
			}

			INativeImageFrame* WindowsBitmapImage::GetFrame(vint index)
			{
				return index==0?frame.Obj():0;
			}

/***********************************************************************
WindowsImageService
***********************************************************************/

			WindowsImageService::WindowsImageService()
			{
				IWICImagingFactory* factory=0;
				HRESULT hr = CoCreateInstance(
#if defined(WINCODEC_SDK_VERSION2)
					CLSID_WICImagingFactory1,
#else
					CLSID_WICImagingFactory,
#endif
					NULL,
					CLSCTX_INPROC_SERVER,
					IID_IWICImagingFactory,
					(LPVOID*)&factory
					);
				if(SUCCEEDED(hr))
				{
					imagingFactory=factory;
				}
			}

			WindowsImageService::~WindowsImageService()
			{
			}

			Ptr<INativeImage> WindowsImageService::CreateImageFromFile(const WString& path)
			{
				IWICBitmapDecoder* bitmapDecoder=0;
				HRESULT hr=imagingFactory->CreateDecoderFromFilename(
					path.Buffer(),
					NULL,
					GENERIC_READ,
					WICDecodeMetadataCacheOnDemand,
					&bitmapDecoder);
				if(SUCCEEDED(hr))
				{
					return new WindowsImage(this, bitmapDecoder);
				}
				else
				{
					return 0;
				}
			}

			Ptr<INativeImage> WindowsImageService::CreateImageFromMemory(void* buffer, vint length)
			{
				Ptr<INativeImage> result;
				::IStream* stream=SHCreateMemStream((const BYTE*)buffer, (int)length);
				if(stream)
				{
					IWICBitmapDecoder* bitmapDecoder=0;
					HRESULT hr=imagingFactory->CreateDecoderFromStream(stream, NULL, WICDecodeMetadataCacheOnDemand, &bitmapDecoder);
					if(SUCCEEDED(hr))
					{
						result=new WindowsImage(this, bitmapDecoder);
					}
					stream->Release();
				}
				return result;
			}

			Ptr<INativeImage> WindowsImageService::CreateImageFromStream(stream::IStream& stream)
			{
				stream::MemoryStream memoryStream;
				char buffer[65536];
				while(true)
				{
					vint length=stream.Read(buffer, sizeof(buffer));
					memoryStream.Write(buffer, length);
					if(length!=sizeof(buffer))
					{
						break;
					}
				}
				return CreateImageFromMemory(memoryStream.GetInternalBuffer(), (vint)memoryStream.Size());
			}

			Ptr<INativeImage> WindowsImageService::CreateImageFromHBITMAP(HBITMAP handle)
			{
				IWICBitmap* bitmap=0;
				HRESULT hr=imagingFactory->CreateBitmapFromHBITMAP(handle, NULL, WICBitmapUseAlpha, &bitmap);
				if(SUCCEEDED(hr))
				{
					Ptr<INativeImage> image=new WindowsBitmapImage(this, bitmap, INativeImage::Bmp);
					bitmap->Release();
					return image;
				}
				else
				{
					return 0;
				}
			}

			Ptr<INativeImage> WindowsImageService::CreateImageFromHICON(HICON handle)
			{
				IWICBitmap* bitmap=0;
				HRESULT hr=imagingFactory->CreateBitmapFromHICON(handle, &bitmap);
				if(SUCCEEDED(hr))
				{
					Ptr<INativeImage> image=new WindowsBitmapImage(this, bitmap, INativeImage::Icon);
					bitmap->Release();
					return image;
				}
				else
				{
					return 0;
				}
			}

			IWICImagingFactory* WindowsImageService::GetImagingFactory()
			{
				return imagingFactory.Obj();
			}

/***********************************************************************
Helper Functions
***********************************************************************/

			IWICImagingFactory* GetWICImagingFactory()
			{
				return dynamic_cast<WindowsImageService*>(GetCurrentController()->ImageService())->GetImagingFactory();
			}

			IWICBitmap* GetWICBitmap(INativeImageFrame* frame)
			{
				return dynamic_cast<WindowsImageFrame*>(frame)->GetFrameBitmap();
			}

			Ptr<INativeImage> CreateImageFromHBITMAP(HBITMAP handle)
			{
				return dynamic_cast<WindowsImageService*>(GetCurrentController()->ImageService())->CreateImageFromHBITMAP(handle);
			}

			Ptr<INativeImage> CreateImageFromHICON(HICON handle)
			{
				return dynamic_cast<WindowsImageService*>(GetCurrentController()->ImageService())->CreateImageFromHICON(handle);
			}
		}
	}
}

/***********************************************************************
NativeWindow\Windows\ServicesImpl\WindowsInputService.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			bool WinIsKeyPressing(vint code)
			{
				return (GetKeyState((int)code)&0xF0)!=0;
			}

			bool WinIsKeyToggled(vint code)
			{
				return (GetKeyState((int)code)&0x0F)!=0;
			}

/***********************************************************************
WindowsInputService
***********************************************************************/

			WindowsInputService::WindowsInputService(HOOKPROC _mouseProc)
				:ownerHandle(NULL)
				,mouseHook(NULL)
				,isTimerEnabled(false)
				,mouseProc(_mouseProc)
			{
			}

			void WindowsInputService::SetOwnerHandle(HWND handle)
			{
				ownerHandle=handle;
			}

			void WindowsInputService::StartHookMouse()
			{
				if(!IsHookingMouse())
				{
					mouseHook=SetWindowsHookEx(WH_MOUSE_LL, mouseProc, NULL, NULL);
				}
			}

			void WindowsInputService::StopHookMouse()
			{
				if(IsHookingMouse())
				{
					UnhookWindowsHookEx(mouseHook);
					mouseHook=NULL;
				}
			}

			bool WindowsInputService::IsHookingMouse()
			{
				return mouseHook!=NULL;
			}

			void WindowsInputService::StartTimer()
			{
				if(!IsTimerEnabled())
				{
					SetTimer(ownerHandle, 1, 16, NULL);
					isTimerEnabled=true;
				}
			}

			void WindowsInputService::StopTimer()
			{
				if(IsTimerEnabled())
				{
					KillTimer(ownerHandle, 1);
					isTimerEnabled=false;
				}
			}

			bool WindowsInputService::IsTimerEnabled()
			{
				return isTimerEnabled;
			}
				
			bool WindowsInputService::IsKeyPressing(vint code)
			{
				return WinIsKeyPressing(code);
			}

			bool WindowsInputService::IsKeyToggled(vint code)
			{
				return WinIsKeyToggled(code);
			}

			WString WindowsInputService::GetKeyName(vint code)
			{
				wchar_t name[256]={0};
				vint scanCode=MapVirtualKey((int)code, MAPVK_VK_TO_VSC)<<16;
				switch(code)
				{
				case VK_INSERT:
				case VK_DELETE:
				case VK_HOME:
				case VK_END:
				case VK_PRIOR:
				case VK_NEXT:
				case VK_LEFT:
				case VK_RIGHT:
				case VK_UP:
				case VK_DOWN:
					scanCode|=1<<24;
					break;
				}
				GetKeyNameText((int)scanCode, name, sizeof(name)/sizeof(*name));
				return name[0]?name:L"?";
			}
		}
	}
}

/***********************************************************************
NativeWindow\Windows\ServicesImpl\WindowsResourceService.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/***********************************************************************
WindowsCursor
***********************************************************************/

			WindowsCursor::WindowsCursor(HCURSOR _handle)
				:handle(_handle)
				,isSystemCursor(false)
				,systemCursorType(INativeCursor::Arrow)
			{
			}

			WindowsCursor::WindowsCursor(SystemCursorType type)
				:handle(NULL)
				,isSystemCursor(true)
				,systemCursorType(type)
			{
				LPWSTR id=NULL;
				switch(type)
				{
				case SmallWaiting:
					id=IDC_APPSTARTING;
					break;
				case LargeWaiting:
					id=IDC_WAIT;
					break;
				case Arrow:
					id=IDC_ARROW;
					break;
				case Cross:
					id=IDC_CROSS;
					break;
				case Hand:
					id=IDC_HAND;
					break;
				case Help:
					id=IDC_HELP;
					break;
				case IBeam:
					id=IDC_IBEAM;
					break;
				case SizeAll:
					id=IDC_SIZEALL;
					break;
				case SizeNESW:
					id=IDC_SIZENESW;
					break;
				case SizeNS:
					id=IDC_SIZENS;
					break;
				case SizeNWSE:
					id=IDC_SIZENWSE;
					break;
				case SizeWE:
					id=IDC_SIZEWE;
					break;
				}
				handle=(HCURSOR)LoadImage(NULL, id, IMAGE_CURSOR, 0, 0, LR_DEFAULTSIZE|LR_SHARED);
			}
				
			bool WindowsCursor::IsSystemCursor()
			{
				return isSystemCursor;
			}

			INativeCursor::SystemCursorType WindowsCursor::GetSystemCursorType()
			{
				return systemCursorType;
			}

			HCURSOR WindowsCursor::GetCursorHandle()
			{
				return handle;
			}

/***********************************************************************
WindowsResourceService
***********************************************************************/

			WindowsResourceService::WindowsResourceService()
			{
				{
					systemCursors.Resize(INativeCursor::SystemCursorCount);
					for(vint i=0;i<systemCursors.Count();i++)
					{
						systemCursors[i]=new WindowsCursor((INativeCursor::SystemCursorType)i);
					}
				}
				{
					NONCLIENTMETRICS metrics;
					metrics.cbSize=sizeof(NONCLIENTMETRICS);
					SystemParametersInfo(SPI_GETNONCLIENTMETRICS, metrics.cbSize, &metrics, 0);
					if(!*metrics.lfMessageFont.lfFaceName)
					{
						metrics.cbSize=sizeof(NONCLIENTMETRICS)-sizeof(metrics.iPaddedBorderWidth);
						SystemParametersInfo(SPI_GETNONCLIENTMETRICS, metrics.cbSize, &metrics, 0);
					}
					defaultFont.fontFamily=metrics.lfMessageFont.lfFaceName;
					defaultFont.size=metrics.lfMessageFont.lfHeight;
					if(defaultFont.size<0)
					{
						defaultFont.size=-defaultFont.size;
					}
				}
			}

			INativeCursor* WindowsResourceService::GetSystemCursor(INativeCursor::SystemCursorType type)
			{
				vint index=(vint)type;
				if(0<=index && index<systemCursors.Count())
				{
					return systemCursors[index].Obj();
				}
				else
				{
					return 0;
				}
			}

			INativeCursor* WindowsResourceService::GetDefaultSystemCursor()
			{
				return GetSystemCursor(INativeCursor::Arrow);
			}

			FontProperties WindowsResourceService::GetDefaultFont()
			{
				return defaultFont;
			}

			void WindowsResourceService::SetDefaultFont(const FontProperties& value)
			{
				defaultFont=value;
			}
		}
	}
}

/***********************************************************************
NativeWindow\Windows\ServicesImpl\WindowsScreenService.cpp
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/***********************************************************************
WindowsScreen
***********************************************************************/

			WindowsScreen::WindowsScreen()
			{
				monitor=NULL;
			}

			Rect WindowsScreen::GetBounds()
			{
				MONITORINFOEX info;
				info.cbSize=sizeof(MONITORINFOEX);
				GetMonitorInfo(monitor, &info);
				return Rect(info.rcMonitor.left, info.rcMonitor.top, info.rcMonitor.right, info.rcMonitor.bottom);
			}

			Rect WindowsScreen::GetClientBounds()
			{
				MONITORINFOEX info;
				info.cbSize=sizeof(MONITORINFOEX);
				GetMonitorInfo(monitor, &info);
				return Rect(info.rcWork.left, info.rcWork.top, info.rcWork.right, info.rcWork.bottom);
			}

			WString WindowsScreen::GetName()
			{
				MONITORINFOEX info;
				info.cbSize=sizeof(MONITORINFOEX);
				GetMonitorInfo(monitor, &info);
					
				wchar_t buffer[sizeof(info.szDevice)/sizeof(*info.szDevice)+1];
				memset(buffer, 0, sizeof(buffer));
				memcpy(buffer, info.szDevice, sizeof(info.szDevice));
				return buffer;
			}

			bool WindowsScreen::IsPrimary()
			{
				MONITORINFOEX info;
				info.cbSize=sizeof(MONITORINFOEX);
				GetMonitorInfo(monitor, &info);
				return info.dwFlags==MONITORINFOF_PRIMARY;
			}

/***********************************************************************
WindowsScreenService
***********************************************************************/

			WindowsScreenService::WindowsScreenService(HandleRetriver _handleRetriver)
				:handleRetriver(_handleRetriver)
			{
			}

			BOOL CALLBACK WindowsScreenService::MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData)
			{
				MonitorEnumProcData* data=(MonitorEnumProcData*)dwData;
				if(data->currentScreen==data->screenService->screens.Count())
				{
					data->screenService->screens.Add(new WindowsScreen());
				}
				data->screenService->screens[data->currentScreen]->monitor=hMonitor;
				data->currentScreen++;
				return TRUE;
			}

			void WindowsScreenService::RefreshScreenInformation()
			{
				for(vint i=0;i<screens.Count();i++)
				{
					screens[i]->monitor=NULL;
				}
				MonitorEnumProcData data;
				data.screenService=this;
				data.currentScreen=0;
				EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, (LPARAM)(&data));
			}
				
			vint WindowsScreenService::GetScreenCount()
			{
				RefreshScreenInformation();
				return GetSystemMetrics(SM_CMONITORS);
			}

			INativeScreen* WindowsScreenService::GetScreen(vint index)
			{
				RefreshScreenInformation();
				return screens[index].Obj();
			}

			INativeScreen* WindowsScreenService::GetScreen(INativeWindow* window)
			{
				RefreshScreenInformation();
				HWND hwnd=handleRetriver(window);
				if(hwnd)
				{
					HMONITOR monitor=MonitorFromWindow(hwnd, MONITOR_DEFAULTTONULL);
					if(monitor!=NULL)
					{
						for(vint i=0;i<screens.Count();i++)
						{
							if(screens[i]->monitor==monitor)
							{
								return screens[i].Obj();
							}
						}
					}
				}
				return 0;
			}
		}
	}
}

/***********************************************************************
NativeWindow\Windows\WinNativeWindow.cpp
***********************************************************************/

#pragma comment(lib, "Imm32.lib")
#pragma comment(lib, "Shlwapi.lib")

namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			using namespace collections;

			HWND GetHWNDFromNativeWindowHandle(INativeWindow* window)
			{
				if(!window) return NULL;
				IWindowsForm* form=GetWindowsForm(window);
				if(!form) return NULL;
				return form->GetWindowHandle();
			}

/***********************************************************************
WindowsClass
***********************************************************************/

			class WinClass : public Object
			{
			protected:
				WString					name;
				WNDCLASSEX				windowClass;
				ATOM					windowAtom;
			public:
				WinClass(WString _name, bool shadow, bool ownDC, WNDPROC procedure, HINSTANCE hInstance)
				{
					name=_name;
					windowClass.cbSize=sizeof(windowClass);
					windowClass.style=CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | (shadow?CS_DROPSHADOW:0) | (ownDC?CS_OWNDC:0);
					windowClass.lpfnWndProc=procedure;
					windowClass.cbClsExtra=0;
					windowClass.cbWndExtra=0;
					windowClass.hInstance=hInstance;
					windowClass.hIcon=LoadIcon(NULL,IDI_APPLICATION);
					windowClass.hCursor=NULL;//LoadCursor(NULL,IDC_ARROW);
					windowClass.hbrBackground=GetSysColorBrush(COLOR_BTNFACE);
					windowClass.lpszMenuName=NULL;
					windowClass.lpszClassName=name.Buffer();
					windowClass.hIconSm=NULL;
					windowAtom=RegisterClassEx(&windowClass);
				}

				bool IsAvailable()
				{
					return windowAtom!=0;
				}

				WString GetName()
				{
					return name;
				}

				ATOM GetClassAtom()
				{
					return windowAtom;
				}
			};

/***********************************************************************
WindowsForm
***********************************************************************/

			class WindowsForm : public Object, public INativeWindow, public IWindowsForm
			{
			protected:
				
				DWORD InternalGetExStyle()
				{
					return (DWORD)GetWindowLongPtr(handle,GWL_EXSTYLE);
				}

				void InternalSetExStyle(DWORD exStyle)
				{
					LONG_PTR result=SetWindowLongPtr(handle,GWL_EXSTYLE,exStyle);
					SetWindowPos(handle,0,0,0,0,0,SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
				}

				bool GetExStyle(DWORD exStyle)
				{
					LONG_PTR Long=InternalGetExStyle();
					return (Long & exStyle) != 0;
				}

				void SetExStyle(DWORD exStyle, bool available)
				{
					DWORD Long=InternalGetExStyle();
					if(available)
					{
						Long|=exStyle;
					}
					else
					{
						Long&=~exStyle;
					}
					InternalSetExStyle((DWORD)Long);
				}

				bool GetStyle(DWORD style)
				{
					LONG_PTR Long=GetWindowLongPtr(handle,GWL_STYLE);
					return (Long & style) != 0;
				}

				void SetStyle(DWORD style, bool available)
				{
					LONG_PTR Long=GetWindowLongPtr(handle,GWL_STYLE);
					if(available)
					{
						Long|=style;
					}
					else
					{
						Long&=~style;
					}
					SetWindowLongPtr(handle,GWL_STYLE,Long);
					SetWindowPos(handle,0,0,0,0,0,SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
				}

				NativeWindowMouseInfo ConvertMouse(WPARAM wParam, LPARAM lParam, bool wheelMessage)
				{
					NativeWindowMouseInfo info;
					if(wheelMessage)
					{
						info.wheel=GET_WHEEL_DELTA_WPARAM(wParam);
						wParam=GET_KEYSTATE_WPARAM(wParam);
					}
					else
					{
						info.wheel=0;
					}
					info.ctrl=(wParam & MK_CONTROL)!=0;
					info.shift=(wParam & MK_SHIFT)!=0;
					info.left=(wParam & MK_LBUTTON)!=0;
					info.middle=(wParam & MK_MBUTTON)!=0;
					info.right=(wParam & MK_RBUTTON)!=0;
					POINTS Point=MAKEPOINTS(lParam);
					info.x=Point.x;
					info.y=Point.y;
					return info;
				}

				NativeWindowKeyInfo ConvertKey(WPARAM wParam, LPARAM lParam)
				{
					NativeWindowKeyInfo info;
					info.code=wParam;
					info.ctrl=WinIsKeyPressing(VK_CONTROL);
					info.shift=WinIsKeyPressing(VK_SHIFT);
					info.alt=WinIsKeyPressing(VK_MENU);
					info.capslock=WinIsKeyToggled(VK_CAPITAL);
					return info;
				}

				NativeWindowCharInfo ConvertChar(WPARAM wParam)
				{
					NativeWindowCharInfo info;
					info.code=(wchar_t)wParam;
					info.ctrl=WinIsKeyPressing(VK_CONTROL);
					info.shift=WinIsKeyPressing(VK_SHIFT);
					info.alt=WinIsKeyPressing(VK_MENU);
					info.capslock=WinIsKeyToggled(VK_CAPITAL);
					return info;
				}

				void TrackMouse(bool enable)
				{
					TRACKMOUSEEVENT trackMouseEvent;
					trackMouseEvent.cbSize=sizeof(trackMouseEvent);
					trackMouseEvent.hwndTrack=handle;
					trackMouseEvent.dwFlags=(enable?0:TME_CANCEL) | TME_HOVER | TME_LEAVE;
					trackMouseEvent.dwHoverTime=HOVER_DEFAULT;
					TrackMouseEvent(&trackMouseEvent);
				}

				void UpdateCompositionForContent()
				{
					HIMC imc = ImmGetContext(handle);
					COMPOSITIONFORM cf;
					cf.dwStyle = CFS_POINT;
					cf.ptCurrentPos.x = (int)caretPoint.x;
					cf.ptCurrentPos.y = (int)caretPoint.y;
					ImmSetCompositionWindow(imc, &cf);
					ImmReleaseContext(handle, imc);
				}

				bool HandleMessageInternal(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& result)
				{
					bool transferFocusEvent=false;
					switch(uMsg)
					{
					case WM_LBUTTONDOWN:
					case WM_LBUTTONUP:
					case WM_LBUTTONDBLCLK:
					case WM_RBUTTONDOWN:
					case WM_RBUTTONUP:
					case WM_RBUTTONDBLCLK:
					case WM_MBUTTONDOWN:
					case WM_MBUTTONUP:
					case WM_MBUTTONDBLCLK:
						transferFocusEvent=true;
					}
					switch(uMsg)
					{
					case WM_MOVING:case WM_SIZING:
						{
							LPRECT rawBounds=(LPRECT)lParam;
							Rect bounds(rawBounds->left, rawBounds->top, rawBounds->right, rawBounds->bottom);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->Moving(bounds, false);
							}
							if(		rawBounds->left!=bounds.Left()
								||	rawBounds->top!=bounds.Top()
								||	rawBounds->right!=bounds.Right()
								||	rawBounds->bottom!=bounds.Bottom())
							{
								rawBounds->left=(int)bounds.Left();
								rawBounds->top=(int)bounds.Top();
								rawBounds->right=(int)bounds.Right();
								rawBounds->bottom=(int)bounds.Bottom();
								result=TRUE;
							}
						}
						break;
					case WM_MOVE:case WM_SIZE:
						{
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->Moved();
							}
						}
						break;
					case WM_ENABLE:
						{
							for(vint i=0;i<listeners.Count();i++)
							{
								if(wParam==TRUE)
								{
									listeners[i]->Enabled();
								}
								else
								{
									listeners[i]->Disabled();
								}
							}
						}
						break;
					case WM_SETFOCUS:
						{
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->GotFocus();
							}
						}
						break;
					case WM_KILLFOCUS:
						{
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->LostFocus();
							}
						}
						break;
					case WM_ACTIVATE:
						{
							for(vint i=0;i<listeners.Count();i++)
							{
								if(wParam==WA_ACTIVE || wParam==WA_CLICKACTIVE)
								{
									listeners[i]->Activated();
								}
								else
								{
									listeners[i]->Deactivated();
								}
							}
						}
						break;
					case WM_SHOWWINDOW:
						{
							if(wParam==TRUE)
							{
								for(vint i=0;i<listeners.Count();i++)
								{
									listeners[i]->Opened();
								}
							}
							else
							{
								for(vint i=0;i<listeners.Count();i++)
								{
									listeners[i]->Closed();
								}
							}
						}
						break;
					case WM_CLOSE:
						{
							bool cancel=false;
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->Closing(cancel);
							}
							return cancel;
						}
						break;
					case WM_LBUTTONDOWN:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->LeftButtonDown(info);
							}
						}
						break;
					case WM_LBUTTONUP:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->LeftButtonUp(info);
							}
						}
						break;
					case WM_LBUTTONDBLCLK:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->LeftButtonDoubleClick(info);
							}
						}
						break;
					case WM_RBUTTONDOWN:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->RightButtonDown(info);
							}
						}
						break;
					case WM_RBUTTONUP:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->RightButtonUp(info);
							}
						}
						break;
					case WM_RBUTTONDBLCLK:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->RightButtonDoubleClick(info);
							}
						}
						break;
					case WM_MBUTTONDOWN:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->MiddleButtonDown(info);
							}
						}
						break;
					case WM_MBUTTONUP:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->MiddleButtonUp(info);
							}
						}
						break;
					case WM_MBUTTONDBLCLK:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->MiddleButtonDoubleClick(info);
							}
						}
						break;
					case WM_MOUSEHWHEEL:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, true);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->HorizontalWheel(info);
							}
						}
						break;
					case WM_MOUSEWHEEL:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, true);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->VerticalWheel(info);
							}
						}
						break;
					case WM_MOUSEMOVE:
						{
							NativeWindowMouseInfo info=ConvertMouse(wParam, lParam, false);
							if(info.x!=mouseLastX || info.y!=mouseLastY)
							{
								if(!mouseHoving)
								{
									mouseHoving=true;
									for(vint i=0;i<listeners.Count();i++)
									{
										listeners[i]->MouseEntered();
									}
									TrackMouse(true);
								}
								for(vint i=0;i<listeners.Count();i++)
								{
									listeners[i]->MouseMoving(info);
								}
							}
						}
						break;
					case WM_MOUSELEAVE:
						{
							mouseLastX=-1;
							mouseLastY=-1;
							mouseHoving=false;
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->MouseLeaved();
							}
						}
						break;
					case WM_MOUSEHOVER:
						{
							TrackMouse(true);
						}
						break;
					case WM_KEYUP:
						{
							NativeWindowKeyInfo info=ConvertKey(wParam, lParam);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->KeyUp(info);
							}
						}
						break;
					case WM_KEYDOWN:
						{
							NativeWindowKeyInfo info=ConvertKey(wParam, lParam);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->KeyDown(info);
							}
						}
						break;
					case WM_SYSKEYUP:
						{
							NativeWindowKeyInfo info=ConvertKey(wParam, lParam);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->SysKeyUp(info);
							}
						}
						break;
					case WM_SYSKEYDOWN:
						{
							NativeWindowKeyInfo info=ConvertKey(wParam, lParam);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->SysKeyDown(info);
							}
						}
						break;
					case WM_CHAR:
						{
							NativeWindowCharInfo info=ConvertChar(wParam);
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->Char(info);
							}
						}
						break;
					case WM_PAINT:
						{
							for(vint i=0;i<listeners.Count();i++)
							{
								listeners[i]->Paint();
							}
						}
						break;
					case WM_ERASEBKGND:
						return true;
					case WM_IME_SETCONTEXT:
						if(wParam==TRUE)
						{
							HIMC imc = ImmGetContext(handle);
							ImmAssociateContext(hwnd, imc);
							ImmReleaseContext(handle, imc);
						}
						break;
					case WM_IME_STARTCOMPOSITION:
						UpdateCompositionForContent();
						break;
					case WM_NCHITTEST:
						{
							POINTS location=MAKEPOINTS(lParam);
							Point windowLocation=GetBounds().LeftTop();
							location.x-=(SHORT)windowLocation.x;
							location.y-=(SHORT)windowLocation.y;
							for(vint i=0;i<listeners.Count();i++)
							{
								switch(listeners[i]->HitTest(Point(location.x, location.y)))
								{
								case INativeWindowListener::BorderNoSizing:
									result=HTBORDER;
									return true;
								case INativeWindowListener::BorderLeft:
									result=HTLEFT;
									return true;
								case INativeWindowListener::BorderRight:
									result=HTRIGHT;
									return true;
								case INativeWindowListener::BorderTop:
									result=HTTOP;
									return true;
								case INativeWindowListener::BorderBottom:
									result=HTBOTTOM;
									return true;
								case INativeWindowListener::BorderLeftTop:
									result=HTTOPLEFT;
									return true;
								case INativeWindowListener::BorderRightTop:
									result=HTTOPRIGHT;
									return true;
								case INativeWindowListener::BorderLeftBottom:
									result=HTBOTTOMLEFT;
									return true;
								case INativeWindowListener::BorderRightBottom:
									result=HTBOTTOMRIGHT;
									return true;
								case INativeWindowListener::Title:
									result=HTCAPTION;
									return true;
								case INativeWindowListener::ButtonMinimum:
									result=HTMINBUTTON;
									return true;
								case INativeWindowListener::ButtonMaximum:
									result=HTMAXBUTTON;
									return true;
								case INativeWindowListener::ButtonClose:
									result=HTCLOSE;
									return true;
								case INativeWindowListener::Client:
									result=HTCLIENT;
									return true;
								case INativeWindowListener::Icon:
									result=HTSYSMENU;
									return true;
								}
							}
						}
						break;
					case WM_SETCURSOR:
						{
							DWORD hitTestResult=LOWORD(lParam);
							if(hitTestResult==HTCLIENT)
							{
								HCURSOR cursorHandle=cursor->GetCursorHandle();
								if(GetCursor()!=cursorHandle)
								{
									SetCursor(cursorHandle);
								}
								result=TRUE;
								return true;
							}
						}
						break;
					case WM_NCCALCSIZE:
						if((BOOL)wParam && customFrameMode)
						{
							result=0;
							return true;
						}
						break;
					case WM_NCACTIVATE:
						if(customFrameMode)
						{
							result=FALSE;
							return true;
						}
						break;
					case WM_NCPAINT:
					case WM_SYNCPAINT:
						if(customFrameMode)
						{
							result=0;
							return true;
						}
						break;
					}
					if(IsWindow(hwnd)!=0)
					{
						if(transferFocusEvent && IsFocused())
						{
							WindowsForm* window=this;
							while(window->parentWindow && window->alwaysPassFocusToParent)
							{
								window=window->parentWindow;
							}
							if(window!=this)
							{
								window->SetFocus();
							}
						}
					}
					return false;
				}
			protected:
				HWND								handle;
				WString								title;
				WindowsCursor*						cursor;
				Point								caretPoint;
				WindowsForm*						parentWindow;
				bool								alwaysPassFocusToParent;
				List<INativeWindowListener*>		listeners;
				vint									mouseLastX;
				vint									mouseLastY;
				vint									mouseHoving;
				Interface*							graphicsHandler;
				bool								customFrameMode;
			public:
				WindowsForm(HWND parent, WString className, HINSTANCE hInstance)
					:cursor(0)
					,parentWindow(0)
					,alwaysPassFocusToParent(false)
					,mouseLastX(-1)
					,mouseLastY(-1)
					,mouseHoving(false)
					,graphicsHandler(0)
					,customFrameMode(false)
				{
					DWORD exStyle=WS_EX_APPWINDOW | WS_EX_CONTROLPARENT;
					DWORD style=WS_BORDER | WS_CAPTION | WS_SIZEBOX | WS_SYSMENU | WS_POPUP | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_MAXIMIZEBOX | WS_MINIMIZEBOX;
					handle=CreateWindowEx(exStyle, className.Buffer(), L"", style, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, parent, NULL, hInstance, NULL);
				}

				~WindowsForm()
				{
					List<INativeWindowListener*> copiedListeners;
					CopyFrom(copiedListeners, listeners);
					for(vint i=0;i<copiedListeners.Count();i++)
					{
						INativeWindowListener* listener=copiedListeners[i];
						if(listeners.Contains(listener))
						{
							listener->Destroyed();
						}
					}
					DestroyWindow(handle);
				}

				void InvokeDestroying()
				{
					for(vint i=0;i<listeners.Count();i++)
					{
						listeners[i]->Destroying();
					}
				}

				bool HandleMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& result)
				{
					return HandleMessageInternal(hwnd, uMsg, wParam, lParam, result);
				}

				HWND GetWindowHandle()
				{
					return handle;
				}

				Interface* GetGraphicsHandler()
				{
					return graphicsHandler;
				}

				void SetGraphicsHandler(Interface* handler)
				{
					graphicsHandler=handler;
				}

				Rect GetBounds()
				{
					RECT rect;
					GetWindowRect(handle, &rect);
					return Rect(rect.left, rect.top, rect.right, rect.bottom);
				}

				void SetBounds(const Rect& bounds)
				{
					Rect newBounds=bounds;
					for(vint i=0;i<listeners.Count();i++)
					{
						listeners[i]->Moving(newBounds, true);
					}
					MoveWindow(handle, (int)newBounds.Left(), (int)newBounds.Top(), (int)newBounds.Width(), (int)newBounds.Height(), FALSE);
				}

				Size GetClientSize()
				{
					return GetClientBoundsInScreen().GetSize();
				}

				void SetClientSize(Size size)
				{
					RECT required={0,0,(int)size.x,(int)size.y};
					RECT bounds;
					GetWindowRect(handle, &bounds);
					AdjustWindowRect(&required, (DWORD)GetWindowLongPtr(handle, GWL_STYLE), FALSE);
					SetBounds(Rect(Point(bounds.left, bounds.top), Size(required.right-required.left, required.bottom-required.top)));
				}

				Rect GetClientBoundsInScreen()
				{
					if(customFrameMode)
					{
						return GetBounds();
					}
					else
					{
						RECT required={0,0,0,0};
						RECT bounds;
						GetWindowRect(handle, &bounds);
						AdjustWindowRect(&required, (DWORD)GetWindowLongPtr(handle, GWL_STYLE), FALSE);
						return Rect(
							Point(
								(bounds.left-required.left),
								(bounds.top-required.top)
								),
							Size(
								(bounds.right-bounds.left)-(required.right-required.left),
								(bounds.bottom-bounds.top)-(required.bottom-required.top)
								)
							);
					}
				}

				WString GetTitle()
				{
					return title;
				}

				void SetTitle(WString _title)
				{
					title=_title;
					SetWindowText(handle, title.Buffer());
				}

				INativeCursor* GetWindowCursor()
				{
					return cursor;
				}

				void SetWindowCursor(INativeCursor* _cursor)
				{
					WindowsCursor* newCursor=dynamic_cast<WindowsCursor*>(_cursor);
					if(newCursor && cursor!=newCursor)
					{
						cursor=newCursor;
						if(mouseHoving && IsVisible())
						{
							SetCursor(cursor->GetCursorHandle());
						}
					}
				}
				
				Point GetCaretPoint()
				{
					return caretPoint;
				}

				void SetCaretPoint(Point point)
				{
					caretPoint=point;
					UpdateCompositionForContent();
				}

				INativeWindow* GetParent()
				{
					return parentWindow;
				}

				void SetParent(INativeWindow* parent)
				{
					WindowsForm* window=dynamic_cast<WindowsForm*>(parent);
					if(window)
					{
						parentWindow=window;
						if(parentWindow)
						{
							SetWindowLongPtr(handle, GWLP_HWNDPARENT, (LONG_PTR)window->handle);
						}
						else
						{
							SetWindowLongPtr(handle, GWLP_HWNDPARENT, NULL);
						}
					}
				}

				bool GetAlwaysPassFocusToParent()
				{
					return alwaysPassFocusToParent;
				}

				void SetAlwaysPassFocusToParent(bool value)
				{
					alwaysPassFocusToParent=value;
				}

				void EnableCustomFrameMode()
				{
					customFrameMode=true;
				}

				void DisableCustomFrameMode()
				{
					customFrameMode=false;
				}

				bool IsCustomFrameModeEnabled()
				{
					return customFrameMode;
				}

				WindowSizeState GetSizeState()
				{
					if(IsIconic(handle))
					{
						return INativeWindow::Minimized;
					}
					else if(IsZoomed(handle))
					{
						return INativeWindow::Maximized;
					}
					else
					{
						return INativeWindow::Restored;
					}
				}

				void Show()
				{
					ShowWindow(handle, SW_SHOWNORMAL);
				}

				void ShowDeactivated()
				{
					ShowWindow(handle, SW_SHOWNOACTIVATE);
					SetWindowPos(handle,HWND_TOP,0,0,0,0,SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
				}

				void ShowRestored()
				{
					ShowWindow(handle, SW_RESTORE);
				}

				void ShowMaximized()
				{
					ShowWindow(handle, SW_SHOWMAXIMIZED);
				}

				void ShowMinimized()
				{
					ShowWindow(handle, SW_SHOWMINIMIZED);
				}

				void Hide()
				{
					SendMessage(handle, WM_CLOSE, NULL, NULL);
				}

				bool IsVisible()
				{
					return IsWindowVisible(handle)!=0;
				}

				void Enable()
				{
					EnableWindow(handle, TRUE);
				}

				void Disable()
				{
					EnableWindow(handle, FALSE);
				}

				bool IsEnabled()
				{
					return IsWindowEnabled(handle)!=0;
				}

				void SetFocus()
				{
					::SetFocus(handle);
				}

				bool IsFocused()
				{
					return GetFocus()==handle;
				}

				void SetActivate()
				{
					SetActiveWindow(handle);
				}

				bool IsActivated()
				{
					return GetActiveWindow()==handle;
				}

				void ShowInTaskBar()
				{
					SetExStyle(WS_EX_APPWINDOW, true);
				}

				void HideInTaskBar()
				{
					SetExStyle(WS_EX_APPWINDOW, false);
				}

				bool IsAppearedInTaskBar()
				{
					return GetExStyle(WS_EX_APPWINDOW);
				}

				void EnableActivate()
				{
					SetExStyle(WS_EX_NOACTIVATE, false);
				}

				void DisableActivate()
				{
					SetExStyle(WS_EX_NOACTIVATE, true);
				}

				bool IsEnabledActivate()
				{
					return !GetExStyle(WS_EX_NOACTIVATE);
				}

				bool RequireCapture()
				{
					SetCapture(handle);
					return true;
				}

				bool ReleaseCapture()
				{
					::ReleaseCapture();
					return true;
				}

				bool IsCapturing()
				{
					return GetCapture()==handle;
				}

				bool GetMaximizedBox()
				{
					return GetStyle(WS_MAXIMIZEBOX);
				}

				void SetMaximizedBox(bool visible)
				{
					SetStyle(WS_MAXIMIZEBOX, visible);
				}

				bool GetMinimizedBox()
				{
					return GetStyle(WS_MINIMIZEBOX);
				}

				void SetMinimizedBox(bool visible)
				{
					SetStyle(WS_MINIMIZEBOX, visible);
				}

				bool GetBorder()
				{
					return GetStyle(WS_BORDER);
				}

				void SetBorder(bool visible)
				{
					SetStyle(WS_BORDER, visible);
				}

				bool GetSizeBox()
				{
					return GetStyle(WS_SIZEBOX);
				}

				void SetSizeBox(bool visible)
				{
					SetStyle(WS_SIZEBOX, visible);
				}

				bool GetIconVisible()
				{
					return GetStyle(WS_SYSMENU);
				}

				void SetIconVisible(bool visible)
				{
					SetStyle(WS_SYSMENU, visible);
				}

				bool GetTitleBar()
				{
					return GetStyle(WS_CAPTION);
				}

				void SetTitleBar(bool visible)
				{
					SetStyle(WS_CAPTION, visible);
				}

				bool GetTopMost()
				{
					return GetExStyle(WS_EX_TOPMOST);
				}

				void SetTopMost(bool topmost)
				{
					SetWindowPos(handle,(topmost?HWND_TOPMOST:HWND_NOTOPMOST),0,0,0,0,SWP_NOSIZE | SWP_NOMOVE | SWP_FRAMECHANGED);
				}

				bool InstallListener(INativeWindowListener* listener)
				{
					if(listeners.Contains(listener))
					{
						return false;
					}
					else
					{
						listeners.Add(listener);
						return true;
					}
				}

				bool UninstallListener(INativeWindowListener* listener)
				{
					if(listeners.Contains(listener))
					{
						listeners.Remove(listener);
						return true;
					}
					else
					{
						return false;
					}
				}

				void RedrawContent()
				{
					if(graphicsHandler)
					{
						SendMessage(this->handle, WM_PAINT, NULL, NULL);
					}
				}
			};

/***********************************************************************
WindowsController
***********************************************************************/

			LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
			LRESULT CALLBACK GodProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
			LRESULT CALLBACK MouseProc(int nCode , WPARAM wParam , LPARAM lParam);

			class WindowsController : public Object, public virtual INativeController, public virtual INativeWindowService
			{
			protected:
				WinClass							windowClass;
				WinClass							godClass;
				HINSTANCE							hInstance;
				HWND								godWindow;
				Dictionary<HWND, WindowsForm*>		windows;
				INativeWindow*						mainWindow;
				HWND								mainWindowHandle;

				WindowsCallbackService				callbackService;
				WindowsResourceService				resourceService;
				WindowsAsyncService					asyncService;
				WindowsClipboardService				clipboardService;
				WindowsImageService					imageService;
				WindowsScreenService				screenService;
				WindowsInputService					inputService;
				WindowsDialogService				dialogService;

			public:
				WindowsController(HINSTANCE _hInstance)
					:hInstance(_hInstance)
					,windowClass(L"VczhWindow", false, false, WndProc, _hInstance)
					,godClass(L"GodWindow", false, false, GodProc, _hInstance)
					,mainWindow(0)
					,mainWindowHandle(0)
					,screenService(&GetHWNDFromNativeWindowHandle)
					,inputService(&MouseProc)
					,dialogService(&GetHWNDFromNativeWindowHandle)
				{
					godWindow=CreateWindowEx(WS_EX_CONTROLPARENT, godClass.GetName().Buffer(), L"GodWindow", WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, NULL, NULL, hInstance, NULL);
					clipboardService.SetOwnerHandle(godWindow);
					inputService.SetOwnerHandle(godWindow);
				}

				~WindowsController()
				{
					inputService.StopTimer();
					inputService.StopHookMouse();
					clipboardService.SetOwnerHandle(NULL);
					DestroyWindow(godWindow);
				}

				bool HandleMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& result)
				{
					bool skipDefaultProcedure=false;
					vint index=windows.Keys().IndexOf(hwnd);
					if(index!=-1)
					{
						WindowsForm* window=windows.Values().Get(index);
						skipDefaultProcedure=window->HandleMessage(hwnd, uMsg, wParam, lParam, result);
						switch(uMsg)
						{
						case WM_CLOSE:
							if(!skipDefaultProcedure)
							{
								ShowWindow(window->GetWindowHandle(), SW_HIDE);
								if(window!=mainWindow)
								{
									skipDefaultProcedure=true;
								}
							}
							break;
						case WM_DESTROY:
							DestroyNativeWindow(window);
							break;
						}
					}

					if(hwnd==mainWindowHandle && uMsg==WM_DESTROY)
					{
						for(vint i=0;i<windows.Count();i++)
						{
							if(windows.Values().Get(i)->IsVisible())
							{
								windows.Values().Get(i)->Hide();
							}
						}
						while(windows.Count())
						{
							DestroyNativeWindow(windows.Values().Get(0));
						}
						PostQuitMessage(0);
					}
					return skipDefaultProcedure;
				}

				//=======================================================================

				INativeWindow* CreateNativeWindow()
				{
					WindowsForm* window=new WindowsForm(godWindow, windowClass.GetName(), hInstance);
					windows.Add(window->GetWindowHandle(), window);
					callbackService.InvokeNativeWindowCreated(window);
					window->SetWindowCursor(resourceService.GetDefaultSystemCursor());
					return window;
				}

				void DestroyNativeWindow(INativeWindow* window)
				{
					WindowsForm* windowsForm=dynamic_cast<WindowsForm*>(window);
					windowsForm->InvokeDestroying();
					if(windowsForm!=0 && windows.Keys().Contains(windowsForm->GetWindowHandle()))
					{
						callbackService.InvokeNativeWindowDestroyed(window);
						windows.Remove(windowsForm->GetWindowHandle());
						delete windowsForm;
					}
				}

				INativeWindow* GetMainWindow()
				{
					return mainWindow;
				}

				void Run(INativeWindow* window)
				{
					mainWindow=window;
					mainWindowHandle=GetWindowsForm(window)->GetWindowHandle();
					mainWindow->Show();
					MSG message;
					while(GetMessage(&message, NULL, 0, 0))
					{
						TranslateMessage(&message);
						DispatchMessage(&message);
						asyncService.ExecuteAsyncTasks();
					}
				}

				INativeWindow* GetWindow(Point location)
				{
					POINT p;
					p.x=(int)location.x;
					p.y=(int)location.y;
					HWND handle=WindowFromPoint(p);
					vint index=windows.Keys().IndexOf(handle);
					if(index==-1)
					{
						return 0;
					}
					else
					{
						return windows.Values().Get(index);
					}
				}

				//=======================================================================

				INativeCallbackService* CallbackService()
				{
					return &callbackService;
				}

				INativeResourceService* ResourceService()
				{
					return &resourceService;
				}
				
				INativeAsyncService* AsyncService()
				{
					return &asyncService;
				}

				INativeClipboardService* ClipboardService()
				{
					return &clipboardService;
				}

				INativeImageService* ImageService()
				{
					return &imageService;
				}

				INativeScreenService* ScreenService()
				{
					return &screenService;
				}

				INativeWindowService* WindowService()
				{
					return this;
				}

				INativeInputService* InputService()
				{
					return &inputService;
				}

				INativeDialogService* DialogService()
				{
					return &dialogService;
				}

				WString GetOSVersionMainPart()
				{
					OSVERSIONINFOEX info;
					ZeroMemory(&info, sizeof(info));
					info.dwOSVersionInfoSize=sizeof(info);
					GetVersionEx((OSVERSIONINFO*)&info);
					switch(info.dwMajorVersion)
					{
					case 5:
						switch(info.dwMinorVersion)
						{
						case 0:
							return L"Windows 2000";
						case 1:
							return L"Windows XP";
						case 2:
							return GetSystemMetrics(SM_SERVERR2)==0?L"Windows Server 2003":L"Windows Server 2003 R2";
						}
					case 6:
						if(info.wProductType==VER_NT_WORKSTATION)
						{
							switch(info.dwMinorVersion)
							{
							case 0:
								return L"Windows Vista";
							case 1:
								return L"Windows 7";
							case 2:
								return L"Windows 8";
							}
						}
						else
						{
							switch(info.dwMinorVersion)
							{
							case 0:
								return L"Windows Server 2008";
							case 1:
								return L"Windows Server 2008 R2";
							case 2:
								return L"Windows Server 2012";
							}
						}
					}
					return L"Windows<Unknown Version>";
				}

				WString GetOSVersionCSDPart()
				{
					OSVERSIONINFOEX info;
					ZeroMemory(&info, sizeof(info));
					info.dwOSVersionInfoSize=sizeof(info);
					GetVersionEx((OSVERSIONINFO*)&info);
					return info.szCSDVersion;
				}

				WString GetOSVersion()
				{
					return GetOSVersionMainPart()+L";"+GetOSVersionCSDPart();
				}

				WString GetExecutablePath()
				{
					Array<wchar_t> buffer(65536);
					GetModuleFileName(NULL, &buffer[0], buffer.Count());
					return &buffer[0];
				}

				//=======================================================================

				void InvokeMouseHook(WPARAM message, Point location)
				{
					callbackService.InvokeMouseHook(message, location);
				}

				void InvokeGlobalTimer()
				{
					callbackService.InvokeGlobalTimer();
				}

				void InvokeClipboardUpdated()
				{
					callbackService.InvokeClipboardUpdated();
				}
			};

/***********************************************************************
Windows Procedure
***********************************************************************/

			LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
			{
				WindowsController* controller=dynamic_cast<WindowsController*>(GetCurrentController());
				if(controller)
				{
					LRESULT result=0;
					if(controller->HandleMessage(hwnd, uMsg, wParam, lParam, result))
					{
						return result;
					}
				}
				return DefWindowProc(hwnd, uMsg, wParam, lParam);
			}

			LRESULT CALLBACK GodProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
			{
				WindowsController* controller=dynamic_cast<WindowsController*>(GetCurrentController());
				if(controller)
				{
					switch(uMsg)
					{
					case WM_TIMER:
						controller->InvokeGlobalTimer();
						break;
					case WM_CLIPBOARDUPDATE:
						controller->InvokeClipboardUpdated();
						break;
					}
				}
				return DefWindowProc(hwnd, uMsg, wParam, lParam);
			}

			LRESULT CALLBACK MouseProc(int nCode , WPARAM wParam , LPARAM lParam)
			{
				WindowsController* controller=dynamic_cast<WindowsController*>(GetCurrentController());
				if(controller)
				{
					MSLLHOOKSTRUCT* mouseHookStruct=(MSLLHOOKSTRUCT*)lParam;
					Point location(mouseHookStruct->pt.x, mouseHookStruct->pt.y);
					controller->InvokeMouseHook(wParam, location);
				}
				return CallNextHookEx(NULL,nCode,wParam,lParam);
			}

/***********************************************************************
Windows Platform Native Controller
***********************************************************************/

			INativeController* CreateWindowsNativeController(HINSTANCE hInstance)
			{
				return new WindowsController(hInstance);
			}

			IWindowsForm* GetWindowsForm(INativeWindow* window)
			{
				return dynamic_cast<WindowsForm*>(window);
			}

			void DestroyWindowsNativeController(INativeController* controller)
			{
				delete controller;
			}
		}
	}
}
