/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: 陈梓瀚(vczh)
***********************************************************************/

/***********************************************************************
COMMON\SOURCE\BASIC.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Basic

Classes:
	NotCopyable									：不可复制对象
	Error										：内部错误，检查到了不可出现的变量、参数或状态错误
	Object										：对象基类

Macros:
	CHECK_ERROR(CONDITION,DESCRIPTION)			：检查内部错误
***********************************************************************/

#ifndef VCZH_BASIC
#define VCZH_BASIC

namespace vl
{

/***********************************************************************
32位/64位兼容
***********************************************************************/

#ifdef _WIN64
#define VCZH_64
#endif

#ifdef VCZH_64
	typedef __int64					vint;
	typedef signed __int64			vsint;
	typedef unsigned __int64		vuint;
#else
	typedef __int32					vint;
	typedef signed __int32			vsint;
	typedef unsigned __int32		vuint;
#endif

typedef signed __int64	pos_t;

#ifdef VCZH_64
#define ITOA_S		_i64toa_s
#define ITOW_S		_i64tow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#else
#define ITOA_S		_itoa_s
#define ITOW_S		_itow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#endif

#ifndef _MSC_VER
#define override
#define abstract
#endif

#define VCZH_NO_OLD_OS

/***********************************************************************
基础
***********************************************************************/

	class NotCopyable
	{
	private:
		NotCopyable(const NotCopyable&);
		NotCopyable& operator=(const NotCopyable&);
	public:
		NotCopyable();
	};

	class Error
	{
	private:
		wchar_t*			description;
	public:
		Error(wchar_t* _description);

		wchar_t*			Description()const;
	};

#ifdef _DEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION) do{if(!(CONDITION))throw Error(DESCRIPTION);}while(0)
#endif
#ifdef NDEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION)
#endif

#define CHECK_FAIL(DESCRIPTION) do{throw Error(DESCRIPTION);}while(0)

	class Object
	{
	public:
		virtual ~Object();
	};

	template<typename T>
	class ObjectBox : public Object
	{
	private:
		T					object;
	public:
		ObjectBox(const T& _object)
		{
			object=_object;
		}

		const T& Unbox()
		{
			return object;
		}
	};

	template<typename T, size_t minSize>
	union BinaryRetriver
	{
		T t;
		char binary[sizeof(T)>minSize?sizeof(T):minSize];
	};

/***********************************************************************
配置
***********************************************************************/

	template<typename T>
	struct KeyType
	{
	public:
		typedef T Type;
	};

	template<typename T>
	struct POD
	{
		static const bool Result=false;
	};

	template<>struct POD<bool>{static const bool Result=true;};
	template<>struct POD<unsigned __int8>{static const bool Result=true;};
	template<>struct POD<signed __int8>{static const bool Result=true;};
	template<>struct POD<unsigned __int16>{static const bool Result=true;};
	template<>struct POD<signed __int16>{static const bool Result=true;};
	template<>struct POD<unsigned __int32>{static const bool Result=true;};
	template<>struct POD<signed __int32>{static const bool Result=true;};
	template<>struct POD<unsigned __int64>{static const bool Result=true;};
	template<>struct POD<signed __int64>{static const bool Result=true;};
	template<>struct POD<char>{static const bool Result=true;};
	template<>struct POD<wchar_t>{static const bool Result=true;};
	template<typename T>struct POD<T*>{static const bool Result=true;};
	template<typename T>struct POD<T&>{static const bool Result=true;};
	template<typename T, typename C>struct POD<T C::*>{static const bool Result=true;};
	template<typename T, vint _Size>struct POD<T[_Size]>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<volatile T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const volatile T>{static const bool Result=POD<T>::Result;};

/***********************************************************************
时间
***********************************************************************/

	struct DateTime
	{
		vint				year;
		vint				month;
		vint				dayOfWeek;
		vint				day;
		vint				hour;
		vint				minute;
		vint				second;
		vint				milliseconds;

		unsigned __int64	totalMilliseconds;
		unsigned __int64	filetime;

		static DateTime		LocalTime();
		static DateTime		UtcTime();

		DateTime			ToLocalTime();
		DateTime			ToUtcTime();
	};

/***********************************************************************
接口
***********************************************************************/

	class Interface : private NotCopyable
	{
	public:
		virtual ~Interface();
	};
}

#endif

/***********************************************************************
COMMON\SOURCE\STRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::String

Classes:
	AString										：Mbcs字符串
	WString										：Utf-16字符串
***********************************************************************/

#ifndef VCZH_STRING
#define VCZH_STRING

#include <memory.h>

namespace vl
{
	template<typename T>
	class ObjectString : public Object
	{
	private:
		static const T	zero=0;

		mutable T*					buffer;
		mutable vint*				reference;
		mutable vint				start;
		mutable vint				length;
		mutable vint				realLength;

		static vint CalculateLength(const T* buffer)
		{
			vint result=0;
			while(*buffer++)result++;
			return result;
		}

		static vint Compare(const T* bufA, const ObjectString<T>& strB)
		{
			const T* bufB=strB.buffer+strB.start;
			const T* bufAOld=bufA;
			vint length=strB.length;
			while(length-- && *bufA)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return CalculateLength(bufAOld)-strB.length;
		}

	public:

		static vint Compare(const ObjectString<T>& strA, const ObjectString<T>& strB)
		{
			const T* bufA=strA.buffer+strA.start;
			const T* bufB=strB.buffer+strB.start;
			vint length=strA.length<strB.length?strA.length:strB.length;
			while(length--)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return strA.length-strB.length;
		}

	private:

		void Inc()const
		{
			if(reference)
			{
				(*reference)++;
			}
		}

		void Dec()const
		{
			if(reference)
			{
				if(--(*reference)==0)
				{
					delete[] buffer;
					delete reference;
				}
			}
		}

		ObjectString(const ObjectString<T>& string, vint _start, vint _length)
		{
			if(_length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=string.buffer;
				reference=string.reference;
				start=string.start+_start;
				length=_length;
				realLength=string.realLength;
				Inc();
			}
		}

		ObjectString(const ObjectString<T>& dest, const ObjectString<T>& source, vint index, vint count)
		{
			if(index==0 && count==dest.length && source.length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				reference=new vint(1);
				start=0;
				length=dest.length-count+source.length;
				realLength=length;
				buffer=new T[length+1];
				memcpy(buffer, dest.buffer+dest.start, sizeof(T)*index);
				memcpy(buffer+index, source.buffer+source.start, sizeof(T)*source.length);
				memcpy(buffer+index+source.length, (dest.buffer+dest.start+index+count), sizeof(T)*(dest.length-index-count));
				buffer[length]=0;
			}
		}
	public:
		static ObjectString<T>	Empty;

		ObjectString()
		{
			buffer=(T*)&zero;
			reference=0;
			start=0;
			length=0;
			realLength=0;
		}

		ObjectString(const T& _char)
		{
			reference=new vint(1);
			start=0;
			length=1;
			buffer=new T[2];
			buffer[0]=_char;
			buffer[1]=0;
			realLength=length;
		}

		ObjectString(const T* _buffer, vint _length)
		{
			if(_length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=new T[_length+1];
				memcpy(buffer, _buffer, _length*sizeof(T));
				buffer[_length]=0;
				reference=new vint(1);
				start=0;
				length=_length;
				realLength=_length;
			}
		}

		ObjectString(const T* _buffer, bool copy = true)
		{
			CHECK_ERROR(_buffer!=0, L"ObjectString<T>::ObjectString(const T*, bool)#不能用空指针构造字符串。");
			if(copy)
			{
				reference=new vint(1);
				start=0;
				length=CalculateLength(_buffer);
				buffer=new T[length+1];
				memcpy(buffer, _buffer, sizeof(T)*(length+1));
				realLength=length;
			}
			else
			{
				buffer=(T*)_buffer;
				reference=0;
				start=0;
				length=CalculateLength(_buffer);
				realLength=length;
			}
		}

		ObjectString(const ObjectString<T>& string)
		{
			buffer=string.buffer;
			reference=string.reference;
			start=string.start;
			length=string.length;
			realLength=string.realLength;
			Inc();
		}

		~ObjectString()
		{
			Dec();
		}

		const T* Buffer()const
		{
			if(start+length!=realLength)
			{
				T* newBuffer=new T[length+1];
				memcpy(newBuffer, buffer+start, sizeof(T)*length);
				newBuffer[length]=0;
				Dec();
				buffer=newBuffer;
				reference=new vint(1);
				start=0;
				realLength=length;
			}
			return buffer+start;
		}

		ObjectString<T>& operator=(const ObjectString<T>& string)
		{
			if(this!=&string)
			{
				Dec();
				buffer=string.buffer;
				reference=string.reference;
				start=string.start;
				length=string.length;
				realLength=string.realLength;
				Inc();
			}
			return *this;
		}

		ObjectString<T>& operator+=(const ObjectString<T>& string)
		{
			return *this=*this+string;
		}

		ObjectString<T> operator+(const ObjectString<T>& string)const
		{
			return ObjectString<T>(*this, string, length, 0);
		}

		bool operator==(const ObjectString<T>& string)const
		{
			return Compare(*this, string)==0;
		}

		bool operator!=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)!=0;
		}

		bool operator>(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>0;
		}

		bool operator>=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>=0;
		}

		bool operator<(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<0;
		}

		bool operator<=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<=0;
		}

		bool operator==(const T* buffer)const
		{
			return Compare(buffer, *this)==0;
		}

		bool operator!=(const T* buffer)const
		{
			return Compare(buffer, *this)!=0;
		}

		bool operator>(const T* buffer)const
		{
			return Compare(buffer, *this)<0;
		}

		bool operator>=(const T* buffer)const
		{
			return Compare(buffer, *this)<=0;
		}

		bool operator<(const T* buffer)const
		{
			return Compare(buffer, *this)>0;
		}

		bool operator<=(const T* buffer)const
		{
			return Compare(buffer, *this)>=0;
		}

		T operator[](vint index)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString:<T>:operator[](vint)#参数index越界。");
			return buffer[start+index];
		}

		vint Length()const
		{
			return length;
		}

		vint IndexOf(T c)const
		{
			const T* reading=buffer+start;
			for(vint i=0;i<length;i++)
			{
				if(reading[i]==c)
					return i;
			}
			return -1;
		}

		ObjectString<T> Left(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Left(vint)#参数count越界。");
			return ObjectString<T>(*this, 0, count);
		}

		ObjectString<T> Right(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Right(vint)#参数count越界。");
			return ObjectString<T>(*this, length-count, count);
		}

		ObjectString<T> Sub(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Sub(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Sub(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, index, count);
		}

		ObjectString<T> Remove(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Remove(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Remove(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, ObjectString<T>(), index, count);
		}

		ObjectString<T> Insert(vint index, const ObjectString<T>& string)const
		{
			CHECK_ERROR(index>=0 && index<=length, L"ObjectString<T>::Insert(vint)#参数count越界。");
			return ObjectString<T>(*this, string, index, 0);
		}

		friend bool operator<(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<0;
		}

		friend bool operator<=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<=0;
		}

		friend bool operator>(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>0;
		}

		friend bool operator>=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>=0;
		}

		friend bool operator==(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)==0;
		}

		friend bool operator!=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)!=0;
		}

		friend ObjectString<T> operator+(const T* left, const ObjectString<T>& right)
		{
			return WString(left, false)+right;
		}
	};

	template<typename T>
	ObjectString<T> ObjectString<T>::Empty=ObjectString<T>();

	typedef ObjectString<char>		AString;
	typedef ObjectString<wchar_t>	WString;

	extern vint					atoi(const AString& string);
	extern vint					wtoi(const WString& string);
	extern __int64				atoi64(const AString& string);
	extern __int64				wtoi64(const WString& string);
	extern vuint				atou(const AString& string);
	extern vuint				wtou(const WString& string);
	extern unsigned __int64		atou64(const AString& string);
	extern unsigned __int64		wtou64(const WString& string);
	extern double				atof(const AString& string);
	extern double				wtof(const WString& string);
	extern AString				itoa(vint number);
	extern WString				itow(vint number);
	extern AString				i64toa(__int64 number);
	extern WString				i64tow(__int64 number);
	extern AString				utoa(vuint number);
	extern WString				utow(vuint number);
	extern AString				u64toa(unsigned __int64 number);
	extern WString				u64tow(unsigned __int64 number);
	extern AString				ftoa(double number);
	extern WString				ftow(double number);
	extern vint					_wtoa(const wchar_t* w, char* a, vint chars);
	extern AString				wtoa(const WString& string);
	extern vint					_atow(const char* a, wchar_t* w, vint chars);
	extern WString				atow(const AString& string);
	extern AString				alower(const AString& string);
	extern WString				wlower(const WString& string);
	extern AString				aupper(const AString& string);
	extern WString				wupper(const WString& string);
}

#endif

/***********************************************************************
COMMON\SOURCE\POINTER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Smart Pointer

Classes:
	Ptr<T>							：智能指针
***********************************************************************/

#ifndef VCZH_POINTER
#define VCZH_POINTER


namespace vl
{
	template<typename T>
	class Ptr
	{
		 template<typename X>
		 friend class Ptr;
	protected:
		vint*				counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				(*counter)++;
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(--(*counter)==0)
				{
					delete counter;
					delete reference;
					counter=0;
					reference=0;
				}
			}
		}

		vint* Counter()const
		{
			return counter;
		}

		Ptr(vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		Ptr()
		{
			counter=0;
			reference=0;
		}

		Ptr(T* pointer)
		{
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		Ptr(const Ptr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		template<typename C>
		Ptr(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		~Ptr()
		{
			Dec();
		}

		template<typename C>
		Ptr<C> Cast()const
		{
			C* converted=dynamic_cast<C*>(reference);
			return Ptr<C>((converted?counter:0), converted);
		}

		Ptr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		Ptr<T>& operator=(const Ptr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		template<typename C>
		Ptr<T>& operator=(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			Dec();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const Ptr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const Ptr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const Ptr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const Ptr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const Ptr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const Ptr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

	template<typename T>
	class ComPtr
	{
	protected:
		vint*				counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				(*counter)++;
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(--(*counter)==0)
				{
					delete counter;
					reference->Release();
					counter=0;
					reference=0;
				}
			}
		}

		vint* Counter()const
		{
			return counter;
		}

		ComPtr(vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		ComPtr()
		{
			counter=0;
			reference=0;
		}

		ComPtr(T* pointer)
		{
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		ComPtr(const ComPtr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		~ComPtr()
		{
			Dec();
		}

		ComPtr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		ComPtr<T>& operator=(const ComPtr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const ComPtr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const ComPtr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const ComPtr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const ComPtr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const ComPtr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const ComPtr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

	template<typename T>
	struct KeyType<Ptr<T>>
	{
		typedef T* Type;
	};

	template<typename T>
	struct POD<Ptr<T>>
	{
		static const bool Result=false;
	};

	template<typename T>
	struct KeyType<ComPtr<T>>
	{
		typedef T* Type;
	};

	template<typename T>
	struct POD<ComPtr<T>>
	{
		static const bool Result=false;
	};
}

#endif

/***********************************************************************
COMMON\SOURCE\FUNCTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Function

Classes:
	Func<function-type>									：函数对象

Functions:
	Curry :: (A->B) -> A -> B							：参数拆分
	Combine :: (A->B) -> (A->C) -> (B->C->D) -> (A->D)	：函数组合
	
本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/
#ifndef VCZH_FUNCTION
#define VCZH_FUNCTION
namespace vl
{
	template<typename T>
	class Func
	{
	};
 
/***********************************************************************
vl::Func<R()>
***********************************************************************/
	template<typename R >
	class Func<R()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)();
		public:
			StaticInvoker(R(*_function)())
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)();
			struct Content
			{
				C*			sender;
				R(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke()
			{
				return (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType();
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R()>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()()const
		{
			return invoker->Invoke();
		}
		bool operator==(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void()>
***********************************************************************/
	template< >
	class Func<void()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)();
		public:
			StaticInvoker(void(*_function)())
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)();
			struct Content
			{
				C*			sender;
				void(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke()
			{
				  (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType();
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void()>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()()const
		{
			  invoker->Invoke();
		}
		bool operator==(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0)>
***********************************************************************/
	template<typename R,typename T0>
	class Func<R(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0);
		public:
			StaticInvoker(R(*_function)(T0))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0)const
		{
			return invoker->Invoke(p0);
		}
		bool operator==(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0)>
***********************************************************************/
	template< typename T0>
	class Func<void(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0);
		public:
			StaticInvoker(void(*_function)(T0))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0)const
		{
			  invoker->Invoke(p0);
		}
		bool operator==(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1)>
***********************************************************************/
	template<typename R,typename T0,typename T1>
	class Func<R(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1);
		public:
			StaticInvoker(R(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1)const
		{
			return invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1)>
***********************************************************************/
	template< typename T0,typename T1>
	class Func<void(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1);
		public:
			StaticInvoker(void(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1)const
		{
			  invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2>
	class Func<R(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2)const
		{
			return invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2)>
***********************************************************************/
	template< typename T0,typename T1,typename T2>
	class Func<void(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2)const
		{
			  invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3>
	class Func<R(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			return invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3>
	class Func<void(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			  invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<R(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<void(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<R(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<void(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<R(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<void(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
	namespace function_lambda
	{
		template<typename T>
		struct LambdaRetriveType
		{
			typedef vint Type;
			typedef vint ResultType;
		};
 
		template<typename T>
		struct FunctionObjectRetriveType
		{
			typedef typename LambdaRetriveType<decltype(&T::operator())>::Type Type;
			typedef typename LambdaRetriveType<decltype(&T::operator())>::ResultType ResultType;
		};
 
/***********************************************************************
vl::Func<R()>
***********************************************************************/
 
		template<typename TObject, typename R >
		struct LambdaRetriveType<R (__thiscall TObject::*)()const>
		{
			typedef Func<R()> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R >
		struct LambdaRetriveType<R (__thiscall TObject::*)()>
		{
			typedef Func<R()> Type;
			typedef R ResultType;
		};
 
		template<typename R >
		struct FunctionObjectRetriveType<R(*)()>
		{
			typedef Func<R()> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0)const>
		{
			typedef Func<R(T0)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0)>
		{
			typedef Func<R(T0)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0>
		struct FunctionObjectRetriveType<R(*)(T0)>
		{
			typedef Func<R(T0)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1)const>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1)>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1>
		struct FunctionObjectRetriveType<R(*)(T0,T1)>
		{
			typedef Func<R(T0,T1)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2)const>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2)>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2)>
		{
			typedef Func<R(T0,T1,T2)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3)const>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3)>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3)>
		{
			typedef Func<R(T0,T1,T2,T3)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4)>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4)>
		{
			typedef Func<R(T0,T1,T2,T3,T4)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> Type;
			typedef R ResultType;
		};
 /***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)const>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R ResultType;
		};
 
		template<typename TObject, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct LambdaRetriveType<R (__thiscall TObject::*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R ResultType;
		};
 
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct FunctionObjectRetriveType<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> Type;
			typedef R ResultType;
		};
 
 
		template<typename T>
		typename LambdaRetriveType<decltype(&T::operator())>::Type Lambda(T functionObject)
		{
			return functionObject;
		}
		template<typename T>
		typename FunctionObjectRetriveType<T>::Type ConvertToFunction(T functionObject)
		{
			return functionObject;
		}
#define LAMBDA vl::function_lambda::Lambda
#define FUNCTION vl::function_lambda::ConvertToFunction
#define FUNCTION_TYPE(T) typename vl::function_lambda::FunctionObjectRetriveType<T>::Type
#define FUNCTION_RESULT_TYPE(T) typename vl::function_lambda::FunctionObjectRetriveType<T>::ResultType
	}
	namespace function_binding
	{
		template<typename T>
		struct Binding
		{
		};
		 
		template<typename T>
		struct CR{typedef const T& Type;};
		template<typename T>
		struct CR<T&>{typedef T& Type;};
		template<typename T>
		struct CR<const T>{typedef const T& Type;};
		template<typename T>
		struct CR<const T&>{typedef const T& Type;};
		 
		template<typename T>
		struct RCR{typedef T Type;};
		template<typename T>
		struct RCR<T&>{typedef T& Type;};
		template<typename T>
		struct RCR<const T>{typedef T Type;};
		template<typename T>
		struct RCR<const T&>{typedef T Type;};
		
 
/***********************************************************************
vl::function_binding::Binding<R(T0)>
***********************************************************************/
		template<typename R,typename T0>
		struct Binding<R(T0)>
		{
			typedef R FunctionType(T0);
			typedef R CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()()const
				{
					return target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0)>
***********************************************************************/
		template< typename T0>
		struct Binding<void(T0)>
		{
			typedef void FunctionType(T0);
			typedef void CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()()const
				{
					  target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1)>
***********************************************************************/
		template<typename R,typename T0,typename T1>
		struct Binding<R(T0,T1)>
		{
			typedef R FunctionType(T0,T1);
			typedef R CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1)const
				{
					return target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1)>
***********************************************************************/
		template< typename T0,typename T1>
		struct Binding<void(T0,T1)>
		{
			typedef void FunctionType(T0,T1);
			typedef void CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1)const
				{
					  target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2>
		struct Binding<R(T0,T1,T2)>
		{
			typedef R FunctionType(T0,T1,T2);
			typedef R CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2)const
				{
					return target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2)>
***********************************************************************/
		template< typename T0,typename T1,typename T2>
		struct Binding<void(T0,T1,T2)>
		{
			typedef void FunctionType(T0,T1,T2);
			typedef void CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2)const
				{
					  target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3>
		struct Binding<R(T0,T1,T2,T3)>
		{
			typedef R FunctionType(T0,T1,T2,T3);
			typedef R CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3)const
				{
					return target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3>
		struct Binding<void(T0,T1,T2,T3)>
		{
			typedef void FunctionType(T0,T1,T2,T3);
			typedef void CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3)const
				{
					  target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<R(T0,T1,T2,T3,T4)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4);
			typedef R CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					return target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<void(T0,T1,T2,T3,T4)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4);
			typedef void CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					  target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<R(T0,T1,T2,T3,T4,T5)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5);
			typedef R CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					return target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<void(T0,T1,T2,T3,T4,T5)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5);
			typedef void CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					  target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Binder(target, argument);
				}
			};
		};
 
	}
 
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(T* function)
	{
		return typename function_binding::Binding<T>::Currier(function);
	}
 
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(const Func<T>& function)
	{
		return typename function_binding::Binding<T>::Currier(function);
	}
 
	namespace function_combining
	{
		template<typename A, typename B, typename C>
		class Combining
		{
		};
 
/***********************************************************************
vl::function_combining::Combining<R1(), R2(), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R >
		class Combining<R1(), R2(), R(R1,R2)> : public Object
		{
		protected:
			Func<R1()>			function1;
			Func<R2()>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType();
			typedef R2 SecondFunctionType();
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType();
			Combining(const Func<R1()>& _function1, const Func<R2()>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()()const
			{
				return converter(function1(), function2());
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0), R2(T0), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0>
		class Combining<R1(T0), R2(T0), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0)>			function1;
			Func<R2(T0)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0);
			typedef R2 SecondFunctionType(T0);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0);
			Combining(const Func<R1(T0)>& _function1, const Func<R2(T0)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0)const
			{
				return converter(function1(p0), function2(p0));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1>
		class Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1)>			function1;
			Func<R2(T0,T1)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1);
			typedef R2 SecondFunctionType(T0,T1);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1);
			Combining(const Func<R1(T0,T1)>& _function1, const Func<R2(T0,T1)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1)const
			{
				return converter(function1(p0,p1), function2(p0,p1));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2>
		class Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2)>			function1;
			Func<R2(T0,T1,T2)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2);
			typedef R2 SecondFunctionType(T0,T1,T2);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2);
			Combining(const Func<R1(T0,T1,T2)>& _function1, const Func<R2(T0,T1,T2)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2)const
			{
				return converter(function1(p0,p1,p2), function2(p0,p1,p2));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3>
		class Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3)>			function1;
			Func<R2(T0,T1,T2,T3)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3);
			typedef R2 SecondFunctionType(T0,T1,T2,T3);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3);
			Combining(const Func<R1(T0,T1,T2,T3)>& _function1, const Func<R2(T0,T1,T2,T3)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
			{
				return converter(function1(p0,p1,p2,p3), function2(p0,p1,p2,p3));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		class Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4)>			function1;
			Func<R2(T0,T1,T2,T3,T4)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4);
			Combining(const Func<R1(T0,T1,T2,T3,T4)>& _function1, const Func<R2(T0,T1,T2,T3,T4)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
			{
				return converter(function1(p0,p1,p2,p3,p4), function2(p0,p1,p2,p3,p4));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		class Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5), function2(p0,p1,p2,p3,p4,p5));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6), function2(p0,p1,p2,p3,p4,p5,p6));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7), function2(p0,p1,p2,p3,p4,p5,p6,p7));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9));
			}
		};
	}
	template<typename F1, typename F2, typename C>
	Func<typename function_combining::Combining<F1, F2, C>::FinalFunctionType>
	Combine(Func<C> converter, Func<F1> function1, Func<F2> function2)
	{
		return function_combining::Combining<F1, F2, C>(function1, function2, converter);
	}
	template<typename T>
	Func<Func<T>(Func<T>,Func<T>)> Combiner(const Func<typename Func<T>::ResultType(typename Func<T>::ResultType,typename Func<T>::ResultType)>& converter)
	{
		typedef typename Func<T>::ResultType R;
		return Curry<Func<T>(Func<R(R,R)>,Func<T>,Func<T>)>(Combine)(converter);
	}
}
#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\PAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Pair

Classes:
	Pair<K, V>							：二元组
***********************************************************************/

#ifndef VCZH_COLLECTIONS_PAIR
#define VCZH_COLLECTIONS_PAIR


namespace vl
{
	namespace collections
	{
		template<typename K, typename V>
		class Pair
		{
		public:
			K				key;
			V				value;

			Pair()
			{
			}

			Pair(const K& _key, const V& _value)
			{
				key=_key;
				value=_value;
			}

			Pair(const Pair<K, V>& pair)
			{
				key=pair.key;
				value=pair.value;
			}

			vint CompareTo(const Pair<K, V>& pair)const
			{
				if(key<pair.key)
				{
					return -1;
				}
				else if(key>pair.key)
				{
					return 1;
				}
				else if(value<pair.value)
				{
					return -1;
				}
				else if(value>pair.value)
				{
					return 1;
				}
				else
				{
					return 0;
				}
			}

			bool operator==(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)==0;
			}

			bool operator!=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)!=0;
			}

			bool operator<(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<0;
			}

			bool operator<=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<=0;
			}

			bool operator>(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>0;
			}

			bool operator>=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>=0;
			}
		};
	}

	template<typename K, typename V>
	struct POD<collections::Pair<K, V>>
	{
		static const bool Result=POD<K>::Result && POD<V>::Result;
	};
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Interfaces

Interfaces:
	IEnumerator<T>									：枚举器
	IEnumerable<T>									：可枚举对象
***********************************************************************/

#ifndef VCZH_COLLECTIONS_INTERFACES
#define VCZH_COLLECTIONS_INTERFACES


namespace vl
{
	namespace collections
	{

/***********************************************************************
接口
***********************************************************************/

		template<typename T>
		class IEnumerator : public virtual Interface
		{
		public:
			virtual IEnumerator<T>*						Clone()const=0;
			virtual const T&							Current()const=0;
			virtual vint								Index()const=0;
			virtual bool								Next()=0;
			virtual void								Reset()=0;
		};

		template<typename T>
		class IEnumerable : public virtual Interface
		{
		public:
			typedef T									ElementType;

			virtual IEnumerator<T>*						CreateEnumerator()const=0;
		};

/***********************************************************************
随机存取
***********************************************************************/

		namespace randomaccess_internal
		{
			template<typename T>
			struct RandomAccessable
			{
				static const bool							CanRead = false;
				static const bool							CanResize = false;
			};

			template<typename T>
			struct RandomAccess
			{
				static vint GetCount(const T& t)
				{
					return t.Count();
				}

				static const typename T::ElementType& GetValue(const T& t, vint index)
				{
					return t.Get(index);
				}

				static void SetCount(T& t, vint count)
				{
					t.Resize(count);
				}

				static void SetValue(T& t, vint index, const typename T::ElementType& value)
				{
					t.Set(index, value);
				}

				static void AppendValue(T& t, const typename T::ElementType& value)
				{
					t.Add(value);
				}
			};
		}
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\LIST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::List

Classes:
	ListStore<T,PODType>				：列表存储复制算法
	ListBase<T,K>						：列表基类
	Array<T,K>							：数组
	List<T,K>							：列表
	SortedList<T,K>						：有序列表
***********************************************************************/

#ifndef VCZH_COLLECTIONS_LIST
#define VCZH_COLLECTIONS_LIST

#include <string.h>

namespace vl
{
	namespace collections
	{

/***********************************************************************
储存结构
***********************************************************************/

		template<typename T, bool PODType>
		class ListStore abstract : public Object
		{
		};
		
		template<typename T>
		class ListStore<T, false> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(dest<source)
				{
					for(vint i=0;i<count;i++)
					{
						dest[i]=source[i];
					}
				}
				else if(dest>source)
				{
					for(vint i=count-1;i>=0;i--)
					{
						dest[i]=source[i];
					}
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
				for(vint i=0;i<count;i++)
				{
					dest[i]=T();
				}
			}
		public:
		};
		
		template<typename T>
		class ListStore<T, true> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(count)
				{
					memmove(dest, source, sizeof(T)*count);
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
			}
		public:
		};
		
		template<typename T>
		class ArrayBase abstract : public ListStore<T,POD<T>::Result>, public virtual IEnumerable<T>
		{
		protected:
			class Enumerator : public Object, public virtual IEnumerator<T>
			{
			private:
				const ArrayBase<T>*				container;
				vint							index;

			public:
				Enumerator(const ArrayBase<T>* _container, vint _index=-1)
				{
					container=_container;
					index=_index;
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(container, index);
				}

				const T& Current()const
				{
					return container->Get(index);
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					return index>=0 && index<container->Count();
				}

				void Reset()
				{
					index=-1;
				}
			};
			
			T*						buffer;
			vint					count;
		public:
			ArrayBase()
				:buffer(0)
				,count(0)
			{
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			vint Count()const
			{
				return count;
			}

			const T& Get(vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ArrayBase<T, K>::Get(vint)#参数越界。");
				return buffer[index];
			}

			const T& operator[](vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ArrayBase<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class ListBase abstract : public ArrayBase<T>
		{
		protected:
			vint					capacity;
			bool					lessMemoryMode;

			vint CalculateCapacity(vint expected)
			{
				vint result=capacity;
				while(result<expected)
				{
					result=result*5/4+1;
				}
				return result;
			}

			void MakeRoom(vint index, vint _count)
			{
				vint newCount=count+_count;
				if(newCount>capacity)
				{
					vint newCapacity=CalculateCapacity(newCount);
					T* newBuffer=new T[newCapacity];
					CopyObjects(newBuffer, buffer, index);
					CopyObjects(newBuffer+index+_count, buffer+index, count-index);
					delete[] buffer;
					capacity=newCapacity;
					buffer=newBuffer;
				}
				else
				{
					CopyObjects(buffer+index+_count, buffer+index, count-index);
				}
				count=newCount;
			}

			void ReleaseUnnecessaryBuffer(vint previousCount)
			{
				if(buffer && count<previousCount)
				{
					ClearObjects(&buffer[count], previousCount-count);
				}
				if(lessMemoryMode && count<=capacity/2)
				{
					vint newCapacity=capacity*5/8;
					if(count<newCapacity)
					{
						T* newBuffer=new T[newCapacity];
						CopyObjects(newBuffer, buffer, count);
						delete[] buffer;
						capacity=newCapacity;
						buffer=newBuffer;
					}
				}
			}
		public:
			ListBase()
			{
				count=0;
				capacity=0;
				buffer=0;
				lessMemoryMode=true;
			}

			~ListBase()
			{
				delete[] buffer;
			}

			void SetLessMemoryMode(bool mode)
			{
				lessMemoryMode=mode;
			}

			bool RemoveAt(vint index)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::RemoveAt(vint)#参数index越界。");
				CopyObjects(buffer+index,buffer+index+1,count-index-1);
				count--;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool RemoveRange(vint index, vint _count)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<=count, L"ListBase<T, K>::RemoveRange(vint, vint)#参数index越界。");
				CHECK_ERROR(index+_count>=0 && index+_count<=count, L"ListBase<T,K>::RemoveRange(vint, vint)#参数_count越界。");
				CopyObjects(buffer+index, buffer+index+_count, count-index-_count);
				count-=_count;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool Clear()
			{
				vint previousCount=count;
				count=0;
				if(lessMemoryMode)
				{
					capacity=0;
					delete[] buffer;
					buffer=0;
				}
				else
				{
					ReleaseUnnecessaryBuffer(previousCount);
				}
				return true;
			}
		};

/***********************************************************************
列表对象
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class Array : public ArrayBase<T>
		{
		protected:
			void Create(vint size)
			{
				if(size>0)
				{
					count=size;
					buffer=new T[size];
				}
				else
				{
					count=0;
					buffer=0;
				}
			}

			void Destroy()
			{
				count=0;
				delete[] buffer;
				buffer=0;
			}
		public:
			Array(vint size=0)
			{
				Create(size);
			}

			Array(const T* _buffer, vint size)
			{
				Create(size);
				CopyObjects(buffer, _buffer, size);
			}

			~Array()
			{
				Destroy();
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			void Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
			}

			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			void Resize(vint size)
			{
				vint oldCount=count;
				T* oldBuffer=buffer;
				Create(size);
				CopyObjects(buffer, oldBuffer, (count<oldCount?count:oldCount));
				delete[] oldBuffer;
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class List : public ListBase<T, K>
		{
		public:
			List()
			{
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			vint Add(const T& item)
			{
				MakeRoom(count, 1);
				buffer[count-1]=item;
				return count-1;
			}

			vint Insert(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<=count, L"List<T, K>::Insert(vint, const T&)#参数index越界。");
				MakeRoom(index,1);
				buffer[index]=item;
				return index;
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
				return true;
			}

			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class SortedList : public ListBase<T, K>
		{
		public:
			SortedList()
			{
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			template<typename Key>
			vint IndexOf(const Key& item)const
			{
				vint start=0;
				vint end=count-1;
				while(start<=end)
				{
					vint index=(start+end)/2;
					if(buffer[index]==item)
					{
						return index;
					}
					else if(buffer[index]>item)
					{
						end=index-1;
					}
					else
					{
						start=index+1;
					}
				}
				return -1;
			}

			vint IndexOf(const K& item)const
			{
				return IndexOf<K>(item);
			}

			vint Add(const T& item)
			{
				if(count==0)
				{
					MakeRoom(0, 1);
					buffer[0]=item;
					return 0;
				}
				else
				{
					vint start=0;
					vint end=count-1;
					vint index=-1;
					while(start<=end)
					{
						index=(start+end)/2;
						if(buffer[index]==item)
						{
							goto SORTED_LIST_INSERT;
						}
						else if(buffer[index]>item)
						{
							end=index-1;
						}
						else
						{
							start=index+1;
						}
					}
					CHECK_ERROR(index>=0 && index<count, L"SortedList<T, K>::Add(const T&)#内部错误，变量index越界");
					if(buffer[index]<item)
					{
						index++;
					}
SORTED_LIST_INSERT:
					MakeRoom(index, 1);
					buffer[index]=item;
					return index;
				}
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}
		};

/***********************************************************************
随机访问
***********************************************************************/

		namespace randomaccess_internal
		{
			template<typename T, typename K>
			struct RandomAccessable<Array<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = true;
			};

			template<typename T, typename K>
			struct RandomAccessable<List<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};

			template<typename T, typename K>
			struct RandomAccessable<SortedList<T, K>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\DICTIONARY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Dictionary

Classes:
	Dictionary<KT, VT, KK, VK>					：映射
	Group<KT, VT, KK, VK>						：多重映射
***********************************************************************/

#ifndef VCZH_COLLECTIONS_DICTIONARY
#define VCZH_COLLECTIONS_DICTIONARY


namespace vl
{
	namespace collections
	{
		template<
			typename KT,
			typename VT,
			typename KK=typename KeyType<KT>::Type, 
			typename VK=typename KeyType<VT>::Type
		>
		class Dictionary : public Object, public virtual IEnumerable<Pair<KT, VT>>
		{
			typedef SortedList<KT, KK>			KeyContainer;
			typedef List<VT, VK>				ValueContainer;
		protected:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const Dictionary<KT, VT, KK, VK>*	container;
				vint								index;
				Pair<KT, VT>						current;

				void UpdateCurrent()
				{
					if(index<container->Count())
					{
						current.key=container->Keys().Get(index);
						current.value=container->Values().Get(index);
					}
				}
			public:
				Enumerator(const Dictionary<KT, VT, KK, VK>* _container, vint _index=-1)
				{
					container=_container;
					index=_index;
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, index);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					UpdateCurrent();
					return index>=0 && index<container->Count();
				}

				void Reset()
				{
					index=-1;
					UpdateCurrent();
				}
			};

			KeyContainer						keys;
			ValueContainer						values;
		public:
			Dictionary()
			{
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			void SetLessMemoryMode(bool mode)
			{
				keys.SetLessMemoryMode(mode);
				values.SetLessMemoryMode(mode);
			}

			const KeyContainer& Keys()const
			{
				return keys;
			}

			const ValueContainer& Values()const
			{
				return values;
			}

			vint Count()const
			{
				return keys.Count();
			}

			const VT& Get(const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			const VT& operator[](const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			bool Set(const KK& key, const VT& value)
			{
				vint index=keys.IndexOf(key);
				if(index==-1)
				{
					index=keys.Add(key);
					values.Insert(index, value);
				}
				else
				{
					values[index]=value;
				}
				return true;
			}

			bool Add(const Pair<KT, VT>& value)
			{
				return Add(value.key, value.value);
			}

			bool Add(const KT& key, const VT& value)
			{
				CHECK_ERROR(!keys.Contains(key), L"Dictionary<KT, KK, ValueContainer, VT, VK>::Add(const KT&, const VT&)#key已存在。");
				vint index=keys.Add(key);
				values.Insert(index, value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					values.RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				keys.Clear();
				values.Clear();
				return true;
			}
		};

		template<
			typename KT,
			typename VT,
			typename KK=typename KeyType<KT>::Type,
			typename VK=typename KeyType<VT>::Type
		>
		class Group : public Object, public virtual IEnumerable<Pair<KT, VT>>
		{
			typedef SortedList<KT, KK>		KeyContainer;
			typedef List<VT, VK>			ValueContainer;
		protected:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const Group<KT, VT, KK, VK>*		container;
				vint								keyIndex;
				vint								valueIndex;
				Pair<KT, VT>						current;

				void UpdateCurrent()
				{
					if(keyIndex<container->Count())
					{
						const ValueContainer& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							current.key=container->Keys().Get(keyIndex);
							current.value=values.Get(valueIndex);
						}
					}
				}
			public:
				Enumerator(const Group<KT, VT, KK, VK>* _container, vint _keyIndex=-1, vint _valueIndex=-1)
				{
					container=_container;
					keyIndex=_keyIndex;
					valueIndex=_valueIndex;
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, keyIndex, valueIndex);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					if(0<=keyIndex && keyIndex<container->Count())
					{
						vint index=0;
						for(vint i=0;i<keyIndex;i++)
						{
							index+=container->GetByIndex(i).Count();
						}
						return index+valueIndex;
					}
					else
					{
						return -1;
					}
				}

				bool Next()
				{
					if(keyIndex==-1)
					{
						keyIndex=0;
					}
					while(keyIndex<container->Count())
					{
						valueIndex++;
						const ValueContainer& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							UpdateCurrent();
							return true;
						}
						else
						{
							keyIndex++;
							valueIndex=-1;
						}
					}
					return false;
				}

				void Reset()
				{
					keyIndex=-1;
					valueIndex=-1;
					UpdateCurrent();
				}
			};

			KeyContainer					keys;
			List<ValueContainer*>			values;
		public:
			Group()
			{
			}

			~Group()
			{
				Clear();
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			const KeyContainer& Keys()const
			{
				return keys;
			}

			vint Count()const
			{
				return keys.Count();
			}

			const ValueContainer& Get(const KK& key)const
			{
				return *values.Get(keys.IndexOf(key));
			}

			const ValueContainer& GetByIndex(vint index)const
			{
				return *values.Get(index);
			}

			const ValueContainer& operator[](const KK& key)const
			{
				return *values.Get(keys.IndexOf(key));
			}

			bool Contains(const KK& key)const
			{
				return keys.Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					return values.Get(index)->Contains(value);
				}
				else
				{
					return false;
				}
			}

			bool Add(const Pair<KT, VT>& value)
			{
				return Add(value.key, value.value);
			}

			bool Add(const KT& key, const VT& value)
			{
				ValueContainer* target=0;
				vint index=keys.IndexOf(key);
				if(index==-1)
				{
					target=new ValueContainer;
					values.Insert(keys.Add(key), target);
				}
				else
				{
					target=values[index];
				}
				target->Add(value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					List<VT, VK>* target=values[index];
					values.RemoveAt(index);
					delete target;
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Remove(const KK& key, const VK& value)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					List<VT, VK>* target=values[index];
					target->Remove(value);
					if(target->Count()==0)
					{
						keys.RemoveAt(index);
						values.RemoveAt(index);
						delete target;
					}
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				for(vint i=0;i<values.Count();i++)
				{
					delete values[i];
				}
				keys.Clear();
				values.Clear();
				return true;
			}
		};

/***********************************************************************
随机访问
***********************************************************************/
		namespace randomaccess_internal
		{
			template<typename KT, typename VT, typename KK, typename VK>
			struct RandomAccessable<Dictionary<KT, VT, KK, VK>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		
			template<typename KT, typename VT, typename KK, typename VK>
			struct RandomAccess<Dictionary<KT, VT, KK, VK>>
			{
				static vint GetCount(const Dictionary<KT, VT, KK, VK>& t)
				{
					return t.Count();
				}

				static Pair<KT, VT> GetValue(const Dictionary<KT, VT, KK, VK>& t, vint index)
				{
					return Pair<KT, VT>(t.Keys().Get(index), t.Values().Get(index));
				}

				static void AppendValue(Dictionary<KT, VT, KK, VK>& t, const Pair<KT, VT>& value)
				{
					t.Set(value.key, value.value);
				}
			};
		}
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONCOPYFROM.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONCOPYFROM
#define VCZH_COLLECTIONS_OPERATIONCOPYFROM


namespace vl
{
	namespace collections
	{

/***********************************************************************
容器复制
***********************************************************************/

		namespace copyfrom_internal
		{
			using namespace randomaccess_internal;

			template<typename Ds, typename Ss, bool DsRA, bool SsRA>
			struct CopyFromAlgorithm
			{
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, true, true>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					vint copyCount=RandomAccess<Ss>::GetCount(ss);
					vint index=(append?RandomAccess<Ds>::GetCount(ds):0);
					vint resizeCount=index+copyCount;
					RandomAccess<Ds>::SetCount(ds, resizeCount);
					for(vint i=0;i<copyCount;i++)
					{
						RandomAccess<Ds>::SetValue(ds, index+i, RandomAccess<Ss>::GetValue(ss, i));
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, false, true>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					if(!append)
					{
						ds.Clear();
					}
					vint copyCount=RandomAccess<Ss>::GetCount(ss);
					for(vint i=0;i<copyCount;i++)
					{
						RandomAccess<Ds>::AppendValue(ds, RandomAccess<Ss>::GetValue(ss, i));
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, true, false>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					Ptr<IEnumerator<typename Ss::ElementType>> enumerator;
					vint copyCount=0;

					enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						copyCount++;
					}

					vint index=(append?RandomAccess<Ds>::GetCount(ds):0);
					vint resizeCount=index+copyCount;
					RandomAccess<Ds>::SetCount(ds, resizeCount);

					enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						RandomAccess<Ds>::SetValue(ds, index++, enumerator->Current());
					}
				}
			};

			template<typename Ds, typename Ss>
			struct CopyFromAlgorithm<Ds, Ss, false, false>
			{
				static void Perform(Ds& ds, const Ss& ss, bool append)
				{
					if(!append)
					{
						ds.Clear();
					}
					Ptr<IEnumerator<typename Ss::ElementType>> enumerator=ss.CreateEnumerator();
					while(enumerator->Next())
					{
						RandomAccess<Ds>::AppendValue(ds, enumerator->Current());
					}
				}
			};

			template<typename T>
			struct Slice
			{
				const T*	items;
				vint		count;
			};
		}

		namespace randomaccess_internal
		{
			template<typename T>
			struct RandomAccessable<copyfrom_internal::Slice<T>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = true;
			};
		
			template<typename T>
			struct RandomAccess<copyfrom_internal::Slice<T>>
			{
				static vint GetCount(const copyfrom_internal::Slice<T>& t)
				{
					return t.count;
				}

				static const T& GetValue(const copyfrom_internal::Slice<T>& t, vint index)
				{
					return t.items[index];
				}
			};
		}

		template<typename Ds, typename Ss>
		void CopyFrom(Ds& ds, const Ss& ss, bool append=false)
		{
			copyfrom_internal::CopyFromAlgorithm<Ds, Ss, randomaccess_internal::RandomAccessable<Ds>::CanResize, randomaccess_internal::RandomAccessable<Ss>::CanRead>::Perform(ds, ss, append);
		}

		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const S* buffer, vint count, bool append=false)
		{
			copyfrom_internal::Slice<S> slice={buffer, count};
			CopyFrom(ds, slice, append);
		}

		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const S* begin, const S* end, bool append=false)
		{
			copyfrom_internal::Slice<S> slice={begin, end-begin};
			CopyFrom(ds, slice, append);
		}
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONENUMERABLE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONENUMERABLE
#define VCZH_COLLECTIONS_OPERATIONENUMERABLE


namespace vl
{
	namespace collections
	{

		template<typename T>
		class Enumerable;

/***********************************************************************
空迭代器
***********************************************************************/

		template<typename T>
		class EmptyEnumerable : public Object, public IEnumerable<T>
		{
			friend class Enumerable<T>;
		private:
			class Enumerator : public Object, public IEnumerator<T>
			{
				IEnumerator<T>* Clone()const
				{
					return new Enumerator;
				}

				const T& Current()const
				{
					return *(T*)0;
				}

				vint Index()const
				{
					return -1;
				}

				bool Next()
				{
					return false;
				}

				void Reset()
				{
				}
			};
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator;
			}
		};

/***********************************************************************
自包含迭代器
***********************************************************************/

		template<typename T, typename TContainer>
		class ContainerEnumerator : public Object, public virtual IEnumerator<T>
		{
		private:
			Ptr<TContainer>					container;
			vint							index;

		public:
			ContainerEnumerator(Ptr<TContainer> _container, vint _index=-1)
			{
				container=_container;
				index=_index;
			}

			IEnumerator<T>* Clone()const
			{
				return new ContainerEnumerator(container, index);
			}

			const T& Current()const
			{
				return container->Get(index);
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				index++;
				return index>=0 && index<container->Count();
			}

			void Reset()
			{
				index=-1;
			}
		};

/***********************************************************************
迭代器比较
***********************************************************************/

		template<typename T, typename U>
		vint CompareEnumerable(const IEnumerable<T>& a, const IEnumerable<U>& b)
		{
			Ptr<IEnumerator<T>> ator=a.CreateEnumerator();
			Ptr<IEnumerator<U>> btor=b.CreateEnumerator();
			while()
			{
				bool a=ator->Next();
				bool b=btor->Next();
				if(a&&!b) return 1;
				if(!a&&b) return -1;
				if(!a&&!b) break;

				const T& ac=ator->Current();
				const U& bc=btor->Current();
				if(ac<bc)
				{
					return -1;
				}
				else if(ac>bc)
				{
					return 1;
				}
				ator->Next();
				btor->Next();
			}
			return 0;
		}
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONSELECT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSELECT
#define VCZH_COLLECTIONS_OPERATIONSELECT


namespace vl
{
	namespace collections
	{

/***********************************************************************
Select
***********************************************************************/

		template<typename T, typename K>
		class SelectEnumerator : public virtual IEnumerator<K>
		{
		protected:
			IEnumerator<T>*		enumerator;
			Func<K(T)>			selector;
			K					current;
		public:
			SelectEnumerator(IEnumerator<T>* _enumerator, const Func<K(T)>& _selector)
				:enumerator(_enumerator)
				,selector(_selector)
			{
			}

			~SelectEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<K>* Clone()const
			{
				return new SelectEnumerator(enumerator->Clone(), selector);
			}

			const K& Current()const
			{
				return current;
			}

			vint Index()const
			{
				return enumerator->Index();
			}

			bool Next()
			{
				if(enumerator->Next())
				{
					current=selector(enumerator->Current());
					return true;
				}
				else
				{
					return false;
				}
			}

			void Reset()
			{
				enumerator->Reset();
			}
		};
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONWHERE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONWHERE
#define VCZH_COLLECTIONS_OPERATIONWHERE


namespace vl
{
	namespace collections
	{
/***********************************************************************
Where
***********************************************************************/

		template<typename T>
		class WhereEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			Func<bool(T)>			selector;
			vint					index;

		public:
			WhereEnumerator(IEnumerator<T>* _enumerator, const Func<bool(T)>& _selector, vint _index=-1)
				:enumerator(_enumerator)
				,selector(_selector)
				,index(_index)
			{
			}

			~WhereEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new WhereEnumerator(enumerator->Clone(), selector, index);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				while(enumerator->Next())
				{
					if(selector(enumerator->Current()))
					{
						index++;
						return true;
					}
				}
				return false;
			}

			void Reset()
			{
				enumerator->Reset();
			}
		};
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONCONCAT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONCONCAT
#define VCZH_COLLECTIONS_OPERATIONCONCAT


namespace vl
{
	namespace collections
	{

/***********************************************************************
Concat
***********************************************************************/

		template<typename T>
		class ConcatEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*					enumerator1;
			IEnumerator<T>*					enumerator2;
			vint							index;
			bool							turned;
		public:
			ConcatEnumerator(IEnumerator<T>* _enumerator1, IEnumerator<T>* _enumerator2, vint _index=-1, bool _turned=false)
				:enumerator1(_enumerator1)
				,enumerator2(_enumerator2)
				,index(_index)
				,turned(_turned)
			{
			}

			~ConcatEnumerator()
			{
				delete enumerator1;
				delete enumerator2;
			}

			IEnumerator<T>* Clone()const
			{
				return new ConcatEnumerator(enumerator1->Clone(), enumerator2->Clone(), index, turned);
			}

			const T& Current()const
			{
				if(turned)
				{
					return enumerator2->Current();
				}
				else
				{
					return enumerator1->Current();
				}
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				index++;
				if(turned)
				{
					return enumerator2->Next();
				}
				else
				{
					if(enumerator1->Next())
					{
						return true;
					}
					else
					{
						turned=true;
						return enumerator2->Next();
					}
				}
			}

			void Reset()
			{
				enumerator1->Reset();
				enumerator2->Reset();
				index=-1;
			}
		};
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONSEQUENCE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSEQUENCE
#define VCZH_COLLECTIONS_OPERATIONSEQUENCE


namespace vl
{
	namespace collections
	{

/***********************************************************************
Take
***********************************************************************/

		template<typename T>
		class TakeEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
		public:
			TakeEnumerator(IEnumerator<T>* _enumerator, vint _count)
				:enumerator(_enumerator)
				,count(_count)
			{
			}

			~TakeEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new TakeEnumerator(enumerator->Clone(), count);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return enumerator->Index();
			}

			bool Next()
			{
				if(enumerator->Index()>=count-1) return false;
				return enumerator->Next();
			}

			void Reset()
			{
				enumerator->Reset();
			}
		};

/***********************************************************************
Skip
***********************************************************************/

		template<typename T>
		class SkipEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
		public:
			SkipEnumerator(IEnumerator<T>* _enumerator, vint _count, bool runSkip=true)
				:enumerator(_enumerator)
				,count(_count)
			{
				if(runSkip)
				{
					for(vint i=0;i<count;i++)
					{
						enumerator->Next();
					}
				}
			}

			~SkipEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new SkipEnumerator(enumerator->Clone(), count, false);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return enumerator->Index()-count;
			}

			bool Next()
			{
				return enumerator->Next();
			}

			void Reset()
			{
				enumerator->Reset();
				for(vint i=0;i<count;i++)
				{
					enumerator->Next();
				}
			}
		};

/***********************************************************************
Repeat
***********************************************************************/

		template<typename T>
		class RepeatEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*			enumerator;
			vint					count;
			vint					index;
			vint					repeatedCount;
		public:
			RepeatEnumerator(IEnumerator<T>* _enumerator, vint _count, vint _index=-1, vint _repeatedCount=0)
				:enumerator(_enumerator)
				,count(_count)
				,index(_index)
				,repeatedCount(_repeatedCount)
			{
			}

			~RepeatEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new RepeatEnumerator(enumerator->Clone(), count, index, repeatedCount);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				while(repeatedCount<count)
				{
					if(enumerator->Next())
					{
						index++;
						return true;
					}
					repeatedCount++;
					enumerator->Reset();
				}
				return false;
			}

			void Reset()
			{
				enumerator->Reset();
				index=-1;
				repeatedCount=0;
			}
		};

/***********************************************************************
Distinct
***********************************************************************/

		template<typename T>
		class DistinctEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*		enumerator;
			SortedList<T>		distinct;
			T					lastValue;

		public:
			DistinctEnumerator(IEnumerator<T>* _enumerator)
				:enumerator(_enumerator)
			{
			}

			DistinctEnumerator(const DistinctEnumerator& _enumerator)
			{
				enumerator=_enumerator.enumerator->Clone();
				CopyFrom(distinct, _enumerator.distinct);
			}

			~DistinctEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new DistinctEnumerator(*this);
			}

			const T& Current()const
			{
				return lastValue;
			}

			vint Index()const
			{
				return distinct.Count()-1;
			}

			bool Next()
			{
				while(enumerator->Next())
				{
					const T& current=enumerator->Current();
					if(!distinct.Contains(current))
					{
						lastValue=current;
						distinct.Add(current);
						return true;
					}
				}
				return false;
			}

			void Reset()
			{
				enumerator->Reset();
				distinct.Clear();
			}
		};

/***********************************************************************
Reverse
***********************************************************************/

		template<typename T>
		class ReverseEnumerator : public virtual IEnumerator<T>
		{
		protected:
			List<T>						cache;
			vint						index;
		public:
			ReverseEnumerator(const IEnumerable<T>& enumerable)
				:index(-1)
			{
				CopyFrom(cache, enumerable);
			}

			ReverseEnumerator(const ReverseEnumerator& _enumerator)
			{
				CopyFrom(cache, _enumerator.cache);
				index=_enumerator.index;
			}

			~ReverseEnumerator()
			{
			}

			IEnumerator<T>* Clone()const
			{
				return new ReverseEnumerator(*this);
			}

			const T& Current()const
			{
				return cache.Get(cache.Count()-1-index);
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				index++;
				return index<cache.Count();
			}

			void Reset()
			{
				index=0;
			}
		};

/***********************************************************************
FromIterator
***********************************************************************/

		template<typename T, typename I>
		class FromIteratorEnumerable : public Object, public IEnumerable<T>
		{
			friend class Enumerable<T>;
		private:
			class Enumerator : public Object, public IEnumerator<T>
			{
			private:
				I				begin;
				I				end;
				I				current;

			public:
				Enumerator(I _begin, I _end, I _current)
					:begin(_begin)
					,end(_end)
					,current(_current)
				{
				}

				IEnumerator<T>* Clone()const
				{
					return new Enumerator(begin, end, current);
				}

				const T& Current()const
				{
					return *current;
				}

				vint Index()const
				{
					return current-begin;
				}

				bool Next()
				{
					current++;
					return begin<=current && current<end;
				}

				void Reset()
				{
					current=begin-1;
				}
			};
		private:
			I					begin;
			I					end;
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new Enumerator(begin, end, begin-1);
			}

			FromIteratorEnumerable(I _begin, I _end)
				:begin(_begin)
				,end(_end)
			{
			}
		};

		template<typename T>
		class FromIterator
		{
		public:
			template<typename I>
			static FromIteratorEnumerable<T, I> Wrap(I begin, I end)
			{
				return FromIteratorEnumerable<T, I>(begin, end);
			}
		};

		template<typename T>
		FromIteratorEnumerable<T, T*> FromPointer(T* begin, T* end)
		{
			return FromIteratorEnumerable<T, T*>(begin, end);
		}

		template<typename T, int size>
		FromIteratorEnumerable<T, T*> FromArray(T (&items)[size])
		{
			return FromIteratorEnumerable<T, T*>(&items[0], &items[size]);
		}
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONSET.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSET
#define VCZH_COLLECTIONS_OPERATIONSET


namespace vl
{
	namespace collections
	{

/***********************************************************************
Intersect/Except
***********************************************************************/

		template<typename T, bool Intersect>
		class IntersectExceptEnumerator : public virtual IEnumerator<T>
		{
		protected:
			IEnumerator<T>*				enumerator;
			SortedList<T>				reference;
			vint						index;

		public:
			IntersectExceptEnumerator(IEnumerator<T>* _enumerator, const IEnumerable<T>& _reference)
				:enumerator(_enumerator)
				,index(-1)
			{
				CopyFrom(reference, _reference);
			}

			IntersectExceptEnumerator(const IntersectExceptEnumerator& _enumerator)
			{
				enumerator=_enumerator.enumerator->Clone();
				CopyFrom(reference, _enumerator.reference);
				index=_enumerator.index;
			}

			~IntersectExceptEnumerator()
			{
				delete enumerator;
			}

			IEnumerator<T>* Clone()const
			{
				return new IntersectExceptEnumerator(*this);
			}

			const T& Current()const
			{
				return enumerator->Current();
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				while(enumerator->Next())
				{
					if(reference.Contains(enumerator->Current())==Intersect)
					{
						index++;
						return true;
					}
				}
				return false;
			}

			void Reset()
			{
				enumerator->Reset();
				index=0;
			}
		};
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONPAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONPAIR
#define VCZH_COLLECTIONS_OPERATIONPAIR


namespace vl
{
	namespace collections
	{

/***********************************************************************
Pairwise
***********************************************************************/

		template<typename S, typename T>
		class PairwiseEnumerator : public virtual IEnumerator<Pair<S, T>>
		{
		protected:
			IEnumerator<S>*					enumerator1;
			IEnumerator<T>*					enumerator2;
			Pair<S, T>						current;
		public:
			PairwiseEnumerator(IEnumerator<S>* _enumerator1, IEnumerator<T>* _enumerator2)
				:enumerator1(_enumerator1)
				,enumerator2(_enumerator2)
			{
			}

			~PairwiseEnumerator()
			{
				delete enumerator1;
				delete enumerator2;
			}

			IEnumerator<Pair<S, T>>* Clone()const
			{
				return new PairwiseEnumerator(enumerator1->Clone(), enumerator2->Clone());
			}

			const Pair<S, T>& Current()const
			{
				return current;
			}

			vint Index()const
			{
				return enumerator1->Index();
			}

			bool Next()
			{
				if(enumerator1->Next() && enumerator2->Next())
				{
					current=Pair<S, T>(enumerator1->Current(), enumerator2->Current());
					return true;
				}
				else
				{
					return false;
				}
			}

			void Reset()
			{
				enumerator1->Reset();
				enumerator2->Reset();
			}
		};
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONSTRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATIONSTRING
#define VCZH_COLLECTIONS_OPERATIONSTRING


namespace vl
{
	namespace collections
	{
		template<typename Ds, typename S>
		void CopyFrom(Ds& ds, const ObjectString<S>& ss, bool append=false)
		{
			const S* buffer=ss.Buffer();
			vint count=ss.Length();
			CopyFrom(ds, buffer, count, append);
		}

		template<typename D, typename Ss>
		void CopyFrom(ObjectString<D>& ds, const Ss& ss, bool append=false)
		{
			Array<D> da(ds.Buffer(), ds.Length());
			CopyFrom(da, ss, append);
			if(da.Count()==0)
			{
				ds=ObjectString<D>();
			}
			else
			{
				ds=ObjectString<D>(&da[0], da.Count());
			}
		}
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATIONFOREACH.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

扩展：
	实现一个函数重载IteratorType CreateForEachIterator(const CollectionType& collection);
	CollectionType是所需要的容器类型
	IteratorType继承自ForEachIterator<T>
	必须写在vl::collections命名空间里
***********************************************************************/

#ifndef VCZH_COLLECTIONS_FOREACH
#define VCZH_COLLECTIONS_FOREACH

namespace vl
{
	namespace collections
	{

/***********************************************************************
ForEach基础设施
***********************************************************************/

		template<typename T>
		class ForEachIterator : public Object
		{
		public:
			virtual bool				Next(T& variable)const=0;

			operator bool()const
			{
				return true;
			}
		};

/***********************************************************************
IEnumerable<T>支持
***********************************************************************/

		template<typename T>
		class EnumerableForEachIterator : public ForEachIterator<T>
		{
		protected:
			Ptr<IEnumerator<T>>			enumerator;
		public:
			EnumerableForEachIterator(const IEnumerable<T>& enumerable)
				:enumerator(enumerable.CreateEnumerator())
			{
			}

			EnumerableForEachIterator(const EnumerableForEachIterator<T>& enumerableIterator)
				:enumerator(enumerableIterator.iterator)
			{
			}

			bool Next(T& variable)const
			{
				if(enumerator->Next())
				{
					variable=enumerator->Current();
					return true;
				}
				else
				{
					return false;
				}
			}
		};

		template<typename T>
		EnumerableForEachIterator<T> CreateForEachIterator(const IEnumerable<T>& enumerable)
		{
			return enumerable;
		}

/***********************************************************************
ForEach宏
***********************************************************************/

#define SCOPE_VARIABLE(TYPE, VARIABLE, VALUE)\
		if(bool __scope_variable_flag__=true)\
			for(TYPE VARIABLE = VALUE;__scope_variable_flag__;__scope_variable_flag__=false)

#define FOREACH(TYPE, VARIABLE, COLLECTION)\
		SCOPE_VARIABLE(const ForEachIterator<TYPE>&, __foreach_iterator__, CreateForEachIterator(COLLECTION))\
		for(TYPE VARIABLE;__foreach_iterator__.Next(VARIABLE);)

#define FOREACH_INDEXER(TYPE, VARIABLE, INDEXER, COLLECTION)\
		SCOPE_VARIABLE(const ForEachIterator<TYPE>&, __foreach_iterator__, CreateForEachIterator(COLLECTION))\
		SCOPE_VARIABLE(vint, INDEXER, 0)\
		for(TYPE VARIABLE;__foreach_iterator__.Next(VARIABLE);INDEXER++)
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\COLLECTIONS\OPERATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Operations

Functions:
	CopyFrom(TargetContainer, SourceContainer)
	[T]		.Select(T->K) => [K]
	[T]		.SelectMany(T->[K]) => [K]
	[T]		.Where(T->bool) => [T]
	[Ptr<T>].Cast<K>() => [Ptr<K>]
	[Ptr<T>].FindType<K>() => [Ptr<K>]
	[T]		.OrderBy(T->T->int) => [T]

	[T]		.Aggregate(T->T->T) => T
	[T]		.Aggregate(T->T->T, T) => T
	[T]		.All(T->bool) => bool
	[T]		.Any(T->bool) => bool
	[T]		.Max() => T
	[T]		.Min() => T
	[T]		.First() => T
	[T]		.FirstOrDefault(T) => T
	[T]		.Last() => T
	[T]		.LastOrDefault(T) => T
	[T]		.Count() => vint
	[T]		.IsEmpty() => bool

	[T]		.Concat([T]) => [T]
	[T]		.Repeat(vint) => [T]
	[T]		.Take(vint) => [T]
	[T]		.Skip(vint) => [T]
	[T]		.Distinct() => [T]
	[T]		.Reverse() => [T]

	[T]		.Pairwise([K]) => [(T,K)]
	[T]		.Intersect([T]) => [T]
	[T]		.Union([T]) => [T]
	[T]		.Except([T]) => [T]

	From(begin, end) => [T]
	From(array) => [T]

	FOREACH(X, a, XList)
	FOREACH_INDEXER(X, a, index, XList)
***********************************************************************/

#ifndef VCZH_COLLECTIONS_OPERATION
#define VCZH_COLLECTIONS_OPERATION


namespace vl
{
	namespace collections
	{

/***********************************************************************
OrderBy Quick Sort
***********************************************************************/

		template<typename T>
		void Sort(T* items, vint length, const Func<vint(T, T)>& orderer)
		{
			if(length==0) return;
			vint pivot=0;
			vint left=0;
			vint right=0;
			bool flag=false;

			while(left+right+1!=length)
			{
				vint& mine=(flag?left:right);
				vint& theirs=(flag?right:left);
				vint candidate=(flag?left:length-right-1);
				vint factor=(flag?-1:1);

				if(orderer(items[pivot], items[candidate])*factor<=0)
				{
					mine++;
				}
				else
				{
					theirs++;
					T temp=items[pivot];
					items[pivot]=items[candidate];
					items[candidate]=temp;
					pivot=candidate;
					flag=!flag;
				}
			}

			Sort(items, left, orderer);
			Sort(items+left+1, right, orderer);
		}

/***********************************************************************
LazyList
***********************************************************************/

		template<typename T>
		class LazyList : public Object, public IEnumerable<T>
		{
		protected:
			Ptr<IEnumerator<T>>			enumeratorPrototype;

			IEnumerator<T>* xs()const
			{
				return enumeratorPrototype->Clone();
			}
		public:
			LazyList(Ptr<IEnumerator<T>> enumerator)
				:enumeratorPrototype(enumerator)
			{
			}

			LazyList(const IEnumerable<T>& enumerable)
				:enumeratorPrototype(enumerable.CreateEnumerator())
			{
			}

			LazyList(const LazyList<T>& lazyList)
				:enumeratorPrototype(lazyList.enumeratorPrototype)
			{
			}

			template<typename TContainer>
			LazyList(Ptr<TContainer> container)
				:enumeratorPrototype(new ContainerEnumerator<T, TContainer>(container))
			{
			}
			
			LazyList()
				:enumeratorPrototype(EmptyEnumerable<T>().CreateEnumerator())
			{
			}

			LazyList<T>& operator=(const LazyList<T>& lazyList)
			{
				enumeratorPrototype=lazyList.enumeratorPrototype;
				return *this;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return enumeratorPrototype->Clone();
			}

			//-------------------------------------------------------

			template<typename F>
			LazyList<FUNCTION_RESULT_TYPE(F)> Select(F f)const
			{
				return new SelectEnumerator<T, FUNCTION_RESULT_TYPE(F)>(xs(), f);
			}

			template<typename F>
			auto SelectMany(F f)const -> LazyList<decltype(From(f(T())).First())>
			{
				typedef decltype(From(f(T())).First()) U;
				return Select(f).Aggregate(LazyList<U>(), [](const LazyList<U>& a, const IEnumerable<U>& b){return a.Concat(b);});
			}
			
			template<typename F>
			LazyList<T> Where(F f)const
			{
				return new WhereEnumerator<T>(xs(), f);
			}

			template<typename U>
			LazyList<Ptr<U>> Cast()const
			{
				Func<Ptr<U>(T)> f=[](T t)->Ptr<U>{return t.Cast<U>();};
				return new SelectEnumerator<T, Ptr<U>>(xs(), f);
			}

			template<typename U>
			LazyList<Ptr<U>> FindType()const
			{
				return Cast<U>().Where([](T t){return t;});
			}

			template<typename F>
			LazyList<T> OrderBy(F f)const
			{
				Ptr<List<T>> sorted=new List<T>;
				CopyFrom(*sorted.Obj(), *this);
				if(sorted->Count()>0)
				{
					Sort<T>(&sorted->operator[](0), sorted->Count(), f);
				}
				return new ContainerEnumerator<T, List<T>>(sorted);
			}

			//-------------------------------------------------------

			template<typename F>
			T Aggregate(F f)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::Aggregate(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				T result=enumerator->Current();
				while(enumerator->Next())
				{
					result=f(result, enumerator->Current());
				}
				return result;
			}

			template<typename I, typename F>
			I Aggregate(I init, F f)const
			{
				FOREACH(T, t, *this)
				{
					init=f(init, t);
				}
				return init;
			}

			template<typename F>
			bool All(F f)const
			{
				return Select(f).Aggregate(true, [](bool a, bool b){return a&&b;});
			}

			template<typename F>
			bool Any(F f)const
			{
				return Select(f).Aggregate(false, [](bool a, bool b){return a||b;});
			}

			T Max()const
			{
				return Aggregate([](T a, T b){return a>b?a:b;});
			}

			T Min()const
			{
				return Aggregate([](T a, T b){return a<b?a:b;});
			}

			T First()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::First(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				return enumerator->Current();
			}

			T First(T defaultValue)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					return defaultValue;
				}
				return enumerator->Current();
			}

			T Last()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				if(!enumerator->Next())
				{
					throw Error(L"LazyList<T>::Last(F)#容器为空并且没有初始值，Aggregate操作失败。");
				}
				else
				{
					T value=enumerator->Current();
					while(enumerator->Next())
					{
						value=enumerator->Current();
					}
					return value;
				}
			}

			T Last(T defaultValue)const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				while(enumerator->Next())
				{
					defaultValue=enumerator->Current();
				}
				return defaultValue;
			}

			vint Count()const
			{
				vint result=0;
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				while(enumerator->Next())
				{
					result++;
				}
				return result;
			}

			bool IsEmpty()const
			{
				Ptr<IEnumerator<T>> enumerator=CreateEnumerator();
				return enumerator->Next();
			}

			//-------------------------------------------------------

			LazyList<T> Concat(const IEnumerable<T>& remains)const
			{
				return new ConcatEnumerator<T>(xs(), remains.CreateEnumerator());
			}

			LazyList<T> Take(vint count)const
			{
				return new TakeEnumerator<T>(xs(), count);
			}

			LazyList<T> Skip(vint count)const
			{
				return new SkipEnumerator<T>(xs(), count);
			}

			LazyList<T> Repeat(vint count)const
			{
				return new RepeatEnumerator<T>(xs(), count);
			}

			LazyList<T> Distinct()const
			{
				return new DistinctEnumerator<T>(xs());
			}

			LazyList<T> Reverse()const
			{
				return new ReverseEnumerator<T>(*this);
			}

			//-------------------------------------------------------

			template<typename U>
			LazyList<Pair<T, U>> Pairwise(const IEnumerable<U>& remains)const
			{
				return new PairwiseEnumerator<T, U>(xs(), remains.CreateEnumerator());
			}

			LazyList<T> Intersect(const IEnumerable<T>& remains)const
			{
				return new IntersectExceptEnumerator<T, true>(xs(), remains);
			}

			LazyList<T> Except(const IEnumerable<T>& remains)const
			{
				return new IntersectExceptEnumerator<T, false>(xs(), remains);
			}

			LazyList<T> Union(const IEnumerable<T>& remains)const
			{
				return Concat(remains).Distinct();
			}
		};

		template<typename T>
		LazyList<T> From(const IEnumerable<T>& enumerable)
		{
			return enumerable;
		}

		template<typename T>
		LazyList<T> From(const T* begin, const T* end)
		{
			return FromPointer(begin, end);
		}

		template<typename T, int size>
		LazyList<T> From(T (&items)[size])
		{
			return FromArray(items);
		}

		template<typename T, int size>
		LazyList<T> From(const T (&items)[size])
		{
			return FromArray(items);
		}
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\THREADING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Threading

Classes:
	Thread										：线程
	CriticalSection
	Mutex
	Semaphore
	EventObject
***********************************************************************/

#ifndef VCZH_THREADING
#define VCZH_THREADING


namespace vl
{

/***********************************************************************
内核模式对象
***********************************************************************/

	namespace threading_internal
	{
		struct WaitableData;
		struct ThreadData;
		struct MutexData;
		struct SemaphoreData;
		struct EventData;

		struct CriticalSectionData;
		struct ReaderWriterLockData;
		struct ConditionVariableData;
	}

	class WaitableObject : public Object, public NotCopyable
	{
	private:
		threading_internal::WaitableData*			waitableData;
	protected:

		WaitableObject();
		void										SetData(threading_internal::WaitableData* data);
	public:

		bool										IsCreated();
		bool										Wait();
		bool										WaitForTime(vint ms);
		
		static bool									WaitAll(WaitableObject** objects, vint count);
		static bool									WaitAllForTime(WaitableObject** objects, vint count, vint ms);
		static vint									WaitAny(WaitableObject** objects, vint count, bool* abandoned);
		static vint									WaitAnyForTime(WaitableObject** objects, vint count, vint ms, bool* abandoned);
	};

	class Thread : public WaitableObject
	{
		friend void InternalThreadProc(Thread* thread);
	public:
		enum ThreadState
		{
			NotStarted,
			Running,
			Paused,
			Stopped
		};

		typedef void(*ThreadProcedure)(Thread*, void*);
	private:
		threading_internal::ThreadData*				internalData;
		volatile ThreadState						threadState;

	protected:

		virtual void								Run()=0;
	public:
		Thread();
		~Thread();

		static Thread*								CreateAndStart(ThreadProcedure procedure, void* argument=0, bool deleteAfterStopped=true);
		static void									Sleep(vint ms);
		static vint									GetCPUCount();
		static vint									GetCurrentThreadId();

		bool										Start();
		bool										Pause();
		bool										Resume();
		bool										Stop();
		ThreadState									GetState();
		void										SetCPU(vint index);
	};

	class Mutex : public WaitableObject
	{
	private:
		threading_internal::MutexData*				internalData;
	public:
		Mutex();
		~Mutex();

		bool										Create(bool owned=false, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Release();
	};

	class Semaphore : public WaitableObject
	{
	private:
		threading_internal::SemaphoreData*			internalData;
	public:
		Semaphore();
		~Semaphore();

		bool										Create(vint initialCount, vint maxCount, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Release();
		vint										Release(vint count);
	};

	class EventObject : public WaitableObject
	{
	private:
		threading_internal::EventData*				internalData;
	public:
		EventObject();
		~EventObject();

		bool										CreateAutoUnsignal(bool signaled, const WString& name=L"");
		bool										CreateManualUnsignal(bool signaled, const WString& name=L"");
		bool										Open(bool inheritable, const WString& name);

		bool										Signal();
		bool										Unsignal();
	};

/***********************************************************************
线程池
***********************************************************************/

	class ThreadPoolLite : public Object
	{
	private:
		ThreadPoolLite();
		~ThreadPoolLite();
	public:
		static bool									Queue(void(*proc)(void*), void* argument);
		static bool									Queue(const Func<void()>& proc);

		template<typename T>
		static void QueueLambda(const T& proc)
		{
			Queue(Func<void()>(proc));
		}
	};

/***********************************************************************
进程内对象
***********************************************************************/

	class CriticalSection : public Object, public NotCopyable
	{
	private:
#ifdef VCZH_NO_OLD_OS
		friend class ConditionVariable;
#endif
		threading_internal::CriticalSectionData*	internalData;
	public:
		CriticalSection();
		~CriticalSection();

		bool										TryEnter();
		void										Enter();
		void										Leave();

	public:
		class Scope : public Object, public NotCopyable
		{
		private:
			CriticalSection*						criticalSection;
		public:
			Scope(CriticalSection& _criticalSection);
			~Scope();
		};
	};

#ifdef VCZH_NO_OLD_OS

	class ReaderWriterLock : public Object, public NotCopyable
	{
	private:
		friend class ConditionVariable;
		threading_internal::ReaderWriterLockData*	internalData;
	public:
		ReaderWriterLock();
		~ReaderWriterLock();

		bool										TryEnterReader();
		void										EnterReader();
		void										LeaveReader();
		bool										TryEnterWriter();
		void										EnterWriter();
		void										LeaveWriter();
	public:
		class ReaderScope : public Object, public NotCopyable
		{
		private:
			ReaderWriterLock*						lock;
		public:
			ReaderScope(ReaderWriterLock& _lock);
			~ReaderScope();
		};
		
		class WriterScope : public Object, public NotCopyable
		{
		private:
			ReaderWriterLock*						lock;
		public:
			WriterScope(ReaderWriterLock& _lock);
			~WriterScope();
		};
	};

	class ConditionVariable : public Object, public NotCopyable
	{
	private:
		threading_internal::ConditionVariableData*	internalData;
	public:
		ConditionVariable();
		~ConditionVariable();

		bool										SleepWith(CriticalSection& cs);
		bool										SleepWithForTime(CriticalSection& cs, vint ms);
		bool										SleepWithReader(ReaderWriterLock& lock);
		bool										SleepWithReaderForTime(ReaderWriterLock& lock, vint ms);
		bool										SleepWithWriter(ReaderWriterLock& lock);
		bool										SleepWithWriterForTime(ReaderWriterLock& lock, vint ms);
		void										WakeOnePending();
		void										WakeAllPendings();
	};
#endif

/***********************************************************************
用户模式对象
***********************************************************************/

	typedef long LockedInt;

	class SpinLock : public Object, public NotCopyable
	{
	protected:
		volatile LockedInt							token;
	public:
		SpinLock();
		~SpinLock();

		bool										TryEnter();
		void										Enter();
		void										Leave();

	public:
		class Scope : public Object, public NotCopyable
		{
		private:
			SpinLock*								spinLock;
		public:
			Scope(SpinLock& _spinLock);
			~Scope();
		};
	};
}

#endif

/***********************************************************************
COMMON\SOURCE\REGEX\REGEX.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Regex::Regular Expression

Classes:
	RegexString						：字符串匹配结果
	RegexMatch						：匹配结果
	Regex							：正则表达式引擎
	RegexToken						：词法记号
	RegexTokens						：词法记号表
	RegexLexer						：词法分析器
***********************************************************************/

#ifndef VCZH_REGEX_REGEX
#define VCZH_REGEX_REGEX


namespace vl
{
	namespace regex_internal
	{
		class PureResult;
		class PureInterpretor;
		class RichResult;
		class RichInterpretor;
	}

	namespace regex
	{

/***********************************************************************
正则表达式引擎数据结构
***********************************************************************/

		class RegexString : public Object
		{
		protected:
			WString										value;
			vint										start;
			vint										length;

		public:
			RegexString(vint _start=0);
			RegexString(const WString& _string, vint _start, vint _length);

			vint										Start()const;
			vint										Length()const;
			const WString&								Value()const;
			bool										operator==(const RegexString& string)const;
		};

		class RegexMatch : public Object, private NotCopyable
		{
			friend class Regex;
		public:
			typedef Ptr<RegexMatch>										Ref;
			typedef collections::List<Ref>								List;
			typedef collections::List<RegexString>						CaptureList;
			typedef collections::Group<WString, RegexString>			CaptureGroup;
		protected:
			collections::List<RegexString>				captures;
			collections::Group<WString, RegexString>	groups;
			bool										success;
			RegexString									result;

			RegexMatch(const WString& _string, regex_internal::PureResult* _result);
			RegexMatch(const WString& _string, regex_internal::RichResult* _result, regex_internal::RichInterpretor* _rich);
			RegexMatch(const RegexString& _result);
		public:
			
			bool										Success()const;
			const RegexString&							Result()const;
			const CaptureList&							Captures()const;
			const CaptureGroup&							Groups()const;
		};

/***********************************************************************
正则表达式引擎
***********************************************************************/

		class Regex : public Object, private NotCopyable
		{
		protected:
			regex_internal::PureInterpretor*			pure;
			regex_internal::RichInterpretor*			rich;

			void										Process(const WString& text, bool keepEmpty, bool keepSuccess, bool keepFail, RegexMatch::List& matches)const;
		public:
			Regex(const WString& code, bool preferPure=true);
			~Regex();

			bool										IsPureMatch()const;
			bool										IsPureTest()const;

			RegexMatch::Ref								MatchHead(const WString& text)const;
			RegexMatch::Ref								Match(const WString& text)const;
			bool										TestHead(const WString& text)const;
			bool										Test(const WString& text)const;
			void										Search(const WString& text, RegexMatch::List& matches)const;
			void										Split(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const;
			void										Cut(const WString& text, bool keepEmptyMatch, RegexMatch::List& matches)const;
		};

/***********************************************************************
正则表达式词法分析器
***********************************************************************/

		class RegexToken
		{
		public:
			vint										start;
			vint										length;
			vint										token;
			const wchar_t*								reading;
			vint										codeIndex;

			vint										rowStart;
			vint										columnStart;
			vint										rowEnd;
			vint										columnEnd;

			bool										operator==(const RegexToken& _token)const;
			bool										operator==(const wchar_t* _token)const;
		};

		class RegexTokens : public Object, public collections::IEnumerable<RegexToken>
		{
			friend class RegexLexer;
		protected:
			regex_internal::PureInterpretor*			pure;
			const collections::Array<vint>&				stateTokens;
			WString										code;
			vint										codeIndex;
			
			RegexTokens(regex_internal::PureInterpretor* _pure, const collections::Array<vint>& _stateTokens, const WString& _code, vint _codeIndex);
		public:

			collections::IEnumerator<RegexToken>*		CreateEnumerator()const;
			void										ReadToEnd(collections::List<RegexToken>& tokens, bool(*discard)(vint)=0)const;
		};

		class RegexLexerWalker : public Object
		{
			friend class RegexLexer;
		protected:
			regex_internal::PureInterpretor*			pure;
			const collections::Array<vint>&				stateTokens;
			
			RegexLexerWalker(regex_internal::PureInterpretor* _pure, const collections::Array<vint>& _stateTokens);
		public:
			RegexLexerWalker(const RegexLexerWalker& walker);
			~RegexLexerWalker();

			vint										GetStartState()const;
			vint										GetRelatedToken(vint state)const;
			void										Walk(wchar_t input, vint& state, vint& token, bool& finalState, bool& previousTokenStop)const;
			vint										Walk(wchar_t input, vint state)const;
		};

		class RegexLexerColorizer : public Object
		{
			friend class RegexLexer;
		public:
			typedef void(*TokenProc)(void* argument, vint start, vint length, vint token);

		protected:
			RegexLexerWalker							walker;
			vint										currentState;

			RegexLexerColorizer(const RegexLexerWalker& _walker);
		public:
			RegexLexerColorizer(const RegexLexerColorizer& colorizer);
			~RegexLexerColorizer();

			void										Reset(vint state);
			void										Pass(wchar_t input);
			vint										GetStartState()const;
			vint										GetCurrentState()const;
			void										Colorize(const wchar_t* input, vint length, TokenProc tokenProc, void* tokenProcArgument);
		};

		class RegexLexer : public Object, private NotCopyable
		{
		protected:
			regex_internal::PureInterpretor*			pure;
			collections::Array<vint>					ids;
			collections::Array<vint>					stateTokens;
		public:
			RegexLexer(const collections::IEnumerable<WString>& tokens);
			~RegexLexer();

			RegexTokens									Parse(const WString& code, vint codeIndex=-1)const;
			RegexLexerWalker							Walk()const;
			RegexLexerColorizer							Colorize()const;
		};
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\STREAM\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Stream::Interfaces

Interfaces:
	IStream							：流
***********************************************************************/

#ifndef VCZH_STREAM_INTERFACES
#define VCZH_STREAM_INTERFACES


namespace vl
{
	namespace stream
	{
		class IStream : public virtual Interface
		{
		public:
			virtual bool					CanRead()const=0;
			virtual bool					CanWrite()const=0;
			virtual bool					CanSeek()const=0;
			virtual bool					CanPeek()const=0;
			virtual bool					IsLimited()const=0;
			virtual bool					IsAvailable()const=0;
			virtual void					Close()=0;
			virtual pos_t					Position()const=0;
			virtual pos_t					Size()const=0;
			virtual void					Seek(pos_t _size)=0;
			virtual void					SeekFromBegin(pos_t _size)=0;
			virtual void					SeekFromEnd(pos_t _size)=0;
			virtual vint					Read(void* _buffer, vint _size)=0;
			virtual vint					Write(void* _buffer, vint _size)=0;
			virtual vint					Peek(void* _buffer, vint _size)=0;
		};

		class IEncoder : public Interface
		{
		public:
			virtual void					Setup(IStream* _stream)=0;
			virtual	void					Close()=0;
			virtual vint					Write(void* _buffer, vint _size)=0;
		};

		class IDecoder : public Interface
		{
		public:
			virtual void					Setup(IStream* _stream)=0;
			virtual	void					Close()=0;
			virtual vint					Read(void* _buffer, vint _size)=0;
		};
	}
}

#endif

/***********************************************************************
COMMON\SOURCE\EXCEPTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Exception

Classes:
	Exception									：异常
	ArgumentException							：预料的的参数错误
***********************************************************************/

#ifndef VCZH_EXCEPTION
#define VCZH_EXCEPTION


namespace vl
{
	class Exception : public Object
	{
	protected:
		WString						message;

	public:
		Exception(const WString& _message=WString::Empty);

		const WString&				Message()const;
	};

	class ArgumentException : public Exception
	{
	protected:
		WString						function;
		WString						name;

	public:
		ArgumentException(const WString& _message=WString::Empty, const WString& _function=WString::Empty, const WString& _name=WString::Empty);

		const WString&				GetFunction()const;
		const WString&				GetName()const;
	};

	class ParsingException : public Exception
	{
	protected:
		vint							position;
		WString						expression;

	public:
		ParsingException(const WString& _message, const WString& _expression, vint _position);

		const WString&				GetExpression()const;
		vint							GetPosition()const;
	};
}

#endif

/***********************************************************************
COMMON\SOURCE\REFLECTION\GUITYPEDESCRIPTOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Reflection

XML Representation for Code Generation:
***********************************************************************/

#ifndef VCZH_REFLECTION_GUITYPEDESCRIPTOR
#define VCZH_REFLECTION_GUITYPEDESCRIPTOR


namespace vl
{
	namespace reflection
	{

/***********************************************************************
Attribute
***********************************************************************/

		namespace description
		{
			class ITypeDescriptor;
		}

		class DescriptableObject
		{
			template<typename T>
			friend class Description;

			friend class DescriptableValue;
		protected:
			size_t									objectSize;
			description::ITypeDescriptor**			typeDescriptor;
		public:
			DescriptableObject();
			virtual ~DescriptableObject();

			description::ITypeDescriptor*			GetTypeDescriptor();
		};

		class IDescriptable : public virtual Interface, public virtual DescriptableObject
		{
		public:
			~IDescriptable(){}
		};
		
		template<typename T>
		class Description : public virtual DescriptableObject
		{
		protected:
			static description::ITypeDescriptor*		associatedTypeDescriptor;
		public:
			Description()
			{
				if(objectSize<sizeof(T))
				{
					objectSize=sizeof(T);
					typeDescriptor=&associatedTypeDescriptor;
				}
			}

			static description::ITypeDescriptor* GetAssociatedTypeDescriptor()
			{
				return associatedTypeDescriptor;
			}

			static void SetAssociatedTypeDescroptor(description::ITypeDescriptor* typeDescroptor)
			{
				if(!associatedTypeDescriptor)
				{
					associatedTypeDescriptor=typeDescroptor;
				}
			}
		};

		template<typename T>
		description::ITypeDescriptor* Description<T>::associatedTypeDescriptor=0;

/***********************************************************************
Value
***********************************************************************/

		namespace description
		{
			class Value : public Object
			{
			public:
				enum ValueType
				{
					Null,
					DescriptableObjectRef,
					DescriptableObjectPtr,
					Text,
				};
			protected:
				ValueType						valueType;
				DescriptableObject*				descriptableObjectRef;
				Ptr<DescriptableObject>			descriptableObjectPtr;
				WString							text;
				ITypeDescriptor*				typeDescriptor;
			public:
				Value();
				Value(DescriptableObject* value);
				Value(Ptr<DescriptableObject> value);
				Value(const WString& value, ITypeDescriptor* associatedTypeDescriptor);
				Value(const Value& value);

				Value&							operator=(const Value& value);

				ValueType						GetValueType()const;
				DescriptableObject*				GetDescriptableObjectRef()const;
				Ptr<DescriptableObject>			GetDescriptableObjectPtr()const;
				const WString&					GetText()const;
				ITypeDescriptor*				GetTypeDescriptor()const;
			};

			class IValueSerializer : public Interface
			{
			public:
				virtual WString					GetName()=0;
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual bool					Validate(const WString& text)=0;
				virtual bool					Parse(const WString& input, Value& output)=0;
			};

			template<typename T>
			class ITypedValueSerializer : public IValueSerializer
			{
				virtual bool					Serialize(const T& input, Value& output)=0;
				virtual bool					Deserialize(const Value& input, T& output)=0;
			};

/***********************************************************************
ITypeDescriptor (basic)
***********************************************************************/

			class IMemberInfo : public virtual Interface
			{
			public:
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual const WString&			GetName()=0;
			};

			class IValueInfo : public virtual Interface
			{
			public:
				virtual ITypeDescriptor*		GetValueTypeDescriptor()=0;
				virtual bool					CanBeNull()=0;
			};

/***********************************************************************
ITypeDescriptor (event)
***********************************************************************/

			class IEventInfo;

			class IEventHandler : public Interface
			{
			public:
				virtual IEventInfo*				GetOwnerEvent()=0;
				virtual Value					GetOwnerObject()=0;
				virtual bool					IsAttached()=0;
				virtual bool					Detach()=0;
				virtual void					Invoke(const Value& thisObject, Value& arguments)=0;
			};

			class IEventInfo : public IMemberInfo
			{
			public:
				virtual Ptr<IEventHandler>		Attach(const Value& thisObject, const Func<void(const Value&, Value&)>& handler)=0;
				virtual void					Invoke(const Value& thisObject, Value& arguments)=0;
			};

/***********************************************************************
ITypeDescriptor (property)
***********************************************************************/

			class IPropertyInfo : public IMemberInfo, public IValueInfo
			{
			public:
				virtual bool					IsReadable()=0;
				virtual bool					IsWritable()=0;
				virtual IEventInfo*				GetValueChangedEvent()=0;
				virtual Value					GetValue(const Value& thisObject)=0;
				virtual void					SetValue(const Value& thisObject, Value newValue)=0;
			};

/***********************************************************************
ITypeDescriptor (method)
***********************************************************************/

			class IMethodInfo;
			class IMethodGroupInfo;

			class IParameterInfo : public IMemberInfo, public IValueInfo
			{
			public:
				virtual IMethodInfo*			GetOwnerMethod()=0;
				virtual bool					CanOutput()=0;
			};

			class IMethodInfo : public IMemberInfo
			{
			public:
				virtual IMethodGroupInfo*		GetOwnerMethodGroup()=0;
				virtual vint					GetParameterCount()=0;
				virtual IParameterInfo*			GetParameter(vint index)=0;
				virtual IValueInfo*				GetReturn()=0;
				virtual Value					Invoke(const Value& thisObject, collections::Array<Value>& arguments)=0;
			};

			class IMethodGroupInfo : public IMemberInfo
			{
			public:
				virtual vint					GetMethodCount()=0;
				virtual IMethodInfo*			GetMethod(vint index)=0;
			};

/***********************************************************************
ITypeDescriptor
***********************************************************************/

			class ITypeDescriptor : public Interface
			{
			public:
				virtual const WString&			GetTypeName()=0;
				virtual IValueSerializer*		GetValueSerializer()=0;
				virtual vint					GetBaseTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetBaseTypeDescriptor(vint index)=0;

				virtual vint					GetPropertyCount()=0;
				virtual IPropertyInfo*			GetProperty(vint index)=0;
				virtual bool					IsPropertyExists(const WString& name, bool inheritable)=0;
				virtual IPropertyInfo*			GetPropertyByName(const WString& name, bool inheritable)=0;

				virtual vint					GetEventCount()=0;
				virtual IEventInfo*				GetEvent(vint index)=0;
				virtual bool					IsEventExists(const WString& name, bool inheritable)=0;
				virtual IEventInfo*				GetEventByName(const WString& name, bool inheritable)=0;

				virtual vint					GetMethodGroupCount()=0;
				virtual IMethodGroupInfo*		GetMethodGroup(vint index)=0;
				virtual bool					IsMethodGroupExists(const WString& name, bool inheritable)=0;
				virtual IMethodGroupInfo*		GetMethodGroupByName(const WString& name, bool inheritable)=0;
				virtual IMethodGroupInfo*		GetConstructorGroup()=0;
			};

/***********************************************************************
ITypeManager
***********************************************************************/

			class ITypeManager;

			class ITypeLoader : public Interface
			{
			public:
				virtual void					Load(ITypeManager* manager)=0;
				virtual void					Unload(ITypeManager* manager)=0;
			};

			class ITypeManager : public Interface
			{
			public:
				virtual vint					GetValueSerializerCount()=0;
				virtual IValueSerializer*		GetValueSerializer(vint index)=0;
				virtual IValueSerializer*		GetValueSerializer(const WString& name)=0;
				virtual bool					SetValueSerializer(const WString& name, Ptr<IValueSerializer> valueSerializer)=0;
				
				virtual vint					GetTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetTypeDescriptor(vint index)=0;
				virtual ITypeDescriptor*		GetTypeDescriptor(const WString& name)=0;
				virtual bool					SetTypeDescriptor(const WString& name, Ptr<ITypeDescriptor> typeDescriptor)=0;

				virtual bool					AddTypeLoader(Ptr<ITypeLoader> typeLoader)=0;
				virtual bool					RemoveTypeLoader(Ptr<ITypeLoader> typeLoader)=0;
				virtual bool					Load()=0;
				virtual bool					Unload()=0;
				virtual bool					Reload()=0;
				virtual bool					IsLoaded()=0;
			};

			extern ITypeManager*				GetGlobalTypeManager();
			extern bool							DestroyGlobalTypeManager();
			extern IValueSerializer*			GetValueSerializer(const WString& name);
			extern ITypeDescriptor*				GetTypeDescriptor(const WString& name);

/***********************************************************************
Exceptions
***********************************************************************/

			class TypeDescriptorException : public Exception
			{
			public:
				TypeDescriptorException(const WString& message)
					:Exception(message)
				{
				}
			};

			class PropertyIsNotReadableException : public TypeDescriptorException
			{
			public:
				PropertyIsNotReadableException(IPropertyInfo* propertyInfo)
					:TypeDescriptorException(L"Cannot read value from a property \""+propertyInfo->GetName()+L"\" that is not readable in type \""+propertyInfo->GetOwnerTypeDescriptor()->GetTypeName()+L"\"/")
				{
				}
			};

			class PropertyIsNotWritableException : public TypeDescriptorException
			{
			public:
				PropertyIsNotWritableException(IPropertyInfo* propertyInfo)
					:TypeDescriptorException(L"Cannot write value to a property \""+propertyInfo->GetName()+L"\" that is not writable in type \""+propertyInfo->GetOwnerTypeDescriptor()->GetTypeName()+L"\"/")
				{
				}
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GACVLPPREFERENCES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI Vczh Library++ 3.0 References

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACVLPPREFERENCES
#define VCZH_PRESENTATION_GACVLPPREFERENCES


#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\GUITYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Common Types

Classes:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUITYPES
#define VCZH_PRESENTATION_GUITYPES


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Enumerations
***********************************************************************/
		
		namespace Alignment
		{
			enum Type
			{
				Left=0,
				Top=0,
				Center=1,
				Right=2,
				Bottom=2,
			};
		}

/***********************************************************************
TextPos
***********************************************************************/
		
		struct TextPos
		{
			vint			row;
			vint			column;

			TextPos()
				:row(0) ,column(0)
			{
			}

			TextPos(vint _row, vint _column)
				:row(_row) ,column(_column)
			{
			}

			vint Compare(const TextPos& value)const
			{
				if(row<value.row) return -1;
				if(row>value.row) return 1;
				if(column<value.column) return -1;
				if(column>value.column) return 1;
				return 0;
			}

			bool operator==(const TextPos& value)const {return Compare(value)==0;}
			bool operator!=(const TextPos& value)const {return Compare(value)!=0;}
			bool operator<(const TextPos& value)const {return Compare(value)<0;}
			bool operator<=(const TextPos& value)const {return Compare(value)<=0;}
			bool operator>(const TextPos& value)const {return Compare(value)>0;}
			bool operator>=(const TextPos& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
Point
***********************************************************************/
		
		struct Point
		{
			vint			x;
			vint			y;

			Point()
				:x(0) ,y(0)
			{
			}

			Point(vint _x, vint _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Point point)const
			{
				return x==point.x && y==point.y;
			}

			bool operator!=(Point point)const
			{
				return x!=point.x || y!=point.y;
			}
		};

/***********************************************************************
Size
***********************************************************************/
		
		struct Size
		{
			vint			x;
			vint			y;

			Size()
				:x(0) ,y(0)
			{
			}

			Size(vint _x, vint _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Size size)const
			{
				return x==size.x && y==size.y;
			}

			bool operator!=(Size size)const
			{
				return x!=size.x || y!=size.y;
			}
		};

/***********************************************************************
Rectangle
***********************************************************************/
		
		struct Rect
		{
			vint		x1;
			vint		y1;
			vint		x2;
			vint		y2;

			Rect()
				:x1(0), y1(0), x2(0), y2(0)
			{
			}

			Rect(vint _x1, vint _y1, vint _x2, vint _y2)
				:x1(_x1), y1(_y1), x2(_x2), y2(_y2)
			{
			}

			Rect(Point p, Size s)
				:x1(p.x), y1(p.y), x2(p.x+s.x), y2(p.y+s.y)
			{
			}

			bool operator==(Rect rect)const
			{
				return x1==rect.x1 && y1==rect.y1 && x2==rect.x2 && y2==rect.y2;
			}

			bool operator!=(Rect rect)const
			{
				return x1!=rect.x1 || y1!=rect.y1 || x2!=rect.x2 || y2!=rect.y2;
			}

			Point LeftTop()const
			{
				return Point(x1, y1);
			}

			Point RightBottom()const
			{
				return Point(x2, y2);
			}

			Size GetSize()const
			{
				return Size(x2-x1, y2-y1);
			}

			vint Left()const
			{
				return x1;
			}

			vint Right()const
			{
				return x2;
			}

			vint Width()const
			{
				return x2-x1;
			}

			vint Top()const
			{
				return y1;
			}

			vint Bottom()const
			{
				return y2;
			}

			vint Height()const
			{
				return y2-y1;
			}

			void Expand(vint x, vint y)
			{
				x1-=x;
				y1-=y;
				x2+=x;
				y2+=y;
			}

			void Expand(Size s)
			{
				x1-=s.x;
				y1-=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			void Move(vint x, vint y)
			{
				x1+=x;
				y1+=y;
				x2+=x;
				y2+=y;
			}

			void Move(Size s)
			{
				x1+=s.x;
				y1+=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			bool Contains(Point p)
			{
				return x1<=p.x && p.x<x2 && y1<=p.y && p.y<y2;
			}
		};

/***********************************************************************
2D operations
***********************************************************************/

		inline Point operator+(Point p, Size s)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator+(Size s, Point p)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator-(Point p, Size s)
		{
			return Point(p.x-s.x, p.y-s.y);
		}

		inline Size operator-(Point p1, Point p2)
		{
			return Size(p1.x-p2.x, p1.y-p2.y);
		}

		inline Size operator+(Size s1, Size s2)
		{
			return Size(s1.x+s2.x, s1.y+s2.y);
		}

		inline Size operator-(Size s1, Size s2)
		{
			return Size(s1.x-s2.x, s1.y-s2.y);
		}

		inline Size operator*(Size s, vint i)
		{
			return Size(s.x*i, s.y*i);
		}

		inline Size operator/(Size s, vint i)
		{
			return Size(s.x/i, s.y/i);
		}

		inline Point operator+=(Point& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Point operator-=(Point& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

		inline Size operator+=(Size& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Size operator-=(Size& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

/***********************************************************************
Color
***********************************************************************/
		
		struct Color
		{
			union
			{
				struct
				{
					unsigned char r;
					unsigned char g;
					unsigned char b;
					unsigned char a;
				};
				unsigned __int32 value;
			};

			Color()
				:r(0), g(0), b(0), a(255)
			{
			}

			Color(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a=255)
				:r(_r), g(_g), b(_b), a(_a)
			{
			}

			vint Compare(Color color)const
			{
				return value-color.value;
			}

			bool operator==(Color color)const {return Compare(color)==0;}
			bool operator!=(Color color)const {return Compare(color)!=0;}
			bool operator<(Color color)const {return Compare(color)<0;}
			bool operator<=(Color color)const {return Compare(color)<=0;}
			bool operator>(Color color)const {return Compare(color)>0;}
			bool operator>=(Color color)const {return Compare(color)>=0;}
		};

/***********************************************************************
Margin
***********************************************************************/
		
		struct Margin
		{
			vint		left;
			vint		top;
			vint		right;
			vint		bottom;

			Margin()
				:left(0), top(0), right(0), bottom(0)
			{
			}

			Margin(vint _left, vint _top, vint _right, vint _bottom)
				:left(_left), top(_top), right(_right), bottom(_bottom)
			{
			}

			bool operator==(Margin margin)const
			{
				return left==margin.left && top==margin.top && right==margin.right && bottom==margin.bottom;
			}

			bool operator!=(Margin margin)const
			{
				return left!=margin.left || top!=margin.top || right!=margin.right || bottom!=margin.bottom;
			}
		};

/***********************************************************************
Resources
***********************************************************************/
		
		struct FontProperties
		{
			WString				fontFamily;
			vint					size;
			bool				bold;
			bool				italic;
			bool				underline;
			bool				strikeline;
			bool				antialias;
			bool				verticalAntialias;

			FontProperties()
				:size(0)
				,bold(false)
				,italic(false)
				,underline(false)
				,strikeline(false)
				,antialias(true)
				,verticalAntialias(false)
			{
			}
			
			vint Compare(const FontProperties& value)const
			{
				vint result=0;
				
				result=WString::Compare(fontFamily, value.fontFamily);
				if(result!=0) return result;

				result=size-value.size;
				if(result!=0) return result;

				result=(vint)bold-(vint)value.bold;
				if(result!=0) return result;

				result=(vint)italic-(vint)value.italic;
				if(result!=0) return result;

				result=(vint)underline-(vint)value.underline;
				if(result!=0) return result;

				result=(vint)strikeline-(vint)value.strikeline;
				if(result!=0) return result;

				result=(vint)antialias-(vint)value.antialias;
				if(result!=0) return result;

				return 0;
			}

			bool operator==(const FontProperties& value)const {return Compare(value)==0;}
			bool operator!=(const FontProperties& value)const {return Compare(value)!=0;}
			bool operator<(const FontProperties& value)const {return Compare(value)<0;}
			bool operator<=(const FontProperties& value)const {return Compare(value)<=0;}
			bool operator>(const FontProperties& value)const {return Compare(value)>0;}
			bool operator>=(const FontProperties& value)const {return Compare(value)>=0;}
		};
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSELEMENTINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENTINTERFACES
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENTINTERFACES


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		namespace elements
		{
			class IGuiGraphicsElement;
			class IGuiGraphicsElementFactory;
			class IGuiGraphicsRenderer;
			class IGuiGraphicsRendererFactory;
			class IGuiGraphicsRenderTarget;

/***********************************************************************
Basic Construction
***********************************************************************/

			class IGuiGraphicsElement : public virtual IDescriptable, public Description<IGuiGraphicsElement>
			{
			public:
				virtual IGuiGraphicsElementFactory*		GetFactory()=0;
				virtual IGuiGraphicsRenderer*			GetRenderer()=0;
			};

			class IGuiGraphicsElementFactory : public Interface
			{
			public:
				virtual WString							GetElementTypeName()=0;
				virtual IGuiGraphicsElement*			Create()=0;
			};

			class IGuiGraphicsRenderer : public Interface
			{
			public:
				virtual IGuiGraphicsRendererFactory*	GetFactory()=0;

				virtual void							Initialize(IGuiGraphicsElement* element)=0;
				virtual void							Finalize()=0;
				virtual void							SetRenderTarget(IGuiGraphicsRenderTarget* renderTarget)=0;
				virtual void							Render(Rect bounds)=0;
				virtual void							OnElementStateChanged()=0;
				virtual Size							GetMinSize()=0;
			};

			class IGuiGraphicsRendererFactory : public Interface
			{
			public:
				virtual IGuiGraphicsRenderer*			Create()=0;
			};

			class IGuiGraphicsRenderTarget : public Interface
			{
			public:
				virtual void							StartRendering()=0;
				virtual void							StopRendering()=0;
				virtual void							PushClipper(Rect clipper)=0;
				virtual void							PopClipper()=0;
				virtual Rect							GetClipper()=0;
				virtual bool							IsClipperCoverWholeTarget()=0;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSDOCUMENTINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTINTERFACES
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTINTERFACES


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		namespace elements
		{

/***********************************************************************
Layout Engine
***********************************************************************/

			class IGuiGraphicsParagraph;
			class IGuiGraphicsLayoutProvider;

			class IGuiGraphicsParagraph : public Interface
			{
			public:
				enum TextStyle
				{
					Bold=1,
					Italic=2,
					Underline=4,
					Strikeline=8,
				};

				enum BreakCondition
				{
					StickToPreviousRun,
					StickToNextRun,
					Alone,
				};

				struct InlineObjectProperties
				{
					Size					size;
					vint						baseline;
					BreakCondition			breakCondition;

					InlineObjectProperties()
						:baseline(-1)
					{
					}
				};

				virtual IGuiGraphicsLayoutProvider*			GetProvider()=0;
				virtual IGuiGraphicsRenderTarget*			GetRenderTarget()=0;
				virtual bool								GetWrapLine()=0;
				virtual void								SetWrapLine(bool value)=0;
				virtual vint									GetMaxWidth()=0;
				virtual void								SetMaxWidth(vint value)=0;

				virtual bool								SetFont(vint start, vint length, const WString& value)=0;
				virtual bool								SetSize(vint start, vint length, vint value)=0;
				virtual bool								SetStyle(vint start, vint length, TextStyle value)=0;
				virtual bool								SetColor(vint start, vint length, Color value)=0;
				virtual bool								SetInlineObject(vint start, vint length, const InlineObjectProperties& properties, Ptr<IGuiGraphicsElement> value)=0;
				virtual bool								ResetInlineObject(vint start, vint length)=0;

				virtual vint									GetHeight()=0;
				virtual void								Render(Rect bounds)=0;
			};

			class IGuiGraphicsLayoutProvider : public Interface
			{
			public:
				virtual Ptr<IGuiGraphicsParagraph>			CreateParagraph(const WString& text, IGuiGraphicsRenderTarget* renderTarget)=0;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\GUINATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Native Window

Interfaces:
  INativeWindow							：窗口适配器
  INativeWindowListener					：窗口事件监听器
  INativeController						：全局控制器
  INativeControllerListener				：全局事件监听器

Renderers:
  GUI_GRAPHICS_RENDERER_GDI
  GUI_GRAPHICS_RENDERER_DIRECT2D
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUINATIVEWINDOW
#define VCZH_PRESENTATION_GUINATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		class INativeWindow;
		class INativeWindowListener;
		class INativeController;
		class INativeControllerListener;

/***********************************************************************
System Object
***********************************************************************/

		class INativeScreen : public Interface
		{
		public:
			virtual Rect				GetBounds()=0;
			virtual Rect				GetClientBounds()=0;
			virtual WString				GetName()=0;
			virtual bool				IsPrimary()=0;
		};
		
		class INativeCursor : public Interface
		{
		public:
			enum SystemCursorType
			{
				SmallWaiting,
				LargeWaiting,
				Arrow,
				Cross,
				Hand,
				Help,
				IBeam,
				SizeAll,
				SizeNESW,
				SizeNS,
				SizeNWSE,
				SizeWE,
				LastSystemCursor=SizeWE,
			};

			static const vint			SystemCursorCount=LastSystemCursor+1;
		public:
			virtual bool				IsSystemCursor()=0;
			virtual SystemCursorType	GetSystemCursorType()=0;
		};

/***********************************************************************
Image Object
***********************************************************************/

		class INativeImageService;
		class INativeImage;
		class INativeImageFrame;
		
		class INativeImageFrameCache : public Interface
		{
		public:
			virtual void						OnAttach(INativeImageFrame* frame)=0;
			virtual void						OnDetach(INativeImageFrame* frame)=0;
		};

		class INativeImageFrame : public Interface
		{
		public:
			virtual INativeImage*				GetImage()=0;
			virtual Size						GetSize()=0;

			virtual bool						SetCache(void* key, Ptr<INativeImageFrameCache> cache)=0;
			virtual Ptr<INativeImageFrameCache>	GetCache(void* key)=0;
			virtual Ptr<INativeImageFrameCache>	RemoveCache(void* key)=0;
		};
		
		class INativeImage : public Interface
		{
		public:
			enum FormatType
			{
				Bmp,
				Gif,
				Icon,
				Jpeg,
				Png,
				Tiff,
				Wmp,
				Unknown,
			};
			
			virtual INativeImageService*		GetImageService()=0;
			virtual FormatType					GetFormat()=0;
			virtual vint							GetFrameCount()=0;
			virtual INativeImageFrame*			GetFrame(vint index)=0;
		};
		
		class INativeImageService : public Interface
		{
		public:
			virtual Ptr<INativeImage>			CreateImageFromFile(const WString& path)=0;

			virtual Ptr<INativeImage>			CreateImageFromMemory(void* buffer, vint length)=0;

			virtual Ptr<INativeImage>			CreateImageFromStream(stream::IStream& stream)=0;
		};

/***********************************************************************
Native Window
***********************************************************************/
		
		class INativeWindow : public Interface
		{
		public:
			virtual Rect				GetBounds()=0;
			virtual void				SetBounds(const Rect& bounds)=0;
			virtual Size				GetClientSize()=0;
			virtual void				SetClientSize(Size size)=0;
			virtual Rect				GetClientBoundsInScreen()=0;
			
			virtual WString				GetTitle()=0;
			virtual void				SetTitle(WString title)=0;
			virtual INativeCursor*		GetWindowCursor()=0;
			virtual void				SetWindowCursor(INativeCursor* cursor)=0;
			virtual Point				GetCaretPoint()=0;
			virtual void				SetCaretPoint(Point point)=0;
			
			virtual INativeWindow*		GetParent()=0;
			virtual void				SetParent(INativeWindow* parent)=0;
			virtual bool				GetAlwaysPassFocusToParent()=0;
			virtual void				SetAlwaysPassFocusToParent(bool value)=0;

			virtual void				EnableCustomFrameMode()=0;
			virtual void				DisableCustomFrameMode()=0;
			virtual bool				IsCustomFrameModeEnabled()=0;

			enum WindowSizeState
			{
				Minimized,
				Restored,
				Maximized,
			};

			virtual WindowSizeState		GetSizeState()=0;
			virtual void				Show()=0;
			virtual void				ShowDeactivated()=0;
			virtual void				ShowRestored()=0;
			virtual void				ShowMaximized()=0;
			virtual void				ShowMinimized()=0;
			virtual void				Hide()=0;
			virtual bool				IsVisible()=0;

			virtual void				Enable()=0;
			virtual void				Disable()=0;
			virtual bool				IsEnabled()=0;
			
			virtual void				SetFocus()=0;
			virtual bool				IsFocused()=0;
			virtual void				SetActivate()=0;
			virtual bool				IsActivated()=0;
			
			virtual void				ShowInTaskBar()=0;
			virtual void				HideInTaskBar()=0;
			virtual bool				IsAppearedInTaskBar()=0;
			
			virtual void				EnableActivate()=0;
			virtual void				DisableActivate()=0;
			virtual bool				IsEnabledActivate()=0;
			
			virtual bool				RequireCapture()=0;
			virtual bool				ReleaseCapture()=0;
			virtual bool				IsCapturing()=0;

			virtual bool				GetMaximizedBox()=0;
			virtual void				SetMaximizedBox(bool visible)=0;
			virtual bool				GetMinimizedBox()=0;
			virtual void				SetMinimizedBox(bool visible)=0;
			virtual bool				GetBorder()=0;
			virtual void				SetBorder(bool visible)=0;
			virtual bool				GetSizeBox()=0;
			virtual void				SetSizeBox(bool visible)=0;
			virtual bool				GetIconVisible()=0;
			virtual void				SetIconVisible(bool visible)=0;
			virtual bool				GetTitleBar()=0;
			virtual void				SetTitleBar(bool visible)=0;
			virtual bool				GetTopMost()=0;
			virtual void				SetTopMost(bool topmost)=0;
			
			virtual bool				InstallListener(INativeWindowListener* listener)=0;
			virtual bool				UninstallListener(INativeWindowListener* listener)=0;
			virtual void				RedrawContent()=0;
		};

		struct NativeWindowMouseInfo
		{
			bool						ctrl;
			bool						shift;
			bool						left;
			bool						middle;
			bool						right;
			vint							x;
			vint							y;
			vint							wheel;
		};
		
		struct NativeWindowKeyInfo
		{
			vint							code;
			bool						ctrl;
			bool						shift;
			bool						alt;
			bool						capslock;
		};
		
		struct NativeWindowCharInfo
		{
			wchar_t						code;
			bool						ctrl;
			bool						shift;
			bool						alt;
			bool						capslock;
		};
		
		class INativeWindowListener : public Interface
		{
		public:
			enum HitTestResult
			{
				BorderNoSizing,
				BorderLeft,
				BorderRight,
				BorderTop,
				BorderBottom,
				BorderLeftTop,
				BorderRightTop,
				BorderLeftBottom,
				BorderRightBottom,
				Title,
				ButtonMinimum,
				ButtonMaximum,
				ButtonClose,
				Client,
				Icon,
				NoDecision,
			};

			virtual HitTestResult		HitTest(Point location);
			virtual void				Moving(Rect& bounds, bool fixSizeOnly);
			virtual void				Moved();
			virtual void				Enabled();
			virtual void				Disabled();
			virtual void				GotFocus();
			virtual void				LostFocus();
			virtual void				Activated();
			virtual void				Deactivated();
			virtual void				Opened();
			virtual void				Closing(bool& cancel);
			virtual void				Closed();
			virtual void				Paint();
			virtual void				Destroying();
			virtual void				Destroyed();
			
			virtual void				LeftButtonDown(const NativeWindowMouseInfo& info);
			virtual void				LeftButtonUp(const NativeWindowMouseInfo& info);
			virtual void				LeftButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				RightButtonDown(const NativeWindowMouseInfo& info);
			virtual void				RightButtonUp(const NativeWindowMouseInfo& info);
			virtual void				RightButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonDown(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonUp(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				HorizontalWheel(const NativeWindowMouseInfo& info);
			virtual void				VerticalWheel(const NativeWindowMouseInfo& info);
			virtual void				MouseMoving(const NativeWindowMouseInfo& info);
			virtual void				MouseEntered();
			virtual void				MouseLeaved();
			
			virtual void				KeyDown(const NativeWindowKeyInfo& info);
			virtual void				KeyUp(const NativeWindowKeyInfo& info);
			virtual void				SysKeyDown(const NativeWindowKeyInfo& info);
			virtual void				SysKeyUp(const NativeWindowKeyInfo& info);
			virtual void				Char(const NativeWindowCharInfo& info);
		};

/***********************************************************************
Native Window Services
***********************************************************************/

		class INativeResourceService : public virtual Interface
		{
		public:
			virtual INativeCursor*			GetSystemCursor(INativeCursor::SystemCursorType type)=0;
			virtual INativeCursor*			GetDefaultSystemCursor()=0;

			virtual FontProperties			GetDefaultFont()=0;
			virtual void					SetDefaultFont(const FontProperties& value)=0;
		};
		
		class INativeAsyncService : public virtual Interface
		{
		public:
			typedef void (AsyncTaskProc)(void* arguments);

			virtual bool					IsInMainThread()=0;
			virtual void					InvokeAsync(AsyncTaskProc* proc, void* argument)=0;
			virtual void					InvokeInMainThread(AsyncTaskProc* proc, void* argument)=0;
			virtual bool					InvokeInMainThreadAndWait(AsyncTaskProc* proc, void* argument, vint milliseconds=-1)=0;
		};
		
		class INativeClipboardService : public virtual Interface
		{
		public:
			virtual bool					ContainsText()=0;
			virtual WString					GetText()=0;
			virtual bool					SetText(const WString& value)=0;
		};
		
		class INativeScreenService : public virtual Interface
		{
		public:
			virtual vint						GetScreenCount()=0;
			virtual INativeScreen*			GetScreen(vint index)=0;
			virtual INativeScreen*			GetScreen(INativeWindow* window)=0;
		};
		
		class INativeWindowService : public virtual Interface
		{
		public:
			virtual INativeWindow*			CreateNativeWindow()=0;
			virtual void					DestroyNativeWindow(INativeWindow* window)=0;
			virtual INativeWindow*			GetMainWindow()=0;
			virtual INativeWindow*			GetWindow(Point location)=0;
			virtual void					Run(INativeWindow* window)=0;
		};
		
		class INativeInputService : public virtual Interface
		{
		public:
			virtual void					StartHookMouse()=0;
			virtual void					StopHookMouse()=0;
			virtual bool					IsHookingMouse()=0;
			
			virtual void					StartTimer()=0;
			virtual void					StopTimer()=0;
			virtual bool					IsTimerEnabled()=0;
			
			virtual bool					IsKeyPressing(vint code)=0;
			virtual bool					IsKeyToggled(vint code)=0;

			virtual WString					GetKeyName(vint code)=0;
		};
		
		class INativeCallbackService : public virtual Interface
		{
		public:
			virtual bool					InstallListener(INativeControllerListener* listener)=0;
			virtual bool					UninstallListener(INativeControllerListener* listener)=0;
		};


		class INativeDialogService : public virtual Interface
		{
		public:
			enum MessageBoxButtonsInput
			{
				DisplayOK,
				DisplayOKCancel,
				DisplayYesNo,
				DisplayYesNoCancel,
				DisplayRetryCancel,
				DisplayAbortRetryIgnore,
				DisplayCancelTryAgainContinue,
			};

			enum MessageBoxButtonsOutput
			{
				SelectOK,
				SelectCancel,
				SelectYes,
				SelectNo,
				SelectRetry,
				SelectAbort,
				SelectIgnore,
				SelectTryAgain,
				SelectContinue,
			};

			enum MessageBoxDefaultButton
			{
				DefaultFirst,
				DefaultSecond,
				DefaultThird,
			};

			enum MessageBoxIcons
			{
				IconNone,
				IconError,
				IconQuestion,
				IconWarning,
				IconInformation,
			};

			enum MessageBoxModalOptions
			{
				ModalWindow,
				ModalTask,
				ModalSystem,
			};

			virtual MessageBoxButtonsOutput			ShowMessageBox(INativeWindow* window, const WString& text, const WString& title=L"", MessageBoxButtonsInput buttons=DisplayOK, MessageBoxDefaultButton defaultButton=DefaultFirst, MessageBoxIcons icon=IconNone, MessageBoxModalOptions modal=ModalWindow)=0;

			enum ColorDialogCustomColorOptions
			{
				CustomColorDisabled,
				CustomColorEnabled,
				CustomColorOpened,
			};

			virtual bool							ShowColorDialog(INativeWindow* window, Color& selection, bool selected=false, ColorDialogCustomColorOptions customColorOptions=CustomColorEnabled, Color* customColors=0)=0;

			virtual bool							ShowFontDialog(INativeWindow* window, FontProperties& selectionFont, Color& selectionColor, bool selected=false, bool showEffect=true, bool forceFontExist=true)=0;
			
			enum FileDialogTypes
			{
				FileDialogOpen,
				FileDialogOpenPreview,
				FileDialogSave,
				FileDialogSavePreview,
			};

			enum FileDialogOptions
			{
				FileDialogAllowMultipleSelection = 1,
				FileDialogFileMustExist = 2,
				FileDialogShowReadOnlyCheckBox = 4,
				FileDialogDereferenceLinks = 8,
				FileDialogShowNetworkButton = 16,
				FileDialogPromptCreateFile = 32,
				FileDialogPromptOverwriteFile = 64,
				FileDialogDirectoryMustExist = 128,
				FileDialogAddToRecent = 256,
			};

			virtual bool							ShowFileDialog(INativeWindow* window, collections::List<WString>& selectionFileNames, vint& selectionFilterIndex, FileDialogTypes dialogType, const WString& title, const WString& initialFileName, const WString& initialDirectory, const WString& defaultExtension, const WString& filter, FileDialogOptions options)=0;
		};

/***********************************************************************
Native Window Controller
***********************************************************************/

		class INativeController : public virtual Interface
		{
		public:
			virtual INativeCallbackService*			CallbackService()=0;
			virtual INativeResourceService*			ResourceService()=0;
			virtual INativeAsyncService*			AsyncService()=0;
			virtual INativeClipboardService*		ClipboardService()=0;
			virtual INativeImageService*			ImageService()=0;
			virtual INativeScreenService*			ScreenService()=0;
			virtual INativeWindowService*			WindowService()=0;
			virtual INativeInputService*			InputService()=0;
			virtual INativeDialogService*			DialogService()=0;
			virtual WString							GetOSVersion()=0;
			virtual WString							GetExecutablePath()=0;
		};
		
		class INativeControllerListener : public Interface
		{
		public:
			virtual void					LeftButtonDown(Point position);
			virtual void					LeftButtonUp(Point position);
			virtual void					RightButtonDown(Point position);
			virtual void					RightButtonUp(Point position);
			virtual void					MouseMoving(Point position);
			virtual void					GlobalTimer();
			virtual void					ClipboardUpdated();
			virtual void					NativeWindowCreated(INativeWindow* window);
			virtual void					NativeWindowDestroying(INativeWindow* window);
		};

		extern								INativeController* GetCurrentController();
		extern void							SetCurrentController(INativeController* controller);
	}
}

/***********************************************************************
Native Window Provider
***********************************************************************/

/*
 * Virtual Keys, Standard Set
 */
#define VKEY_LBUTTON        0x01
#define VKEY_RBUTTON        0x02
#define VKEY_CANCEL         0x03
#define VKEY_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VKEY_XBUTTON1       0x05    /* NOT contiguous with L & RBUTTON */
#define VKEY_XBUTTON2       0x06    /* NOT contiguous with L & RBUTTON */

/*
 * 0x07 : unassigned
 */

#define VKEY_BACK           0x08
#define VKEY_TAB            0x09

/*
 * 0x0A - 0x0B : reserved
 */

#define VKEY_CLEAR          0x0C
#define VKEY_RETURN         0x0D

#define VKEY_SHIFT          0x10
#define VKEY_CONTROL        0x11
#define VKEY_MENU           0x12
#define VKEY_PAUSE          0x13
#define VKEY_CAPITAL        0x14

#define VKEY_KANA           0x15
#define VKEY_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VKEY_HANGUL         0x15
#define VKEY_JUNJA          0x17
#define VKEY_FINAL          0x18
#define VKEY_HANJA          0x19
#define VKEY_KANJI          0x19

#define VKEY_ESCAPE         0x1B

#define VKEY_CONVERT        0x1C
#define VKEY_NONCONVERT     0x1D
#define VKEY_ACCEPT         0x1E
#define VKEY_MODECHANGE     0x1F

#define VKEY_SPACE          0x20
#define VKEY_PRIOR          0x21
#define VKEY_NEXT           0x22
#define VKEY_END            0x23
#define VKEY_HOME           0x24
#define VKEY_LEFT           0x25
#define VKEY_UP             0x26
#define VKEY_RIGHT          0x27
#define VKEY_DOWN           0x28
#define VKEY_SELECT         0x29
#define VKEY_PRINT          0x2A
#define VKEY_EXECUTE        0x2B
#define VKEY_SNAPSHOT       0x2C
#define VKEY_INSERT         0x2D
#define VKEY_DELETE         0x2E
#define VKEY_HELP           0x2F

/*
 * VKEY_0 - VKEY_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
 * 0x40 : unassigned
 * VKEY_A - VKEY_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
 */

#define VKEY_LWIN           0x5B
#define VKEY_RWIN           0x5C
#define VKEY_APPS           0x5D

/*
 * 0x5E : reserved
 */

#define VKEY_SLEEP          0x5F

#define VKEY_NUMPAD0        0x60
#define VKEY_NUMPAD1        0x61
#define VKEY_NUMPAD2        0x62
#define VKEY_NUMPAD3        0x63
#define VKEY_NUMPAD4        0x64
#define VKEY_NUMPAD5        0x65
#define VKEY_NUMPAD6        0x66
#define VKEY_NUMPAD7        0x67
#define VKEY_NUMPAD8        0x68
#define VKEY_NUMPAD9        0x69
#define VKEY_MULTIPLY       0x6A
#define VKEY_ADD            0x6B
#define VKEY_SEPARATOR      0x6C
#define VKEY_SUBTRACT       0x6D
#define VKEY_DECIMAL        0x6E
#define VKEY_DIVIDE         0x6F
#define VKEY_F1             0x70
#define VKEY_F2             0x71
#define VKEY_F3             0x72
#define VKEY_F4             0x73
#define VKEY_F5             0x74
#define VKEY_F6             0x75
#define VKEY_F7             0x76
#define VKEY_F8             0x77
#define VKEY_F9             0x78
#define VKEY_F10            0x79
#define VKEY_F11            0x7A
#define VKEY_F12            0x7B
#define VKEY_F13            0x7C
#define VKEY_F14            0x7D
#define VKEY_F15            0x7E
#define VKEY_F16            0x7F
#define VKEY_F17            0x80
#define VKEY_F18            0x81
#define VKEY_F19            0x82
#define VKEY_F20            0x83
#define VKEY_F21            0x84
#define VKEY_F22            0x85
#define VKEY_F23            0x86
#define VKEY_F24            0x87

/*
 * 0x88 - 0x8F : unassigned
 */

#define VKEY_NUMLOCK        0x90
#define VKEY_SCROLL         0x91

/*
 * NEC PC-9800 kbd definitions
 */
#define VKEY_OEM_NEC_EQUAL  0x92   // '=' key on numpad

/*
 * Fujitsu/OASYS kbd definitions
 */
#define VKEY_OEM_FJ_JISHO   0x92   // 'Dictionary' key
#define VKEY_OEM_FJ_MASSHOU 0x93   // 'Unregister word' key
#define VKEY_OEM_FJ_TOUROKU 0x94   // 'Register word' key
#define VKEY_OEM_FJ_LOYA    0x95   // 'Left OYAYUBI' key
#define VKEY_OEM_FJ_ROYA    0x96   // 'Right OYAYUBI' key

/*
 * 0x97 - 0x9F : unassigned
 */

/*
 * VKEY_L* & VKEY_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VKEY_LSHIFT         0xA0
#define VKEY_RSHIFT         0xA1
#define VKEY_LCONTROL       0xA2
#define VKEY_RCONTROL       0xA3
#define VKEY_LMENU          0xA4
#define VKEY_RMENU          0xA5

#define VKEY_BROWSER_BACK        0xA6
#define VKEY_BROWSER_FORWARD     0xA7
#define VKEY_BROWSER_REFRESH     0xA8
#define VKEY_BROWSER_STOP        0xA9
#define VKEY_BROWSER_SEARCH      0xAA
#define VKEY_BROWSER_FAVORITES   0xAB
#define VKEY_BROWSER_HOME        0xAC

#define VKEY_VOLUME_MUTE         0xAD
#define VKEY_VOLUME_DOWN         0xAE
#define VKEY_VOLUME_UP           0xAF
#define VKEY_MEDIA_NEXT_TRACK    0xB0
#define VKEY_MEDIA_PREV_TRACK    0xB1
#define VKEY_MEDIA_STOP          0xB2
#define VKEY_MEDIA_PLAY_PAUSE    0xB3
#define VKEY_LAUNCH_MAIL         0xB4
#define VKEY_LAUNCH_MEDIA_SELECT 0xB5
#define VKEY_LAUNCH_APP1         0xB6
#define VKEY_LAUNCH_APP2         0xB7

/*
 * 0xB8 - 0xB9 : reserved
 */

#define VKEY_OEM_1          0xBA   // ';:' for US
#define VKEY_OEM_PLUS       0xBB   // '+' any country
#define VKEY_OEM_COMMA      0xBC   // ',' any country
#define VKEY_OEM_MINUS      0xBD   // '-' any country
#define VKEY_OEM_PERIOD     0xBE   // '.' any country
#define VKEY_OEM_2          0xBF   // '/?' for US
#define VKEY_OEM_3          0xC0   // '`~' for US

/*
 * 0xC1 - 0xD7 : reserved
 */

/*
 * 0xD8 - 0xDA : unassigned
 */

#define VKEY_OEM_4          0xDB  //  '[{' for US
#define VKEY_OEM_5          0xDC  //  '\|' for US
#define VKEY_OEM_6          0xDD  //  ']}' for US
#define VKEY_OEM_7          0xDE  //  ''"' for US
#define VKEY_OEM_8          0xDF

/*
 * 0xE0 : reserved
 */

/*
 * Various extended or enhanced keyboards
 */

#define VKEY_OEM_AX         0xE1  //  'AX' key on Japanese AX kbd
#define VKEY_OEM_102        0xE2  //  "<>" or "\|" on RT 102-key kbd.
#define VKEY_ICO_HELP       0xE3  //  Help key on ICO
#define VKEY_ICO_00         0xE4  //  00 key on ICO

#define VKEY_PROCESSKEY     0xE5
#define VKEY_ICO_CLEAR      0xE6
#define VKEY_PACKET         0xE7

/*
 * 0xE8 : unassigned
 */

/*
 * Nokia/Ericsson definitions
 */
#define VKEY_OEM_RESET      0xE9
#define VKEY_OEM_JUMP       0xEA
#define VKEY_OEM_PA1        0xEB
#define VKEY_OEM_PA2        0xEC
#define VKEY_OEM_PA3        0xED
#define VKEY_OEM_WSCTRL     0xEE
#define VKEY_OEM_CUSEL      0xEF
#define VKEY_OEM_ATTN       0xF0
#define VKEY_OEM_FINISH     0xF1
#define VKEY_OEM_COPY       0xF2
#define VKEY_OEM_AUTO       0xF3
#define VKEY_OEM_ENLW       0xF4
#define VKEY_OEM_BACKTAB    0xF5

#define VKEY_ATTN           0xF6
#define VKEY_CRSEL          0xF7
#define VKEY_EXSEL          0xF8
#define VKEY_EREOF          0xF9
#define VKEY_PLAY           0xFA
#define VKEY_ZOOM           0xFB
#define VKEY_NONAME         0xFC
#define VKEY_PA1            0xFD
#define VKEY_OEM_CLEAR      0xFE

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSRESOURCEMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRESOURCEMANAGER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRESOURCEMANAGER


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Resource Manager
***********************************************************************/

			class GuiGraphicsResourceManager : public Object
			{
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsElementFactory>>		elementFactoryMap;
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsRendererFactory>>		rendererFactoryMap;
			protected:
				elementFactoryMap						elementFactories;
				rendererFactoryMap						rendererFactories;
			public:
				GuiGraphicsResourceManager();
				~GuiGraphicsResourceManager();

				virtual bool							RegisterElementFactory(IGuiGraphicsElementFactory* factory);
				virtual bool							RegisterRendererFactory(const WString& elementTypeName, IGuiGraphicsRendererFactory* factory);
				virtual IGuiGraphicsElementFactory*		GetElementFactory(const WString& elementTypeName);
				virtual IGuiGraphicsRendererFactory*	GetRendererFactory(const WString& elementTypeName);
				virtual IGuiGraphicsRenderTarget*		GetRenderTarget(INativeWindow* window)=0;
				virtual IGuiGraphicsLayoutProvider*		GetLayoutProvider()=0;
			};

			extern GuiGraphicsResourceManager*			GetGuiGraphicsResourceManager();
			extern void									SetGuiGraphicsResourceManager(GuiGraphicsResourceManager* resourceManager);
			extern bool									RegisterFactories(IGuiGraphicsElementFactory* elementFactory, IGuiGraphicsRendererFactory* rendererFactory);

/***********************************************************************
Helpers
***********************************************************************/

#define DEFINE_GUI_GRAPHICS_ELEMENT(TELEMENT, ELEMENT_TYPE_NAME)\
			public:\
				class Factory : public Object, public IGuiGraphicsElementFactory\
				{\
				public:\
					WString GetElementTypeName()\
					{\
						return TELEMENT::GetElementTypeName();\
					}\
					IGuiGraphicsElement* Create()\
					{\
						TELEMENT* element=new TELEMENT;\
						element->factory=this;\
						IGuiGraphicsRendererFactory* rendererFactory=GetGuiGraphicsResourceManager()->GetRendererFactory(GetElementTypeName());\
						if(rendererFactory)\
						{\
							element->renderer=rendererFactory->Create();\
							element->renderer->Initialize(element);\
						}\
						return element;\
					}\
				};\
			protected:\
				IGuiGraphicsElementFactory*		factory;\
				Ptr<IGuiGraphicsRenderer>		renderer;\
			public:\
				static WString GetElementTypeName()\
				{\
					return ELEMENT_TYPE_NAME;\
				}\
				static TELEMENT* Create()\
				{\
					return dynamic_cast<TELEMENT*>(GetGuiGraphicsResourceManager()->GetElementFactory(TELEMENT::GetElementTypeName())->Create());\
				}\
				IGuiGraphicsElementFactory* GetFactory()override\
				{\
					return factory;\
				}\
				IGuiGraphicsRenderer* GetRenderer()override\
				{\
					return renderer.Obj();\
				}\

#define DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, TTARGET)\
			public:\
				class Factory : public Object, public IGuiGraphicsRendererFactory\
				{\
				public:\
					IGuiGraphicsRenderer* Create()\
					{\
						TRENDERER* renderer=new TRENDERER;\
						renderer->factory=this;\
						renderer->element=0;\
						renderer->renderTarget=0;\
						return renderer;\
					}\
				};\
			protected:\
				IGuiGraphicsRendererFactory*	factory;\
				TELEMENT*						element;\
				TTARGET*						renderTarget;\
				Size							minSize;\
			public:\
				static void Register()\
				{\
					RegisterFactories(new TELEMENT::Factory, new TRENDERER::Factory);\
				}\
				IGuiGraphicsRendererFactory* GetFactory()override\
				{\
					return factory;\
				}\
				void Initialize(IGuiGraphicsElement* _element)override\
				{\
					element=dynamic_cast<TELEMENT*>(_element);\
					InitializeInternal();\
				}\
				void Finalize()override\
				{\
					FinalizeInternal();\
				}\
				void SetRenderTarget(IGuiGraphicsRenderTarget* _renderTarget)override\
				{\
					TTARGET* oldRenderTarget=renderTarget;\
					renderTarget=dynamic_cast<TTARGET*>(_renderTarget);\
					RenderTargetChangedInternal(oldRenderTarget, renderTarget);\
				}\
				Size GetMinSize()override\
				{\
					return minSize;\
				}\

#define DEFINE_CACHED_RESOURCE_ALLOCATOR(TKEY, TVALUE)\
			public:\
				static const vint DeadPackageMax=32;\
				struct Package\
				{\
					TVALUE							resource;\
					vint								counter;\
					bool operator==(const Package& package)const{return false;}\
					bool operator!=(const Package& package)const{return true;}\
				};\
				struct DeadPackage\
				{\
					TKEY							key;\
					TVALUE							value;\
					bool operator==(const DeadPackage& package)const{return false;}\
					bool operator!=(const DeadPackage& package)const{return true;}\
				};\
				Dictionary<TKEY, Package>			aliveResources;\
				List<DeadPackage>					deadResources;\
			public:\
				TVALUE Create(const TKEY& key)\
				{\
					vint index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values().Get(index);\
						package.counter++;\
						aliveResources.Set(key, package);\
						return package.resource;\
					}\
					TVALUE resource;\
					for(vint i=0;i<deadResources.Count();i++)\
					{\
						if(deadResources[i].key==key)\
						{\
							DeadPackage deadPackage=deadResources[i];\
							deadResources.RemoveAt(i);\
							resource=deadPackage.value;\
							break;\
						}\
					}\
					if(!resource)\
					{\
						resource=CreateInternal(key);\
					}\
					Package package;\
					package.resource=resource;\
					package.counter=1;\
					aliveResources.Add(key, package);\
					return package.resource;\
				}\
				void Destroy(const TKEY& key)\
				{\
					vint index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values().Get(index);\
						package.counter--;\
						if(package.counter==0)\
						{\
							aliveResources.Remove(key);\
							if(deadResources.Count()==DeadPackageMax)\
							{\
								deadResources.RemoveAt(DeadPackageMax-1);\
							}\
							DeadPackage deadPackage;\
							deadPackage.key=key;\
							deadPackage.value=package.resource;\
							deadResources.Insert(0, deadPackage);\
						}\
						else\
						{\
							aliveResources.Set(key, package);\
						}\
					}\
				}
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Elements
***********************************************************************/

			namespace ElementShape
			{
				enum Type
				{
					Rectangle,
					Ellipse,
				};
			};

			class GuiSolidBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBorderElement, L"SolidBorder")
			protected:
				Color					color;
				ElementShape::Type		shape;

				GuiSolidBorderElement();
			public:
				~GuiSolidBorderElement();

				Color					GetColor();
				void					SetColor(Color value);
				ElementShape::Type		GetShape();
				void					SetShape(ElementShape::Type value);
			};
			
			class GuiRoundBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiRoundBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiRoundBorderElement, L"RoundBorder")
			protected:
				Color					color;
				vint						radius;

				GuiRoundBorderElement();
			public:
				~GuiRoundBorderElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				
				vint						GetRadius();
				void					SetRadius(vint value);
			};
			
			class Gui3DBorderElement : public Object, public IGuiGraphicsElement, public Description<Gui3DBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DBorderElement, L"3DBorder")
			protected:
				Color					color1;
				Color					color2;

				Gui3DBorderElement();
			public:
				~Gui3DBorderElement();
				
				Color					GetColor1();
				Color					GetColor2();
				void					SetColors(Color value1, Color value2);
			};
			
			class Gui3DSplitterElement : public Object, public IGuiGraphicsElement, public Description<Gui3DSplitterElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DSplitterElement, L"3DSplitter")
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;

				Gui3DSplitterElement();
			public:
				~Gui3DSplitterElement();
				
				Color					GetColor1();
				Color					GetColor2();
				void					SetColors(Color value1, Color value2);
				
				Direction				GetDirection();
				void					SetDirection(Direction value);
			};

			class GuiSolidBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBackgroundElement, L"SolidBackground")
			protected:
				Color					color;
				ElementShape::Type		shape;

				GuiSolidBackgroundElement();
			public:
				~GuiSolidBackgroundElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				ElementShape::Type		GetShape();
				void					SetShape(ElementShape::Type value);
			};
			
			class GuiGradientBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiGradientBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiGradientBackgroundElement, L"GradientBackground")
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
					Slash,
					Backslash,
				};
			protected:
				Color					color1, color2;
				Direction				direction;
				ElementShape::Type		shape;

				GuiGradientBackgroundElement();
			public:
				~GuiGradientBackgroundElement();
				
				Color					GetColor1();
				Color					GetColor2();
				void					SetColors(Color value1, Color value2);
				
				Direction				GetDirection();
				void					SetDirection(Direction value);
				ElementShape::Type		GetShape();
				void					SetShape(ElementShape::Type value);
			};
			
			class GuiSolidLabelElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidLabelElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidLabelElement, L"SolidLabel");
			protected:
				Color					color;
				FontProperties			fontProperties;
				WString					text;
				Alignment::Type			hAlignment;
				Alignment::Type			vAlignment;
				bool					wrapLine;
				bool					ellipse;
				bool					multiline;
				bool					wrapLineHeightCalculation;

				GuiSolidLabelElement();
			public:
				~GuiSolidLabelElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				
				const FontProperties&	GetFont();
				void					SetFont(const FontProperties& value);
				
				const WString&			GetText();
				void					SetText(const WString& value);
				
				Alignment::Type			GetHorizontalAlignment();
				Alignment::Type			GetVerticalAlignment();
				void					SetAlignments(Alignment::Type horizontal, Alignment::Type vertical);
				
				bool					GetWrapLine();
				void					SetWrapLine(bool value);
				
				bool					GetEllipse();
				void					SetEllipse(bool value);
				
				bool					GetMultiline();
				void					SetMultiline(bool value);

				bool					GetWrapLineHeightCalculation();
				void					SetWrapLineHeightCalculation(bool value);
			};

			class GuiImageFrameElement : public Object, public IGuiGraphicsElement, public Description<GuiImageFrameElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiImageFrameElement, L"ImageFrame");
			protected:
				Ptr<INativeImage>		image;
				vint						frameIndex;
				Alignment::Type			hAlignment;
				Alignment::Type			vAlignment;
				bool					stretch;
				bool					enabled;

				GuiImageFrameElement();
			public:
				~GuiImageFrameElement();

				Ptr<INativeImage>		GetImage();
				vint						GetFrameIndex();
				void					SetImage(Ptr<INativeImage> _image, vint _frameIndex=0);
				
				Alignment::Type			GetHorizontalAlignment();
				Alignment::Type			GetVerticalAlignment();
				void					SetAlignments(Alignment::Type horizontal, Alignment::Type vertical);

				bool					GetStretch();
				void					SetStretch(bool value);

				bool					GetEnabled();
				void					SetEnabled(bool value);
			};

			class GuiPolygonElement : public Object, public IGuiGraphicsElement, public Description<GuiPolygonElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiPolygonElement, L"Polygon");
			protected:
				Size							size;
				collections::Array<Point>		points;
				Color							borderColor;
				Color							backgroundColor;

				GuiPolygonElement();
			public:
				~GuiPolygonElement();

				Size					GetSize();
				void					SetSize(Size value);

				const Point&			GetPoint(vint index);
				vint						GetPointCount();
				void					SetPoints(const Point* p, vint count);
				
				Color					GetBorderColor();
				void					SetBorderColor(Color value);
				Color					GetBackgroundColor();
				void					SetBackgroundColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSTEXTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Colorized Plain Text (model)
***********************************************************************/

			namespace text
			{
				struct CharAtt
				{
					unsigned __int32				rightOffset;
					unsigned __int32				colorIndex;
				};
				
				struct TextLine
				{
					static const vint				BlockSize=32;
					static const vint				MaxWidth=0xFFFF;
					
					wchar_t*						text;
					CharAtt*						att;
					vint								availableOffsetCount;
					vint								bufferLength;
					vint								dataLength;
					vint								lexerFinalState;
					vint								contextFinalState;

					TextLine();
					~TextLine();

					static vint						CalculateBufferLength(vint dataLength);
					bool							operator==(const TextLine& value)const{return false;}
					bool							operator!=(const TextLine& value)const{return true;}

					void							Initialize();
					void							Finalize();
					bool							IsReady();
					bool							Modify(vint start, vint count, const wchar_t* input, vint inputCount);
					TextLine						Split(vint index);
					void							AppendAndFinalize(TextLine& line);
				};

				class CharMeasurer : public virtual IDescriptable
				{
				protected:
					IGuiGraphicsRenderTarget*		oldRenderTarget;
					vint								rowHeight;
					vint								widths[65536];
					
					virtual vint						MeasureWidthInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)=0;
					virtual vint						GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)=0;
				public:

					CharMeasurer(vint _rowHeight);
					~CharMeasurer();

					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					vint								MeasureWidth(wchar_t character);
					vint								GetRowHeight();
				};

				struct TextLines
				{
					typedef collections::List<TextLine>		TextLineList;
				protected:
					TextLineList					lines;
					CharMeasurer*					charMeasurer;
					IGuiGraphicsRenderTarget*		renderTarget;
					vint								tabWidth;
					vint								tabSpaceCount;
					vint								availableColorizedLines;
					wchar_t							passwordChar;
				public:
					TextLines();
					~TextLines();

					vint								GetCount();
					TextLine&						GetLine(vint row);
					vint								GetAvailableColorizedLines();
					void							SetAvailableColorizedLines(vint value);
					CharMeasurer*					GetCharMeasurer();
					void							SetCharMeasurer(CharMeasurer* value);
					IGuiGraphicsRenderTarget*		GetRenderTarget();
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					WString							GetText(TextPos start, TextPos end);
					WString							GetText();
					void							SetText(const WString& value);
					
					bool							RemoveLines(vint start, vint count);
					bool							IsAvailable(TextPos pos);
					TextPos							Normalize(TextPos pos);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t** inputs, vint* inputCounts, vint rows);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input, vint inputCount);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input);
					TextPos							Modify(TextPos start, TextPos end, const WString& input);
					void							Clear();
					
					void							ClearMeasurement();
					vint								GetTabSpaceCount();
					void							SetTabSpaceCount(vint value);
					void							MeasureRow(vint row);
					vint								GetRowWidth(vint row);
					vint								GetRowHeight();
					vint								GetMaxWidth();
					vint								GetMaxHeight();
					TextPos							GetTextPosFromPoint(Point point);
					Point							GetPointFromTextPos(TextPos pos);
					Rect							GetRectFromTextPos(TextPos pos);
					wchar_t							GetPasswordChar();
					void							SetPasswordChar(wchar_t value);
				};
				
				struct ColorItem
				{
					Color							text;
					Color							background;
				};
				
				struct ColorEntry
				{
					ColorItem						normal;
					ColorItem						selectedFocused;
					ColorItem						selectedUnfocused;

					bool							operator==(const ColorEntry& value){return false;}
					bool							operator!=(const ColorEntry& value){return true;}
				};
			}

/***********************************************************************
Colorized Plain Text (element)
***********************************************************************/
			
			class GuiColorizedTextElement : public Object, public IGuiGraphicsElement, public Description<GuiColorizedTextElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiColorizedTextElement, L"ColorizedText");

				typedef collections::Array<text::ColorEntry>			ColorArray;
			public:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual void					ColorChanged()=0;
					virtual void					FontChanged()=0;
				};
			protected:
				ICallback*							callback;
				ColorArray							colors;
				FontProperties						font;
				Point								viewPosition;
				bool								isVisuallyEnabled;
				bool								isFocused;

				TextPos								caretBegin;
				TextPos								caretEnd;
				bool								caretVisible;
				Color								caretColor;

				text::TextLines						lines;

				GuiColorizedTextElement();
			public:
				~GuiColorizedTextElement();

				text::TextLines&					GetLines();
				ICallback*							GetCallback();
				void								SetCallback(ICallback* value);
				
				const ColorArray&					GetColors();
				void								SetColors(const ColorArray& value);
				const FontProperties&				GetFont();
				void								SetFont(const FontProperties& value);
				wchar_t								GetPasswordChar();
				void								SetPasswordChar(wchar_t value);
				Point								GetViewPosition();
				void								SetViewPosition(Point value);
				bool								GetVisuallyEnabled();
				void								SetVisuallyEnabled(bool value);
				bool								GetFocused();
				void								SetFocused(bool value);
				
				TextPos								GetCaretBegin();
				void								SetCaretBegin(TextPos value);
				TextPos								GetCaretEnd();
				void								SetCaretEnd(TextPos value);
				bool								GetCaretVisible();
				void								SetCaretVisible(bool value);
				Color								GetCaretColor();
				void								SetCaretColor(Color value);
			};

/***********************************************************************
Rich Content Document (model)
***********************************************************************/

			namespace text
			{
				class DocumentTextRun;
				class DocumentImageRun;

				class DocumentRun : public Object, public Description<DocumentRun>
				{
				public:
					class IVisitor : public Interface
					{
					public:
						virtual void				Visit(DocumentTextRun* run)=0;
						virtual void				Visit(DocumentImageRun* run)=0;
					};

					DocumentRun(){}

					virtual void					Accept(IVisitor* visitor)=0;
				};
				
				class DocumentTextRun : public DocumentRun, public Description<DocumentTextRun>
				{
				public:
					FontProperties					style;
					Color							color;
					WString							text;

					DocumentTextRun(){}

					void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
				};
				
				class DocumentInlineObjectRun : public DocumentRun, public Description<DocumentInlineObjectRun>
				{
				public:
					Size							size;
					vint								baseline;

					DocumentInlineObjectRun():baseline(-1){}
				};
				
				class DocumentImageRun : public DocumentInlineObjectRun, public Description<DocumentImageRun>
				{
				public:
					Ptr<INativeImage>				image;
					vint								frameIndex;

					DocumentImageRun():frameIndex(0){}

					void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
				};

				//--------------------------------------------------------------------------

				class DocumentLine : public Object, public Description<DocumentLine>
				{
					typedef collections::List<Ptr<DocumentRun>>			RunList;
				public:
					RunList							runs;
				};

				class DocumentParagraph : public Object, public Description<DocumentParagraph>
				{
					typedef collections::List<Ptr<DocumentLine>>		LineList;
				public:
					LineList						lines;
				};

				class DocumentModel : public Object, public Description<DocumentModel>
				{
					typedef collections::List<Ptr<DocumentParagraph>>	ParagraphList;
				public:
					ParagraphList					paragraphs;
				};

				struct ParagraphCache
				{
					WString							fullText;
					Ptr<IGuiGraphicsParagraph>		graphicsParagraph;
				};
			}

/***********************************************************************
Rich Content Document (element)
***********************************************************************/

			class GuiDocumentElement : public Object, public IGuiGraphicsElement, public Description<GuiColorizedTextElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiDocumentElement, L"RichDocument");
			public:
				class GuiDocumentElementRenderer : public Object, public IGuiGraphicsRenderer
				{
					DEFINE_GUI_GRAPHICS_RENDERER(GuiDocumentElement, GuiDocumentElementRenderer, IGuiGraphicsRenderTarget)
				protected:

					typedef collections::Array<Ptr<text::ParagraphCache>>		ParagraphCacheArray;
				protected:
					vint									paragraphDistance;
					vint									lastMaxWidth;
					vint									cachedTotalHeight;
					IGuiGraphicsLayoutProvider*			layoutProvider;
					ParagraphCacheArray					paragraphCaches;
					collections::Array<vint>				paragraphHeights;

					void					InitializeInternal();
					void					FinalizeInternal();
					void					RenderTargetChangedInternal(IGuiGraphicsRenderTarget* oldRenderTarget, IGuiGraphicsRenderTarget* newRenderTarget);
				public:
					GuiDocumentElementRenderer();

					void					Render(Rect bounds)override;
					void					OnElementStateChanged()override;

					void					NotifyParagraphUpdated(vint index);
				};

			protected:
				Ptr<text::DocumentModel>	document;

				GuiDocumentElement();
			public:
				~GuiDocumentElement();
				
				Ptr<text::DocumentModel>	GetDocument();
				void						SetDocument(Ptr<text::DocumentModel> value);
				void						NotifyParagraphUpdated(vint index);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSCOMPOSITION\GUIGRAPHICSEVENTRECEIVER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Event Model

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace tree
			{
				class INodeProvider;
			}
		}
	}
}

namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		namespace compositions
		{
			class GuiGraphicsComposition;

/***********************************************************************
Event
***********************************************************************/

			template<typename T>
			class GuiGraphicsEvent : public Object, public Description<GuiGraphicsEvent<T>>
			{
			public:
				typedef void(RawFunctionType)(GuiGraphicsComposition*, T&);
				typedef Func<RawFunctionType>						FunctionType;

				class IHandler : public virtual IDescriptable, public Description<IHandler>
				{
				public:
					virtual void			Execute(GuiGraphicsComposition* sender, T& argument)=0;
				};
				
				class FunctionHandler : public Object, public IHandler
				{
				protected:
					FunctionType		handler;
				public:
					FunctionHandler(const FunctionType& _handler)
						:handler(_handler)
					{
					}

					void Execute(GuiGraphicsComposition* sender, T& argument)override
					{
						handler(sender, argument);
					}
				};
			protected:
				struct HandlerNode
				{
					Ptr<IHandler>										handler;
					Ptr<HandlerNode>									next;
				};

				GuiGraphicsComposition*									sender;
				Ptr<HandlerNode>										handlers;
				collections::List<Ptr<description::IEventHandler>>		reflectionEventHandlers;
			public:
				GuiGraphicsEvent(GuiGraphicsComposition* _sender=0)
					:sender(_sender)
				{
				}

				~GuiGraphicsEvent()
				{
					for(vint i=reflectionEventHandlers.Count()-1;i>=0;i--)
					{
						Ptr<description::IEventHandler> eventHandler=reflectionEventHandlers[i];
						eventHandler->Detach();
					}
				}

				void ReflectionAddEventHandler(Ptr<description::IEventHandler> eventHandler)
				{
					reflectionEventHandlers.Add(eventHandler);
				}

				void ReflectionRemoveEventHandler(description::IEventHandler* eventHandler)
				{
					reflectionEventHandlers.Remove(eventHandler);
				}

				GuiGraphicsComposition* GetAssociatedComposition()
				{
					return sender;
				}

				void SetAssociatedComposition(GuiGraphicsComposition* _sender)
				{
					sender=_sender;
				}

				bool Attach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							return false;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					(*currentHandler)=new HandlerNode;
					(*currentHandler)->handler=handler;
					return true;
				}

				template<typename TClass, typename TMethod>
				Ptr<IHandler> AttachMethod(TClass* receiver, TMethod TClass::* method)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(receiver, method));
					Attach(handler);
					return handler;
				}

				Ptr<IHandler> AttachFunction(RawFunctionType* function)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(function));
					Attach(handler);
					return handler;
				}

				Ptr<IHandler> AttachFunction(const FunctionType& function)
				{
					Ptr<IHandler> handler=new FunctionHandler(function);
					Attach(handler);
					return handler;
				}

				template<typename T>
				Ptr<IHandler> AttachLambda(const T& lambda)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(lambda));
					Attach(handler);
					return handler;
				}

				bool Detach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							Ptr<HandlerNode> next=(*currentHandler)->next;
							(*currentHandler)=next;
							return true;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					return false;
				}

				void ExecuteWithNewSender(T& argument, GuiGraphicsComposition* newSender)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
									(*currentHandler)->handler->Execute(newSender?newSender:sender, argument);
						currentHandler=&(*currentHandler)->next;
					}
				}

				void Execute(T& argument)
				{
					ExecuteWithNewSender(argument, 0);
				}
			};

/***********************************************************************
Predefined Events
***********************************************************************/

			struct GuiEventArgs
			{
				GuiGraphicsComposition*		compositionSource;
				GuiGraphicsComposition*		eventSource;
				bool						handled;

				GuiEventArgs()
					:compositionSource(0)
					,eventSource(0)
					,handled(false)
				{
				}

				GuiEventArgs(GuiGraphicsComposition* composition)
					:compositionSource(composition)
					,eventSource(composition)
					,handled(false)
				{
				}
			};
			
			struct GuiRequestEventArgs : public GuiEventArgs
			{
				bool		cancel;
				
				GuiRequestEventArgs()
					:cancel(false)
				{
				}
				
				GuiRequestEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,cancel(false)
				{
				}
			};
			
			struct GuiKeyEventArgs : public GuiEventArgs, public NativeWindowKeyInfo
			{
				GuiKeyEventArgs()
				{
				}
				
				GuiKeyEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			struct GuiCharEventArgs : public GuiEventArgs, public NativeWindowCharInfo
			{
				GuiCharEventArgs()
				{
				}
				
				GuiCharEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			struct GuiMouseEventArgs : public GuiEventArgs, public NativeWindowMouseInfo
			{
				GuiMouseEventArgs()
				{
				}
				
				GuiMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiEventArgs>				GuiNotifyEvent;
			typedef GuiGraphicsEvent<GuiRequestEventArgs>		GuiRequestEvent;
			typedef GuiGraphicsEvent<GuiKeyEventArgs>			GuiKeyEvent;
			typedef GuiGraphicsEvent<GuiCharEventArgs>			GuiCharEvent;
			typedef GuiGraphicsEvent<GuiMouseEventArgs>			GuiMouseEvent;

/***********************************************************************
Predefined Item Events
***********************************************************************/
			
			struct GuiItemEventArgs : public GuiEventArgs
			{
				vint			itemIndex;

				GuiItemEventArgs()
					:itemIndex(-1)
				{
				}
				
				GuiItemEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,itemIndex(-1)
				{
				}
			};
			
			struct GuiItemMouseEventArgs : public GuiMouseEventArgs
			{
				vint			itemIndex;

				GuiItemMouseEventArgs()
					:itemIndex(-1)
				{
				}
				
				GuiItemMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
					,itemIndex(-1)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiItemEventArgs>			GuiItemNotifyEvent;
			typedef GuiGraphicsEvent<GuiItemMouseEventArgs>		GuiItemMouseEvent;

/***********************************************************************
Predefined Node Events
***********************************************************************/
			
			struct GuiNodeEventArgs : public GuiEventArgs
			{
				controls::tree::INodeProvider*		node;

				GuiNodeEventArgs()
					:node(0)
				{
				}
				
				GuiNodeEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,node(0)
				{
				}
			};
			
			struct GuiNodeMouseEventArgs : public GuiMouseEventArgs
			{
				controls::tree::INodeProvider*		node;

				GuiNodeMouseEventArgs()
					:node(0)
				{
				}
				
				GuiNodeMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
					,node(0)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiNodeEventArgs>			GuiNodeNotifyEvent;
			typedef GuiGraphicsEvent<GuiNodeMouseEventArgs>		GuiNodeMouseEvent;

/***********************************************************************
Event Receiver
***********************************************************************/

			class GuiGraphicsEventReceiver : public Object
			{
			protected:
				GuiGraphicsComposition*			sender;
			public:
				GuiGraphicsEventReceiver(GuiGraphicsComposition* _sender);
				~GuiGraphicsEventReceiver();

				GuiGraphicsComposition*			GetAssociatedComposition();

				GuiMouseEvent					leftButtonDown;
				GuiMouseEvent					leftButtonUp;
				GuiMouseEvent					leftButtonDoubleClick;
				GuiMouseEvent					middleButtonDown;
				GuiMouseEvent					middleButtonUp;
				GuiMouseEvent					middleButtonDoubleClick;
				GuiMouseEvent					rightButtonDown;
				GuiMouseEvent					rightButtonUp;
				GuiMouseEvent					rightButtonDoubleClick;
				GuiMouseEvent					horizontalWheel;
				GuiMouseEvent					verticalWheel;
				GuiMouseEvent					mouseMove;
				GuiNotifyEvent					mouseEnter;
				GuiNotifyEvent					mouseLeave;
				
				GuiKeyEvent						previewKey;
				GuiKeyEvent						keyDown;
				GuiKeyEvent						keyUp;
				GuiKeyEvent						systemKeyDown;
				GuiKeyEvent						systemKeyUp;
				GuiCharEvent					previewCharInput;
				GuiCharEvent					charInput;
				GuiNotifyEvent					gotFocus;
				GuiNotifyEvent					lostFocus;
				GuiNotifyEvent					caretNotify;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSCOMPOSITION\GUIGRAPHICSCOMPOSITIONBASE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITIONBASE
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITIONBASE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{
			class GuiGraphicsHost;

/***********************************************************************
Basic Construction
***********************************************************************/

			class GuiGraphicsComposition : public Object, public Description<GuiGraphicsComposition>
			{
				typedef collections::List<GuiGraphicsComposition*> CompositionList;

				friend class controls::GuiControl;
				friend class GuiGraphicsHost;
			public:
				enum MinSizeLimitation
				{
					NoLimit,
					LimitToElement,
					LimitToElementAndChildren,
				};
			protected:
				CompositionList								children;
				GuiGraphicsComposition*						parent;
				Ptr<elements::IGuiGraphicsElement>			ownedElement;
				bool										visible;
				elements::IGuiGraphicsRenderTarget*			renderTarget;
				MinSizeLimitation							minSizeLimitation;

				Ptr<compositions::GuiGraphicsEventReceiver>	eventReceiver;
				controls::GuiControl*						associatedControl;
				GuiGraphicsHost*							associatedHost;
				INativeCursor*								associatedCursor;
				INativeWindowListener::HitTestResult		associatedHitTestResult;

				Margin										margin;
				Margin										internalMargin;
				Size										preferredMinSize;

				virtual void								OnControlParentChanged(controls::GuiControl* control);
				virtual void								OnChildInserted(GuiGraphicsComposition* child);
				virtual void								OnChildRemoved(GuiGraphicsComposition* child);
				virtual void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent);
				virtual void								OnRenderTargetChanged();
				
				virtual void								SetAssociatedControl(controls::GuiControl* control);
				virtual void								SetAssociatedHost(GuiGraphicsHost* host);
			public:
				GuiGraphicsComposition();
				~GuiGraphicsComposition();

				GuiGraphicsComposition*						GetParent();
				const CompositionList&						Children();
				bool										AddChild(GuiGraphicsComposition* child);
				bool										InsertChild(vint index, GuiGraphicsComposition* child);
				bool										RemoveChild(GuiGraphicsComposition* child);
				bool										MoveChild(GuiGraphicsComposition* child, vint newIndex);

				Ptr<elements::IGuiGraphicsElement>			GetOwnedElement();
				void										SetOwnedElement(Ptr<elements::IGuiGraphicsElement> element);
				bool										GetVisible();
				void										SetVisible(bool value);
				MinSizeLimitation							GetMinSizeLimitation();
				void										SetMinSizeLimitation(MinSizeLimitation value);
				elements::IGuiGraphicsRenderTarget*			GetRenderTarget();
				void										SetRenderTarget(elements::IGuiGraphicsRenderTarget* value);

				void										Render(Size offset);
				compositions::GuiGraphicsEventReceiver*		GetEventReceiver();
				bool										HasEventReceiver();
				GuiGraphicsComposition*						FindComposition(Point location);
				Rect										GetGlobalBounds();

				controls::GuiControl*						GetAssociatedControl();
				GuiGraphicsHost*							GetAssociatedHost();
				INativeCursor*								GetAssociatedCursor();
				void										SetAssociatedCursor(INativeCursor* cursor);
				INativeWindowListener::HitTestResult		GetAssociatedHitTestResult();
				void										SetAssociatedHitTestResult(INativeWindowListener::HitTestResult value);
				
				controls::GuiControl*						GetRelatedControl();
				GuiGraphicsHost*							GetRelatedGraphicsHost();
				controls::GuiControlHost*					GetRelatedControlHost();
				INativeCursor*								GetRelatedCursor();
				
				virtual Margin								GetMargin();
				virtual void								SetMargin(Margin value);
				virtual Margin								GetInternalMargin();
				virtual void								SetInternalMargin(Margin value);
				virtual Size								GetPreferredMinSize();
				virtual void								SetPreferredMinSize(Size value);
				virtual Rect								GetClientArea();
				virtual void								ForceCalculateSizeImmediately();
				
				virtual bool								IsSizeAffectParent()=0;
				virtual Size								GetMinPreferredClientSize()=0;
				virtual Rect								GetPreferredBounds()=0;
				virtual Rect								GetBounds()=0;
			};

			class GuiGraphicsSite : public GuiGraphicsComposition, public Description<GuiGraphicsSite>
			{
			protected:

				virtual Rect						GetBoundsInternal(Rect expectedBounds);
			public:
				GuiGraphicsSite();
				~GuiGraphicsSite();
				
				bool								IsSizeAffectParent()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetPreferredBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSCOMPOSITION\GUIGRAPHICSBASICCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSBASICCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSBASICCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Basic Compositions
***********************************************************************/
			
			class GuiWindowComposition : public GuiGraphicsSite, public Description<GuiWindowComposition>
			{
			protected:
				INativeWindow*						attachedWindow;
			public:
				GuiWindowComposition();
				~GuiWindowComposition();
				
				INativeWindow*						GetAttachedWindow();
				void								SetAttachedWindow(INativeWindow* window);

				Rect								GetBounds()override;
				void								SetMargin(Margin value)override;
			};

			class GuiBoundsComposition : public GuiGraphicsSite, public Description<GuiBoundsComposition>
			{
			protected:
				Rect								compositionBounds;
				Rect								previousBounds;
				Margin								alignmentToParent;
				
			public:
				GuiBoundsComposition();
				~GuiBoundsComposition();

				compositions::GuiNotifyEvent		BoundsChanged;
				
				Rect								GetPreferredBounds()override;
				Rect								GetBounds()override;
				void								SetBounds(Rect value);

				void								ClearAlignmentToParent();
				Margin								GetAlignmentToParent();
				void								SetAlignmentToParent(Margin value);
				bool								IsAlignedToParent();
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSCOMPOSITION\GUIGRAPHICSTABLECOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTABLECOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTABLECOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Table Compositions
***********************************************************************/

			class GuiTableComposition;
			class GuiCellComposition;

			struct GuiCellOption
			{
				enum ComposeType
				{
					Absolute,
					Percentage,
					MinSize,
				};

				ComposeType		composeType;
				vint				absolute;
				double			percentage;

				GuiCellOption()
					:composeType(Absolute)
					,absolute(20)
					,percentage(0)
				{
				}

				bool operator==(const GuiCellOption& value){return false;}
				bool operator!=(const GuiCellOption& value){return true;}

				static GuiCellOption AbsoluteOption(vint value)
				{
					GuiCellOption option;
					option.composeType=Absolute;
					option.absolute=value;
					return option;
				}
				
				static GuiCellOption PercentageOption(double value)
				{
					GuiCellOption option;
					option.composeType=Percentage;
					option.percentage=value;
					return option;
				}
				
				static GuiCellOption MinSizeOption()
				{
					GuiCellOption option;
					option.composeType=MinSize;
					return option;
				}
			};

			class GuiTableComposition : public GuiBoundsComposition, public Description<GuiTableComposition>
			{
				friend class GuiCellComposition;
			protected:
				vint											rows;
				vint											columns;
				vint											cellPadding;
				vint											rowExtending;
				vint											columnExtending;
				collections::Array<GuiCellOption>			rowOptions;
				collections::Array<GuiCellOption>			columnOptions;
				collections::Array<GuiCellComposition*>		cellCompositions;
				collections::Array<Rect>					cellBounds;
				Rect										previousBounds;
				Size										previousContentMinSize;
				Size										tableContentMinSize;

				vint									GetSiteIndex(vint _rows, vint _columns, vint _row, vint _column);
				void								SetSitedCell(vint _row, vint _column, GuiCellComposition* cell);

				void								UpdateCellBoundsInternal(
														collections::Array<vint>& dimSizes,
														vint& dimSize, 
														vint& dimSizeWithPercentage,
														collections::Array<GuiCellOption>& dimOptions,
														vint GuiTableComposition::* dim1,
														vint GuiTableComposition::* dim2,
														vint (*getSize)(Size),
														vint (*getLocation)(GuiCellComposition*),
														vint (*getSpan)(GuiCellComposition*),
														vint (*getRow)(vint, vint),
														vint (*getCol)(vint, vint),
														vint maxPass
														);
				void								UpdateCellBoundsPercentages(
														collections::Array<vint>& dimSizes,
														vint dimSize,
														vint maxDimSize,
														collections::Array<GuiCellOption>& dimOptions
														);
				vint									UpdateCellBoundsOffsets(
														collections::Array<vint>& offsets,
														collections::Array<vint>& sizes,
														vint start,
														vint max
														);
				
				void								UpdateCellBoundsInternal();
				void								UpdateTableContentMinSize();
				void								OnRenderTargetChanged()override;
			public:
				GuiTableComposition();
				~GuiTableComposition();

				vint									GetRows();
				vint									GetColumns();
				bool								SetRowsAndColumns(vint _rows, vint _columns);
				GuiCellComposition*					GetSitedCell(vint _row, vint _column);

				GuiCellOption						GetRowOption(vint _row);
				void								SetRowOption(vint _row, GuiCellOption option);
				GuiCellOption						GetColumnOption(vint _column);
				void								SetColumnOption(vint _column, GuiCellOption option);

				vint									GetCellPadding();
				void								SetCellPadding(vint value);
				Rect								GetCellArea();
				void								UpdateCellBounds();
				
				void								ForceCalculateSizeImmediately()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
			};

			class GuiCellComposition : public GuiGraphicsSite, public Description<GuiCellComposition>
			{
				friend class GuiTableComposition;
			protected:
				vint									row;
				vint									rowSpan;
				vint									column;
				vint									columnSpan;
				GuiTableComposition*				tableParent;
				Size								lastPreferredSize;
				
				void								ClearSitedCells(GuiTableComposition* table);
				void								SetSitedCells(GuiTableComposition* table);
				void								ResetSiteInternal();
				bool								SetSiteInternal(vint _row, vint _column, vint _rowSpan, vint _columnSpan);
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnTableRowsAndColumnsChanged();
			public:
				GuiCellComposition();
				~GuiCellComposition();

				GuiTableComposition*				GetTableParent();

				vint									GetRow();
				vint									GetRowSpan();
				vint									GetColumn();
				vint									GetColumnSpan();
				bool								SetSite(vint _row, vint _column, vint _rowSpan, vint _columnSpan);

				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSCOMPOSITION\GUIGRAPHICSSTACKCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSSTACKCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSSTACKCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Stack Compositions
***********************************************************************/

			class GuiStackComposition;
			class GuiStackItemComposition;

			class GuiStackComposition : public GuiBoundsComposition, public Description<GuiStackComposition>
			{
				friend class GuiStackItemComposition;

				typedef collections::List<GuiStackItemComposition*>				ItemCompositionList;
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction							direction;
				ItemCompositionList					stackItems;
				collections::Array<Rect>			stackItemBounds;
				Size								stackItemTotalSize;
				vint									padding;
				Rect								previousBounds;
				Margin								extraMargin;

				void								UpdateStackItemBounds();
				void								FixStackItemSizes();
				void								OnChildInserted(GuiGraphicsComposition* child)override;
				void								OnChildRemoved(GuiGraphicsComposition* child)override;
			public:
				GuiStackComposition();
				~GuiStackComposition();

				const ItemCompositionList&			GetStackItems();
				bool								InsertStackItem(vint index, GuiStackItemComposition* item);
				
				Direction							GetDirection();
				void								SetDirection(Direction value);
				vint									GetPadding();
				void								SetPadding(vint value);

				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
				
				Margin								GetExtraMargin();
				void								SetExtraMargin(Margin value);
				bool								IsStackItemClipped();
			};
			
			class GuiStackItemComposition : public GuiGraphicsSite, public Description<GuiStackItemComposition>
			{
				friend class GuiStackComposition;
			protected:
				GuiStackComposition*				stackParent;
				Rect								bounds;
				Margin								extraMargin;

				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				Size								GetMinSize();
			public:
				GuiStackItemComposition();
				~GuiStackItemComposition();
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
				void								SetBounds(Rect value);
				
				Margin								GetExtraMargin();
				void								SetExtraMargin(Margin value);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSCOMPOSITION\GUIGRAPHICSSPECIALIZEDCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSSPECIALIZEDCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSSPECIALIZEDCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Specialized Compositions
***********************************************************************/

			class GuiSideAlignedComposition : public GuiGraphicsSite, public Description<GuiSideAlignedComposition>
			{
			public:
				enum Direction
				{
					Left,
					Top,
					Right,
					Bottom,
				};
			protected:
				Direction							direction;
				vint									maxLength;
				double								maxRatio;
			public:
				GuiSideAlignedComposition();
				~GuiSideAlignedComposition();
				
				Direction							GetDirection();
				void								SetDirection(Direction value);
				vint									GetMaxLength();
				void								SetMaxLength(vint value);
				double								GetMaxRatio();
				void								SetMaxRatio(double value);
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};

			class GuiPartialViewComposition : public GuiGraphicsSite, public Description<GuiPartialViewComposition>
			{
			protected:
				double								wRatio;
				double								wPageSize;
				double								hRatio;
				double								hPageSize;

			public:
				GuiPartialViewComposition();
				~GuiPartialViewComposition();
				
				double								GetWidthRatio();
				double								GetWidthPageSize();
				double								GetHeightRatio();
				double								GetHeightPageSize();
				void								SetWidthRatio(double value);
				void								SetWidthPageSize(double value);
				void								SetHeightRatio(double value);
				void								SetHeightPageSize(double value);
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSCOMPOSITION\GUIGRAPHICSCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiSubComponentMeasurer : public Object, public Description<GuiSubComponentMeasurer>
			{
			public:
				class IMeasuringSource : public Interface
				{
				public:
					virtual void						AttachMeasurer(GuiSubComponentMeasurer* value)=0;
					virtual void						DetachMeasurer(GuiSubComponentMeasurer* value)=0;
					virtual GuiSubComponentMeasurer*	GetAttachedMeasurer()=0;
					virtual WString						GetMeasuringCategory()=0;
					virtual vint							GetSubComponentCount()=0;
					virtual WString						GetSubComponentName(vint index)=0;
					virtual GuiGraphicsComposition*		GetSubComponentComposition(vint index)=0;
					virtual GuiGraphicsComposition*		GetSubComponentComposition(const WString& name)=0;
					virtual GuiGraphicsComposition*		GetMainComposition()=0;
					virtual void						SubComponentPreferredMinSizeUpdated()=0;
				};
				
				enum Direction
				{
					Horizontal,
					Vertical,
				};

				class MeasuringSource : public Object, public IMeasuringSource
				{
					typedef collections::Dictionary<WString, GuiGraphicsComposition*>	SubComponentMap;
				protected:
					GuiSubComponentMeasurer*			measurer;
					WString								measuringCategory;
					GuiGraphicsComposition*				mainComposition;
					SubComponentMap						subComponents;

				public:
					MeasuringSource(const WString& _measuringCategory, GuiGraphicsComposition* _mainComposition);
					~MeasuringSource();

					bool								AddSubComponent(const WString& name, GuiGraphicsComposition* composition);
					void								AttachMeasurer(GuiSubComponentMeasurer* value)override;
					void								DetachMeasurer(GuiSubComponentMeasurer* value)override;
					GuiSubComponentMeasurer*			GetAttachedMeasurer()override;
					WString								GetMeasuringCategory()override;
					vint									GetSubComponentCount()override;
					WString								GetSubComponentName(vint index)override;
					GuiGraphicsComposition*				GetSubComponentComposition(vint index)override;
					GuiGraphicsComposition*				GetSubComponentComposition(const WString& name)override;
					GuiGraphicsComposition*				GetMainComposition()override;
					void								SubComponentPreferredMinSizeUpdated()override;
				};
			protected:
				typedef collections::List<IMeasuringSource*>	MeasuringSourceList;

				MeasuringSourceList						measuringSources;
			public:
				GuiSubComponentMeasurer();
				~GuiSubComponentMeasurer();

				bool									AttachMeasuringSource(IMeasuringSource* value);
				bool									DetachMeasuringSource(IMeasuringSource* value);
				void									MeasureAndUpdate(const WString& measuringCategory, Direction direction);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSHOST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Animation
***********************************************************************/

			class IGuiGraphicsAnimation : public virtual IDescriptable, public Description<IGuiGraphicsAnimation>
			{
			public:
				virtual vint						GetTotalLength()=0;
				virtual vint						GetCurrentPosition()=0;
				virtual void					Play(vint currentPosition, vint totalLength)=0;
				virtual void					Stop()=0;
			};

			class GuiGraphicsAnimationManager : public Object
			{
				typedef collections::List<Ptr<IGuiGraphicsAnimation>>		AnimationList;
			protected:
				AnimationList					playingAnimations;
			public:
				GuiGraphicsAnimationManager();
				~GuiGraphicsAnimationManager();

				void							AddAnimation(Ptr<IGuiGraphicsAnimation> animation);
				bool							HasAnimation();
				void							Play();
			};

/***********************************************************************
Shortcut Key Manager
***********************************************************************/

			class IGuiShortcutKeyManager;

			class IGuiShortcutKeyItem : public Interface, public Description<IGuiShortcutKeyItem>
			{
			public:
				GuiNotifyEvent							Executed;

				virtual IGuiShortcutKeyManager*			GetManager()=0;
				virtual WString							GetName()=0;
			};
			
			class IGuiShortcutKeyManager : public Interface, public Description<IGuiShortcutKeyManager>
			{
			public:
				virtual vint								GetItemCount()=0;
				virtual IGuiShortcutKeyItem*			GetItem(vint index)=0;
				virtual bool							Execute(const NativeWindowKeyInfo& info)=0;
			};

/***********************************************************************
Host
***********************************************************************/

			class GuiGraphicsHost : public Object, private INativeWindowListener, private INativeControllerListener, public Description<GuiGraphicsHost>
			{
				typedef collections::List<GuiGraphicsComposition*>		CompositionList;
			public:
				static const unsigned __int64	CaretInterval=500;
			protected:
				INativeWindow*							nativeWindow;
				IGuiShortcutKeyManager*					shortcutKeyManager;
				GuiWindowComposition*					windowComposition;
				GuiGraphicsComposition*					focusedComposition;
				Size									previousClientSize;
				Size									minSize;
				Point									caretPoint;
				unsigned __int64						lastCaretTime;

				GuiGraphicsAnimationManager				animationManager;
				GuiGraphicsComposition*					mouseCaptureComposition;
				CompositionList							mouseEnterCompositions;

				void									DisconnectCompositionInternal(GuiGraphicsComposition* composition);
				void									MouseCapture(const NativeWindowMouseInfo& info);
				void									MouseUncapture(const NativeWindowMouseInfo& info);
				void									OnCharInput(const NativeWindowCharInfo& info, GuiGraphicsComposition* composition, GuiCharEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									OnKeyInput(const NativeWindowKeyInfo& info, GuiGraphicsComposition* composition, GuiKeyEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									RaiseMouseEvent(GuiMouseEventArgs& arguments, GuiGraphicsComposition* composition, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									OnMouseInput(const NativeWindowMouseInfo& info, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				
			private:
				INativeWindowListener::HitTestResult	HitTest(Point location)override;
				void									Moving(Rect& bounds, bool fixSizeOnly)override;
				void									Moved()override;

				void									LeftButtonDown(const NativeWindowMouseInfo& info)override;
				void									LeftButtonUp(const NativeWindowMouseInfo& info)override;
				void									LeftButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									RightButtonDown(const NativeWindowMouseInfo& info)override;
				void									RightButtonUp(const NativeWindowMouseInfo& info)override;
				void									RightButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonDown(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonUp(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									HorizontalWheel(const NativeWindowMouseInfo& info)override;
				void									VerticalWheel(const NativeWindowMouseInfo& info)override;
				void									MouseMoving(const NativeWindowMouseInfo& info)override;
				void									MouseEntered()override;
				void									MouseLeaved()override;

				void									KeyDown(const NativeWindowKeyInfo& info)override;
				void									KeyUp(const NativeWindowKeyInfo& info)override;
				void									SysKeyDown(const NativeWindowKeyInfo& info)override;
				void									SysKeyUp(const NativeWindowKeyInfo& info)override;
				void									Char(const NativeWindowCharInfo& info)override;

				void									GlobalTimer()override;
			public:
				GuiGraphicsHost();
				~GuiGraphicsHost();

				INativeWindow*							GetNativeWindow();
				void									SetNativeWindow(INativeWindow* _nativeWindow);
				GuiGraphicsComposition*					GetMainComposition();
				void									Render();

				IGuiShortcutKeyManager*					GetShortcutKeyManager();
				void									SetShortcutKeyManager(IGuiShortcutKeyManager* value);

				bool									SetFocus(GuiGraphicsComposition* composition);
				GuiGraphicsComposition*					GetFocusedComposition();
				Point									GetCaretPoint();
				void									SetCaretPoint(Point value, GuiGraphicsComposition* referenceComposition=0);

				GuiGraphicsAnimationManager*			GetAnimationManager();
				void									DisconnectComposition(GuiGraphicsComposition* composition);
			};

/***********************************************************************
Animation Helpers
***********************************************************************/
			
			class GuiTimeBasedAnimation : public IGuiGraphicsAnimation, public Description<GuiTimeBasedAnimation>
			{
			protected:
				unsigned __int64				startTime;
				vint								length;
			public:
				GuiTimeBasedAnimation(vint totalMilliseconds);
				~GuiTimeBasedAnimation();

				void							Restart(vint totalMilliseconds=-1);
				vint								GetTotalLength()override;
				vint								GetCurrentPosition()override;
			};

/***********************************************************************
Shortcut Key Manager Helpers
***********************************************************************/

			class GuiShortcutKeyManager;

			class GuiShortcutKeyItem : public Object, public IGuiShortcutKeyItem
			{
			protected:
				GuiShortcutKeyManager*			shortcutKeyManager;
				bool							ctrl;
				bool							shift;
				bool							alt;
				vint								key;

				void							AttachManager(GuiShortcutKeyManager* manager);
				void							DetachManager(GuiShortcutKeyManager* manager);
			public:
				GuiShortcutKeyItem(GuiShortcutKeyManager* _shortcutKeyManager, bool _ctrl, bool _shift, bool _alt, vint _key);
				~GuiShortcutKeyItem();

				IGuiShortcutKeyManager*			GetManager()override;
				WString							GetName()override;
				bool							CanActivate(const NativeWindowKeyInfo& info);
				bool							CanActivate(bool _ctrl, bool _shift, bool _alt, vint _key);
			};

			class GuiShortcutKeyManager : public Object, public IGuiShortcutKeyManager, public Description<GuiShortcutKeyManager>
			{
				typedef collections::List<Ptr<GuiShortcutKeyItem>>		ShortcutKeyItemList;
			protected:
				ShortcutKeyItemList				shortcutKeyItems;

			public:
				GuiShortcutKeyManager();
				~GuiShortcutKeyManager();

				vint								GetItemCount()override;
				IGuiShortcutKeyItem*			GetItem(vint index)override;
				bool							Execute(const NativeWindowKeyInfo& info)override;

				IGuiShortcutKeyItem*			CreateShortcut(bool ctrl, bool shift, bool alt, vint key);
				bool							DestroyShortcut(bool ctrl, bool shift, bool alt, vint key);
				IGuiShortcutKeyItem*			TryGetShortcut(bool ctrl, bool shift, bool alt, vint key);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\GUIBASICCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Basic Construction
***********************************************************************/

			class GuiControl : public Object, public Description<GuiControl>
			{
				friend class compositions::GuiGraphicsComposition;
				typedef collections::List<GuiControl*>		ControlList;
			public:
				class IStyleController : public virtual IDescriptable, public Description<IStyleController>
				{
				public:
					virtual compositions::GuiBoundsComposition*		GetBoundsComposition()=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					virtual void									SetText(const WString& value)=0;
					virtual void									SetFont(const FontProperties& value)=0;
					virtual void									SetVisuallyEnabled(bool value)=0;
				};

				class EmptyStyleController : public Object, public IStyleController, public Description<EmptyStyleController>
				{
				protected:
					compositions::GuiBoundsComposition*				boundsComposition;
				public:
					EmptyStyleController();
					~EmptyStyleController();

					compositions::GuiBoundsComposition*				GetBoundsComposition()override;
					compositions::GuiGraphicsComposition*			GetContainerComposition()override;
					void											SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
					void											SetText(const WString& value)override;
					void											SetFont(const FontProperties& value)override;
					void											SetVisuallyEnabled(bool value)override;
				};

				class IStyleProvider : public virtual IDescriptable, public Description<IStyleProvider>
				{
				public:
					virtual void								AssociateStyleController(IStyleController* controller)=0;
					virtual void								SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					virtual void								SetText(const WString& value)=0;
					virtual void								SetFont(const FontProperties& value)=0;
					virtual void								SetVisuallyEnabled(bool value)=0;
				};
			protected:
				Ptr<IStyleController>							styleController;
				compositions::GuiBoundsComposition*				boundsComposition;
				compositions::GuiGraphicsComposition*			focusableComposition;
				compositions::GuiGraphicsEventReceiver*			eventReceiver;

				bool									isEnabled;
				bool									isVisuallyEnabled;
				bool									isVisible;
				WString									text;
				FontProperties							font;

				GuiControl*								parent;
				ControlList								children;
				Ptr<Object>								tag;

				virtual void							OnChildInserted(GuiControl* control);
				virtual void							OnChildRemoved(GuiControl* control);
				virtual void							OnParentChanged(GuiControl* oldParent, GuiControl* newParent);
				virtual void							OnParentLineChanged();
				virtual void							OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget);
				virtual void							OnBeforeReleaseGraphicsHost();
				virtual void							UpdateVisuallyEnabled();
				void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);
			public:
				GuiControl(IStyleController* _styleController);
				~GuiControl();

				compositions::GuiNotifyEvent			VisibleChanged;
				compositions::GuiNotifyEvent			EnabledChanged;
				compositions::GuiNotifyEvent			VisuallyEnabledChanged;
				compositions::GuiNotifyEvent			TextChanged;
				compositions::GuiNotifyEvent			FontChanged;

				compositions::GuiEventArgs				GetNotifyEventArguments();
				IStyleController*						GetStyleController();
				compositions::GuiBoundsComposition*		GetBoundsComposition();
				compositions::GuiGraphicsComposition*	GetContainerComposition();
				compositions::GuiGraphicsComposition*	GetFocusableComposition();
				compositions::GuiGraphicsEventReceiver*	GetEventReceiver();
				GuiControl*								GetParent();
				vint										GetChildrenCount();
				GuiControl*								GetChild(vint index);
				bool									AddChild(GuiControl* control);
				
				virtual GuiControlHost*					GetRelatedControlHost();
				virtual bool							GetVisuallyEnabled();
				virtual bool							GetEnabled();
				virtual void							SetEnabled(bool value);
				virtual bool							GetVisible();
				virtual void							SetVisible(bool value);
				virtual const WString&					GetText();
				virtual void							SetText(const WString& value);
				virtual const FontProperties&			GetFont();
				virtual void							SetFont(const FontProperties& value);
				virtual void							SetFocus();

				Ptr<Object>								GetTag();
				void									SetTag(Ptr<Object> value);

				virtual IDescriptable*					QueryService(const WString& identifier);

				template<typename T>
				T* QueryService()
				{
					return dynamic_cast<T*>(QueryService(T::Identifier));
				}
			};

			class GuiComponent : public Object, public Description<GuiComponent>
			{
			public:
				GuiComponent();
				~GuiComponent();
			};

			template<typename T>
			class GuiObjectComponent : public GuiComponent
			{
			public:
				Ptr<T>				object;

				GuiObjectComponent()
				{
				}

				GuiObjectComponent(Ptr<T> _object)
					:object(_object)
				{
				}
			};
			
			class GuiImageData : public Object
			{
			protected:
				Ptr<INativeImage>				image;
				vint								frameIndex;

			public:
				GuiImageData();
				GuiImageData(Ptr<INativeImage> _image, vint _frameIndex);
				~GuiImageData();

				Ptr<INativeImage>				GetImage();
				vint								GetFrameIndex();
			};

/***********************************************************************
Label
***********************************************************************/

			class GuiLabel : public GuiControl, public Description<GuiLabel>
			{
			public:
				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual Color						GetDefaultTextColor()=0;
					virtual void						SetTextColor(Color value)=0;
				};
			protected:
				Color									textColor;
				IStyleController*						styleController;
			public:
				GuiLabel(IStyleController* _styleController);
				~GuiLabel();
				
				Color									GetTextColor();
				void									SetTextColor(Color value);
			};

/***********************************************************************
Buttons
***********************************************************************/

			class GuiButton : public GuiControl, public Description<GuiButton>
			{
			public:
				enum ControlState
				{
					Normal,
					Active,
					Pressed,
				};

				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						Transfer(ControlState value)=0;
				};
			protected:
				IStyleController*						styleController;
				bool									clickOnMouseUp;
				bool									mousePressing;
				bool									mouseHoving;
				ControlState							controlState;
				
				void									OnParentLineChanged()override;
				void									UpdateControlState();
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiButton(IStyleController* _styleController);
				~GuiButton();

				compositions::GuiNotifyEvent			Clicked;

				bool									GetClickOnMouseUp();
				void									SetClickOnMouseUp(bool value);
			};

			class GuiSelectableButton : public GuiButton, public Description<GuiSelectableButton>
			{
			public:
				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						SetSelected(bool value)=0;
				};

				class GroupController : public GuiComponent, public Description<GroupController>
				{
				protected:
					collections::List<GuiSelectableButton*>	buttons;
				public:
					GroupController();
					~GroupController();

					virtual void						Attach(GuiSelectableButton* button);
					virtual void						Detach(GuiSelectableButton* button);
					virtual void						OnSelectedChanged(GuiSelectableButton* button)=0;
				};

				class MutexGroupController : public GroupController, public Description<MutexGroupController>
				{
				protected:
					bool								suppress;
				public:
					MutexGroupController();
					~MutexGroupController();

					void								OnSelectedChanged(GuiSelectableButton* button)override;
				};

			protected:
				IStyleController*						styleController;
				GroupController*						groupController;
				bool									autoSelection;
				bool									isSelected;

				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiSelectableButton(IStyleController* _styleController);
				~GuiSelectableButton();

				compositions::GuiNotifyEvent			GroupControllerChanged;
				compositions::GuiNotifyEvent			AutoSelectionChanged;
				compositions::GuiNotifyEvent			SelectedChanged;

				virtual GroupController*				GetGroupController();
				virtual void							SetGroupController(GroupController* value);
				
				virtual bool							GetAutoSelection();
				virtual void							SetAutoSelection(bool value);
				
				virtual bool							GetSelected();
				virtual void							SetSelected(bool value);
			};

/***********************************************************************
Scrolls
***********************************************************************/

			class GuiScroll : public GuiControl, public Description<GuiScroll>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void						SmallDecrease()=0;
					virtual void						SmallIncrease()=0;
					virtual void						BigDecrease()=0;
					virtual void						BigIncrease()=0;

					virtual void						SetTotalSize(vint value)=0;
					virtual void						SetPageSize(vint value)=0;
					virtual void						SetPosition(vint value)=0;
				};
				
				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void						SetTotalSize(vint value)=0;
					virtual void						SetPageSize(vint value)=0;
					virtual void						SetPosition(vint value)=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiScroll*							scroll;
				public:
					CommandExecutor(GuiScroll* _scroll);
					~CommandExecutor();

					void								SmallDecrease()override;
					void								SmallIncrease()override;
					void								BigDecrease()override;
					void								BigIncrease()override;

					void								SetTotalSize(vint value)override;
					void								SetPageSize(vint value)override;
					void								SetPosition(vint value)override;
				};

				IStyleController*						styleController;
				Ptr<CommandExecutor>					commandExecutor;
				vint										totalSize;
				vint										pageSize;
				vint										position;
				vint										smallMove;
				vint										bigMove;
			public:
				GuiScroll(IStyleController* _styleController);
				~GuiScroll();
				
				compositions::GuiNotifyEvent			TotalSizeChanged;
				compositions::GuiNotifyEvent			PageSizeChanged;
				compositions::GuiNotifyEvent			PositionChanged;
				compositions::GuiNotifyEvent			SmallMoveChanged;
				compositions::GuiNotifyEvent			BigMoveChanged;
				
				virtual vint								GetTotalSize();
				virtual void							SetTotalSize(vint value);
				virtual vint								GetPageSize();
				virtual void							SetPageSize(vint value);
				virtual vint								GetPosition();
				virtual void							SetPosition(vint value);
				virtual vint								GetSmallMove();
				virtual void							SetSmallMove(vint value);
				virtual vint								GetBigMove();
				virtual void							SetBigMove(vint value);
				
				vint										GetMinPosition();
				vint										GetMaxPosition();
			};
			
			namespace list
			{
/***********************************************************************
List interface common implementation
***********************************************************************/

				template<typename T, typename K=typename KeyType<T>::Type>
				class ItemsBase : public Object, public virtual collections::IEnumerable<T>
				{
				protected:
					collections::List<T, K>					items;

					virtual void NotifyUpdateInternal(vint start, vint count, vint newCount)
					{
					}

					virtual bool InsertInternal(vint index, const T& value)
					{
						items.Insert(index, value);
						return true;
					}

					virtual bool RemoveAtInternal(vint index, const T& value)
					{
						items.RemoveAt(index);
						return true;
					}
					
				public:
					ItemsBase()
					{
					}

					~ItemsBase()
					{
					}

					collections::IEnumerator<T>* CreateEnumerator()const
					{
						return items.CreateEnumerator();
					}

					bool NotifyUpdate(vint start, vint count=1)
					{
						if(start<0 || start>=items.Count() || count<=0 || start+count>items.Count())
						{
							return false;
						}
						else
						{
							NotifyUpdateInternal(start, count, count);
							return true;
						}
					}

					bool Contains(const K& item)const
					{
						return items.Contains(item);
					}

					vint Count()const
					{
						return items.Count();
					}

					vint Count()
					{
						return items.Count();
					}

					const T& Get(vint index)const
					{
						return items.Get(index);
					}

					const T& operator[](vint index)const
					{
						return items.Get(index);
					}

					vint IndexOf(const K& item)const
					{
						return items.IndexOf(item);
					}

					vint Add(const T& item)
					{
						return Insert(items.Count(), item);
					}

					bool Remove(const K& item)
					{
						vint index=items.IndexOf(item);
						if(index==-1) return false;
						return RemoveAt(index);
					}

					bool RemoveAt(vint index)
					{
						if(RemoveAtInternal(index, items[index]))
						{
							NotifyUpdateInternal(index, 1, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					bool RemoveRange(vint index, vint count)
					{
						if(count<=0) return false;
						if(0<=index && index<items.Count() && index+count<=items.Count())
						{
							while(count-->0)
							{
								RemoveAt(index+count);
							}
							return true;
						}
						else
						{
							return false;
						}
					}

					bool Clear()
					{
						while(items.Count()>0)
						{
							RemoveAt(items.Count()-1);
						}
						return true;
					}

					vint Insert(vint index, const T& item)
					{
						if(InsertInternal(index, item))
						{
							NotifyUpdateInternal(index, 0, 1);
							return index;
						}
						else
						{
							return -1;
						}
					}

					bool Set(vint index, const T& item)
					{
						if(Insert(index, item))
						{
							return RemoveAt(index+1);
						}
						else
						{
							return false;
						}
					}
				};
			}
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<typename T>
			struct RandomAccessable<presentation::controls::list::ItemsBase<T>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\GUIWINDOWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Control Host
***********************************************************************/

			class GuiControlHost : public GuiControl, private INativeWindowListener, public Description<GuiControlHost>
			{
			protected:
				compositions::GuiGraphicsHost*			host;
				collections::List<GuiComponent*>		components;

				virtual void							OnNativeWindowChanged();
				virtual void							OnVisualStatusChanged();
			private:
				
				void									Moved()override;
				void									Enabled()override;
				void									Disabled()override;
				void									GotFocus()override;
				void									LostFocus()override;
				void									Activated()override;
				void									Deactivated()override;
				void									Opened()override;
				void									Closing(bool& cancel)override;
				void									Closed()override;
				void									Destroying()override;
			public:
				GuiControlHost(GuiControl::IStyleController* _styleController);
				~GuiControlHost();
				
				compositions::GuiNotifyEvent			WindowGotFocus;
				compositions::GuiNotifyEvent			WindowLostFocus;
				compositions::GuiNotifyEvent			WindowActivated;
				compositions::GuiNotifyEvent			WindowDeactivated;
				compositions::GuiNotifyEvent			WindowOpened;
				compositions::GuiRequestEvent			WindowClosing;
				compositions::GuiNotifyEvent			WindowClosed;
				compositions::GuiNotifyEvent			WindowDestroying;

				compositions::GuiGraphicsHost*			GetGraphicsHost();
				compositions::GuiGraphicsComposition*	GetMainComposition();
				INativeWindow*							GetNativeWindow();
				void									SetNativeWindow(INativeWindow* window);
				void									ForceCalculateSizeImmediately();
				void									Render();
				
				bool									GetEnabled()override;
				void									SetEnabled(bool value)override;
				bool									GetFocused();
				void									SetFocused();
				bool									GetActivated();
				void									SetActivated();
				bool									GetShowInTaskBar();
				void									SetShowInTaskBar(bool value);
				bool									GetEnabledActivate();
				void									SetEnabledActivate(bool value);
				bool									GetTopMost();
				void									SetTopMost(bool topmost);

				bool									AddComponent(GuiComponent* component);
				bool									RemoveComponent(GuiComponent* component);
				bool									ContainsComponent(GuiComponent* component);
				compositions::IGuiShortcutKeyManager*	GetShortcutKeyManager();
				void									SetShortcutKeyManager(compositions::IGuiShortcutKeyManager* value);

				Size									GetClientSize();
				void									SetClientSize(Size value);
				Rect									GetBounds();
				void									SetBounds(Rect value);
				GuiControlHost*							GetRelatedControlHost()override;
				const WString&							GetText()override;
				void									SetText(const WString& value)override;

				INativeScreen*							GetRelatedScreen();
				void									Show();
				void									ShowDeactivated();
				void									ShowRestored();
				void									ShowMaximized();
				void									ShowMinimized();
				void									Hide();
				void									Close();
				bool									GetOpening();
			};

/***********************************************************************
Window
***********************************************************************/

			class GuiWindow : public GuiControlHost, public Description<GuiWindow>
			{
				friend class GuiApplication;
			public:
				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						AttachWindow(GuiWindow* _window)=0;
					virtual void						InitializeNativeWindowProperties()=0;
					virtual bool						GetMaximizedBox()=0;
					virtual void						SetMaximizedBox(bool visible)=0;
					virtual bool						GetMinimizedBox()=0;
					virtual void						SetMinimizedBox(bool visible)=0;
					virtual bool						GetBorder()=0;
					virtual void						SetBorder(bool visible)=0;
					virtual bool						GetSizeBox()=0;
					virtual void						SetSizeBox(bool visible)=0;
					virtual bool						GetIconVisible()=0;
					virtual void						SetIconVisible(bool visible)=0;
					virtual bool						GetTitleBar()=0;
					virtual void						SetTitleBar(bool visible)=0;
				};
				
				class DefaultBehaviorStyleController : virtual public IStyleController
				{
				protected:
					GuiWindow*							window;
				public:
					DefaultBehaviorStyleController();
					~DefaultBehaviorStyleController();

					void								AttachWindow(GuiWindow* _window)override;
					void								InitializeNativeWindowProperties()override;
					bool								GetMaximizedBox()override;
					void								SetMaximizedBox(bool visible)override;
					bool								GetMinimizedBox()override;
					void								SetMinimizedBox(bool visible)override;
					bool								GetBorder()override;
					void								SetBorder(bool visible)override;
					bool								GetSizeBox()override;
					void								SetSizeBox(bool visible)override;
					bool								GetIconVisible()override;
					void								SetIconVisible(bool visible)override;
					bool								GetTitleBar()override;
					void								SetTitleBar(bool visible)override;
				};
			protected:
				IStyleController*						styleController;

				void									OnNativeWindowChanged()override;
				void									OnVisualStatusChanged()override;
				virtual void							MouseClickedOnOtherWindow(GuiWindow* window);
			public:
				GuiWindow(IStyleController* _styleController);
				~GuiWindow();

				compositions::GuiNotifyEvent			ClipboardUpdated;

				void									MoveToScreenCenter();
				
				bool									GetMaximizedBox();
				void									SetMaximizedBox(bool visible);
				bool									GetMinimizedBox();
				void									SetMinimizedBox(bool visible);
				bool									GetBorder();
				void									SetBorder(bool visible);
				bool									GetSizeBox();
				void									SetSizeBox(bool visible);
				bool									GetIconVisible();
				void									SetIconVisible(bool visible);
				bool									GetTitleBar();
				void									SetTitleBar(bool visible);
			};
			
			class GuiPopup : public GuiWindow, public Description<GuiPopup>
			{
			protected:
				void									MouseClickedOnOtherWindow(GuiWindow* window)override;

				void									PopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									PopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiPopup(IStyleController* _styleController);
				~GuiPopup();

				bool									IsClippedByScreen(Point location);
				void									ShowPopup(Point location);
				void									ShowPopup(GuiControl* control, bool preferredTopBottomSide);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\GUIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION
#define VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiApplication : public Object, private INativeControllerListener
			{
				friend void GuiApplicationInitialize();
				friend class GuiWindow;
				friend class GuiPopup;
				friend class Ptr<GuiApplication>;
			private:
				void											LeftButtonDown(Point position)override;
				void											LeftButtonUp(Point position)override;
				void											RightButtonDown(Point position)override;
				void											RightButtonUp(Point position)override;
				void											ClipboardUpdated()override;
			protected:
				GuiWindow*										mainWindow;
				collections::List<GuiWindow*>					windows;
				collections::SortedList<GuiPopup*>				openingPopups;

				GuiApplication();
				~GuiApplication();

				void											RegisterWindow(GuiWindow* window);
				void											UnregisterWindow(GuiWindow* window);
				void											RegisterPopupOpened(GuiPopup* popup);
				void											RegisterPopupClosed(GuiPopup* popup);
				void											OnMouseDown(Point location);
			public:
				void											Run(GuiWindow* _mainWindow);
				const collections::List<GuiWindow*>&			GetWindows();
				GuiWindow*										GetWindow(Point location);
				WString											GetExecutablePath();
				WString											GetExecutableFolder();

				bool											IsInMainThread();
				void											InvokeAsync(INativeAsyncService::AsyncTaskProc* proc, void* argument);
				void											InvokeInMainThread(INativeAsyncService::AsyncTaskProc* proc, void* argument);
				bool											InvokeInMainThreadAndWait(INativeAsyncService::AsyncTaskProc* proc, void* argument, vint milliseconds=-1);
				void											InvokeAsync(const Func<void()>& proc);
				void											InvokeInMainThread(const Func<void()>& proc);
				bool											InvokeInMainThreadAndWait(const Func<void()>& proc, vint milliseconds=-1);

				template<typename T>
				void InvokeLambdaInMainThread(const T& proc)
				{
					InvokeInMainThread(Func<void()>(proc));
				}
				
				template<typename T>
				bool InvokeLambdaInMainThreadAndWait(const T& proc, vint milliseconds=-1)
				{
					return InvokeInMainThreadAndWait(Func<void()>(proc), milliseconds);
				}
			};

			extern GuiApplication*								GetApplication();
		}
	}
}

extern void GuiApplicationMain();

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\GUICONTAINERCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
/***********************************************************************
Tab Control
***********************************************************************/

			class GuiTab;

			class GuiTabPage : public Object, public Description<GuiTabPage>
			{
				friend class GuiTab;
				friend class Ptr<GuiTabPage>;
			protected:
				GuiControl*										container;
				GuiTab*											owner;
				WString											text;
				
				GuiTabPage();
				~GuiTabPage();

				bool											AssociateTab(GuiTab* _owner, GuiControl::IStyleController* _styleController);
				bool											DeassociateTab(GuiTab* _owner);
			public:
				compositions::GuiNotifyEvent					TextChanged;
				compositions::GuiNotifyEvent					PageInstalled;
				compositions::GuiNotifyEvent					PageUninstalled;
				compositions::GuiNotifyEvent					PageContainerReady;

				GuiControl*										GetContainer();
				GuiTab*											GetOwnerTab();
				const WString&									GetText();
				void											SetText(const WString& param);
				bool											GetSelected();
			};

			class GuiTab : public GuiControl, public Description<GuiTab>
			{
				friend class GuiTabPage;
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void								ShowTab(vint index)=0;
				};
				
				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void								SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void								InsertTab(vint index)=0;
					virtual void								SetTabText(vint index, const WString& value)=0;
					virtual void								RemoveTab(vint index)=0;
					virtual void								MoveTab(vint oldIndex, vint newIndex)=0;
					virtual void								SetSelectedTab(vint index)=0;
					virtual GuiControl::IStyleController*		CreateTabPageStyleController()=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiTab*										tab;
				public:
					CommandExecutor(GuiTab* _tab);
					~CommandExecutor();

					void										ShowTab(vint index)override;
				};

				Ptr<CommandExecutor>							commandExecutor;
				IStyleController*								styleController;
				collections::List<GuiTabPage*>					tabPages;
				GuiTabPage*										selectedPage;
			public:
				GuiTab(IStyleController* _styleController);
				~GuiTab();

				compositions::GuiNotifyEvent					SelectedPageChanged;

				GuiTabPage*										CreatePage(vint index=-1);
				bool											CreatePage(GuiTabPage* page, vint index=-1);
				bool											RemovePage(GuiTabPage* value);
				bool											MovePage(GuiTabPage* page, vint newIndex);
				const collections::List<GuiTabPage*>&			GetPages();

				GuiTabPage*										GetSelectedPage();
				bool											SetSelectedPage(GuiTabPage* value);
			};

/***********************************************************************
Scroll View
***********************************************************************/

			class GuiScrollView : public GuiControl, public Description<GuiScrollView>
			{
			public:
				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiScroll::IStyleController*			CreateHorizontalScrollStyle()=0;
					virtual GuiScroll::IStyleController*			CreateVerticalScrollStyle()=0;
					virtual vint										GetDefaultScrollSize()=0;
					virtual compositions::GuiGraphicsComposition*	InstallBackground(compositions::GuiBoundsComposition* boundsComposition)=0;
				};
				
				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>						styleProvider;
					GuiScrollView*							scrollView;
					GuiScroll*								horizontalScroll;
					GuiScroll*								verticalScroll;
					compositions::GuiBoundsComposition*		boundsComposition;
					compositions::GuiTableComposition*		tableComposition;
					compositions::GuiCellComposition*		containerCellComposition;
					compositions::GuiBoundsComposition*		containerComposition;
					bool									horizontalAlwaysVisible;
					bool									verticalAlwaysVisible;

					void									UpdateTable();
				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetScrollView(GuiScrollView* _scrollView);
					void									AdjustView(Size fullSize);
					IStyleProvider*							GetStyleProvider();

					GuiScroll*								GetHorizontalScroll();
					GuiScroll*								GetVerticalScroll();
					compositions::GuiTableComposition*		GetInternalTableComposition();
					compositions::GuiBoundsComposition*		GetInternalContainerComposition();

					bool									GetHorizontalAlwaysVisible();
					void									SetHorizontalAlwaysVisible(bool value);
					bool									GetVerticalAlwaysVisible();
					void									SetVerticalAlwaysVisible(bool value);

					compositions::GuiBoundsComposition*		GetBoundsComposition()override;
					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};
			protected:

				StyleController*						styleController;
				bool									supressScrolling;

				void									OnContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnVerticalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									CallUpdateView();
				void									Initialize();

				virtual Size							QueryFullSize()=0;
				virtual void							UpdateView(Rect viewBounds)=0;
				
				GuiScrollView(StyleController* _styleController);
			public:
				GuiScrollView(IStyleProvider* styleProvider);
				~GuiScrollView();

				void									CalculateView();
				Size									GetViewSize();
				Rect									GetViewBounds();
				
				GuiScroll*								GetHorizontalScroll();
				GuiScroll*								GetVerticalScroll();
				bool									GetHorizontalAlwaysVisible();
				void									SetHorizontalAlwaysVisible(bool value);
				bool									GetVerticalAlwaysVisible();
				void									SetVerticalAlwaysVisible(bool value);
			};
			
			class GuiScrollContainer : public GuiScrollView, public Description<GuiScrollContainer>
			{
			public:
				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					compositions::GuiBoundsComposition*		controlContainerComposition;
					bool									extendToFullWidth;
				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									MoveContainer(Point leftTop);

					bool									GetExtendToFullWidth();
					void									SetExtendToFullWidth(bool value);
				};

			protected:
				StyleController*						styleController;

				void									OnControlContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				Size									QueryFullSize()override;
				void									UpdateView(Rect viewBounds)override;
			public:
				GuiScrollContainer(GuiScrollContainer::IStyleProvider* styleProvider);
				~GuiScrollContainer();
				
				bool									GetExtendToFullWidth();
				void									SetExtendToFullWidth(bool value);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\TEXTEDITORPACKAGE\GUITEXTGENERALOPERATIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTELEMENTOPERATOR
#define VCZH_PRESENTATION_CONTROLS_GUITEXTELEMENTOPERATOR


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Operations
***********************************************************************/

			class ICommonTextEditCallback : public virtual IDescriptable, public Description<ICommonTextEditCallback>
			{
			public:
				virtual void							Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock)=0;
				virtual void							Detach()=0;
				virtual void							TextEditNotify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\TEXTEDITORPACKAGE\GUITEXTCOLORIZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCOLORIZER
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCOLORIZER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Colorizer
***********************************************************************/
			
			class GuiTextBoxColorizerBase : public Object, public ICommonTextEditCallback
			{
			public:
				typedef collections::Array<elements::text::ColorEntry>			ColorArray;
			protected:
				elements::GuiColorizedTextElement*			element;
				SpinLock*									elementModifyLock;
				volatile vint								colorizedLineCount;
				volatile bool								isColorizerRunning;
				volatile bool								isFinalizing;
				SpinLock									colorizerRunningEvent;

				static void									ColorizerThreadProc(void* argument);

				void										StartColorizer();
				void										StopColorizer();
			public:
				GuiTextBoxColorizerBase();
				~GuiTextBoxColorizerBase();

				void										Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock)override;
				void										Detach()override;
				void										TextEditNotify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
				void										RestartColorizer();

				virtual vint								GetLexerStartState()=0;
				virtual vint								GetContextStartState()=0;
				virtual void								ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, unsigned __int32* colors, vint length, vint& lexerState, vint& contextState)=0;
				virtual const ColorArray&					GetColors()=0;
			};

			class GuiTextBoxRegexColorizer : public GuiTextBoxColorizerBase
			{
			protected:
				Ptr<regex::RegexLexer>										lexer;
				Ptr<regex::RegexLexerColorizer>								colorizer;
				ColorArray													colors;

				elements::text::ColorEntry									defaultColor;
				collections::List<WString>									tokenRegexes;
				collections::List<elements::text::ColorEntry>				tokenColors;
				collections::List<elements::text::ColorEntry>				extraTokenColors;

				static void													ColorizerProc(void* argument, vint start, vint length, vint token);
			public:
				GuiTextBoxRegexColorizer();
				~GuiTextBoxRegexColorizer();

				elements::text::ColorEntry									GetDefaultColor();
				collections::List<WString>&									GetTokenRegexes();
				collections::List<elements::text::ColorEntry>&				GetTokenColors();
				collections::List<elements::text::ColorEntry>&				GetExtraTokenColors();
				vint														GetExtraTokenIndexStart();
				
				bool														SetDefaultColor(elements::text::ColorEntry value);
				vint														AddToken(const WString& regex, elements::text::ColorEntry color);
				vint														AddExtraToken(elements::text::ColorEntry color);
				bool														Setup();
				virtual void												ColorizeTokenContextSensitive(vint lineIndex, const wchar_t* text, vint start, vint length, vint& token, vint& contextState);

				vint														GetLexerStartState()override;
				vint														GetContextStartState()override;
				void														ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, unsigned __int32* colors, vint length, vint& lexerState, vint& contextState)override;
				const ColorArray&											GetColors()override;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\TEXTEDITORPACKAGE\GUITEXTUNDOREDO.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTUNDOREDO
#define VCZH_PRESENTATION_CONTROLS_GUITEXTUNDOREDO


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

			class GuiTextBoxCommonInterface;

/***********************************************************************
Undo Redo
***********************************************************************/

			class GuiGeneralUndoRedoProcessor : public Object
			{
			protected:
				class IEditStep : public Interface
				{
				public:
					virtual void							Undo()=0;
					virtual void							Redo()=0;
				};
				friend class collections::ArrayBase<Ptr<IEditStep>>;

			protected:
				collections::List<Ptr<IEditStep>>			steps;
				vint										firstFutureStep;
				vint										savedStep;
				bool										performingUndoRedo;

				void										PushStep(Ptr<IEditStep> step);
			public:
				GuiGeneralUndoRedoProcessor();
				~GuiGeneralUndoRedoProcessor();

				bool										CanUndo();
				bool										CanRedo();
				void										ClearUndoRedo();
				bool										GetModified();
				void										NotifyModificationSaved();
				bool										Undo();
				bool										Redo();
			};

			class GuiTextBoxUndoRedoProcessor : public GuiGeneralUndoRedoProcessor, public ICommonTextEditCallback
			{
			protected:
				class EditStep : public Object, public IEditStep
				{
				public:
					GuiTextBoxUndoRedoProcessor*			processor;
					TextPos									originalStart;
					TextPos									originalEnd;
					WString									originalText;
					TextPos									inputStart;
					TextPos									inputEnd;
					WString									inputText;
					
					void									Undo();
					void									Redo();
				};

				GuiTextBoxCommonInterface*					textBoxCommonInterface;
			public:
				GuiTextBoxUndoRedoProcessor(GuiTextBoxCommonInterface* _textBoxCommonInterface);
				~GuiTextBoxUndoRedoProcessor();

				void										Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock);
				void										Detach();
				void										TextEditNotify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\TEXTEDITORPACKAGE\GUITEXTCOMMONINTERFACE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCOMMONINTERFACE
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCOMMONINTERFACE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Interface
***********************************************************************/

			class GuiTextBoxCommonInterface : public Description<GuiTextBoxCommonInterface>
			{
			protected:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual TextPos									GetLeftWord(TextPos pos)=0;
					virtual TextPos									GetRightWord(TextPos pos)=0;
					virtual void									GetWord(TextPos pos, TextPos& begin, TextPos& end)=0;
					virtual vint									GetPageRows()=0;
					virtual bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)=0;
					virtual void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
					virtual void									ScrollToView(Point point)=0;
					virtual vint									GetTextMargin()=0;
				};

				class DefaultCallback : public Object, public ICallback, public Description<DefaultCallback>
				{
				protected:
					elements::GuiColorizedTextElement*				textElement;
					compositions::GuiGraphicsComposition*			textComposition;
					bool											readonly;
				public:
					DefaultCallback(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition);
					~DefaultCallback();

					TextPos											GetLeftWord(TextPos pos)override;
					TextPos											GetRightWord(TextPos pos)override;
					void											GetWord(TextPos pos, TextPos& begin, TextPos& end)override;
					vint											GetPageRows()override;
					bool											BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
				};

			public:
				class ShortcutCommand
				{
				protected:
					bool											ctrl;
					bool											shift;
					vint											key;
					Func<void()>									action;
				public:
					ShortcutCommand(bool _ctrl, bool _shift, vint _key, const Func<void()> _action);
					ShortcutCommand(bool _ctrl, bool _shift, vint _key, const Func<bool()> _action);
					~ShortcutCommand();

					bool											IsTheRightKey(bool _ctrl, bool _shift, vint _key);
					void											Execute();
				};

			private:
				elements::GuiColorizedTextElement*					textElement;
				compositions::GuiGraphicsComposition*				textComposition;
				GuiControl*											textControl;
				ICallback*											callback;
				bool												dragging;
				bool												readonly;
				Ptr<GuiTextBoxColorizerBase>						colorizer;
				Ptr<GuiTextBoxUndoRedoProcessor>					undoRedoProcessor;

				SpinLock											elementModifyLock;
				collections::List<Ptr<ICommonTextEditCallback>>		textEditCallbacks;
				collections::List<Ptr<ShortcutCommand>>				shortcutCommands;

				void												UpdateCaretPoint();
				void												Move(TextPos pos, bool shift);
				void												Modify(TextPos start, TextPos end, const WString& input);
				bool												ProcessKey(vint code, bool shift, bool ctrl);
					
				void												OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void												OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void												OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);

			protected:

				void												Install(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition, GuiControl* _textControl);
				ICallback*											GetCallback();
				void												SetCallback(ICallback* value);
				bool												AttachTextEditCallback(Ptr<ICommonTextEditCallback> value);
				bool												DetachTextEditCallback(Ptr<ICommonTextEditCallback> value);
				void												AddShortcutCommand(Ptr<ShortcutCommand> shortcutCommand);
				elements::GuiColorizedTextElement*					GetTextElement();
				void												UnsafeSetText(const WString& value);

			public:
				GuiTextBoxCommonInterface();
				~GuiTextBoxCommonInterface();

				compositions::GuiNotifyEvent						SelectionChanged;

				//================ clipboard operations

				bool												CanCut();
				bool												CanCopy();
				bool												CanPaste();
				bool												Cut();
				bool												Copy();
				bool												Paste();

				//================ editing control

				bool												GetReadonly();
				void												SetReadonly(bool value);

				//================ text operations

				void												SelectAll();
				void												Select(TextPos begin, TextPos end);
				WString												GetSelectionText();
				void												SetSelectionText(const WString& value);
				
				WString												GetRowText(vint row);
				WString												GetFragmentText(TextPos start, TextPos end);

				TextPos												GetCaretBegin();
				TextPos												GetCaretEnd();
				TextPos												GetCaretSmall();
				TextPos												GetCaretLarge();

				//================ position query

				vint												GetRowWidth(vint row);
				vint												GetRowHeight();
				vint												GetMaxWidth();
				vint												GetMaxHeight();
				TextPos												GetTextPosFromPoint(Point point);
				Point												GetPointFromTextPos(TextPos pos);
				Rect												GetRectFromTextPos(TextPos pos);
				TextPos												GetNearestTextPos(Point point);

				//================ colorizing

				Ptr<GuiTextBoxColorizerBase>						GetColorizer();
				void												SetColorizer(Ptr<GuiTextBoxColorizerBase> value);

				//================ undo redo control

				bool												CanUndo();
				bool												CanRedo();
				void												ClearUndoRedo();
				bool												GetModified();
				void												NotifyModificationSaved();
				bool												Undo();
				bool												Redo();
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\TEXTEDITORPACKAGE\GUITEXTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
MultilineTextBox
***********************************************************************/

			class GuiMultilineTextBox : public GuiScrollView, public GuiTextBoxCommonInterface, public Description<GuiMultilineTextBox>
			{
			public:
				static const vint							TextMargin=3;

				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					elements::GuiColorizedTextElement*			textElement;
					compositions::GuiBoundsComposition*			textComposition;
					GuiMultilineTextBox*						textBox;
					Ptr<GuiTextBoxCommonInterface::ICallback>	defaultCallback;

				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					void									Initialize(GuiMultilineTextBox* control);
					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					void									SetViewPosition(Point value);
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;

					WString									GetText();
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};

				class TextElementOperatorCallback : public GuiTextBoxCommonInterface::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiMultilineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiMultilineTextBox* _textControl);

					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					vint									GetTextMargin()override;
				};

			protected:
				StyleController*							styleController;

				void										CalculateViewAndSetScroll();
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				Size										QueryFullSize()override;
				void										UpdateView(Rect viewBounds)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiMultilineTextBox(GuiMultilineTextBox::IStyleProvider* styleProvider);
				~GuiMultilineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
			};

/***********************************************************************
SinglelineTextBox
***********************************************************************/
			
			class GuiSinglelineTextBox : public GuiControl, public GuiTextBoxCommonInterface, public Description<GuiSinglelineTextBox>
			{
			public:
				static const vint							TextMargin=3;

				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* background)=0;
				};

				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>							styleProvider;
					compositions::GuiBoundsComposition*			boundsComposition;
					compositions::GuiGraphicsComposition*		containerComposition;

					GuiSinglelineTextBox*						textBox;
					elements::GuiColorizedTextElement*			textElement;
					compositions::GuiTableComposition*			textCompositionTable;
					compositions::GuiCellComposition*			textComposition;
					Ptr<GuiTextBoxCommonInterface::ICallback>	defaultCallback;

				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetTextBox(GuiSinglelineTextBox* control);
					void									RearrangeTextElement();
					compositions::GuiBoundsComposition*		GetBoundsComposition();
					compositions::GuiGraphicsComposition*	GetContainerComposition();
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);

					WString									GetText();
					void									SetText(const WString& value);
					void									SetFont(const FontProperties& value);
					void									SetVisuallyEnabled(bool value);

					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					void									SetViewPosition(Point value);
				};

				class TextElementOperatorCallback : public GuiTextBoxCommonInterface::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiSinglelineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiSinglelineTextBox* _textControl);

					bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					vint									GetTextMargin()override;
				};
			protected:
				StyleController*							styleController;
				
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiSinglelineTextBox(GuiSinglelineTextBox::IStyleProvider* styleProvider);
				~GuiSinglelineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				wchar_t										GetPasswordChar();
				void										SetPasswordChar(wchar_t value);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\LISTCONTROLPACKAGE\GUILISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
List Control
***********************************************************************/

			class GuiListControl : public GuiScrollView, public Description<GuiListControl>
			{
			public:
				class IItemProvider;
				class IItemStyleController;
				class IItemStyleProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class IItemProviderCallback : public virtual IDescriptable, public Description<IItemProviderCallback>
				{
				public:
					virtual void								OnAttached(IItemProvider* provider)=0;
					virtual void								OnItemModified(vint start, vint count, vint newCount)=0;
				};

				class IItemArrangerCallback : public virtual IDescriptable, public Description<IItemArrangerCallback>
				{
				public:
					virtual IItemStyleController*					RequestItem(vint itemIndex)=0;
					virtual void									ReleaseItem(IItemStyleController* style)=0;
					virtual void									SetViewLocation(Point value)=0;
					virtual Size									GetStylePreferredSize(IItemStyleController* style)=0;
					virtual void									SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)=0;
					virtual Rect									GetStyleBounds(IItemStyleController* style)=0;
					virtual void									SetStyleBounds(IItemStyleController* style, Rect bounds)=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void									OnTotalSizeChanged()=0;
				};

				//-----------------------------------------------------------
				// Common Views
				//-----------------------------------------------------------

				class IItemPrimaryTextView : public virtual IDescriptable, public Description<IItemPrimaryTextView>
				{
				public:
					static const wchar_t* const					Identifier;

					virtual WString								GetPrimaryTextViewText(vint itemIndex)=0;
					virtual bool								ContainsPrimaryText(vint itemIndex)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				enum KeyDirection
				{
					Up,
					Down,
					Left,
					Right,
					Home,
					End,
					PageUp,
					PageDown,
					PageLeft,
					PageRight,
				};

				class IItemProvider : public virtual IDescriptable, public Description<IItemProvider>
				{
				public:
					virtual bool								AttachCallback(IItemProviderCallback* value)=0;
					virtual bool								DetachCallback(IItemProviderCallback* value)=0;
					virtual vint									Count()=0;
					virtual IDescriptable*						RequestView(const WString& identifier)=0;
					virtual void								ReleaseView(IDescriptable* view)=0;
				};
				
				class IItemStyleController : public virtual IDescriptable, public Description<IItemStyleController>
				{
				public:
					virtual IItemStyleProvider*					GetStyleProvider()=0;
					virtual vint									GetItemStyleId()=0;
					virtual compositions::GuiBoundsComposition*	GetBoundsComposition()=0;
					virtual bool								IsCacheable()=0;
					virtual bool								IsInstalled()=0;
					virtual void								OnInstalled()=0;
					virtual void								OnUninstalled()=0;
				};
				
				class IItemStyleProvider : public virtual IDescriptable, public Description<IItemStyleProvider>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual vint									GetItemStyleId(vint itemIndex)=0;
					virtual IItemStyleController*				CreateItemStyle(vint styleId)=0;
					virtual void								DestroyItemStyle(IItemStyleController* style)=0;
					virtual void								Install(IItemStyleController* style, vint itemIndex)=0;
				};
				
				class IItemArranger : public virtual IItemProviderCallback, public Description<IItemArranger>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual IItemArrangerCallback*				GetCallback()=0;
					virtual void								SetCallback(IItemArrangerCallback* value)=0;
					virtual Size								GetTotalSize()=0;
					virtual IItemStyleController*				GetVisibleStyle(vint itemIndex)=0;
					virtual vint									GetVisibleIndex(IItemStyleController* style)=0;
					virtual void								OnViewChanged(Rect bounds)=0;
					virtual vint									FindItem(vint itemIndex, KeyDirection key)=0;
					virtual bool								EnsureItemVisible(vint itemIndex)=0;
				};
				
				class IItemCoordinateTransformer : public virtual IDescriptable, public Description<IItemCoordinateTransformer>
				{
				public:
					virtual Size								RealSizeToVirtualSize(Size size)=0;
					virtual Size								VirtualSizeToRealSize(Size size)=0;
					virtual Point								RealPointToVirtualPoint(Size realFullSize, Point point)=0;
					virtual Point								VirtualPointToRealPoint(Size realFullSize, Point point)=0;
					virtual Rect								RealRectToVirtualRect(Size realFullSize, Rect rect)=0;
					virtual Rect								VirtualRectToRealRect(Size realFullSize, Rect rect)=0;
					virtual Margin								RealMarginToVirtualMargin(Margin margin)=0;
					virtual Margin								VirtualMarginToRealMargin(Margin margin)=0;
					virtual KeyDirection						RealKeyDirectionToVirtualKeyDirection(KeyDirection key)=0;
				};

			protected:

				//-----------------------------------------------------------
				// ItemCallback
				//-----------------------------------------------------------

				class ItemCallback : public IItemProviderCallback, public IItemArrangerCallback
				{
					typedef collections::List<IItemStyleController*>			StyleList;
				protected:
					GuiListControl*								listControl;
					IItemProvider*								itemProvider;
					StyleList									cachedStyles;
					StyleList									installedStyles;

				public:
					ItemCallback(GuiListControl* _listControl);
					~ItemCallback();

					void										ClearCache();

					void										OnAttached(IItemProvider* provider)override;
					void										OnItemModified(vint start, vint count, vint newCount)override;
					IItemStyleController*						RequestItem(vint itemIndex)override;
					void										ReleaseItem(IItemStyleController* style)override;
					void										SetViewLocation(Point value)override;
					Size										GetStylePreferredSize(IItemStyleController* style)override;
					void										SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)override;
					Rect										GetStyleBounds(IItemStyleController* style)override;
					void										SetStyleBounds(IItemStyleController* style, Rect bounds)override;
					compositions::GuiGraphicsComposition*		GetContainerComposition()override;
					void										OnTotalSizeChanged()override;
				};

				//-----------------------------------------------------------
				// State management
				//-----------------------------------------------------------

				Ptr<ItemCallback>								callback;
				Ptr<IItemProvider>								itemProvider;
				Ptr<IItemStyleProvider>							itemStyleProvider;
				Ptr<IItemArranger>								itemArranger;
				Ptr<IItemCoordinateTransformer>					itemCoordinateTransformer;
				Size											fullSize;

				virtual void									OnItemModified(vint start, vint count, vint newCount);
				virtual void									OnStyleInstalled(vint itemIndex, IItemStyleController* style);
				virtual void									OnStyleUninstalled(IItemStyleController* style);
				
				void											OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void											OnBeforeReleaseGraphicsHost()override;
				Size											QueryFullSize()override;
				void											UpdateView(Rect viewBounds)override;
				
				void											OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											SetStyleProviderAndArranger(Ptr<IItemStyleProvider> styleProvider, Ptr<IItemArranger> arranger);

				//-----------------------------------------------------------
				// Item event management
				//-----------------------------------------------------------

				class VisibleStyleHelper
				{
				public:
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		mouseMoveHandler;
					Ptr<compositions::GuiNotifyEvent::IHandler>		mouseEnterHandler;
					Ptr<compositions::GuiNotifyEvent::IHandler>		mouseLeaveHandler;
				};
				
				friend class collections::ArrayBase<Ptr<VisibleStyleHelper>>;
				collections::Dictionary<IItemStyleController*, Ptr<VisibleStyleHelper>>		visibleStyles;

				void											OnItemMouseEvent(compositions::GuiItemMouseEvent& itemEvent, IItemStyleController* style, compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											OnItemNotifyEvent(compositions::GuiItemNotifyEvent& itemEvent, IItemStyleController* style, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											AttachItemEvents(IItemStyleController* style);
				void											DetachItemEvents(IItemStyleController* style);
			public:
				GuiListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider, bool acceptFocus=false);
				~GuiListControl();

				compositions::GuiNotifyEvent					StyleProviderChanged;
				compositions::GuiNotifyEvent					ArrangerChanged;
				compositions::GuiNotifyEvent					CoordinateTransformerChanged;

				compositions::GuiItemMouseEvent					ItemLeftButtonDown;
				compositions::GuiItemMouseEvent					ItemLeftButtonUp;
				compositions::GuiItemMouseEvent					ItemLeftButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemMiddleButtonDown;
				compositions::GuiItemMouseEvent					ItemMiddleButtonUp;
				compositions::GuiItemMouseEvent					ItemMiddleButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemRightButtonDown;
				compositions::GuiItemMouseEvent					ItemRightButtonUp;
				compositions::GuiItemMouseEvent					ItemRightButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemMouseMove;
				compositions::GuiItemNotifyEvent				ItemMouseEnter;
				compositions::GuiItemNotifyEvent				ItemMouseLeave;

				virtual IItemProvider*							GetItemProvider();
				virtual IItemStyleProvider*						GetStyleProvider();
				virtual Ptr<IItemStyleProvider>					SetStyleProvider(Ptr<IItemStyleProvider> value);
				virtual IItemArranger*							GetArranger();
				virtual Ptr<IItemArranger>						SetArranger(Ptr<IItemArranger> value);
				virtual IItemCoordinateTransformer*				GetCoordinateTransformer();
				virtual Ptr<IItemCoordinateTransformer>			SetCoordinateTransformer(Ptr<IItemCoordinateTransformer> value);
				virtual bool									EnsureItemVisible(vint itemIndex);
			};

/***********************************************************************
Selectable List Control
***********************************************************************/

			class GuiSelectableListControl : public GuiListControl, public Description<GuiSelectableListControl>
			{
			public:
				class IItemStyleProvider : public virtual GuiListControl::IItemStyleProvider, public Description<IItemStyleProvider>
				{
				public:
					virtual void								SetStyleSelected(IItemStyleController* style, bool value)=0;
				};
			protected:

				Ptr<IItemStyleProvider>							selectableStyleProvider;
				collections::SortedList<vint>					selectedItems;
				bool											multiSelect;
				vint												selectedItemIndexStart;
				vint												selectedItemIndexEnd;

				void											OnItemModified(vint start, vint count, vint newCount)override;
				void											OnStyleInstalled(vint itemIndex, IItemStyleController* style)override;
				void											OnStyleUninstalled(IItemStyleController* style)override;
				virtual void									OnItemSelectionChanged(vint itemIndex, bool value);
				virtual void									OnItemSelectionCleared();
				void											OnItemLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);

				void											NormalizeSelectedItemIndexStartEnd();
				void											SetMultipleItemsSelectedSilently(vint start, vint end, bool selected);
				void											OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
			public:
				GuiSelectableListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider);
				~GuiSelectableListControl();

				compositions::GuiNotifyEvent					SelectionChanged;

				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;

				bool											GetMultiSelect();
				void											SetMultiSelect(bool value);
				
				const collections::SortedList<vint>&				GetSelectedItems();
				bool											GetSelected(vint itemIndex);
				void											SetSelected(vint itemIndex, bool value);
				bool											SelectItemsByClick(vint itemIndex, bool ctrl, bool shift);
				bool											SelectItemsByKey(vint code, bool ctrl, bool shift);
				void											ClearSelection();
			};

/***********************************************************************
Predefined ItemCoordinateTransformer
***********************************************************************/

			namespace list
			{
				class DefaultItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<DefaultItemCoordinateTransformer>
				{
				public:
					DefaultItemCoordinateTransformer();
					~DefaultItemCoordinateTransformer();

					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
					GuiListControl::KeyDirection				RealKeyDirectionToVirtualKeyDirection(GuiListControl::KeyDirection key)override;
				};
				
				class AxisAlignedItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<AxisAlignedItemCoordinateTransformer>
				{
				public:
					enum Alignment
					{
						LeftDown,
						RightDown,
						LeftUp,
						RightUp,
						DownLeft,
						DownRight,
						UpLeft,
						UpRight,
					};
				protected:
					Alignment									alignment;

				public:
					AxisAlignedItemCoordinateTransformer(Alignment _alignment);
					~AxisAlignedItemCoordinateTransformer();

					Alignment									GetAlignment();
					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
					GuiListControl::KeyDirection				RealKeyDirectionToVirtualKeyDirection(GuiListControl::KeyDirection key)override;
				};
			};

/***********************************************************************
Predefined ItemArranger
***********************************************************************/

			namespace list
			{
				class RangedItemArrangerBase : public Object, virtual public GuiListControl::IItemArranger, public Description<RangedItemArrangerBase>
				{
					typedef collections::List<GuiListControl::IItemStyleController*>		StyleList;
				protected:
					GuiListControl::IItemArrangerCallback*		callback;
					GuiListControl::IItemProvider*				itemProvider;
					Rect										viewBounds;
					vint											startIndex;
					StyleList									visibleStyles;

					virtual void								ClearStyles();
					virtual void								OnStylesCleared()=0;
					virtual Size								OnCalculateTotalSize()=0;
					virtual void								OnViewChangedInternal(Rect oldBounds, Rect newBounds)=0;
				public:
					RangedItemArrangerBase();
					~RangedItemArrangerBase();

					void										OnAttached(GuiListControl::IItemProvider* provider)override;
					void										OnItemModified(vint start, vint count, vint newCount)override;
					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemArrangerCallback*		GetCallback()override;
					void										SetCallback(GuiListControl::IItemArrangerCallback* value)override;
					Size										GetTotalSize()override;
					GuiListControl::IItemStyleController*		GetVisibleStyle(vint itemIndex)override;
					vint											GetVisibleIndex(GuiListControl::IItemStyleController* style)override;
					void										OnViewChanged(Rect bounds)override;
				};
				
				class FixedHeightItemArranger : public RangedItemArrangerBase, public Description<FixedHeightItemArranger>
				{
				protected:
					vint											rowHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					virtual vint									GetWidth();
					virtual vint									GetYOffset();
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightItemArranger();
					~FixedHeightItemArranger();

					vint											FindItem(vint itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(vint itemIndex)override;
				};

				class FixedSizeMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedSizeMultiColumnItemArranger>
				{
				protected:
					Size										itemSize;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(Size itemSize, Rect bounds, vint count, vint& start, vint& end);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedSizeMultiColumnItemArranger();
					~FixedSizeMultiColumnItemArranger();

					vint											FindItem(vint itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(vint itemIndex)override;
				};
				
				class FixedHeightMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedHeightMultiColumnItemArranger>
				{
				protected:
					vint											itemHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(vint itemHeight, Rect bounds, vint& rows, vint& startColumn);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightMultiColumnItemArranger();
					~FixedHeightMultiColumnItemArranger();

					vint											FindItem(vint itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(vint itemIndex)override;
				};
			}

/***********************************************************************
Predefined ItemStyleController
***********************************************************************/

			namespace list
			{
				class ItemStyleControllerBase : public Object, public virtual GuiListControl::IItemStyleController, public Description<ItemStyleControllerBase>
				{
				protected:
					GuiListControl::IItemStyleProvider*			provider;
					vint											styleId;
					compositions::GuiBoundsComposition*			boundsComposition;
					GuiControl*									associatedControl;
					bool										isInstalled;

					void										Initialize(compositions::GuiBoundsComposition* _boundsComposition, GuiControl* _associatedControl);
					void										Finalize();

					ItemStyleControllerBase(GuiListControl::IItemStyleProvider* _provider, vint _styleId);
				public:
					~ItemStyleControllerBase();
					
					GuiListControl::IItemStyleProvider*			GetStyleProvider()override;
					vint											GetItemStyleId()override;
					compositions::GuiBoundsComposition*			GetBoundsComposition()override;
					bool										IsCacheable()override;
					bool										IsInstalled()override;
					void										OnInstalled()override;
					void										OnUninstalled()override;
				};
			}

/***********************************************************************
Predefined ItemProvider
***********************************************************************/

			namespace list
			{
				class ItemProviderBase : public Object, public virtual GuiListControl::IItemProvider, public Description<ItemProviderBase>
				{
				protected:
					collections::List<GuiListControl::IItemProviderCallback*>	callbacks;

					virtual void								InvokeOnItemModified(vint start, vint count, vint newCount);
				public:
					ItemProviderBase();
					~ItemProviderBase();

					bool										AttachCallback(GuiListControl::IItemProviderCallback* value);
					bool										DetachCallback(GuiListControl::IItemProviderCallback* value);
				};

				template<typename T>
				class ListProvider : public ItemProviderBase, public ItemsBase<T>
				{
				protected:
					void NotifyUpdateInternal(vint start, vint count, vint newCount)
					{
						InvokeOnItemModified(start, count, newCount);
					}
				public:
					vint Count()override
					{
						return items.Count();
					}
				};
			}
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\LISTCONTROLPACKAGE\GUITEXTLISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualTextList;

			namespace list
			{

/***********************************************************************
TextList Style Provider
***********************************************************************/

				class TextItemStyleProvider : public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<TextItemStyleProvider>
				{
				public:
					class ITextItemStyleProvider : public virtual IDescriptable, public Description<ITextItemStyleProvider>
					{
					public:
						virtual GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()=0;
						virtual GuiSelectableButton::IStyleController*		CreateBulletStyleController()=0;
					};

					class ITextItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<ITextItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual WString							GetText(vint itemIndex)=0;
						virtual bool							GetChecked(vint itemIndex)=0;
						virtual void							SetCheckedSilently(vint itemIndex, bool value)=0;
					};

					class TextItemStyleController : public ItemStyleControllerBase, public Description<TextItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						GuiSelectableButton*					bulletButton;
						elements::GuiSolidLabelElement*			textElement;
						TextItemStyleProvider*					textItemStyleProvider;

						void									OnBulletSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						TextItemStyleController(TextItemStyleProvider* provider);
						~TextItemStyleController();
						
						bool									GetSelected();
						void									SetSelected(bool value);
						bool									GetChecked();
						void									SetChecked(bool value);
						const WString&							GetText();
						void									SetText(const WString& value);
					};

				protected:
					Ptr<ITextItemStyleProvider>					textItemStyleProvider;
					ITextItemView*								textItemView;
					GuiListControl*								listControl;

					void										OnStyleCheckedChanged(TextItemStyleController* style);
				public:
					TextItemStyleProvider(ITextItemStyleProvider* _textItemStyleProvider);
					~TextItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					vint											GetItemStyleId(vint itemIndex)override;
					GuiListControl::IItemStyleController*		CreateItemStyle(vint styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, vint itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};

/***********************************************************************
TextList Data Source
***********************************************************************/

				class TextItem
				{
					friend class TextItemProvider;
				protected:
					WString										text;
					bool										checked;
				public:
					TextItem();
					TextItem(const TextItem& item);
					TextItem(const WString& _text, bool _checked=false);
					TextItem(const wchar_t* _text, bool _checked=false);
					~TextItem();

					bool										operator==(const TextItem& value)const;
					bool										operator!=(const TextItem& value)const;
					
					const WString&								GetText()const;
					bool										GetChecked()const;
				};

				class TextItemProvider : public ListProvider<TextItem>, protected TextItemStyleProvider::ITextItemView, public Description<TextItemProvider>
				{
				protected:
					bool										ContainsPrimaryText(vint itemIndex)override;
					WString										GetPrimaryTextViewText(vint itemIndex)override;
					WString										GetText(vint itemIndex)override;
					bool										GetChecked(vint itemIndex)override;
					void										SetCheckedSilently(vint itemIndex, bool value)override;
				public:
					TextItemProvider();
					~TextItemProvider();
					
					void										SetText(vint itemIndex, const WString& value);
					void										SetChecked(vint itemIndex, bool value);

					IDescriptable*								RequestView(const WString& identifier)override;
					void										ReleaseView(IDescriptable* view)override;
				};
			}

/***********************************************************************
TextList Control
***********************************************************************/

			class GuiVirtualTextList : public GuiSelectableListControl, public Description<GuiVirtualTextList>
			{
			public:
				GuiVirtualTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualTextList();
				
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;
				Ptr<GuiListControl::IItemStyleProvider>			ChangeItemStyle(list::TextItemStyleProvider::ITextItemStyleProvider* itemStyleProvider);
			};
			
			class GuiTextList : public GuiVirtualTextList, public Description<GuiTextList>
			{
			protected:
				list::TextItemProvider*							items;
			public:
				GuiTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider);
				~GuiTextList();

				list::TextItemProvider&							GetItems();
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\TOOLSTRIPPACKAGE\GUIMENUCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Menu Service
***********************************************************************/

			class GuiMenu;

			class IGuiMenuService : public virtual IDescriptable, public Description<IGuiMenuService>
			{
			public:
				static const wchar_t* const				Identifier;

				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				GuiMenu*								openingMenu;
			public:
				IGuiMenuService();

				virtual IGuiMenuService*				GetParentMenuService()=0;
				virtual Direction						GetPreferredDirection()=0;
				virtual bool							IsActiveState()=0;
				virtual bool							IsSubMenuActivatedByMouseDown()=0;

				virtual void							MenuItemExecuted();
				virtual GuiMenu*						GetOpeningMenu();
				virtual void							MenuOpened(GuiMenu* menu);
				virtual void							MenuClosed(GuiMenu* menu);
			};

/***********************************************************************
Menu
***********************************************************************/

			class GuiMenu : public GuiPopup, private IGuiMenuService, public Description<GuiMenu>
			{
			private:
				IGuiMenuService*						parentMenuService;

				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				bool									IsSubMenuActivatedByMouseDown()override;
				void									MenuItemExecuted()override;
			protected:
				GuiControl*								owner;

				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
				void									OnWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenu(IStyleController* _styleController, GuiControl* _owner);
				~GuiMenu();

				void									UpdateMenuService();
				IDescriptable*							QueryService(const WString& identifier)override;
			};
			
			class GuiMenuBar : public GuiControl, private IGuiMenuService, public Description<GuiMenuBar>
			{
			private:
				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				bool									IsSubMenuActivatedByMouseDown()override;
			public:
				GuiMenuBar(GuiControl::IStyleController* _styleController);
				~GuiMenuBar();
				
				IDescriptable*							QueryService(const WString& identifier)override;
			};

/***********************************************************************
MenuButton
***********************************************************************/

			class GuiMenuButton : public GuiButton, public Description<GuiMenuButton>
			{
			public:
				static const wchar_t* const				MenuItemSubComponentMeasuringCategoryName;
				class IStyleController : public GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual GuiMenu::IStyleController*	CreateSubMenuStyleController()=0;
					virtual void						SetSubMenuExisting(bool value)=0;
					virtual void						SetSubMenuOpening(bool value)=0;
					virtual GuiButton*					GetSubMenuHost()=0;
					virtual void						SetImage(Ptr<GuiImageData> value)=0;
					virtual void						SetShortcutText(const WString& value)=0;
					virtual compositions::GuiSubComponentMeasurer::IMeasuringSource*	GetMeasuringSource()=0;
				};
			protected:
				IStyleController*						styleController;
				Ptr<GuiImageData>						image;
				WString									shortcutText;
				GuiMenu*								subMenu;
				bool									ownedSubMenu;
				Size									preferredMenuClientSize;
				IGuiMenuService*						ownerMenuService;

				GuiButton*								GetSubMenuHost();
				void									OpenSubMenuInternal();
				void									OnParentLineChanged()override;
				void									OnSubMenuWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnSubMenuWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenuButton(IStyleController* _styleController);
				~GuiMenuButton();

				compositions::GuiNotifyEvent			SubMenuOpeningChanged;
				compositions::GuiNotifyEvent			ImageChanged;
				compositions::GuiNotifyEvent			ShortcutTextChanged;

				Ptr<GuiImageData>						GetImage();
				void									SetImage(Ptr<GuiImageData> value);
				const WString&							GetShortcutText();
				void									SetShortcutText(const WString& value);

				bool									IsSubMenuExists();
				GuiMenu*								GetSubMenu();
				void									CreateSubMenu(GuiMenu::IStyleController* subMenuStyleController=0);
				void									SetSubMenu(GuiMenu* value, bool owned);
				void									DestroySubMenu();
				bool									GetOwnedSubMenu();

				bool									GetSubMenuOpening();
				void									SetSubMenuOpening(bool value);

				Size									GetPreferredMenuClientSize();
				void									SetPreferredMenuClientSize(Size value);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\LISTCONTROLPACKAGE\GUILISTVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiListViewBase;

			namespace list
			{

/***********************************************************************
ListView Base
***********************************************************************/

				class ListViewItemStyleProviderBase: public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<ListViewItemStyleProviderBase>
				{
				public:
					class ListViewItemStyleController : public ItemStyleControllerBase, public Description<ListViewItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						ListViewItemStyleProviderBase*			listViewItemStyleProvider;

					public:
						ListViewItemStyleController(ListViewItemStyleProviderBase* provider);
						~ListViewItemStyleController();

						bool									GetSelected();
						void									SetSelected(bool value);
					};

				protected:
					GuiListViewBase*							listControl;

				public:
					ListViewItemStyleProviderBase();
					~ListViewItemStyleProviderBase();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					vint											GetItemStyleId(vint itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

			class GuiListViewColumnHeader : public GuiMenuButton, public Description<GuiListViewColumnHeader>
			{
			public:
				enum ColumnSortingState
				{
					NotSorted,
					Ascending,
					Descending,
				};
				
				class IStyleController : public virtual GuiMenuButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void								SetColumnSortingState(ColumnSortingState value)=0;
				};

			protected:
				IStyleController*								styleController;
				ColumnSortingState								columnSortingState;

			public:
				GuiListViewColumnHeader(IStyleController* _styleController);
				~GuiListViewColumnHeader();

				ColumnSortingState								GetColumnSortingState();
				void											SetColumnSortingState(ColumnSortingState value);
			};

			class GuiListViewBase : public GuiSelectableListControl, public Description<GuiListViewBase>
			{
			public:
				class IStyleProvider : public virtual GuiSelectableListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiListViewColumnHeader::IStyleController*	CreateColumnStyle()=0;
					virtual Color										GetPrimaryTextColor()=0;
					virtual Color										GetSecondaryTextColor()=0;
					virtual Color										GetItemSeparatorColor()=0;
				};

			protected:
				IStyleProvider*									styleProvider;

			public:
				GuiListViewBase(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiListViewBase();

				compositions::GuiItemNotifyEvent				ColumnClicked;
				
				IStyleProvider*									GetListViewStyleProvider();
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;
			};

/***********************************************************************
ListView ItemStyleProvider
***********************************************************************/

			namespace list
			{
				class ListViewItemStyleProvider : public ListViewItemStyleProviderBase, public Description<ListViewItemStyleProvider>
				{
				public:
					class IListViewItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<IListViewItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual Ptr<GuiImageData>				GetSmallImage(vint itemIndex)=0;
						virtual Ptr<GuiImageData>				GetLargeImage(vint itemIndex)=0;
						virtual WString							GetText(vint itemIndex)=0;
						virtual WString							GetSubItem(vint itemIndex, vint index)=0;

						virtual vint								GetDataColumnCount()=0;
						virtual vint								GetDataColumn(vint index)=0;

						virtual vint								GetColumnCount()=0;
						virtual WString							GetColumnText(vint index)=0;
					};

					class IListViewItemContent : public virtual IDescriptable, public Description<IListViewItemContent>
					{
					public:
						virtual compositions::GuiBoundsComposition*				GetContentComposition()=0;
						virtual compositions::GuiBoundsComposition*				GetBackgroundDecorator()=0;
						virtual void											Install(GuiListViewBase::IStyleProvider* styleProvider, IListViewItemView* view, vint itemIndex)=0;
					};

					class IListViewItemContentProvider : public virtual IDescriptable, public Description<IListViewItemContentProvider>
					{
					public:
						virtual GuiListControl::IItemCoordinateTransformer*		CreatePreferredCoordinateTransformer()=0;
						virtual GuiListControl::IItemArranger*					CreatePreferredArranger()=0;
						virtual IListViewItemContent*							CreateItemContent(const FontProperties& font)=0;
						virtual void											AttachListControl(GuiListControl* value)=0;
						virtual void											DetachListControl()=0;
					};

					class ListViewContentItemStyleController : public ListViewItemStyleController, public Description<ListViewContentItemStyleController>
					{
					protected:
						ListViewItemStyleProvider*				listViewItemStyleProvider;
						Ptr<IListViewItemContent>				content;
					public:
						ListViewContentItemStyleController(ListViewItemStyleProvider* provider);
						~ListViewContentItemStyleController();

						IListViewItemContent*					GetItemContent();
						void									Install(IListViewItemView* view, vint itemIndex);
					};

				protected:

					typedef collections::List<GuiListControl::IItemStyleController*>				ItemStyleList;

					IListViewItemView*							listViewItemView;
					Ptr<IListViewItemContentProvider>			listViewItemContentProvider;
					ItemStyleList								itemStyles;
				public:
					ListViewItemStyleProvider(IListViewItemContentProvider* itemContentProvider);
					~ListViewItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemStyleController*		CreateItemStyle(vint styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, vint itemIndex)override;

					const ItemStyleList&						GetCreatedItemStyles();
					bool										IsItemStyleAttachedToListView(GuiListControl::IItemStyleController* itemStyle);

					template<typename T>
					T* GetItemContent(GuiListControl::IItemStyleController* itemStyleController)
					{
						if(itemStyleController)
						{
							ListViewContentItemStyleController* item=dynamic_cast<ListViewContentItemStyleController*>(itemStyleController);
							if(item)
							{
								IListViewItemContent* itemContent=item->GetItemContent();
								return dynamic_cast<T*>(itemContent);
							}
						}
						return 0;
					}
				};
			}

/***********************************************************************
ListView ItemContentProvider
***********************************************************************/

			namespace list
			{
				class ListViewBigIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewBigIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewBigIconContentProvider(Size _iconSize=Size(32, 32));
					~ListViewBigIconContentProvider();

					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewSmallIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewSmallIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewSmallIconContentProvider(Size _iconSize=Size(16, 16));
					~ListViewSmallIconContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewListContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewListContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewListContentProvider(Size _iconSize=Size(16, 16));
					~ListViewListContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewTileContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewTileContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						void											RemoveTextElement(vint textRow);
						elements::GuiSolidLabelElement*					CreateTextElement(vint textRow, const FontProperties& font);
						void											ResetTextTable(vint textRows);
					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewTileContentProvider(Size _iconSize=Size(32, 32));
					~ListViewTileContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewInformationContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewInformationContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						FontProperties									baselineFont;
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						elements::GuiSolidBackgroundElement*			bottomLine;
						compositions::GuiBoundsComposition*				bottomLineComposition;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewInformationContentProvider(Size _iconSize=Size(32, 32));
					~ListViewInformationContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};

/***********************************************************************
ListView ItemContentProvider(Detailed)
***********************************************************************/

				class ListViewColumnItemArranger : public FixedHeightItemArranger, public Description<ListViewColumnItemArranger>
				{
					typedef collections::List<GuiListViewColumnHeader*>					ColumnHeaderButtonList;
					typedef collections::List<compositions::GuiBoundsComposition*>		ColumnHeaderSplitterList;
				public:
					static const vint							SplitterWidth=8;
					
					class IColumnItemViewCallback : public virtual IDescriptable, public Description<IColumnItemViewCallback>
					{
					public:
						virtual void							OnColumnChanged()=0;
					};
					
					class IColumnItemView : public virtual IDescriptable, public Description<IColumnItemView>
					{
					public:
						static const wchar_t* const								Identifier;
						
						virtual bool											AttachCallback(IColumnItemViewCallback* value)=0;
						virtual bool											DetachCallback(IColumnItemViewCallback* value)=0;
						virtual vint												GetColumnCount()=0;
						virtual WString											GetColumnText(vint index)=0;
						virtual vint												GetColumnSize(vint index)=0;
						virtual void											SetColumnSize(vint index, vint value)=0;
						virtual GuiMenu*										GetDropdownPopup(vint index)=0;
						virtual GuiListViewColumnHeader::ColumnSortingState		GetSortingState(vint index)=0;
					};
				protected:
					class ColumnItemViewCallback : public Object, public virtual IColumnItemViewCallback
					{
					protected:
						ListViewColumnItemArranger*				arranger;
					public:
						ColumnItemViewCallback(ListViewColumnItemArranger* _arranger);
						~ColumnItemViewCallback();

						void									OnColumnChanged();
					};

					GuiListViewBase*							listView;
					GuiListViewBase::IStyleProvider*			styleProvider;
					IColumnItemView*							columnItemView;
					Ptr<ColumnItemViewCallback>					columnItemViewCallback;
					compositions::GuiStackComposition*			columnHeaders;
					ColumnHeaderButtonList						columnHeaderButtons;
					ColumnHeaderSplitterList					columnHeaderSplitters;
					bool										splitterDragging;
					vint											splitterLatestX;

					void										ColumnClicked(vint index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);

					void										RearrangeItemBounds()override;
					vint											GetWidth()override;
					vint											GetYOffset()override;
					Size										OnCalculateTotalSize()override;
					void										DeleteColumnButtons();
					void										RebuildColumns();
				public:
					ListViewColumnItemArranger();
					~ListViewColumnItemArranger();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
				};
				
				class ListViewDetailContentProvider
					: public Object
					, public virtual ListViewItemStyleProvider::IListViewItemContentProvider
					, protected virtual ListViewColumnItemArranger::IColumnItemViewCallback
					, public Description<ListViewDetailContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::List<elements::GuiSolidLabelElement*>		SubItemList;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						SubItemList										subItems;

						GuiListControl::IItemProvider*					itemProvider;
						ListViewColumnItemArranger::IColumnItemView*	columnItemView;

					public:
						ItemContent(Size iconSize, const FontProperties& font, GuiListControl::IItemProvider* _itemProvider);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											UpdateSubItemSize();
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
					};

					Size												iconSize;
					GuiListControl::IItemProvider*						itemProvider;
					ListViewColumnItemArranger::IColumnItemView*		columnItemView;
					ListViewItemStyleProvider*							listViewItemStyleProvider;

					void												OnColumnChanged()override;
				public:
					ListViewDetailContentProvider(Size _iconSize=Size(16, 16));
					~ListViewDetailContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
			}

/***********************************************************************
ListView
***********************************************************************/

			namespace list
			{
				class ListViewItem
				{
				public:
					Ptr<GuiImageData>								smallImage;
					Ptr<GuiImageData>								largeImage;
					WString											text;
					collections::List<WString>						subItems;
					Ptr<Object>										tag;
				};
				
				class ListViewColumn
				{
				public:
					WString											text;
					vint												size;
					GuiMenu*										dropdownPopup;
					GuiListViewColumnHeader::ColumnSortingState		sortingState;

					ListViewColumn(const WString& _text=L"", vint _size=160);
				};

				class ListViewDataColumns : public ItemsBase<vint>
				{
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*						itemProvider;

					void NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					ListViewDataColumns();
					~ListViewDataColumns();
				};
				
				class ListViewColumns : public ItemsBase<Ptr<ListViewColumn>>
				{
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*						itemProvider;

					void NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					ListViewColumns();
					~ListViewColumns();
				};
				
				class ListViewItemProvider
					: public ListProvider<Ptr<ListViewItem>>
					, protected virtual ListViewItemStyleProvider::IListViewItemView
					, protected virtual ListViewColumnItemArranger::IColumnItemView
					, public Description<ListViewItemProvider>
				{
					friend class ListViewColumns;
					friend class ListViewDataColumns;
					typedef collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					ListViewDataColumns									dataColumns;
					ListViewColumns										columns;
					ColumnItemViewCallbackList							columnItemViewCallbacks;

					bool												ContainsPrimaryText(vint itemIndex)override;
					WString												GetPrimaryTextViewText(vint itemIndex)override;
					Ptr<GuiImageData>									GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>									GetLargeImage(vint itemIndex)override;
					WString												GetText(vint itemIndex)override;
					WString												GetSubItem(vint itemIndex, vint index)override;
					vint													GetDataColumnCount()override;
					vint													GetDataColumn(vint index)override;

					bool												AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool												DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint													GetColumnCount()override;
					WString												GetColumnText(vint index)override;
					vint													GetColumnSize(vint index)override;
					void												SetColumnSize(vint index, vint value)override;
					GuiMenu*											GetDropdownPopup(vint index)override;
					GuiListViewColumnHeader::ColumnSortingState			GetSortingState(vint index)override;
				public:
					ListViewItemProvider();
					~ListViewItemProvider();

					IDescriptable*										RequestView(const WString& identifier)override;
					void												ReleaseView(IDescriptable* view)override;

					ListViewDataColumns&								GetDataColumns();
					ListViewColumns&									GetColumns();
				};
			}
			
			class GuiVirtualListView : public GuiListViewBase, public Description<GuiVirtualListView>
			{
			public:
				GuiVirtualListView(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualListView();
				
				void											ChangeItemStyle(list::ListViewItemStyleProvider::IListViewItemContentProvider* contentProvider);
			};
			
			class GuiListView : public GuiVirtualListView, public Description<GuiListView>
			{
			protected:
				list::ListViewItemProvider*						items;
			public:
				GuiListView(IStyleProvider* _styleProvider);
				~GuiListView();
				
				list::ListViewItemProvider&						GetItems();
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\LISTCONTROLPACKAGE\GUITREEVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiVirtualTreeListControl NodeProvider
***********************************************************************/

			namespace tree
			{
				class INodeProvider;
				class INodeRootProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class INodeProviderCallback : public virtual IDescriptable, public Description<INodeProviderCallback>
				{
				public:
					virtual void					OnAttached(INodeRootProvider* provider)=0;
					virtual void					OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)=0;
					virtual void					OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)=0;
					virtual void					OnItemExpanded(INodeProvider* node)=0;
					virtual void					OnItemCollapsed(INodeProvider* node)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				class INodeProvider : public virtual IDescriptable, public Description<INodeProvider>
				{
				public:
					virtual bool					GetExpanding()=0;
					virtual void					SetExpanding(bool value)=0;
					virtual vint						CalculateTotalVisibleNodes()=0;

					virtual vint						GetChildCount()=0;
					virtual INodeProvider*			GetParent()=0;
					virtual INodeProvider*			GetChild(vint index)=0;
					virtual void					Increase()=0;
					virtual void					Release()=0;
				};
				
				class INodeRootProvider : public virtual IDescriptable, public Description<INodeRootProvider>
				{
				public:
					virtual INodeProvider*			GetRootNode()=0;
					virtual bool					CanGetNodeByVisibleIndex()=0;
					virtual INodeProvider*			GetNodeByVisibleIndex(vint index)=0;
					virtual bool					AttachCallback(INodeProviderCallback* value)=0;
					virtual bool					DetachCallback(INodeProviderCallback* value)=0;
					virtual IDescriptable*			RequestView(const WString& identifier)=0;
					virtual void					ReleaseView(IDescriptable* view)=0;
				};
			}

			namespace tree
			{
				//-----------------------------------------------------------
				// Tree to ListControl (IItemProvider)
				//-----------------------------------------------------------

				class INodeItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<INodeItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual INodeProvider*			RequestNode(vint index)=0;
					virtual void					ReleaseNode(INodeProvider* node)=0;
					virtual vint						CalculateNodeVisibilityIndex(INodeProvider* node)=0;
				};

				class INodeItemPrimaryTextView : public virtual IDescriptable, public Description<INodeItemPrimaryTextView>
				{
				public:
					static const wchar_t* const		Identifier;
					
					virtual WString					GetPrimaryTextViewText(INodeProvider* node)=0;
				};

				class NodeItemProvider
					: public list::ItemProviderBase
					, protected virtual INodeProviderCallback
					, protected virtual INodeItemView
					, public Description<NodeItemProvider>
				{
				protected:
					Ptr<INodeRootProvider>			root;
					INodeItemPrimaryTextView*		nodeItemPrimaryTextView;
					vint								offsetBeforeChildModified;

					INodeProvider*					GetNodeByOffset(INodeProvider* provider, vint offset);
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
					vint								CalculateNodeVisibilityIndexInternal(INodeProvider* node);
					vint								CalculateNodeVisibilityIndex(INodeProvider* node)override;
					
					bool							ContainsPrimaryText(vint itemIndex)override;
					WString							GetPrimaryTextViewText(vint itemIndex)override;
					INodeProvider*					RequestNode(vint index)override;
					void							ReleaseNode(INodeProvider* node)override;
				public:
					NodeItemProvider(INodeRootProvider* _root);
					~NodeItemProvider();
					
					Ptr<INodeRootProvider>			GetRoot();
					vint								Count()override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};

				//-----------------------------------------------------------
				// Tree to ListControl (IItemStyleProvider)
				//-----------------------------------------------------------

				class INodeItemStyleProvider;

				class INodeItemStyleController : public virtual GuiListControl::IItemStyleController, public Description<INodeItemStyleController>
				{
				public:
					virtual INodeItemStyleProvider*					GetNodeStyleProvider()=0;
				};
				
				class INodeItemStyleProvider : public virtual IDescriptable, public Description<INodeItemStyleProvider>
				{
				public:
					virtual void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)=0;
					virtual GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()=0;
					virtual void									AttachListControl(GuiListControl* value)=0;
					virtual void									DetachListControl()=0;
					virtual vint										GetItemStyleId(INodeProvider* node)=0;
					virtual INodeItemStyleController*				CreateItemStyle(vint styleId)=0;
					virtual void									DestroyItemStyle(INodeItemStyleController* style)=0;
					virtual void									Install(INodeItemStyleController* style, INodeProvider* node)=0;
					virtual void									SetStyleSelected(INodeItemStyleController* style, bool value)=0;
				};
				
				class NodeItemStyleProvider : public Object, public virtual GuiSelectableListControl::IItemStyleProvider, public Description<NodeItemStyleProvider>
				{
				protected:
					Ptr<INodeItemStyleProvider>						nodeItemStyleProvider;
					GuiListControl*									listControl;
					INodeItemView*									nodeItemView;
				public:
					NodeItemStyleProvider(Ptr<INodeItemStyleProvider> provider);
					~NodeItemStyleProvider();

					void											AttachListControl(GuiListControl* value)override;
					void											DetachListControl()override;
					vint												GetItemStyleId(vint itemIndex)override;
					GuiListControl::IItemStyleController*			CreateItemStyle(vint styleId)override;
					void											DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void											Install(GuiListControl::IItemStyleController* style, vint itemIndex)override;
					void											SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

/***********************************************************************
GuiVirtualTreeListControl Predefined NodeProvider
***********************************************************************/

			namespace tree
			{
				class MemoryNodeProvider
					: public Object
					, public virtual INodeProvider
					, public Description<MemoryNodeProvider>
				{
					typedef collections::List<Ptr<MemoryNodeProvider>> ChildList;
					typedef collections::IEnumerator<Ptr<MemoryNodeProvider>> ChildListEnumerator;

				public:
					class NodeCollection : public list::ItemsBase<Ptr<MemoryNodeProvider>>
					{
						friend class MemoryNodeProvider;
					protected:
						MemoryNodeProvider*			ownerProvider;

						void						OnBeforeChildModified(vint start, vint count, vint newCount);
						void						OnAfterChildModified(vint start, vint count, vint newCount);
						bool						InsertInternal(vint index, Ptr<MemoryNodeProvider> const& child)override;
						bool						RemoveAtInternal(vint index, Ptr<MemoryNodeProvider> const& child)override;

						NodeCollection();
					public:
					};

				protected:
					MemoryNodeProvider*				parent;
					bool							expanding;
					vint								childCount;
					vint								totalVisibleNodeCount;
					vint								offsetBeforeChildModified;
					Ptr<DescriptableObject>			data;
					NodeCollection					children;

					virtual INodeProviderCallback*	GetCallbackProxyInternal();
					void							OnChildTotalVisibleNodesChanged(vint offset);
				public:
					MemoryNodeProvider();
					MemoryNodeProvider(const Ptr<DescriptableObject>& _data);
					~MemoryNodeProvider();

					Ptr<DescriptableObject>			GetData();
					void							SetData(const Ptr<DescriptableObject>& value);
					void							NotifyDataModified();
					NodeCollection&					Children();

					bool							GetExpanding()override;
					void							SetExpanding(bool value)override;
					vint								CalculateTotalVisibleNodes()override;

					vint								GetChildCount()override;
					INodeProvider*					GetParent()override;
					INodeProvider*					GetChild(vint index)override;
					void							Increase()override;
					void							Release()override;
				};

				class NodeRootProviderBase : public virtual INodeRootProvider, protected virtual INodeProviderCallback, public Description<NodeRootProviderBase>
				{
					collections::List<INodeProviderCallback*>			callbacks;
				protected:
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
				public:
					NodeRootProviderBase();
					~NodeRootProviderBase();
					
					bool							CanGetNodeByVisibleIndex()override;
					INodeProvider*					GetNodeByVisibleIndex(vint index)override;
					bool							AttachCallback(INodeProviderCallback* value)override;
					bool							DetachCallback(INodeProviderCallback* value)override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};
				
				class MemoryNodeRootProvider
					: public MemoryNodeProvider
					, public NodeRootProviderBase
					, public Description<MemoryNodeRootProvider>
				{
				protected:
					INodeProviderCallback*			GetCallbackProxyInternal()override;
				public:
					MemoryNodeRootProvider();
					~MemoryNodeRootProvider();

					INodeProvider*					GetRootNode()override;
					MemoryNodeProvider*				GetMemoryNode(INodeProvider* node);
				};
			}

/***********************************************************************
GuiVirtualTreeListControl
***********************************************************************/

			class GuiVirtualTreeListControl : public GuiSelectableListControl, private virtual tree::INodeProviderCallback, public Description<GuiVirtualTreeListControl>
			{
			private:
				void								OnAttached(tree::INodeRootProvider* provider)override;
				void								OnBeforeItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void								OnAfterItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void								OnItemExpanded(tree::INodeProvider* node)override;
				void								OnItemCollapsed(tree::INodeProvider* node)override;
			protected:
				tree::NodeItemProvider*				nodeItemProvider;
				tree::INodeItemView*				nodeItemView;
				Ptr<tree::INodeItemStyleProvider>	nodeStyleProvider;

				void								OnItemMouseEvent(compositions::GuiNodeMouseEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void								OnItemNotifyEvent(compositions::GuiNodeNotifyEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
			public:
				GuiVirtualTreeListControl(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider);
				~GuiVirtualTreeListControl();

				compositions::GuiNodeMouseEvent		NodeLeftButtonDown;
				compositions::GuiNodeMouseEvent		NodeLeftButtonUp;
				compositions::GuiNodeMouseEvent		NodeLeftButtonDoubleClick;
				compositions::GuiNodeMouseEvent		NodeMiddleButtonDown;
				compositions::GuiNodeMouseEvent		NodeMiddleButtonUp;
				compositions::GuiNodeMouseEvent		NodeMiddleButtonDoubleClick;
				compositions::GuiNodeMouseEvent		NodeRightButtonDown;
				compositions::GuiNodeMouseEvent		NodeRightButtonUp;
				compositions::GuiNodeMouseEvent		NodeRightButtonDoubleClick;
				compositions::GuiNodeMouseEvent		NodeMouseMove;
				compositions::GuiNodeNotifyEvent	NodeMouseEnter;
				compositions::GuiNodeNotifyEvent	NodeMouseLeave;
				compositions::GuiNodeNotifyEvent	NodeExpanded;
				compositions::GuiNodeNotifyEvent	NodeCollapsed;

				tree::INodeItemView*				GetNodeItemView();
				tree::INodeRootProvider*			GetNodeRootProvider();
				tree::INodeItemStyleProvider*		GetNodeStyleProvider();
				Ptr<tree::INodeItemStyleProvider>	SetNodeStyleProvider(Ptr<tree::INodeItemStyleProvider> styleProvider);
			};

/***********************************************************************
TreeView
***********************************************************************/

			namespace tree
			{
				class ITreeViewItemView : public virtual INodeItemPrimaryTextView, public Description<ITreeViewItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual Ptr<GuiImageData>		GetNodeImage(INodeProvider* node)=0;
					virtual WString					GetNodeText(INodeProvider* node)=0;
				};

				class TreeViewItem : public Object, public Description<TreeViewItem>
				{
				public:
					Ptr<GuiImageData>				image;
					WString							text;
					Ptr<Object>						tag;

					TreeViewItem();
					TreeViewItem(const Ptr<GuiImageData>& _image, const WString& _text);
				};

				class TreeViewItemRootProvider
					: public MemoryNodeRootProvider
					, protected virtual ITreeViewItemView
					, public Description<TreeViewItemRootProvider>
				{
				protected:

					WString							GetPrimaryTextViewText(INodeProvider* node)override;
					Ptr<GuiImageData>				GetNodeImage(INodeProvider* node)override;
					WString							GetNodeText(INodeProvider* node)override;
				public:
					TreeViewItemRootProvider();
					~TreeViewItemRootProvider();

					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;

					Ptr<TreeViewItem>				GetTreeViewData(INodeProvider* node);
					void							SetTreeViewData(INodeProvider* node, Ptr<TreeViewItem> value);
					void							UpdateTreeViewData(INodeProvider* node);
				};
			}
			
			class GuiVirtualTreeView : public GuiVirtualTreeListControl, public Description<GuiVirtualTreeView>
			{
			public:
				class IStyleProvider : public virtual GuiVirtualTreeListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()=0;
					virtual Color										GetTextColor()=0;
				};
			protected:
				IStyleProvider*											styleProvider;
			public:
				GuiVirtualTreeView(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider);
				~GuiVirtualTreeView();

				IStyleProvider*											GetTreeViewStyleProvider();
			};
			
			class GuiTreeView : public GuiVirtualTreeView, public Description<GuiTreeView>
			{
			protected:
				Ptr<tree::TreeViewItemRootProvider>						nodes;
			public:
				GuiTreeView(IStyleProvider* _styleProvider);
				~GuiTreeView();

				Ptr<tree::TreeViewItemRootProvider>						Nodes();
			};

			namespace tree
			{
				class TreeViewNodeItemStyleProvider
					: public Object
					, public virtual INodeItemStyleProvider
					, protected virtual INodeProviderCallback
					, public Description<TreeViewNodeItemStyleProvider>
				{
				protected:
#pragma warning(push)
#pragma warning(disable:4250)
					class ItemController : public list::ItemStyleControllerBase, public virtual INodeItemStyleController
					{
					protected:
						TreeViewNodeItemStyleProvider*		styleProvider;
						GuiSelectableButton*				backgroundButton;
						GuiSelectableButton*				expandingButton;
						compositions::GuiTableComposition*	table;
						elements::GuiImageFrameElement*		image;
						elements::GuiSolidLabelElement*		text;

						void								SwitchNodeExpanding();
						void								OnBackgroundButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						ItemController(TreeViewNodeItemStyleProvider* _styleProvider);

						INodeItemStyleProvider*				GetNodeStyleProvider()override;
						void								Install(INodeProvider* node);

						bool								GetSelected();
						void								SetSelected(bool value);
						void								UpdateExpandingButton(INodeProvider* associatedNode);
					};
#pragma warning(pop)

					GuiVirtualTreeView*						treeControl;
					GuiListControl::IItemStyleProvider*		bindedItemStyleProvider;
					ITreeViewItemView*						treeViewItemView;

				protected:
					ItemController*							GetRelatedController(INodeProvider* node);
					void									UpdateExpandingButton(INodeProvider* node);
					void									OnAttached(INodeRootProvider* provider)override;
					void									OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void									OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void									OnItemExpanded(INodeProvider* node)override;
					void									OnItemCollapsed(INodeProvider* node)override;
				public:
					TreeViewNodeItemStyleProvider();
					~TreeViewNodeItemStyleProvider();

					void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)override;
					GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()override;
					void									AttachListControl(GuiListControl* value)override;
					void									DetachListControl()override;
					vint										GetItemStyleId(INodeProvider* node)override;
					INodeItemStyleController*				CreateItemStyle(vint styleId)override;
					void									DestroyItemStyle(INodeItemStyleController* style)override;
					void									Install(INodeItemStyleController* style, INodeProvider* node)override;
					void									SetStyleSelected(INodeItemStyleController* style, bool value)override;
				};
			}
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<>
			struct RandomAccessable<presentation::controls::tree::MemoryNodeProvider>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\LISTCONTROLPACKAGE\GUICOMBOCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ComboBox Base
***********************************************************************/

			class GuiComboBoxBase : public GuiButton, public Description<GuiComboBoxBase>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void							ShowPopup()=0;
					virtual void							SelectItem()=0;
				};
				
				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void							SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void							OnClicked()=0;
					virtual void							OnPopupOpened()=0;
					virtual void							OnPopupClosed()=0;
					virtual void							OnItemSelected()=0;
					virtual GuiWindow::IStyleController*	CreatePopupStyle()=0;
				};
			protected:

				class CommandExecutor : public Object, public virtual ICommandExecutor
				{
				protected:
					GuiComboBoxBase*						combo;

				public:
					CommandExecutor(GuiComboBoxBase* _combo);
					~CommandExecutor();

					void									ShowPopup()override;
					void									SelectItem()override;
				};

				Ptr<CommandExecutor>						commandExecutor;
				IStyleController*							styleController;
				GuiPopup*									popup;

				virtual void								SelectItem();
				void										OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnPopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnPopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxBase(IStyleController* _styleController);
				~GuiComboBoxBase();

				compositions::GuiNotifyEvent				PopupOpened;
				compositions::GuiNotifyEvent				PopupClosed;
				compositions::GuiNotifyEvent				ItemSelecting;
				compositions::GuiNotifyEvent				ItemSelected;

				void										ShowPopup();
				GuiPopup*									GetPopup();
			};

/***********************************************************************
ComboBox with GuiListControl
***********************************************************************/

			class GuiComboBoxListControl : public GuiComboBoxBase, public Description<GuiComboBoxListControl>
			{
			protected:
				GuiSelectableListControl*					containedListControl;
				GuiListControl::IItemPrimaryTextView*		primaryTextView;

				virtual void								DisplaySelectedContent(vint itemIndex);
				void										OnListControlSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxListControl(IStyleController* _styleController, GuiSelectableListControl* _containedListControl);
				~GuiComboBoxListControl();

				compositions::GuiNotifyEvent				SelectedIndexChanged;
				
				void										SetFont(const FontProperties& value)override;
				GuiSelectableListControl*					GetContainedListControl();
				
				vint											GetSelectedIndex();
				void										SetSelectedIndex(vint value);
				GuiListControl::IItemProvider*				GetItemProvider();
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\TOOLSTRIPPACKAGE\GUITOOLSTRIPCOMMAND.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPCOMMAND
#define VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPCOMMAND


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiToolstripCommand : public GuiComponent, public Description<GuiToolstripCommand>
			{
			protected:
				Ptr<GuiImageData>							image;
				WString										text;
				compositions::IGuiShortcutKeyItem*			shortcutKeyItem;
				bool										enabled;
				Ptr<compositions::GuiNotifyEvent::IHandler>	shortcutKeyItemExecutedHandler;

				void										OnShortcutKeyItemExecuted(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										InvokeDescriptionChanged();
			public:
				GuiToolstripCommand();
				~GuiToolstripCommand();

				compositions::GuiNotifyEvent				Executed;

				compositions::GuiNotifyEvent				DescriptionChanged;

				Ptr<GuiImageData>							GetImage();
				void										SetImage(Ptr<GuiImageData> value);
				const WString&								GetText();
				void										SetText(const WString& value);
				compositions::IGuiShortcutKeyItem*			GetShortcut();
				void										SetShortcut(compositions::IGuiShortcutKeyItem* value);
				bool										GetEnabled();
				void										SetEnabled(bool value);
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\TOOLSTRIPPACKAGE\GUITOOLSTRIPMENU.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPMENU
#define VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPMENU


namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			class ITheme;
		}

		namespace controls
		{

/***********************************************************************
Toolstrip Item Collection
***********************************************************************/

			class GuiToolstripCollection : public list::ItemsBase<GuiControl*>
			{
			public:
				class IContentCallback : public Interface
				{
				public:
					virtual void							UpdateLayout()=0;
				};
			protected:
				IContentCallback*							contentCallback;
				compositions::GuiStackComposition*			stackComposition;
				Ptr<compositions::GuiSubComponentMeasurer>	subComponentMeasurer;

				void										InvokeUpdateLayout();
				void										OnInterestingMenuButtonPropertyChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				bool										RemoveAtInternal(vint index, GuiControl* const& control)override;
				bool										InsertInternal(vint index, GuiControl* const& control)override;
			public:
				GuiToolstripCollection(IContentCallback* _contentCallback, compositions::GuiStackComposition* _stackComposition, Ptr<compositions::GuiSubComponentMeasurer> _subComponentMeasurer);
				~GuiToolstripCollection();
			};

/***********************************************************************
Toolstrip Builder Facade
***********************************************************************/

			class GuiToolstripButton;

			class GuiToolstripBuilder : public Object
			{
				friend class GuiToolstripMenu;
				friend class GuiToolstripMenuBar;
				friend class GuiToolstripToolbar;
			protected:
				enum Environment
				{
					Menu,
					MenuBar,
					Toolbar,
				};

				Environment									environment;
				GuiToolstripCollection*						toolstripItems;
				GuiToolstripBuilder*						previousBuilder;
				theme::ITheme*								theme;
				GuiToolstripButton*							lastCreatedButton;
				
				GuiToolstripBuilder(Environment _environment, GuiToolstripCollection* _toolstripItems);
			public:
				~GuiToolstripBuilder();

				GuiToolstripBuilder*						Button(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						Button(GuiToolstripCommand* command, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						DropdownButton(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						DropdownButton(GuiToolstripCommand* command, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						SplitButton(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						SplitButton(GuiToolstripCommand* command, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						Splitter();
				GuiToolstripBuilder*						Control(GuiControl* control);
				GuiToolstripBuilder*						BeginSubMenu();
				GuiToolstripBuilder*						EndSubMenu();
			};

/***********************************************************************
Toolstrip Container
***********************************************************************/

			class GuiToolstripMenu : public GuiMenu, protected GuiToolstripCollection::IContentCallback,  Description<GuiToolstripMenu>
			{
			protected:
				compositions::GuiStackComposition*			stackComposition;
				Ptr<GuiToolstripCollection>					toolstripItems;
				Ptr<compositions::GuiSubComponentMeasurer>	subComponentMeasurer;
				Ptr<GuiToolstripBuilder>					builder;

				void										UpdateLayout()override;
			public:
				GuiToolstripMenu(IStyleController* _styleController, GuiControl* _owner);
				~GuiToolstripMenu();
				
				GuiToolstripCollection&						GetToolstripItems();
				GuiToolstripBuilder*						GetBuilder(theme::ITheme* themeObject=0);
			};

			class GuiToolstripMenuBar : public GuiMenuBar, public Description<GuiToolstripMenuBar>
			{
			protected:
				compositions::GuiStackComposition*			stackComposition;
				Ptr<GuiToolstripCollection>					toolstripItems;
				Ptr<GuiToolstripBuilder>					builder;

			public:
				GuiToolstripMenuBar(IStyleController* _styleController);
				~GuiToolstripMenuBar();
				
				GuiToolstripCollection&						GetToolstripItems();
				GuiToolstripBuilder*						GetBuilder(theme::ITheme* themeObject=0);
			};

			class GuiToolstripToolbar : public GuiControl, public Description<GuiToolstripToolbar>
			{
			protected:
				compositions::GuiStackComposition*			stackComposition;
				Ptr<GuiToolstripCollection>					toolstripItems;
				Ptr<GuiToolstripBuilder>					builder;

			public:
				GuiToolstripToolbar(IStyleController* _styleController);
				~GuiToolstripToolbar();
				
				GuiToolstripCollection&						GetToolstripItems();
				GuiToolstripBuilder*						GetBuilder(theme::ITheme* themeObject=0);
			};

/***********************************************************************
Toolstrip Component
***********************************************************************/

			class GuiToolstripButton : public GuiMenuButton, public Description<GuiToolstripButton>
			{
			protected:
				GuiToolstripCommand*							command;
				Ptr<compositions::GuiNotifyEvent::IHandler>		descriptionChangedHandler;

				void											UpdateCommandContent();
				void											OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnCommandDescriptionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiToolstripButton(IStyleController* _styleController);
				~GuiToolstripButton();

				GuiToolstripCommand*							GetCommand();
				void											SetCommand(GuiToolstripCommand* value);

				GuiToolstripMenu*								GetToolstripSubMenu();
				void											CreateToolstripSubMenu(GuiToolstripMenu::IStyleController* subMenuStyleController=0);
			};
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<>
			struct RandomAccessable<presentation::controls::GuiToolstripCollection>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\STYLES\GUITHEMESTYLEFACTORY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY
#define VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY





namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			class ITheme : public IDescriptable, public Description<ITheme>
			{
			public:
				virtual controls::GuiWindow::IStyleController*								CreateWindowStyle()=0;
				virtual controls::GuiLabel::IStyleController*								CreateLabelStyle()=0;
				virtual controls::GuiScrollContainer::IStyleProvider*						CreateScrollContainerStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateGroupBoxStyle()=0;
				virtual controls::GuiTab::IStyleController*									CreateTabStyle()=0;
				virtual controls::GuiComboBoxBase::IStyleController*						CreateComboBoxStyle()=0;
				virtual controls::GuiScrollView::IStyleProvider*							CreateMultilineTextBoxStyle()=0;
				virtual controls::GuiSinglelineTextBox::IStyleProvider*						CreateTextBoxStyle()=0;
				virtual elements::text::ColorEntry											GetDefaultTextBoxColorEntry()=0;
				virtual controls::GuiListView::IStyleProvider*								CreateListViewStyle()=0;
				virtual controls::GuiTreeView::IStyleProvider*								CreateTreeViewStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateListItemBackgroundStyle()=0;
				
				virtual controls::GuiToolstripMenu::IStyleController*						CreateMenuStyle()=0;
				virtual controls::GuiToolstripMenuBar::IStyleController*					CreateMenuBarStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateMenuSplitterStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateMenuBarButtonStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateMenuItemButtonStyle()=0;
				virtual controls::GuiToolstripToolbar::IStyleController*					CreateToolbarStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateToolbarButtonStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateToolbarDropdownButtonStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateToolbarSplitButtonStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateToolbarSplitterStyle()=0;
				
				virtual controls::GuiButton::IStyleController*								CreateButtonStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateCheckBoxStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateRadioButtonStyle()=0;
				
				virtual controls::GuiScroll::IStyleController*								CreateHScrollStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateVScrollStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateHTrackerStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateVTrackerStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateProgressBarStyle()=0;
				virtual vint																	GetScrollDefaultSize()=0;
				virtual vint																	GetTrackerDefaultSize()=0;
				
				virtual controls::GuiScrollView::IStyleProvider*							CreateTextListStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateTextListItemStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateCheckTextListItemStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateRadioTextListItemStyle()=0;
			};

			extern ITheme*						GetCurrentTheme();
			extern void							SetCurrentTheme(ITheme* theam);

			namespace g
			{
				extern controls::GuiWindow*						NewWindow();
				extern controls::GuiLabel*						NewLabel();
				extern controls::GuiScrollContainer*			NewScrollContainer();
				extern controls::GuiControl*					NewGroupBox();
				extern controls::GuiTab*						NewTab();
				extern controls::GuiComboBoxListControl*		NewComboBox(controls::GuiSelectableListControl* containedListControl);
				extern controls::GuiMultilineTextBox*			NewMultilineTextBox();
				extern controls::GuiSinglelineTextBox*			NewTextBox();
				extern controls::GuiListView*					NewListViewBigIcon();
				extern controls::GuiListView*					NewListViewSmallIcon();
				extern controls::GuiListView*					NewListViewList();
				extern controls::GuiListView*					NewListViewDetail();
				extern controls::GuiListView*					NewListViewTile();
				extern controls::GuiListView*					NewListViewInformation();
				extern controls::GuiTreeView*					NewTreeView();

				extern controls::GuiToolstripMenu*				NewMenu(controls::GuiControl* owner);
				extern controls::GuiToolstripMenuBar*			NewMenuBar();
				extern controls::GuiControl*					NewMenuSplitter();
				extern controls::GuiToolstripButton*			NewMenuBarButton();
				extern controls::GuiToolstripButton*			NewMenuItemButton();
				extern controls::GuiToolstripToolbar*			NewToolbar();
				extern controls::GuiToolstripButton*			NewToolbarButton();
				extern controls::GuiToolstripButton*			NewToolbarDropdownButton();
				extern controls::GuiToolstripButton*			NewToolbarSplitButton();
				extern controls::GuiControl*					NewToolbarSplitter();

				extern controls::GuiButton*						NewButton();
				extern controls::GuiSelectableButton*			NewCheckBox();
				extern controls::GuiSelectableButton*			NewRadioButton();

				extern controls::GuiScroll*						NewHScroll();
				extern controls::GuiScroll*						NewVScroll();
				extern controls::GuiScroll*						NewHTracker();
				extern controls::GuiScroll*						NewVTracker();
				extern controls::GuiScroll*						NewProgressBar();

				extern controls::GuiTextList*					NewTextList();
				extern controls::GuiTextList*					NewCheckTextList();
				extern controls::GuiTextList*					NewRadioTextList();
			}
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\STYLES\GUIWIN7STYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES
#define VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Theme
***********************************************************************/

			class Win7Theme : public theme::ITheme
			{
			public:
				Win7Theme();
				~Win7Theme();

				controls::GuiWindow::IStyleController*								CreateWindowStyle()override;
				controls::GuiLabel::IStyleController*								CreateLabelStyle()override;
				controls::GuiScrollContainer::IStyleProvider*						CreateScrollContainerStyle()override;
				controls::GuiControl::IStyleController*								CreateGroupBoxStyle()override;
				controls::GuiTab::IStyleController*									CreateTabStyle()override;
				controls::GuiComboBoxBase::IStyleController*						CreateComboBoxStyle()override;
				controls::GuiScrollView::IStyleProvider*							CreateMultilineTextBoxStyle()override;
				controls::GuiSinglelineTextBox::IStyleProvider*						CreateTextBoxStyle()override;
				elements::text::ColorEntry											GetDefaultTextBoxColorEntry()override;
				controls::GuiListView::IStyleProvider*								CreateListViewStyle()override;
				controls::GuiTreeView::IStyleProvider*								CreateTreeViewStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateListItemBackgroundStyle()override;
				
				controls::GuiToolstripMenu::IStyleController*						CreateMenuStyle()override;
				controls::GuiToolstripMenuBar::IStyleController*					CreateMenuBarStyle()override;
				controls::GuiControl::IStyleController*								CreateMenuSplitterStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateMenuBarButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateMenuItemButtonStyle()override;
				controls::GuiToolstripToolbar::IStyleController*					CreateToolbarStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolbarButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolbarDropdownButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolbarSplitButtonStyle()override;
				controls::GuiControl::IStyleController*								CreateToolbarSplitterStyle()override;

				controls::GuiButton::IStyleController*								CreateButtonStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateCheckBoxStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateRadioButtonStyle()override;
				
				controls::GuiScroll::IStyleController*								CreateHScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateVScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateHTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateVTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateProgressBarStyle()override;
				vint																	GetScrollDefaultSize()override;
				vint																	GetTrackerDefaultSize()override;

				controls::GuiScrollView::IStyleProvider*							CreateTextListStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateCheckTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateRadioTextListItemStyle()override;
			};
		}
	}
}

#endif

/***********************************************************************
LIBRARIES\GACUI\SOURCE\CONTROLS\STYLES\GUIWIN8STYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWIN8STYLES
#define VCZH_PRESENTATION_CONTROLS_GUIWIN8STYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Theme
***********************************************************************/

			class Win8Theme : public /*theme::ITheme*/ win7::Win7Theme
			{
			public:
				Win8Theme();
				~Win8Theme();

				controls::GuiWindow::IStyleController*								CreateWindowStyle()override;
				controls::GuiLabel::IStyleController*								CreateLabelStyle()override;
				controls::GuiScrollContainer::IStyleProvider*						CreateScrollContainerStyle()override;
				controls::GuiControl::IStyleController*								CreateGroupBoxStyle()override;
				//controls::GuiTab::IStyleController*									CreateTabStyle()override;
				controls::GuiComboBoxBase::IStyleController*						CreateComboBoxStyle()override;
				controls::GuiScrollView::IStyleProvider*							CreateMultilineTextBoxStyle()override;
				controls::GuiSinglelineTextBox::IStyleProvider*						CreateTextBoxStyle()override;
				elements::text::ColorEntry											GetDefaultTextBoxColorEntry()override;
				controls::GuiListView::IStyleProvider*								CreateListViewStyle()override;
				controls::GuiTreeView::IStyleProvider*								CreateTreeViewStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateListItemBackgroundStyle()override;

				controls::GuiToolstripMenu::IStyleController*						CreateMenuStyle()override;
				controls::GuiToolstripMenuBar::IStyleController*					CreateMenuBarStyle()override;
				controls::GuiControl::IStyleController*								CreateMenuSplitterStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateMenuBarButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateMenuItemButtonStyle()override;
				controls::GuiToolstripToolbar::IStyleController*					CreateToolbarStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolbarButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolbarDropdownButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolbarSplitButtonStyle()override;
				controls::GuiControl::IStyleController*								CreateToolbarSplitterStyle()override;

				controls::GuiButton::IStyleController*								CreateButtonStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateCheckBoxStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateRadioButtonStyle()override;

				controls::GuiScroll::IStyleController*								CreateHScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateVScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateHTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateVTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateProgressBarStyle()override;
				vint																	GetScrollDefaultSize()override;
				vint																	GetTrackerDefaultSize()override;

				controls::GuiScrollView::IStyleProvider*							CreateTextListStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateCheckTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateRadioTextListItemStyle()override;
			};
		}
	}
}

#endif

/***********************************************************************
Libraries\GacUI\Source\GacUI.h
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI Header Files and Common Namespaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUI
#define VCZH_PRESENTATION_GACUI


using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;
using namespace vl::presentation::theme;

extern int SetupWindowsGDIRenderer();
extern int SetupWindowsDirect2DRenderer();

#endif
