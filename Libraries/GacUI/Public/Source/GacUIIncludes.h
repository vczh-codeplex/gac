/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: ???(vczh)
***********************************************************************/

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\BASIC.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Basic

Classes:
	NotCopyable									：不可复制对象
	Error										：内部错误，检查到了不可出现的变量、参数或状态错误
	Object										：对象基类

Macros:
	CHECK_ERROR(CONDITION,DESCRIPTION)			：检查内部错误
***********************************************************************/

#ifndef VCZH_BASIC
#define VCZH_BASIC

namespace vl
{

/***********************************************************************
32位/64位兼容
***********************************************************************/

#ifdef _WIN64
#define VCZH_64
#endif

#ifdef VCZH_64
	typedef __int64					vint;
	typedef signed __int64			vsint;
	typedef unsigned __int64		vuint;
#else
	typedef __int32					vint;
	typedef signed __int32			vsint;
	typedef unsigned __int32		vuint;
#endif

typedef signed __int64	pos_t;

#ifdef VCZH_64
#define ITOA_S		_i64toa_s
#define ITOW_S		_i64tow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#else
#define ITOA_S		_itoa_s
#define ITOW_S		_itow_s
#define I64TOA_S	_i64toa_s
#define I64TOW_S	_i64tow_s
#define UITOA_S		_ui64toa_s
#define UITOW_S		_ui64tow_s
#define UI64TOA_S	_ui64toa_s
#define UI64TOW_S	_ui64tow_s
#endif

#ifndef _MSC_VER
#define override
#endif

#define VCZH_NO_OLD_OS

/***********************************************************************
基础
***********************************************************************/

	class NotCopyable
	{
	private:
		NotCopyable(const NotCopyable&);
		NotCopyable& operator=(const NotCopyable&);
	public:
		NotCopyable();
	};

	class Error
	{
	private:
		wchar_t*			description;
	public:
		Error(wchar_t* _description);

		wchar_t*			Description()const;
	};

#ifdef _DEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION) do{if(!(CONDITION))throw Error(DESCRIPTION);}while(0)
#endif
#ifdef NDEBUG
	#define CHECK_ERROR(CONDITION,DESCRIPTION)
#endif

#define CHECK_FAIL(DESCRIPTION) do{throw Error(DESCRIPTION);}while(0)

	class Object
	{
	public:
		virtual ~Object();
	};

	template<typename T>
	class ObjectBox : public Object
	{
	private:
		T					object;
	public:
		ObjectBox(const T& _object)
		{
			object=_object;
		}

		const T& Unbox()
		{
			return object;
		}
	};

	template<typename T, size_t minSize>
	union BinaryRetriver
	{
		T t;
		char binary[sizeof(T)>minSize?sizeof(T):minSize];
	};

/***********************************************************************
配置
***********************************************************************/

	template<typename T>
	struct KeyType
	{
	public:
		typedef T Type;
	};

	template<typename T>
	struct POD
	{
		static const bool Result=false;
	};

	template<>struct POD<bool>{static const bool Result=true;};
	template<>struct POD<unsigned __int8>{static const bool Result=true;};
	template<>struct POD<signed __int8>{static const bool Result=true;};
	template<>struct POD<unsigned __int16>{static const bool Result=true;};
	template<>struct POD<signed __int16>{static const bool Result=true;};
	template<>struct POD<unsigned __int32>{static const bool Result=true;};
	template<>struct POD<signed __int32>{static const bool Result=true;};
	template<>struct POD<unsigned __int64>{static const bool Result=true;};
	template<>struct POD<signed __int64>{static const bool Result=true;};
	template<>struct POD<char>{static const bool Result=true;};
	template<>struct POD<wchar_t>{static const bool Result=true;};
	template<typename T>struct POD<T*>{static const bool Result=true;};
	template<typename T>struct POD<T&>{static const bool Result=true;};
	template<typename T, typename C>struct POD<T C::*>{static const bool Result=true;};
	template<typename T, vint _Size>struct POD<T[_Size]>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<volatile T>{static const bool Result=POD<T>::Result;};
	template<typename T>struct POD<const volatile T>{static const bool Result=POD<T>::Result;};

/***********************************************************************
时间
***********************************************************************/

	struct DateTime
	{
		vint				year;
		vint				month;
		vint				dayOfWeek;
		vint				day;
		vint				hour;
		vint				minute;
		vint				second;
		vint				milliseconds;

		unsigned __int64	totalMilliseconds;
		unsigned __int64	filetime;

		static DateTime		LocalTime();
		static DateTime		UtcTime();

		DateTime			ToLocalTime();
		DateTime			ToUtcTime();
	};

/***********************************************************************
接口
***********************************************************************/

	class Interface : private NotCopyable
	{
	public:
		virtual ~Interface();
	};
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\STRING.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::String

Classes:
	AString										：Mbcs字符串
	WString										：Utf-16字符串
***********************************************************************/

#ifndef VCZH_STRING
#define VCZH_STRING

#include <memory.h>

namespace vl
{
	template<typename T>
	class ObjectString : public Object
	{
	private:
		static const T	zero=0;

		mutable T*					buffer;
		mutable vint*				reference;
		mutable vint				start;
		mutable vint				length;
		mutable vint				realLength;

		static vint CalculateLength(const T* buffer)
		{
			vint result=0;
			while(*buffer++)result++;
			return result;
		}

		static vint Compare(const T* bufA, const ObjectString<T>& strB)
		{
			const T* bufB=strB.buffer+strB.start;
			const T* bufAOld=bufA;
			vint length=strB.length;
			while(length-- && *bufA)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return CalculateLength(bufAOld)-strB.length;
		}

	public:

		static vint Compare(const ObjectString<T>& strA, const ObjectString<T>& strB)
		{
			const T* bufA=strA.buffer+strA.start;
			const T* bufB=strB.buffer+strB.start;
			vint length=strA.length<strB.length?strA.length:strB.length;
			while(length--)
			{
				vint diff=*bufA++-*bufB++;
				if(diff!=0)
				{
					return diff;
				}
			};
			return strA.length-strB.length;
		}

	private:

		void Inc()const
		{
			if(reference)
			{
				(*reference)++;
			}
		}

		void Dec()const
		{
			if(reference)
			{
				if(--(*reference)==0)
				{
					delete[] buffer;
					delete reference;
				}
			}
		}

		ObjectString(const ObjectString<T>& string, vint _start, vint _length)
		{
			if(_length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=string.buffer;
				reference=string.reference;
				start=string.start+_start;
				length=_length;
				realLength=string.realLength;
				Inc();
			}
		}

		ObjectString(const ObjectString<T>& dest, const ObjectString<T>& source, vint index, vint count)
		{
			if(index==0 && count==dest.length && source.length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				reference=new vint(1);
				start=0;
				length=dest.length-count+source.length;
				realLength=length;
				buffer=new T[length+1];
				memcpy(buffer, dest.buffer+dest.start, sizeof(T)*index);
				memcpy(buffer+index, source.buffer+source.start, sizeof(T)*source.length);
				memcpy(buffer+index+source.length, (dest.buffer+dest.start+index+count), sizeof(T)*(dest.length-index-count));
				buffer[length]=0;
			}
		}
	public:
		static ObjectString<T>	Empty;

		ObjectString()
		{
			buffer=(T*)&zero;
			reference=0;
			start=0;
			length=0;
			realLength=0;
		}

		ObjectString(const T& _char)
		{
			reference=new vint(1);
			start=0;
			length=1;
			buffer=new T[2];
			buffer[0]=_char;
			buffer[1]=0;
			realLength=length;
		}

		ObjectString(const T* _buffer, vint _length)
		{
			if(_length==0)
			{
				buffer=(T*)&zero;
				reference=0;
				start=0;
				length=0;
				realLength=0;
			}
			else
			{
				buffer=new T[_length+1];
				memcpy(buffer, _buffer, _length*sizeof(T));
				buffer[_length]=0;
				reference=new vint(1);
				start=0;
				length=_length;
				realLength=_length;
			}
		}

		ObjectString(const T* _buffer, bool copy = true)
		{
			CHECK_ERROR(_buffer!=0, L"ObjectString<T>::ObjectString(const T*, bool)#不能用空指针构造字符串。");
			if(copy)
			{
				reference=new vint(1);
				start=0;
				length=CalculateLength(_buffer);
				buffer=new T[length+1];
				memcpy(buffer, _buffer, sizeof(T)*(length+1));
				realLength=length;
			}
			else
			{
				buffer=(T*)_buffer;
				reference=0;
				start=0;
				length=CalculateLength(_buffer);
				realLength=length;
			}
		}

		ObjectString(const ObjectString<T>& string)
		{
			buffer=string.buffer;
			reference=string.reference;
			start=string.start;
			length=string.length;
			realLength=string.realLength;
			Inc();
		}

		~ObjectString()
		{
			Dec();
		}

		const T* Buffer()const
		{
			if(start+length!=realLength)
			{
				T* newBuffer=new T[length+1];
				memcpy(newBuffer, buffer+start, sizeof(T)*length);
				newBuffer[length]=0;
				Dec();
				buffer=newBuffer;
				reference=new vint(1);
				start=0;
				realLength=length;
			}
			return buffer+start;
		}

		ObjectString<T>& operator=(const ObjectString<T>& string)
		{
			if(this!=&string)
			{
				Dec();
				buffer=string.buffer;
				reference=string.reference;
				start=string.start;
				length=string.length;
				realLength=string.realLength;
				Inc();
			}
			return *this;
		}

		ObjectString<T>& operator+=(const ObjectString<T>& string)
		{
			return *this=*this+string;
		}

		ObjectString<T> operator+(const ObjectString<T>& string)const
		{
			return ObjectString<T>(*this, string, length, 0);
		}

		bool operator==(const ObjectString<T>& string)const
		{
			return Compare(*this, string)==0;
		}

		bool operator!=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)!=0;
		}

		bool operator>(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>0;
		}

		bool operator>=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)>=0;
		}

		bool operator<(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<0;
		}

		bool operator<=(const ObjectString<T>& string)const
		{
			return Compare(*this, string)<=0;
		}

		bool operator==(const T* buffer)const
		{
			return Compare(buffer, *this)==0;
		}

		bool operator!=(const T* buffer)const
		{
			return Compare(buffer, *this)!=0;
		}

		bool operator>(const T* buffer)const
		{
			return Compare(buffer, *this)<0;
		}

		bool operator>=(const T* buffer)const
		{
			return Compare(buffer, *this)<=0;
		}

		bool operator<(const T* buffer)const
		{
			return Compare(buffer, *this)>0;
		}

		bool operator<=(const T* buffer)const
		{
			return Compare(buffer, *this)>=0;
		}

		T operator[](vint index)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString:<T>:operator[](vint)#参数index越界。");
			return buffer[start+index];
		}

		vint Length()const
		{
			return length;
		}

		vint IndexOf(T c)const
		{
			const T* reading=buffer+start;
			for(vint i=0;i<length;i++)
			{
				if(reading[i]==c)
					return i;
			}
			return -1;
		}

		ObjectString<T> Left(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Left(vint)#参数count越界。");
			return ObjectString<T>(*this, 0, count);
		}

		ObjectString<T> Right(vint count)const
		{
			CHECK_ERROR(count>=0 && count<=length, L"ObjectString<T>::Right(vint)#参数count越界。");
			return ObjectString<T>(*this, length-count, count);
		}

		ObjectString<T> Sub(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Sub(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Sub(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, index, count);
		}

		ObjectString<T> Remove(vint index, vint count)const
		{
			CHECK_ERROR(index>=0 && index<length, L"ObjectString<T>::Remove(vint, vint)#参数index越界。");
			CHECK_ERROR(index+count>=0 && index+count<=length, L"ObjectString<T>::Remove(vint, vint)#参数count越界。");
			return ObjectString<T>(*this, ObjectString<T>(), index, count);
		}

		ObjectString<T> Insert(vint index, const ObjectString<T>& string)const
		{
			CHECK_ERROR(index>=0 && index<=length, L"ObjectString<T>::Insert(vint)#参数count越界。");
			return ObjectString<T>(*this, string, index, 0);
		}

		friend bool operator<(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<0;
		}

		friend bool operator<=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)<=0;
		}

		friend bool operator>(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>0;
		}

		friend bool operator>=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)>=0;
		}

		friend bool operator==(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)==0;
		}

		friend bool operator!=(const T* left, const ObjectString<T>& right)
		{
			return Compare(left, right)!=0;
		}

		friend ObjectString<T> operator+(const T* left, const ObjectString<T>& right)
		{
			return WString(left, false)+right;
		}
	};

	template<typename T>
	ObjectString<T> ObjectString<T>::Empty=ObjectString<T>();

	typedef ObjectString<char>		AString;
	typedef ObjectString<wchar_t>	WString;

	extern vint					atoi(const AString& string);
	extern vint					wtoi(const WString& string);
	extern __int64				atoi64(const AString& string);
	extern __int64				wtoi64(const WString& string);
	extern vuint			atou(const AString& string);
	extern vuint			wtou(const WString& string);
	extern unsigned __int64		atou64(const AString& string);
	extern unsigned __int64		wtou64(const WString& string);
	extern double				atof(const AString& string);
	extern double				wtof(const WString& string);
	extern AString				itoa(vint number);
	extern WString				itow(vint number);
	extern AString				i64toa(__int64 number);
	extern WString				i64tow(__int64 number);
	extern AString				utoa(vuint number);
	extern WString				utow(vuint number);
	extern AString				u64toa(unsigned __int64 number);
	extern WString				u64tow(unsigned __int64 number);
	extern AString				ftoa(double number);
	extern WString				ftow(double number);
	extern vint					_wtoa(const wchar_t* w, char* a, vint chars);
	extern AString				wtoa(const WString& string);
	extern vint					_atow(const char* a, wchar_t* w, vint chars);
	extern WString				atow(const AString& string);
	extern AString				alower(const AString& string);
	extern WString				wlower(const WString& string);
	extern AString				aupper(const AString& string);
	extern WString				wupper(const WString& string);
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\POINTER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Smart Pointer

Classes:
	Ptr<T>							：智能指针
***********************************************************************/

#ifndef VCZH_POINTER
#define VCZH_POINTER


namespace vl
{
	template<typename T>
	class Ptr
	{
		 template<typename X>
		 friend class Ptr;
	protected:
		vint*				counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				(*counter)++;
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(--(*counter)==0)
				{
					delete counter;
					delete reference;
					counter=0;
					reference=0;
				}
			}
		}

		vint* Counter()const
		{
			return counter;
		}

		Ptr(vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		Ptr()
		{
			counter=0;
			reference=0;
		}

		Ptr(T* pointer)
		{
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		Ptr(const Ptr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		template<typename C>
		Ptr(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		~Ptr()
		{
			Dec();
		}

		template<typename C>
		Ptr<C> Cast()const
		{
			C* converted=dynamic_cast<C*>(reference);
			return Ptr<C>((converted?counter:0), converted);
		}

		Ptr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		Ptr<T>& operator=(const Ptr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		template<typename C>
		Ptr<T>& operator=(const Ptr<C>& pointer)
		{
			T* converted=pointer.Obj();
			Dec();
			if(converted)
			{
				counter=pointer.Counter();
				reference=converted;
				Inc();
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const Ptr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const Ptr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const Ptr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const Ptr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const Ptr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const Ptr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

	template<typename T>
	class ComPtr
	{
	protected:
		vint*				counter;
		T*					reference;

		void Inc()
		{
			if(counter)
			{
				(*counter)++;
			}
		}

		void Dec()
		{
			if(counter)
			{
				if(--(*counter)==0)
				{
					delete counter;
					reference->Release();
					counter=0;
					reference=0;
				}
			}
		}

		vint* Counter()const
		{
			return counter;
		}

		ComPtr(vint* _counter, T* _reference)
			:counter(_counter)
			,reference(_reference)
		{
			Inc();
		}
	public:

		ComPtr()
		{
			counter=0;
			reference=0;
		}

		ComPtr(T* pointer)
		{
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
		}

		ComPtr(const ComPtr<T>& pointer)
		{
			counter=pointer.counter;
			reference=pointer.reference;
			Inc();
		}

		~ComPtr()
		{
			Dec();
		}

		ComPtr<T>& operator=(T* pointer)
		{
			Dec();
			if(pointer)
			{
				counter=new vint(1);
				reference=pointer;
			}
			else
			{
				counter=0;
				reference=0;
			}
			return *this;
		}

		ComPtr<T>& operator=(const ComPtr<T>& pointer)
		{
			if(this!=&pointer)
			{
				Dec();
				counter=pointer.counter;
				reference=pointer.reference;
				Inc();
			}
			return *this;
		}

		bool operator==(const T* pointer)const
		{
			return reference==pointer;
		}

		bool operator!=(const T* pointer)const
		{
			return reference!=pointer;
		}

		bool operator>(const T* pointer)const
		{
			return reference>pointer;
		}

		bool operator>=(const T* pointer)const
		{
			return reference>=pointer;
		}

		bool operator<(const T* pointer)const
		{
			return reference<pointer;
		}

		bool operator<=(const T* pointer)const
		{
			return reference<=pointer;
		}

		bool operator==(const ComPtr<T>& pointer)const
		{
			return reference==pointer.reference;
		}

		bool operator!=(const ComPtr<T>& pointer)const
		{
			return reference!=pointer.reference;
		}

		bool operator>(const ComPtr<T>& pointer)const
		{
			return reference>pointer.reference;
		}

		bool operator>=(const ComPtr<T>& pointer)const
		{
			return reference>=pointer.reference;
		}

		bool operator<(const ComPtr<T>& pointer)const
		{
			return reference<pointer.reference;
		}

		bool operator<=(const ComPtr<T>& pointer)const
		{
			return reference<=pointer.reference;
		}

		operator bool()const
		{
			return reference!=0;
		}

		T* Obj()const
		{
			return reference;
		}

		T* operator->()const
		{
			return reference;
		}
	};

	template<typename T>
	struct KeyType<Ptr<T>>
	{
		typedef T* Type;
	};

	template<typename T>
	struct POD<Ptr<T>>
	{
		static const bool Result=false;
	};

	template<typename T>
	struct KeyType<ComPtr<T>>
	{
		typedef T* Type;
	};

	template<typename T>
	struct POD<ComPtr<T>>
	{
		static const bool Result=false;
	};
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\FUNCTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Framework::Function

Classes:
	Func<function-type>									：函数对象

Functions:
	Curry :: (A->B) -> A -> B							：参数拆分
	Combine :: (A->B) -> (A->C) -> (B->C->D) -> (A->D)	：函数组合
	
本文件使用Vczh Functional Macro工具自动生成
***********************************************************************/
#ifndef VCZH_FUNCTION
#define VCZH_FUNCTION
namespace vl
{
	template<typename T>
	class Func
	{
	};
 
/***********************************************************************
vl::Func<R()>
***********************************************************************/
	template<typename R >
	class Func<R()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)();
		public:
			StaticInvoker(R(*_function)())
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)();
			struct Content
			{
				C*			sender;
				R(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke()
			{
				return (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function->operator()();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function->operator()();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke()
			{
				return function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType();
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R()>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()()const
		{
			return invoker->Invoke();
		}
		bool operator==(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void()>
***********************************************************************/
	template< >
	class Func<void()> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke()=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)();
		public:
			StaticInvoker(void(*_function)())
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)();
			struct Content
			{
				C*			sender;
				void(C::*function)();
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)())
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke()
			{
				  (sender->*function)();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function->operator()();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function->operator()();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke()
			{
				  function();
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType();
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void()>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)())
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)())
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()()const
		{
			  invoker->Invoke();
		}
		bool operator==(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void()>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0)>
***********************************************************************/
	template<typename R,typename T0>
	class Func<R(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0);
		public:
			StaticInvoker(R(*_function)(T0))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function->operator()(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function->operator()(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0)
			{
				return function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0)const
		{
			return invoker->Invoke(p0);
		}
		bool operator==(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0)>
***********************************************************************/
	template< typename T0>
	class Func<void(T0)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0);
		public:
			StaticInvoker(void(*_function)(T0))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  (sender->*function)(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function->operator()(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function->operator()(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0)
			{
				  function(p0);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0)const
		{
			  invoker->Invoke(p0);
		}
		bool operator==(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1)>
***********************************************************************/
	template<typename R,typename T0,typename T1>
	class Func<R(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1);
		public:
			StaticInvoker(R(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function->operator()(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function->operator()(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1)
			{
				return function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1)const
		{
			return invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1)>
***********************************************************************/
	template< typename T0,typename T1>
	class Func<void(T0,T1)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1);
		public:
			StaticInvoker(void(*_function)(T0,T1))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  (sender->*function)(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function->operator()(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function->operator()(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1)
			{
				  function(p0,p1);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1)const
		{
			  invoker->Invoke(p0,p1);
		}
		bool operator==(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2>
	class Func<R(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function->operator()(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function->operator()(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2)
			{
				return function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2)const
		{
			return invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2)>
***********************************************************************/
	template< typename T0,typename T1,typename T2>
	class Func<void(T0,T1,T2)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  (sender->*function)(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function->operator()(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function->operator()(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2)
			{
				  function(p0,p1,p2);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2)const
		{
			  invoker->Invoke(p0,p1,p2);
		}
		bool operator==(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3>
	class Func<R(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function->operator()(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function->operator()(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				return function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			return invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3>
	class Func<void(T0,T1,T2,T3)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  (sender->*function)(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function->operator()(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function->operator()(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3)
			{
				  function(p0,p1,p2,p3);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
		{
			  invoker->Invoke(p0,p1,p2,p3);
		}
		bool operator==(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<R(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function->operator()(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function->operator()(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				return function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4>
	class Func<void(T0,T1,T2,T3,T4)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  (sender->*function)(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function->operator()(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function->operator()(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)
			{
				  function(p0,p1,p2,p3,p4);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<R(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				return function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
	class Func<void(T0,T1,T2,T3,T4,T5)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)
			{
				  function(p0,p1,p2,p3,p4,p5);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<R(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				return function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
	class Func<void(T0,T1,T2,T3,T4,T5,T6)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)
			{
				  function(p0,p1,p2,p3,p4,p5,p6);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
  
/***********************************************************************
vl::Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(R(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<R(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, R(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function->operator()(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual R Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				return function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef R ResultType;
		Func()
		{
		}
		Func(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(R(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, R(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			return invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
/***********************************************************************
vl::Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
	template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
	class Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)> : public Object
	{
		static const vint BinarySize = sizeof(void*)*8;
	protected:
		class Invoker : public Object
		{
		public:
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)=0;
			virtual void RetriveBinary(char* binary)=0;
		};
		class StaticInvoker : public Invoker
		{
		protected:
			void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		public:
			StaticInvoker(void(*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void(*)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class MemberInvoker : public Invoker
		{
		protected:
			C*			sender;
			void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			struct Content
			{
				C*			sender;
				void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			};
		public:
			MemberInvoker(C* _sender, void(C::*_function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
				:sender(_sender)
				,function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  (sender->*function)(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<Content, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t.sender=sender;
				retriver.t.function=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class PointerInvoker : public Invoker
		{
		protected:
			C*			function;
		public:
			PointerInvoker(C* _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class SmartPointerInvoker : public Invoker
		{
		protected:
			Ptr<C>		function;
		public:
			SmartPointerInvoker(const Ptr<C>& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function->operator()(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<C*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=function.Obj();
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
		template<typename C>
		class ObjectInvoker : public Invoker
		{
		protected:
			C			function;
		public:
			ObjectInvoker(const C& _function)
				:function(_function)
			{
			}
			virtual void Invoke(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)
			{
				  function(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
			}
			virtual void RetriveBinary(char* binary)
			{
				BinaryRetriver<void*, BinarySize> retriver;
				memset(retriver.binary, 0, BinarySize);
				retriver.t=this;
				memcpy(binary, retriver.binary, BinarySize);
			}
		};
	protected:
		Ptr<Invoker>			invoker;
	public:
		typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
		typedef void ResultType;
		Func()
		{
		}
		Func(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)
		{
			invoker=function.invoker;
		}
		Func(void(*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new StaticInvoker(function);
		}
		template<typename C>
		Func(C* sender, void(C::*function)(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9))
		{
			invoker=new MemberInvoker<C>(sender, function);
		}
		template<typename C>
		Func(C* function)
		{
			invoker=new PointerInvoker<C>(function);
		}
		template<typename C>
		Func(const Ptr<C>& function)
		{
			invoker=new SmartPointerInvoker<C>(function);
		}
		template<typename C>
		Func(const C& function)
		{
			invoker=new ObjectInvoker<C>(function);
		}
		void operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
		{
			  invoker->Invoke(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
		}
		bool operator==(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)==0;
		}
		bool operator!=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)!=0;
		}
		bool operator<(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<0;
		}
		bool operator<=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)<=0;
		}
		bool operator>(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>0;
		}
		bool operator>=(const Func<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& function)const
		{
			char a[BinarySize];
			char b[BinarySize];
			invoker->RetriveBinary(a);
			function.invoker->RetriveBinary(b);
			return memcmp(a, b, BinarySize)>=0;
		}
		operator bool()const
		{
			return invoker;
		}
	};
 
	namespace function_binding
	{
		template<typename T>
		struct Binding
		{
		};
		 
		template<typename T>
		struct CR{typedef const T& Type;};
		template<typename T>
		struct CR<T&>{typedef T& Type;};
		template<typename T>
		struct CR<const T>{typedef const T& Type;};
		template<typename T>
		struct CR<const T&>{typedef const T& Type;};
		 
		template<typename T>
		struct RCR{typedef T Type;};
		template<typename T>
		struct RCR<T&>{typedef T& Type;};
		template<typename T>
		struct RCR<const T>{typedef T Type;};
		template<typename T>
		struct RCR<const T&>{typedef T Type;};
		
 
/***********************************************************************
vl::function_binding::Binding<R(T0)>
***********************************************************************/
		template<typename R,typename T0>
		struct Binding<R(T0)>
		{
			typedef R FunctionType(T0);
			typedef R CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()()const
				{
					return target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0)>
***********************************************************************/
		template< typename T0>
		struct Binding<void(T0)>
		{
			typedef void FunctionType(T0);
			typedef void CurriedType();
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()()const
				{
					  target(p0);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1)>
***********************************************************************/
		template<typename R,typename T0,typename T1>
		struct Binding<R(T0,T1)>
		{
			typedef R FunctionType(T0,T1);
			typedef R CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1)const
				{
					return target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1)>
***********************************************************************/
		template< typename T0,typename T1>
		struct Binding<void(T0,T1)>
		{
			typedef void FunctionType(T0,T1);
			typedef void CurriedType(T1);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1)const
				{
					  target(p0,p1);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2>
		struct Binding<R(T0,T1,T2)>
		{
			typedef R FunctionType(T0,T1,T2);
			typedef R CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2)const
				{
					return target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2)>
***********************************************************************/
		template< typename T0,typename T1,typename T2>
		struct Binding<void(T0,T1,T2)>
		{
			typedef void FunctionType(T0,T1,T2);
			typedef void CurriedType(T1,T2);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2)const
				{
					  target(p0,p1,p2);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3>
		struct Binding<R(T0,T1,T2,T3)>
		{
			typedef R FunctionType(T0,T1,T2,T3);
			typedef R CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3)const
				{
					return target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3>
		struct Binding<void(T0,T1,T2,T3)>
		{
			typedef void FunctionType(T0,T1,T2,T3);
			typedef void CurriedType(T1,T2,T3);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3)const
				{
					  target(p0,p1,p2,p3);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<R(T0,T1,T2,T3,T4)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4);
			typedef R CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					return target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4>
		struct Binding<void(T0,T1,T2,T3,T4)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4);
			typedef void CurriedType(T1,T2,T3,T4);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4)const
				{
					  target(p0,p1,p2,p3,p4);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<R(T0,T1,T2,T3,T4,T5)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5);
			typedef R CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					return target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		struct Binding<void(T0,T1,T2,T3,T4,T5)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5);
			typedef void CurriedType(T1,T2,T3,T4,T5);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
				{
					  target(p0,p1,p2,p3,p4,p5);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
  
/***********************************************************************
vl::function_binding::Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template<typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<R(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef R FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				R operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					return target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
/***********************************************************************
vl::function_binding::Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
***********************************************************************/
		template< typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		struct Binding<void(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>
		{
			typedef void FunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef void CurriedType(T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef T0 ParameterType;
			class Binder : public Object
			{
			protected:
				Func<FunctionType>		target;
				typename RCR<T0>::Type	p0;
			public:
				Binder(const Func<FunctionType>& _target, typename CR<T0>::Type _p0)
					:target(_target)
					,p0(_p0)
				{
				}
				void operator()(T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
				{
					  target(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9);
				}
			};
			class Currier : public Object
			{
			protected:
				Func<FunctionType>		target;
			public:
				Currier(const Func<FunctionType>& _target)
					:target(_target)
				{
				}
				Func<CurriedType> operator()(typename CR<T0>::Type argument)const
				{
					return Ptr<Binder>(new Binder(target, argument));
				}
			};
		};
 
	}
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(T* function)
	{
		return Ptr<typename function_binding::Binding<T>::Currier>(new typename function_binding::Binding<T>::Currier(function));
	}
	template<typename T>
	Func<Func<typename function_binding::Binding<T>::CurriedType>(typename function_binding::Binding<T>::ParameterType)>
	Curry(const Func<T>& function)
	{
		return Ptr<typename function_binding::Binding<T>::Currier>(new typename function_binding::Binding<T>::Currier(function));
	}
	namespace function_combining
	{
		template<typename A, typename B, typename C>
		class Combining
		{
		};
		
 
/***********************************************************************
vl::function_combining::Combining<R1(), R2(), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R >
		class Combining<R1(), R2(), R(R1,R2)> : public Object
		{
		protected:
			Func<R1()>			function1;
			Func<R2()>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType();
			typedef R2 SecondFunctionType();
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType();
			Combining(const Func<R1()>& _function1, const Func<R2()>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()()const
			{
				return converter(function1(), function2());
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0), R2(T0), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0>
		class Combining<R1(T0), R2(T0), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0)>			function1;
			Func<R2(T0)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0);
			typedef R2 SecondFunctionType(T0);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0);
			Combining(const Func<R1(T0)>& _function1, const Func<R2(T0)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0)const
			{
				return converter(function1(p0), function2(p0));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1>
		class Combining<R1(T0,T1), R2(T0,T1), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1)>			function1;
			Func<R2(T0,T1)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1);
			typedef R2 SecondFunctionType(T0,T1);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1);
			Combining(const Func<R1(T0,T1)>& _function1, const Func<R2(T0,T1)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1)const
			{
				return converter(function1(p0,p1), function2(p0,p1));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2>
		class Combining<R1(T0,T1,T2), R2(T0,T1,T2), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2)>			function1;
			Func<R2(T0,T1,T2)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2);
			typedef R2 SecondFunctionType(T0,T1,T2);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2);
			Combining(const Func<R1(T0,T1,T2)>& _function1, const Func<R2(T0,T1,T2)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2)const
			{
				return converter(function1(p0,p1,p2), function2(p0,p1,p2));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3>
		class Combining<R1(T0,T1,T2,T3), R2(T0,T1,T2,T3), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3)>			function1;
			Func<R2(T0,T1,T2,T3)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3);
			typedef R2 SecondFunctionType(T0,T1,T2,T3);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3);
			Combining(const Func<R1(T0,T1,T2,T3)>& _function1, const Func<R2(T0,T1,T2,T3)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3)const
			{
				return converter(function1(p0,p1,p2,p3), function2(p0,p1,p2,p3));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4>
		class Combining<R1(T0,T1,T2,T3,T4), R2(T0,T1,T2,T3,T4), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4)>			function1;
			Func<R2(T0,T1,T2,T3,T4)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4);
			Combining(const Func<R1(T0,T1,T2,T3,T4)>& _function1, const Func<R2(T0,T1,T2,T3,T4)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4)const
			{
				return converter(function1(p0,p1,p2,p3,p4), function2(p0,p1,p2,p3,p4));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5>
		class Combining<R1(T0,T1,T2,T3,T4,T5), R2(T0,T1,T2,T3,T4,T5), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5), function2(p0,p1,p2,p3,p4,p5));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6), R2(T0,T1,T2,T3,T4,T5,T6), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6), function2(p0,p1,p2,p3,p4,p5,p6));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7), R2(T0,T1,T2,T3,T4,T5,T6,T7), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7), function2(p0,p1,p2,p3,p4,p5,p6,p7));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8));
			}
		}; 
/***********************************************************************
vl::function_combining::Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)>
***********************************************************************/
		template<typename R1, typename R2, typename R,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9>
		class Combining<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9), R(R1,R2)> : public Object
		{
		protected:
			Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function1;
			Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>			function2;
			Func<R(R1,R2)>							converter;
		public:
			typedef R1 FirstFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R2 SecondFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			typedef R ConverterFunctionType(R1,R2);
			typedef R FinalFunctionType(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9);
			Combining(const Func<R1(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function1, const Func<R2(T0,T1,T2,T3,T4,T5,T6,T7,T8,T9)>& _function2, const Func<R(R1,R2)>& _converter)
				:function1(_function1)
				,function2(_function2)
				,converter(_converter)
			{
			}
			R operator()(T0 p0,T1 p1,T2 p2,T3 p3,T4 p4,T5 p5,T6 p6,T7 p7,T8 p8,T9 p9)const
			{
				return converter(function1(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9), function2(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9));
			}
		};
	}
	template<typename F1, typename F2, typename C>
	Func<typename function_combining::Combining<F1, F2, C>::FinalFunctionType>
	Combine(Func<C> converter, Func<F1> function1, Func<F2> function2)
	{
		return Ptr<function_combining::Combining<F1, F2, C>>(new function_combining::Combining<F1, F2, C>(function1, function2, converter));
	}
	template<typename T>
	Func<Func<T>(Func<T>,Func<T>)> Combiner(const Func<typename Func<T>::ResultType(typename Func<T>::ResultType,typename Func<T>::ResultType)>& converter)
	{
		typedef typename Func<T>::ResultType R;
		return Curry<Func<T>(Func<R(R,R)>,Func<T>,Func<T>)>(Combine)(converter);
	}
}
#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\COLLECTIONS\PAIR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Pair

Classes:
	Pair<K, V>							：二元组
***********************************************************************/

#ifndef VCZH_COLLECTIONS_PAIR
#define VCZH_COLLECTIONS_PAIR


namespace vl
{
	namespace collections
	{
		template<typename K, typename V>
		class Pair
		{
		public:
			K				key;
			V				value;

			Pair()
			{
			}

			Pair(const K& _key, const V& _value)
			{
				key=_key;
				value=_value;
			}

			Pair(const Pair<K, V>& pair)
			{
				key=pair.key;
				value=pair.value;
			}

			vint CompareTo(const Pair<K, V>& pair)const
			{
				if(key<pair.key)
				{
					return -1;
				}
				else if(key>pair.key)
				{
					return 1;
				}
				else if(value<pair.value)
				{
					return -1;
				}
				else if(value>pair.value)
				{
					return 1;
				}
				else
				{
					return 0;
				}
			}

			bool operator==(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)==0;
			}

			bool operator!=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)!=0;
			}

			bool operator<(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<0;
			}

			bool operator<=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)<=0;
			}

			bool operator>(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>0;
			}

			bool operator>=(const Pair<K, V>& pair)const
			{
				return CompareTo(pair)>=0;
			}
		};
	}

	template<typename K, typename V>
	struct POD<collections::Pair<K, V>>
	{
		static const bool Result=POD<K>::Result && POD<V>::Result;
	};
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\COLLECTIONS\INTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Interfaces

Interfaces:
	IEnumerator<T>									：枚举器
	IEnumerable<T>									：可枚举对象
	IReadonlyList<T>								：只读列表
	IArray<T>										：数组
	ICollection<T>									：集合
	IList<T>										：列表
	IReadonlyDictionary<K,V>						：只读映射
	IDictionary<K,V>								：映射
	IReadonlyGroup<K,V>								：只读多重映射
	IGroup<K,V>										：多重映射
***********************************************************************/

#ifndef VCZH_COLLECTIONS_INTERFACES
#define VCZH_COLLECTIONS_INTERFACES


namespace vl
{
	namespace collections
	{

/***********************************************************************
接口
***********************************************************************/

		template<typename T>
		class IEnumerator : public virtual Interface
		{
		public:
			virtual IEnumerator<T>*						Clone()const=0;
			virtual const T&							Current()const=0;
			virtual vint								Index()const=0;
			virtual bool								Next()=0;
			virtual bool								Available()const=0;
			virtual void								Reset()=0;
		};

		template<typename T>
		class IEnumerable : public virtual Interface
		{
		public:
			virtual IEnumerator<T>*						CreateEnumerator()const=0;
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class IReadonlyList : public virtual IEnumerable<T>
		{
		public:
			virtual bool								Contains(const K& item)const=0;
			virtual vint								Count()const=0;
			virtual const T&							Get(vint index)const=0;
			virtual const T&							operator[](vint index)const=0;
			virtual vint								IndexOf(const K& item)const=0;
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class IArray : public virtual IReadonlyList<T, K>
		{
		public:
			virtual void								Set(vint index, const T& item)=0;
			virtual void								Resize(vint size)=0;
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class ICollection : public virtual IReadonlyList<T, K>
		{
		public:
			virtual vint								Add(const T& item)=0;
			virtual bool								Remove(const K& item)=0;
			virtual bool								RemoveAt(vint index)=0;
			virtual bool								RemoveRange(vint index, vint count)=0;
			virtual bool								Clear()=0;
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class IList : public virtual ICollection<T, K>
		{
		public:
			virtual vint								Insert(vint index, const T& item)=0;
			virtual bool								Set(vint index, const T& item)=0;
		};

		template<typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class IReadonlyDictionary : public virtual IEnumerable<Pair<KT, VT>>
		{
		public:
			virtual const IReadonlyList<KT, KK>&		Keys()const=0;
			virtual const IReadonlyList<VT, VK>&		Values()const=0;
			virtual vint								Count()const=0;
			virtual const VT&							Get(const KK& key)const=0;
			virtual const VT&							operator[](const KK& key)const=0;
		};

		template<typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class IDictionary : public virtual IReadonlyDictionary<KT, VT, KK, VK>
		{
		public:
			virtual bool								Set(const KK& key, const VT& value)=0;
			virtual bool								Add(const KT& key, const VT& value)=0;
			virtual bool								Remove(const KK& key)=0;
			virtual bool								Clear()=0;
		};

		template<typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class IReadonlyGroup : public virtual IEnumerable<Pair<KT, VT>>
		{
		public:
			virtual const IReadonlyList<KT, KK>&		Keys()const=0;
			virtual vint								Count()const=0;
			virtual const IReadonlyList<VT, VK>&		Get(const KK& key)const=0;
			virtual const IReadonlyList<VT, VK>&		GetByIndex(vint index)const=0;
			virtual const IReadonlyList<VT, VK>&		operator[](const KK& key)const=0;
			virtual bool								Contains(const KK& key)const=0;
			virtual bool								Contains(const KK& key, const VK& value)const=0;
		};

		template<typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class IGroup: public virtual IReadonlyGroup<KT, VT, KK, VK>
		{
		public:
			virtual bool								Add(const KT& key, const VT& value)=0;
			virtual bool								Remove(const KK& key)=0;
			virtual bool								Remove(const KK& key, const VK& value)=0;
			virtual bool								Clear()=0;
		};
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\COLLECTIONS\LISTWRAPPERS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::List Wrappers

Classes:
	ReadonlyListEnumerator<T>
	ReadonlyListConverter<T>
	ReadonlyListWrapper<T>
	ArrayWrapper<T>
	CollectionWrapper<T>
	ListWrapper<T>
***********************************************************************/

#ifndef VCZH_COLLECTIONS_LISTWRAPPERS
#define VCZH_COLLECTIONS_LISTWRAPPERS


namespace vl
{
	namespace collections
	{

/***********************************************************************
代理
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class ReadonlyListEnumerator : public Object, public virtual IEnumerator<T>
		{
		private:
			const IReadonlyList<T, K>*			container;
			vint									index;
		public:
			ReadonlyListEnumerator(const IReadonlyList<T, K>* _container, vint _index)
			{
				container=_container;
				index=_index;
			}

			ReadonlyListEnumerator<T>* Clone()const
			{
				return new ReadonlyListEnumerator<T, K>(container, index);
			}

			const T& Current()const
			{
				return container->Get(index);
			}

			vint Index()const
			{
				return index;
			}

			bool Next()
			{
				index++;
				return Available();
			}

			bool Available()const
			{
				return index>=0 && index<container->Count();
			}

			void Reset()
			{
				index=0;
			}
		};

		template<typename C, typename T, typename K=typename KeyType<T>::Type>
		class ReadonlyListWrapper : public Object, public virtual IReadonlyList<T, K>
		{
		private:
			C*									container;
		public:
			ReadonlyListWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return container->Contains(item);
			}

			vint Count()const
			{
				return container->Count();
			}

			const T& Get(vint index)const
			{
				return container->Get(index);
			}

			const T& operator[](vint index)const
			{
				return container->operator[](index);
			}

			vint IndexOf(const K& item)const
			{
				return container->IndexOf(item);
			}
		};

		template<typename C, typename T, typename K=typename KeyType<T>::Type>
		class ArrayWrapper : public Object, public virtual IArray<T, K>
		{
		private:
			C*									container;
		public:
			ArrayWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return container->Contains(item);
			}

			vint Count()const
			{
				return container->Count();
			}

			const T& Get(vint index)const
			{
				return container->Get(index);
			}

			const T& operator[](vint index)const
			{
				return container->operator[](index);
			}

			vint IndexOf(const K& item)const
			{
				return container->IndexOf(item);
			}

			void Set(vint index, const T& item)
			{
				container->Set(index, item);
			}

			void Resize(vint size)
			{
				container->Resize(size);
			}
		};

		template<typename C, typename T, typename K=KeyType<T>::Type>
		class CollectionWrapper : public Object, public virtual ICollection<T, K>
		{
		private:
			C*									container;
		public:
			CollectionWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return container->Contains(item);
			}

			vint Count()const
			{
				return container->Count();
			}

			const T& Get(vint index)const
			{
				return container->Get(index);
			}

			const T& operator[](vint index)const
			{
				return container->operator[](index);
			}

			vint IndexOf(const K& item)const
			{
				return container->IndexOf(item);
			}

			vint Add(const T& item)
			{
				return container->Add(item);
			}

			bool Remove(const K& item)
			{
				return container->Remove(item);
			}

			bool RemoveAt(vint index)
			{
				return container->RemoveAt(index);
			}

			bool RemoveRange(vint index, vint count)
			{
				return container->RemoveRange(index, count);
			}

			bool Clear()
			{
				return container->Clear();
			}
		};

		template<typename C, typename T, typename K=KeyType<T>::Type>
		class ListWrapper : public Object, public virtual IList<T, K>
		{
		private:
			C*									container;
		public:
			ListWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return container->Contains(item);
			}

			vint Count()const
			{
				return container->Count();
			}

			const T& Get(vint index)const
			{
				return container->Get(index);
			}

			const T& operator[](vint index)const
			{
				return container->operator[](index);
			}

			vint IndexOf(const K& item)const
			{
				return container->IndexOf(item);
			}

			vint Add(const T& item)
			{
				return container->Add(item);
			}

			bool Remove(const K& item)
			{
				return container->Remove(item);
			}

			bool RemoveAt(vint index)
			{
				return container->RemoveAt(index);
			}

			bool RemoveRange(vint index, vint count)
			{
				return container->RemoveRange(index, count);
			}

			bool Clear()
			{
				return container->Clear();
			}

			vint Insert(vint index, const T& item)
			{
				return container->Insert(index, item);
			}

			bool Set(vint index, const T& item)
			{
				return container->Set(index, item);
			}
		};

/***********************************************************************
类型转换代理
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class ReadonlyListImplBase : public virtual IReadonlyList<T, K>
		{
		public:
			IEnumerator<T>* CreateEnumerator()const
			{
				return new ReadonlyListEnumerator<T, K>(this, 0);
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			const T& operator[](vint index)const
			{
				return Get(index);
			}

			vint IndexOf(const K& item)const
			{
				vint count=Count();
				for(vint i=0;i<count;i++)
				{
					if(Get(i)==item)
					{
						return i;
					}
				}
				return -1;
			}
		};

		template<typename TS, typename TD, typename KS=typename KeyType<TS>::Type, typename KD=typename KeyType<TD>::Type>
		class ReadonlyListConverterBase : protected ReadonlyListImplBase<TD, KD>
		{
		private:
			IReadonlyList<TS, KS>*				container;

		protected:
			ReadonlyListConverterBase()
				:container(0)
			{
			}

			vint Count()const
			{
				return container->Count();
			}

			const TD& Get(vint index)const
			{
				return Convert(container->Get(index));
			}

			void SetContainer(IReadonlyList<TS, KS>* _container)
			{
				container=_container;
			}

			virtual const TD& Convert(const TS& value)const;
		};
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\COLLECTIONS\LIST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::List

Classes:
	ListStore<T,PODType>				：列表存储复制算法
	ListBase<T,K>						：列表基类
	Array<T,K>							：数组
	List<T,K>							：列表
	SortedList<T,K>						：有序列表
***********************************************************************/

#ifndef VCZH_COLLECTIONS_LIST
#define VCZH_COLLECTIONS_LIST

#include <string.h>

namespace vl
{
	namespace collections
	{

/***********************************************************************
储存结构
***********************************************************************/

		template<typename T, bool PODType>
		class ListStore abstract : public Object
		{
		};
		
		template<typename T>
		class ListStore<T,false> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(dest<source)
				{
					for(vint i=0;i<count;i++)
					{
						dest[i]=source[i];
					}
				}
				else if(dest>source)
				{
					for(vint i=count-1;i>=0;i--)
					{
						dest[i]=source[i];
					}
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
				for(int i=0;i<count;i++)
				{
					dest[i]=T();
				}
			}
		public:
		};
		
		template<typename T>
		class ListStore<T,true> abstract : public Object
		{
		protected:
			static void CopyObjects(T* dest, const T* source, vint count)
			{
				if(count)
				{
					memmove(dest, source, sizeof(T)*count);
				}
			}

			static void ClearObjects(T* dest, vint count)
			{
			}
		public:
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class ListBase abstract : public ListStore<T,POD<T>::Result>
		{
		protected:
			vint						count;
			vint						capacity;
			T*						buffer;
			bool					lessMemoryMode;

			vint CalculateCapacity(vint expected)
			{
				vint result=capacity;
				while(result<expected)
				{
					result=result*5/4+1;
				}
				return result;
			}

			void MakeRoom(vint index, vint _count)
			{
				vint newCount=count+_count;
				if(newCount>capacity)
				{
					vint newCapacity=CalculateCapacity(newCount);
					T* newBuffer=new T[newCapacity];
					CopyObjects(newBuffer, buffer, index);
					CopyObjects(newBuffer+index+_count, buffer+index, count-index);
					delete[] buffer;
					capacity=newCapacity;
					buffer=newBuffer;
				}
				else
				{
					CopyObjects(buffer+index+_count, buffer+index, count-index);
				}
				count=newCount;
			}

			void ReleaseUnnecessaryBuffer(vint previousCount)
			{
				if(buffer && count<previousCount)
				{
					ClearObjects(&buffer[count], previousCount-count);
				}
				if(lessMemoryMode && count<=capacity/2)
				{
					vint newCapacity=capacity*5/8;
					if(count<newCapacity)
					{
						T* newBuffer=new T[newCapacity];
						CopyObjects(newBuffer, buffer, count);
						delete[] buffer;
						capacity=newCapacity;
						buffer=newBuffer;
					}
				}
			}
		public:
			ListBase()
			{
				count=0;
				capacity=0;
				buffer=0;
				lessMemoryMode=true;
			}

			~ListBase()
			{
				delete[] buffer;
			}

			void SetLessMemoryMode(bool mode)
			{
				lessMemoryMode=mode;
			}

			vint Count()const
			{
				return count;
			}

			const T& Get(vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::Get(vint)#参数越界。");
				return buffer[index];
			}

			const T& operator[](vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			bool RemoveAt(vint index)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<count, L"ListBase<T, K>::RemoveAt(vint)#参数index越界。");
				CopyObjects(buffer+index,buffer+index+1,count-index-1);
				count--;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool RemoveRange(vint index, vint _count)
			{
				vint previousCount=count;
				CHECK_ERROR(index>=0 && index<=count, L"ListBase<T, K>::RemoveRange(vint, vint)#参数index越界。");
				CHECK_ERROR(index+_count>=0 && index+_count<=count, L"ListBase<T,K>::RemoveRange(vint, vint)#参数_count越界。");
				CopyObjects(buffer+index, buffer+index+_count, count-index-_count);
				count-=_count;
				ReleaseUnnecessaryBuffer(previousCount);
				return true;
			}

			bool Clear()
			{
				vint previousCount=count;
				count=0;
				if(lessMemoryMode)
				{
					capacity=0;
					delete[] buffer;
					buffer=0;
				}
				else
				{
					ReleaseUnnecessaryBuffer(previousCount);
				}
				return true;
			}
		};

/***********************************************************************
列表对象
***********************************************************************/

		template<typename T, typename K=typename KeyType<T>::Type>
		class Array : public ListStore<T, POD<T>::Result>, private NotCopyable
		{
		protected:
			vint								count;
			T*								buffer;
			mutable ArrayWrapper<Array<T, K>, T, K>		wrapper;

			void Create(vint size)
			{
				if(size>0)
				{
					count=size;
					buffer=new T[size];
				}
				else
				{
					count=0;
					buffer=0;
				}
			}

			void Destroy()
			{
				count=0;
				delete[] buffer;
				buffer=0;
			}
		public:
			Array(vint size=0)
			{
				wrapper.SetContainer(this);
				Create(size);
			}

			Array(const T* _buffer, vint size)
			{
				wrapper.SetContainer(this);
				Create(size);
				CopyObjects(buffer, _buffer, size);
			}

			~Array()
			{
				Destroy();
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint Count()const
			{
				return count;
			}

			const T& Get(vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::Get(vint)#参数越界。");
				return buffer[index];
			}

			const T& operator[](vint index)const
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			void Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
			}

			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"Array<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			void Resize(vint size)
			{
				vint oldCount=count;
				T* oldBuffer=buffer;
				Create(size);
				CopyObjects(buffer, oldBuffer, (count<oldCount?count:oldCount));
				delete[] oldBuffer;
			}

			IArray<T, K>& Wrap()const
			{
				return wrapper;
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class List : public ListBase<T, K>, private NotCopyable
		{
		protected:
			mutable ListWrapper<List<T, K>, T, K>	wrapper;
		public:
			List()
			{
				wrapper.SetContainer(this);
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			vint IndexOf(const K& item)const
			{
				for(vint i=0;i<count;i++)
				{
					if(buffer[i]==item)
					{
						return i;
					}
				}
				return -1;
			}

			vint Add(const T& item)
			{
				MakeRoom(count, 1);
				buffer[count-1]=item;
				return count-1;
			}

			vint Insert(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<=count, L"List<T, K>::Insert(vint, const T&)#参数index越界。");
				MakeRoom(index,1);
				buffer[index]=item;
				return index;
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Set(vint index, const T& item)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::Set(vint)#参数index越界。");
				buffer[index]=item;
				return true;
			}

			T& operator[](vint index)
			{
				CHECK_ERROR(index>=0 && index<count, L"List<T, K>::operator[](vint)#参数index越界。");
				return buffer[index];
			}

			IList<T, K>& Wrap()const
			{
				return wrapper;
			}
		};

		template<typename T, typename K=typename KeyType<T>::Type>
		class SortedList : public ListBase<T, K>, private NotCopyable
		{
		protected:
			mutable CollectionWrapper<SortedList<T, K>, T, K>	wrapper;
		public:
			SortedList()
			{
				wrapper.SetContainer(this);
			}

			bool Contains(const K& item)const
			{
				return IndexOf(item)!=-1;
			}

			template<typename Key>
			vint IndexOf(const Key& item)const
			{
				vint start=0;
				vint end=count-1;
				while(start<=end)
				{
					vint index=(start+end)/2;
					if(buffer[index]==item)
					{
						return index;
					}
					else if(buffer[index]>item)
					{
						end=index-1;
					}
					else
					{
						start=index+1;
					}
				}
				return -1;
			}

			vint IndexOf(const K& item)const
			{
				return IndexOf<K>(item);
			}

			vint Add(const T& item)
			{
				if(count==0)
				{
					MakeRoom(0, 1);
					buffer[0]=item;
					return 0;
				}
				else
				{
					vint start=0;
					vint end=count-1;
					vint index=-1;
					while(start<=end)
					{
						index=(start+end)/2;
						if(buffer[index]==item)
						{
							goto SORTED_LIST_INSERT;
						}
						else if(buffer[index]>item)
						{
							end=index-1;
						}
						else
						{
							start=index+1;
						}
					}
					CHECK_ERROR(index>=0 && index<count, L"SortedList<T, K>::Add(const T&)#内部错误，变量index越界");
					if(buffer[index]<item)
					{
						index++;
					}
SORTED_LIST_INSERT:
					MakeRoom(index, 1);
					buffer[index]=item;
					return index;
				}
			}

			bool Remove(const K& item)
			{
				vint index=IndexOf(item);
				if(index>=0 && index<count)
				{
					RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			ICollection<T, K>& Wrap()const
			{
				return wrapper;
			}
		};

/***********************************************************************
容器复制模板
***********************************************************************/

		template<typename A, typename B>
		void CopyToCollection(A& dst, const B& src, bool append=false)
		{
			if(!append)dst.Clear();
			vint count=src.Count();
			for(vint i=0;i<count;i++)
			{
				dst.Add(src.Get(i));
			}
		}

		template<typename A, typename B>
		void CopyToArray(A& dst, const B& src, bool append=false)
		{
			vint start=0;
			vint count=src.Count();
			if(append)
			{
				start=dst.Count();
				dst.Resize(start+count);
			}
			else
			{
				dst.Resize(count);
			}
			for(vint i=0;i<count;i++)
			{
				dst[start+i]=src.Get(i);
			}
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\COLLECTIONS\DICTIONARYWRAPPERS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Dictionary Wrappers

Classes:
	ReadonlyDictionaryWrapper<V,K>
	DictionaryWrapper<V,K>
	ReadonlyGroupWrapper<V,K>
	GroupWrapper<V,K>
***********************************************************************/

#ifndef VCZH_COLLECTIONS_DICTIONARYWRAPPERS
#define VCZH_COLLECTIONS_DICTIONARYWRAPPERS


namespace vl
{
	namespace collections
	{

/***********************************************************************
代理
***********************************************************************/

		template<typename C, typename KT, typename VT, typename KK, typename VK>
		class DictionaryWrapper;
		
		template<typename C, typename KT, typename VT, typename KK, typename VK>
		class GroupWrapper;

		template<typename C, typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class ReadonlyDictionaryWrapper : public Object, public virtual IReadonlyDictionary<KT, VT, KK, VK>
		{
			friend class DictionaryWrapper<C, KT, VT, KK, VK>;
		private:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const IReadonlyDictionary<KT, VT, KK, VK>*	container;
				vint											index;
				Pair<KT, VT>								current;

				void UpdateCurrent()
				{
					if(index<container->Count())
					{
						current.key=container->Keys()[index];
						current.value=container->Values()[index];
					}
				}
			public:
				Enumerator(const IReadonlyDictionary* _container, vint _index=0)
				{
					container=_container;
					index=_index;
					UpdateCurrent();
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, index);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					return index;
				}

				bool Next()
				{
					index++;
					UpdateCurrent();
					return Available();
				}

				bool Available()const
				{
					return index>=0 && index<container->Count();
				}

				void Reset()
				{
					index=0;
					UpdateCurrent();
				}
			};

			C*						container;
		public:
			ReadonlyDictionaryWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return container->Keys();
			}

			const IReadonlyList<VT, VK>& Values()const
			{
				return container->Values();
			}

			vint Count()const
			{
				return container->Count();
			}

			const VT& Get(const KK& key)const
			{
				return container->Get(key);
			}

			const VT& operator[](const KK& key)const
			{
				return container->operator[](key);
			}
		};

		template<typename C, typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class DictionaryWrapper : public Object, public virtual IDictionary<KT, VT, KK, VK>
		{
		private:
			C*						container;
		public:
			DictionaryWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new ReadonlyDictionaryWrapper<C, KT, VT, KK, VK>::Enumerator(this);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return container->Keys();
			}

			const IReadonlyList<VT, VK>& Values()const
			{
				return container->Values();
			}

			vint Count()const
			{
				return container->Count();
			}

			const VT& Get(const KK& key)const
			{
				return container->Get(key);
			}

			const VT& operator[](const KK& key)const
			{
				return container->operator[](key);
			}

			bool Set(const KK& key, const VT& value)
			{
				return container->Set(key, value);
			}

			bool Add(const KT& key, const VT& value)
			{
				return container->Add(key, value);
			}

			bool Remove(const KK& key)
			{
				return container->Remove(key);
			}

			bool Clear()
			{
				return container->Clear();
			}
		};

		template<typename C, typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class ReadonlyGroupWrapper : public Object, public virtual IReadonlyGroup<KT, VT, KK, VK>
		{
			friend class GroupWrapper<C, KT, VT, KK, VK>;
		private:
			class Enumerator : public Object, public virtual IEnumerator<Pair<KT, VT>>
			{
			private:
				const IReadonlyGroup<KT, VT, KK, VK>*		container;
				vint											keyIndex;
				vint											valueIndex;
				Pair<KT, VT>								current;

				void UpdateCurrent()
				{
					if(keyIndex<container->Count())
					{
						const IReadonlyList<VT, VK>& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							current.key=container->Keys()[keyIndex];
							current.value=values[valueIndex];
						}
					}
				}
			public:
				Enumerator(const IReadonlyGroup* _container, vint _keyIndex=0, vint _valueIndex=0)
				{
					container=_container;
					keyIndex=_keyIndex;
					valueIndex=_valueIndex;
					UpdateCurrent();
				}
				
				IEnumerator<Pair<KT, VT>>* Clone()const
				{
					return new Enumerator(container, keyIndex, valueIndex);
				}

				const Pair<KT, VT>& Current()const
				{
					return current;
				}

				vint Index()const
				{
					if(Available())
					{
						vint index=0;
						for(vint i=0;i<keyIndex;i++)
						{
							index+=container->GetByIndex(i).Count();
						}
						return index+valueIndex;
					}
					else
					{
						return -1;
					}
				}

				bool Next()
				{
					if(keyIndex<container->Count())
					{
						const IReadonlyList<VT, VK>& values=container->GetByIndex(keyIndex);
						valueIndex++;
						if(valueIndex<values.Count())
						{
							UpdateCurrent();
							return true;
						}
						else
						{
							keyIndex++;
							valueIndex=0;
							UpdateCurrent();
							return keyIndex<container->Count();
						}
					}
					else
					{
						return false;
					}
				}

				bool Available()const
				{
					if(keyIndex<container->Count())
					{
						const IReadonlyList<VT, VK>& values=container->GetByIndex(keyIndex);
						if(valueIndex<values.Count())
						{
							return true;
						}
					}
					return false;
				}

				void Reset()
				{
					keyIndex=0;
					valueIndex=0;
					UpdateCurrent();
				}
			};

			C*									container;
		public:
			ReadonlyGroupWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new Enumerator(this);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return container->Keys();
			}

			vint Count()const
			{
				return container->Count();
			}

			const IReadonlyList<VT, VK>& Get(const KK& key)const
			{
				return container->Get(key);
			}

			const IReadonlyList<VT, VK>& GetByIndex(vint index)const
			{
				return container->GetByIndex(index);
			}

			const IReadonlyList<VT, VK>& operator[](const KK& key)const
			{
				return container->operator[](key);
			}

			bool Contains(const KK& key)const
			{
				return container->Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				return container->Contains(key, value);
			}
		};

		template<typename C, typename KT, typename VT, typename KK=typename KeyType<KT>::Type, typename VK=typename KeyType<VT>::Type>
		class GroupWrapper : public Object, public virtual IGroup<KT, VT, KK, VK>
		{
		private:
			C*									container;
		public:
			GroupWrapper(C* _container=0)
			{
				container=_container;
			}

			C* GetContainer()
			{
				return container;
			}

			void SetContainer(C* _container)
			{
				container=_container;
			}

			IEnumerator<Pair<KT, VT>>* CreateEnumerator()const
			{
				return new ReadonlyGroupWrapper<C, KT, VT, KK, VK>::Enumerator(this);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return container->Keys();
			}

			vint Count()const
			{
				return container->Count();
			}

			const IReadonlyList<VT, VK>& Get(const KK& key)const
			{
				return container->Get(key);
			}

			const IReadonlyList<VT, VK>& GetByIndex(vint index)const
			{
				return container->GetByIndex(index);
			}

			const IReadonlyList<VT, VK>& operator[](const KK& key)const
			{
				return container->operator[](key);
			}

			bool Contains(const KK& key)const
			{
				return container->Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				return container->Contains(key, value);
			}

			bool Add(const KT& key, const VT& value)
			{
				return container->Add(key, value);
			}

			bool Remove(const KK& key)
			{
				return container->Remove(key);
			}

			bool Remove(const KK& key, const VK& value)
			{
				return container->Remove(key, value);
			}

			bool Clear()
			{
				return container->Clear();
			}
		};

/***********************************************************************
类型转换代理
***********************************************************************/
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\COMMON\SOURCE\COLLECTIONS\DICTIONARY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
Data Structure::Dictionary

Classes:
	Dictionary<KT, VT, KK, VK>					：映射
	Group<KT, VT, KK, VK>						：多重映射
***********************************************************************/

#ifndef VCZH_COLLECTIONS_DICTIONARY
#define VCZH_COLLECTIONS_DICTIONARY


namespace vl
{
	namespace collections
	{
		template<
			typename KT,
			typename VT,
			typename ValueContainer=List<VT, typename KeyType<VT>::Type>,
			typename KK=typename KeyType<KT>::Type, 
			typename VK=typename KeyType<VT>::Type
		>
		class Dictionary : public Object, private NotCopyable
		{
		protected:
			SortedList<KT, KK>					keys;
			ValueContainer						values;
			mutable DictionaryWrapper<Dictionary<KT, VT, ValueContainer, KK, VK>, KT, VT, KK, VK>	wrapper;
		public:
			Dictionary()
			{
				wrapper.SetContainer(this);
			}

			void SetLessMemoryMode(bool mode)
			{
				keys.SetLessMemoryMode(mode);
				values.SetLessMemoryMode(mode);
			}

			template<typename T>
			void CopyKeysToCollection(T& dst, bool append=false)const
			{
				CopyToCollection(dst, keys, append);
			}

			template<typename T>
			void CopyKeysToArray(T& dst, bool append=false)const
			{
				CopyToArray(dst, keys, append);
			}

			template<typename T>
			void CopyValuesToCollection(T& dst, bool append=false)const
			{
				CopyToCollection(dst, values, append);
			}

			template<typename T>
			void CopyValuesToArray(T& dst, bool append=false)const
			{
				CopyToArray(dst, values, append);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return keys.Wrap();
			}

			const IReadonlyList<VT, VK>& Values()const
			{
				return values.Wrap();
			}

			vint Count()const
			{
				return keys.Count();
			}

			const VT& Get(const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			const VT& operator[](const KK& key)const
			{
				return values.Get(keys.IndexOf(key));
			}

			bool Set(const KK& key, const VT& value)
			{
				vint index=keys.IndexOf(key);
				if(index==-1)
				{
					index=keys.Add(key);
					values.Insert(index, value);
				}
				else
				{
					values[index]=value;
				}
				return true;
			}

			bool Add(const KT& key, const VT& value)
			{
				CHECK_ERROR(!keys.Contains(key), L"Dictionary<KT, KK, ValueContainer, VT, VK>::Add(const KT&, const VT&)#key已存在。");
				vint index=keys.Add(key);
				values.Insert(index, value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					values.RemoveAt(index);
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				keys.Clear();
				values.Clear();
				return true;
			}

			IDictionary<KT, VT, KK, VK>& Wrap()const
			{
				return wrapper;
			}
		};

		template<
			typename KT,
			typename VT,
			typename ValueContainer=List<VT, typename KeyType<VT>::Type>,
			typename KK=typename KeyType<KT>::Type,
			typename VK=typename KeyType<VT>::Type
		>
		class Group : public Object, private NotCopyable
		{
		protected:
			SortedList<KT, KK>				keys;
			List<ValueContainer*>			values;
			mutable GroupWrapper<Group<KT, VT, ValueContainer, KK, VK>, KT, VT, KK, VK>	wrapper;
		public:
			Group()
			{
				wrapper.SetContainer(this);
			}

			~Group()
			{
				Clear();
			}

			template<typename T>
			void CopyKeysToCollection(T& dst, bool append=false)const
			{
				CopyToCollection(dst, keys, append);
			}

			template<typename T>
			void CopyKeysToArray(T& dst, bool append=false)const
			{
				CopyToArray(dst, keys, append);
			}

			template<typename T>
			void CopyValuesToCollection(vint index, T& dst, bool append=false)const
			{
				CopyToCollection(dst, *(values.Get(index)), append);
			}

			template<typename T>
			void CopyValuesToArray(vint index, T& dst, bool append=false)const
			{
				CopyToArray(dst, *(values.Get(index)), append);
			}

			const IReadonlyList<KT, KK>& Keys()const
			{
				return keys.Wrap();
			}

			vint Count()const
			{
				return keys.Count();
			}

			const IReadonlyList<VT, VK>& Get(const KK& key)const
			{
				return values.Get(keys.IndexOf(key))->Wrap();
			}

			const IReadonlyList<VT, VK>& GetByIndex(vint index)const
			{
				return values.Get(index)->Wrap();
			}

			const IReadonlyList<VT, VK>& operator[](const KK& key)const
			{
				return values.Get(keys.IndexOf(key))->Wrap();
			}

			bool Contains(const KK& key)const
			{
				return keys.Contains(key);
			}

			bool Contains(const KK& key, const VK& value)const
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					return values.Get(index)->Contains(value);
				}
				else
				{
					return false;
				}
			}

			bool Add(const KT& key, const VT& value)
			{
				ValueContainer* target=0;
				vint index=keys.IndexOf(key);
				if(index==-1)
				{
					target=new ValueContainer;
					values.Insert(keys.Add(key), target);
				}
				else
				{
					target=values[index];
				}
				target->Add(value);
				return true;
			}

			bool Remove(const KK& key)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					keys.RemoveAt(index);
					List<VT, VK>* target=values[index];
					values.RemoveAt(index);
					delete target;
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Remove(const KK& key, const VK& value)
			{
				vint index=keys.IndexOf(key);
				if(index!=-1)
				{
					List<VT, VK>* target=values[index];
					target->Remove(value);
					if(target->Count()==0)
					{
						keys.RemoveAt(index);
						values.RemoveAt(index);
						delete target;
					}
					return true;
				}
				else
				{
					return false;
				}
			}

			bool Clear()
			{
				for(vint i=0;i<values.Count();i++)
				{
					delete values[i];
				}
				keys.Clear();
				values.Clear();
				return true;
			}

			IGroup<KT, VT, KK, VK>& Wrap()const
			{
				return wrapper;
			}
		};
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\GACVLPPREFERENCES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI Vczh Library++ 3.0 References

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACVLPPREFERENCES
#define VCZH_PRESENTATION_GACVLPPREFERENCES


#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\GUITYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Common Types

Classes:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUITYPES
#define VCZH_PRESENTATION_GUITYPES


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Enumerations
***********************************************************************/
		
		namespace Alignment
		{
			/// <summary>
			/// Defines an alignment direction.
			/// </summary>
			enum Type
			{
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the left side.</summary>
				Left=0,
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the top side.</summary>
				Top=0,
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the center.</summary>
				Center=1,
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the right side.</summary>
				Right=2,
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the bottom side.</summary>
				Bottom=2,
			};
		}

/***********************************************************************
TextPos
***********************************************************************/
		
		/// <summary>
		/// Represents the position in multiple lines of text.
		/// </summary>
		struct TextPos
		{
			/// <summary>
			/// Row number.
			/// </summary>
			int			row;
			/// <summary>
			/// Column number. If a line has 4 characters, there are 5 available column numbers(from 0 to 4) in this line.
			/// </summary>
			int			column;

			TextPos()
				:row(0) ,column(0)
			{
			}

			TextPos(int _row, int _column)
				:row(_row) ,column(_column)
			{
			}

			int Compare(const TextPos& value)const
			{
				if(row<value.row) return -1;
				if(row>value.row) return 1;
				if(column<value.column) return -1;
				if(column>value.column) return 1;
				return 0;
			}

			bool operator==(const TextPos& value)const {return Compare(value)==0;}
			bool operator!=(const TextPos& value)const {return Compare(value)!=0;}
			bool operator<(const TextPos& value)const {return Compare(value)<0;}
			bool operator<=(const TextPos& value)const {return Compare(value)<=0;}
			bool operator>(const TextPos& value)const {return Compare(value)>0;}
			bool operator>=(const TextPos& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
Point
***********************************************************************/
		
		/// <summary>
		/// Represents a position in a two dimensions space.
		/// </summary>
		struct Point
		{
			/// <summary>
			/// Position in x dimension.
			/// </summary>
			int			x;
			/// <summary>
			/// Position in y dimension.
			/// </summary>
			int			y;

			Point()
				:x(0) ,y(0)
			{
			}

			Point(int _x, int _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Point point)const
			{
				return x==point.x && y==point.y;
			}

			bool operator!=(Point point)const
			{
				return x!=point.x || y!=point.y;
			}
		};

/***********************************************************************
Size
***********************************************************************/
		
		/// <summary>
		/// Represents a size in a two dimensions space.
		/// </summary>
		struct Size
		{
			/// <summary>
			/// Size in x dimension.
			/// </summary>
			int			x;
			/// <summary>
			/// Size in y dimension.
			/// </summary>
			int			y;

			Size()
				:x(0) ,y(0)
			{
			}

			Size(int _x, int _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Size size)const
			{
				return x==size.x && y==size.y;
			}

			bool operator!=(Size size)const
			{
				return x!=size.x || y!=size.y;
			}
		};

/***********************************************************************
Rectangle
***********************************************************************/
		
		/// <summary>
		/// Represents a bounds in a two dimensions space.
		/// </summary>
		struct Rect
		{
			/// <summary>
			/// Left.
			/// </summary>
			int		x1;
			/// <summary>
			/// Top.
			/// </summary>
			int		y1;
			/// <summary>
			/// Left + Width.
			/// </summary>
			int		x2;
			/// <summary>
			/// Top + Height.
			/// </summary>
			int		y2;

			Rect()
				:x1(0), y1(0), x2(0), y2(0)
			{
			}

			Rect(int _x1, int _y1, int _x2, int _y2)
				:x1(_x1), y1(_y1), x2(_x2), y2(_y2)
			{
			}

			Rect(Point p, Size s)
				:x1(p.x), y1(p.y), x2(p.x+s.x), y2(p.y+s.y)
			{
			}

			bool operator==(Rect rect)const
			{
				return x1==rect.x1 && y1==rect.y1 && x2==rect.x2 && y2==rect.y2;
			}

			bool operator!=(Rect rect)const
			{
				return x1!=rect.x1 || y1!=rect.y1 || x2!=rect.x2 || y2!=rect.y2;
			}

			Point LeftTop()const
			{
				return Point(x1, y1);
			}

			Point RightBottom()const
			{
				return Point(x2, y2);
			}

			Size GetSize()const
			{
				return Size(x2-x1, y2-y1);
			}

			int Left()const
			{
				return x1;
			}

			int Right()const
			{
				return x2;
			}

			int Width()const
			{
				return x2-x1;
			}

			int Top()const
			{
				return y1;
			}

			int Bottom()const
			{
				return y2;
			}

			int Height()const
			{
				return y2-y1;
			}

			void Expand(int x, int y)
			{
				x1-=x;
				y1-=y;
				x2+=x;
				y2+=y;
			}

			void Expand(Size s)
			{
				x1-=s.x;
				y1-=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			void Move(int x, int y)
			{
				x1+=x;
				y1+=y;
				x2+=x;
				y2+=y;
			}

			void Move(Size s)
			{
				x1+=s.x;
				y1+=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			bool Contains(Point p)
			{
				return x1<=p.x && p.x<x2 && y1<=p.y && p.y<y2;
			}
		};

/***********************************************************************
2D operations
***********************************************************************/

		inline Point operator+(Point p, Size s)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator+(Size s, Point p)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator-(Point p, Size s)
		{
			return Point(p.x-s.x, p.y-s.y);
		}

		inline Size operator-(Point p1, Point p2)
		{
			return Size(p1.x-p2.x, p1.y-p2.y);
		}

		inline Size operator+(Size s1, Size s2)
		{
			return Size(s1.x+s2.x, s1.y+s2.y);
		}

		inline Size operator-(Size s1, Size s2)
		{
			return Size(s1.x-s2.x, s1.y-s2.y);
		}

		inline Size operator*(Size s, int i)
		{
			return Size(s.x*i, s.y*i);
		}

		inline Size operator/(Size s, int i)
		{
			return Size(s.x/i, s.y/i);
		}

		inline Point operator+=(Point& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Point operator-=(Point& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

		inline Size operator+=(Size& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Size operator-=(Size& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

/***********************************************************************
Color
***********************************************************************/
		
		struct Color
		{
			union
			{
				struct
				{
					unsigned char r;
					unsigned char g;
					unsigned char b;
					unsigned char a;
				};
				unsigned __int32 value;
			};

			Color()
				:r(0), g(0), b(0), a(255)
			{
			}

			Color(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a=255)
				:r(_r), g(_g), b(_b), a(_a)
			{
			}

			int Compare(Color color)const
			{
				return value-color.value;
			}

			bool operator==(Color color)const {return Compare(color)==0;}
			bool operator!=(Color color)const {return Compare(color)!=0;}
			bool operator<(Color color)const {return Compare(color)<0;}
			bool operator<=(Color color)const {return Compare(color)<=0;}
			bool operator>(Color color)const {return Compare(color)>0;}
			bool operator>=(Color color)const {return Compare(color)>=0;}
		};

/***********************************************************************
Margin
***********************************************************************/
		
		/// <summary>
		/// Represents a margin in a two dimensions space.
		/// </summary>
		struct Margin
		{
			/// <summary>
			/// The left margin.
			/// </summary>
			int		left;
			/// <summary>
			/// The top margin.
			/// </summary>
			int		top;
			/// <summary>
			/// The right margin.
			/// </summary>
			int		right;
			/// <summary>
			/// The bottom margin.
			/// </summary>
			int		bottom;

			Margin()
				:left(0), top(0), right(0), bottom(0)
			{
			}

			Margin(int _left, int _top, int _right, int _bottom)
				:left(_left), top(_top), right(_right), bottom(_bottom)
			{
			}

			bool operator==(Margin margin)const
			{
				return left==margin.left && top==margin.top && right==margin.right && bottom==margin.bottom;
			}

			bool operator!=(Margin margin)const
			{
				return left!=margin.left || top!=margin.top || right!=margin.right || bottom!=margin.bottom;
			}
		};

/***********************************************************************
Resources
***********************************************************************/
		
		/// <summary>
		/// Represents a font configuration.
		/// </summary>
		struct FontProperties
		{
			/// <summary>
			/// Font family (or font name, usually).
			/// </summary>
			WString				fontFamily;
			/// <summary>
			/// Font size in pixel.
			/// </summary>
			int					size;
			/// <summary>
			/// True if the font is bold.
			/// </summary>
			bool				bold;
			/// <summary>
			/// True if the font is italic.
			/// </summary>
			bool				italic;
			/// <summary>
			/// True if the font has a underline.
			/// </summary>
			bool				underline;
			/// <summary>
			/// True if the font has a strikeline.
			/// </summary>
			bool				strikeline;
			/// <summary>
			/// True if the font has anti alias rendering.
			/// </summary>
			bool				antialias;
			/// <summary>
			/// True if the font has anti alias rendering in vertical direction.
			/// </summary>
			bool				verticalAntialias;

			FontProperties()
				:size(0)
				,bold(false)
				,italic(false)
				,underline(false)
				,strikeline(false)
				,antialias(true)
				,verticalAntialias(false)
			{
			}
			
			int Compare(const FontProperties& value)const
			{
				int result=0;
				
				result=WString::Compare(fontFamily, value.fontFamily);
				if(result!=0) return result;

				result=size-value.size;
				if(result!=0) return result;

				result=(int)bold-(int)value.bold;
				if(result!=0) return result;

				result=(int)italic-(int)value.italic;
				if(result!=0) return result;

				result=(int)underline-(int)value.underline;
				if(result!=0) return result;

				result=(int)strikeline-(int)value.strikeline;
				if(result!=0) return result;

				result=(int)antialias-(int)value.antialias;
				if(result!=0) return result;

				return 0;
			}

			bool operator==(const FontProperties& value)const {return Compare(value)==0;}
			bool operator!=(const FontProperties& value)const {return Compare(value)!=0;}
			bool operator<(const FontProperties& value)const {return Compare(value)<0;}
			bool operator<=(const FontProperties& value)const {return Compare(value)<=0;}
			bool operator>(const FontProperties& value)const {return Compare(value)>0;}
			bool operator>=(const FontProperties& value)const {return Compare(value)>=0;}
		};
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\GUINATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Native Window

Interfaces:
  INativeWindow							：窗口适配器
  INativeWindowListener					：窗口事件监听器
  INativeController						：全局控制器
  INativeControllerListener				：全局事件监听器

Renderers:
  GUI_GRAPHICS_RENDERER_GDI
  GUI_GRAPHICS_RENDERER_DIRECT2D
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUINATIVEWINDOW
#define VCZH_PRESENTATION_GUINATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		class INativeWindow;
		class INativeWindowListener;
		class INativeController;
		class INativeControllerListener;

/***********************************************************************
System Object
***********************************************************************/

		/// <summary>
		/// Represents a screen.
		/// </summary>
		class INativeScreen : public Interface
		{
		public:
			/// <summary>
			/// Get the bounds of the screen.
			/// </summary>
			/// <returns>The bounds of the screen.</returns>
			virtual Rect				GetBounds()=0;
			/// <summary>
			/// Get the bounds of the screen client area.
			/// </summary>
			/// <returns>The bounds of the screen client area.</returns>
			virtual Rect				GetClientBounds()=0;
			/// <summary>
			/// Get the name of the screen.
			/// </summary>
			/// <returns>The name of the screen.</returns>
			virtual WString				GetName()=0;
			/// <summary>
			/// Test is the screen is a primary screen.
			/// </summary>
			/// <returns>Returns true if the screen is a primary screen.</returns>
			virtual bool				IsPrimary()=0;
		};
		
		/// <summary>
		/// Represents a cursor.
		/// </summary>
		class INativeCursor : public Interface
		{
		public:
			/// <summary>
			/// Represents a predefined cursor type.
			/// </summary>
			enum SystemCursorType
			{
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Small waiting cursor.
				/// </summary>
				SmallWaiting,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]large waiting cursor.
				/// </summary>
				LargeWaiting,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Arrow cursor.
				/// </summary>
				Arrow,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Cross cursor.
				/// </summary>
				Cross,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Hand cursor.
				/// </summary>
				Hand,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Help cursor.
				/// </summary>
				Help,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]I beam cursor.
				/// </summary>
				IBeam,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing in all direction cursor.
				/// </summary>
				SizeAll,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing NE-SW cursor.
				/// </summary>
				SizeNESW,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing N-S cursor.
				/// </summary>
				SizeNS,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing NW-SE cursor.
				/// </summary>
				SizeNWSE,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing W-E cursor.
				/// </summary>
				SizeWE,
				LastSystemCursor=SizeWE,
			};

			static const int			SystemCursorCount=LastSystemCursor+1;
		public:
			/// <summary>
			/// Test is the cursor a system provided cursor.
			/// </summary>
			/// <returns>Returns true if the cursor a system provided cursor.</returns>
			virtual bool				IsSystemCursor()=0;
			/// <summary>
			/// Get the cursor type if the cursor a system provided cursor.
			/// </summary>
			/// <returns>The cursor type.</returns>
			virtual SystemCursorType	GetSystemCursorType()=0;
		};

/***********************************************************************
Image Object
***********************************************************************/

		class INativeImageService;
		class INativeImage;
		class INativeImageFrame;
		
		/// <summary>
		/// Represents a customized cache object for an image frame.
		/// </summary>
		class INativeImageFrameCache : public Interface
		{
		public:
			/// <summary>
			/// Called when this cache object is attached to an image frame.
			/// </summary>
			/// <param name="frame">The image frame that attached to.</param>
			virtual void						OnAttach(INativeImageFrame* frame)=0;
			/// <summary>
			/// Called when this cache object is detached to an image frame.
			/// </summary>
			/// <param name="frame">The image frame that detached from.</param>
			virtual void						OnDetach(INativeImageFrame* frame)=0;
		};

		/// <summary>
		/// Represents an image frame.
		/// </summary>
		class INativeImageFrame : public Interface
		{
		public:
			/// <summary>
			/// Get the image that owns this frame.
			/// </summary>
			/// <returns>The image that owns this frame.</returns>
			virtual INativeImage*				GetImage()=0;
			/// <summary>
			/// Get the size of this frame.
			/// </summary>
			/// <returns>The size of this frame.</returns>
			virtual Size						GetSize()=0;

			/// <summary>
			/// Attach a customized cache object to this image frame and bind to a key.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			/// <param name="cache">The customized cache object.</param>
			virtual bool						SetCache(void* key, Ptr<INativeImageFrameCache> cache)=0;
			/// <summary>
			/// Get the attached customized cache object that is already binded to a key.
			/// </summary>
			/// <returns>The attached customized cache object.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			virtual Ptr<INativeImageFrameCache>	GetCache(void* key)=0;
			/// <summary>
			/// Get the attached customized cache object that is already binded to a key, and then detach it.
			/// </summary>
			/// <returns>The detached customized cache object.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			virtual Ptr<INativeImageFrameCache>	RemoveCache(void* key)=0;
		};
		
		/// <summary>
		/// Represents an image.
		/// </summary>
		class INativeImage : public Interface
		{
		public:
			/// <summary>
			/// Represents an image format.
			/// </summary>
			enum FormatType
			{
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Bitmap format.
				/// </summary>
				Bmp,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]GIF format.
				/// </summary>
				Gif,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Icon format.
				/// </summary>
				Icon,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]JPEG format.
				/// </summary>
				Jpeg,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]PNG format.
				/// </summary>
				Png,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]TIFF format.
				/// </summary>
				Tiff,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]WMP format.
				/// </summary>
				Wmp,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Unknown format.
				/// </summary>
				Unknown,
			};
			
			/// <summary>
			/// Get the image service that creates this image.
			/// </summary>
			/// <returns>The image service that creates this image.</returns>
			virtual INativeImageService*		GetImageService()=0;
			/// <summary>
			/// Get the image format.
			/// </summary>
			/// <returns>The image format.</returns>
			virtual FormatType					GetFormat()=0;
			/// <summary>
			/// Get the number of frames in this image.
			/// </summary>
			/// <returns>The number of frames in this image.</returns>
			virtual int							GetFrameCount()=0;
			/// <summary>
			/// Get the frame in this image by a specified frame index.
			/// </summary>
			/// <returns>The frame in this image by a specified frame index.</returns>
			/// <param name="index">The specified frame index.</param>
			virtual INativeImageFrame*			GetFrame(int index)=0;
		};
		
		/// <summary>
		/// Image service. To access this service, use [M:vl.presentation.INativeController.ImageService].
		/// </summary>
		class INativeImageService : public Interface
		{
		public:
			/// <summary>
			/// Create an image from file.
			/// </summary>
			/// <returns>The created image.</returns>
			/// <param name="path">The file path.</param>
			virtual Ptr<INativeImage>			CreateImageFromFile(const WString& path)=0;
		};

/***********************************************************************
Native Window
***********************************************************************/
		
		/// <summary>
		/// Represents a window.
		/// </summary>
		class INativeWindow : public Interface
		{
		public:
			/// <summary>
			/// Get the bounds of the window.
			/// </summary>
			/// <returns>The bounds of the window.</returns>
			virtual Rect				GetBounds()=0;
			/// <summary>
			/// Set the bounds of the window.
			/// </summary>
			/// <param name="bounds">The bounds of the window.</param>
			virtual void				SetBounds(const Rect& bounds)=0;
			/// <summary>
			/// Get the client size of the window.
			/// </summary>
			/// <returns>The client size of the window.</returns>
			virtual Size				GetClientSize()=0;
			/// <summary>
			/// Set the client size of the window.
			/// </summary>
			/// <param name="size">The client size of the window.</param>
			virtual void				SetClientSize(Size size)=0;
			/// <summary>
			/// Get the client bounds in screen space.
			/// </summary>
			/// <returns>The client bounds in screen space.</returns>
			virtual Rect				GetClientBoundsInScreen()=0;
			
			/// <summary>
			/// Get the title of the window. A title will be displayed as a name of this window.
			/// </summary>
			/// <returns>The title of the window.</returns>
			virtual WString				GetTitle()=0;
			/// <summary>
			/// Set the title of the window. A title will be displayed as a name of this window.
			/// </summary>
			/// <param name="title">The title of the window.</param>
			virtual void				SetTitle(WString title)=0;
			/// <summary>
			/// Get the mouse cursor of the window. When the mouse is on the window, the mouse cursor will be rendered.
			/// </summary>
			/// <returns>The mouse cursor of the window.</returns>
			virtual INativeCursor*		GetWindowCursor()=0;
			/// <summary>
			/// Set the mouse cursor of the window. When the mouse is on the window, the mouse cursor will be rendered.
			/// </summary>
			/// <param name="cursor">The mouse cursor of the window.</param>
			virtual void				SetWindowCursor(INativeCursor* cursor)=0;
			/// <summary>
			/// Get the caret point of the window. When an input method editor is opened, the input text box will be located to the caret point.
			/// </summary>
			/// <returns>The caret point of the window.</returns>
			virtual Point				GetCaretPoint()=0;
			/// <summary>
			/// Set the caret point of the window. When an input method editor is opened, the input text box will be located to the caret point.
			/// </summary>
			/// <param name="point">The caret point of the window.</param>
			virtual void				SetCaretPoint(Point point)=0;
			
			/// <summary>
			/// Get the parent window. A parent window doesn't contain a child window. It always displayed below the child windows. When a parent window is minimized or restored, so as its child windows.
			/// </summary>
			/// <returns>The parent window.</returns>
			virtual INativeWindow*		GetParent()=0;
			/// <summary>
			/// Set the parent window. A parent window doesn't contain a child window. It always displayed below the child windows. When a parent window is minimized or restored, so as its child windows.
			/// </summary>
			/// <param name="parent">The parent window.</param>
			virtual void				SetParent(INativeWindow* parent)=0;
			/// <summary>
			/// Test is the window always pass the focus to it's parent window.
			/// </summary>
			/// <returns>Returns true if the window always pass the focus to it's parent window.</returns>
			virtual bool				GetAlwaysPassFocusToParent()=0;
			/// <summary>
			/// Enable or disble always passing the focus to it's parent window.
			/// </summary>
			/// <param name="value">True to enable always passing the focus to it's parent window.</param>
			virtual void				SetAlwaysPassFocusToParent(bool value)=0;

			/// <summary>
			/// Show the window.
			/// </summary>
			virtual void				Show()=0;
			/// <summary>
			/// Show the window without activation.
			/// </summary>
			virtual void				ShowDeactivated()=0;
			/// <summary>
			/// Restore the window.
			/// </summary>
			virtual void				ShowRestored()=0;
			/// <summary>
			/// Maximize the window.
			/// </summary>
			virtual void				ShowMaximized()=0;
			/// <summary>
			/// Minimize the window.
			/// </summary>
			virtual void				ShowMinimized()=0;
			/// <summary>
			/// Hide the window.
			/// </summary>
			virtual void				Hide()=0;
			/// <summary>
			/// Test is the window visible.
			/// </summary>
			/// <returns>Returns true if the window is visible.</returns>
			virtual bool				IsVisible()=0;

			/// <summary>
			/// Enable the window.
			/// </summary>
			virtual void				Enable()=0;
			/// <summary>
			/// Disable the window.
			/// </summary>
			virtual void				Disable()=0;
			/// <summary>
			/// Test is the window enabled.
			/// </summary>
			/// <returns>Returns true if the window is enabled.</returns>
			virtual bool				IsEnabled()=0;
			
			/// <summary>
			/// Set focus to the window.
			/// </summary>
			virtual void				SetFocus()=0;
			/// <summary>
			/// Test is the window focused.
			/// </summary>
			/// <returns>Returns true if the window is focused.</returns>
			virtual bool				IsFocused()=0;
			/// <summary>
			/// Activate to the window.
			/// </summary>
			virtual void				SetActivate()=0;
			/// <summary>
			/// Test is the window activated.
			/// </summary>
			/// <returns>Returns true if the window is activated.</returns>
			virtual bool				IsActivated()=0;
			
			/// <summary>
			/// Show the icon in the task bar.
			/// </summary>
			virtual void				ShowInTaskBar()=0;
			/// <summary>
			/// Hide the icon in the task bar.
			/// </summary>
			virtual void				HideInTaskBar()=0;
			/// <summary>
			/// Test is the window icon appeared in the task bar.
			/// </summary>
			/// <returns>Returns true if the window icon appears in the task bar.</returns>
			virtual bool				IsAppearedInTaskBar()=0;
			
			/// <summary>
			/// Enable activation to the window.
			/// </summary>
			virtual void				EnableActivate()=0;
			/// <summary>
			/// Disable activation to the window.
			/// </summary>
			virtual void				DisableActivate()=0;
			/// <summary>
			/// Test is the window allowed to be activated.
			/// </summary>
			/// <returns>Returns true if the window is allowed to be activated.</returns>
			virtual bool				IsEnabledActivate()=0;
			
			/// <summary>
			/// Require mouse message capturing to this window. If the capture is required, all mouse message will be send to this window.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool				RequireCapture()=0;
			/// <summary>
			/// Release mouse message capturing to this window. If the capture is required, all mouse message will be send to this window.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool				ReleaseCapture()=0;

			/// <summary>
			/// Test is the maximize box visible.
			/// </summary>
			/// <returns>Returns true if the maximize box is visible.</returns>
			virtual bool				GetMaximizedBox()=0;
			/// <summary>
			/// Make the maximize box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the maximize box visible.</param>
			virtual void				SetMaximizedBox(bool visible)=0;
			/// <summary>
			/// Test is the minimize box visible.
			/// </summary>
			/// <returns>Returns true if the minimize box is visible.</returns>
			virtual bool				GetMinimizedBox()=0;
			/// <summary>
			/// Make the minimize box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the minimize box visible.</param>
			virtual void				SetMinimizedBox(bool visible)=0;
			/// <summary>
			/// Test is the border visible.
			/// </summary>
			/// <returns>Returns true if the border is visible.</returns>
			virtual bool				GetBorder()=0;
			/// <summary>
			/// Make the border visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the border visible.</param>
			virtual void				SetBorder(bool visible)=0;
			/// <summary>
			/// Test is the size box visible.
			/// </summary>
			/// <returns>Returns true if the size box is visible.</returns>
			virtual bool				GetSizeBox()=0;
			/// <summary>
			/// Make the size box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the size box visible.</param>
			virtual void				SetSizeBox(bool visible)=0;
			/// <summary>
			/// Test is the icon visible.
			/// </summary>
			/// <returns>Returns true if the icon is visible.</returns>
			virtual bool				GetIconVisible()=0;
			/// <summary>
			/// Make the icon visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the icon visible.</param>
			virtual void				SetIconVisible(bool visible)=0;
			/// <summary>
			/// Test is the title bar visible.
			/// </summary>
			/// <returns>Returns true if the title bar is visible.</returns>
			virtual bool				GetTitleBar()=0;
			/// <summary>
			/// Make the title bar visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the title bar visible.</param>
			virtual void				SetTitleBar(bool visible)=0;
			/// <summary>
			/// Test is the window always on top of the desktop.
			/// </summary>
			/// <returns>Returns true if the window is always on top of the desktop.</returns>
			virtual bool				GetTopMost()=0;
			/// <summary>
			/// Make the window always or never on top of the desktop.
			/// </summary>
			/// <param name="topmost">True to make the window always  on top of the desktop.</param>
			virtual void				SetTopMost(bool topmost)=0;
			
			/// <summary>
			/// Install an message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The listener to install.</param>
			virtual bool				InstallListener(INativeWindowListener* listener)=0;
			/// <summary>
			/// Uninstall an message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The listener to uninstall.</param>
			virtual bool				UninstallListener(INativeWindowListener* listener)=0;
			/// <summary>
			/// Redraw the content of the window.
			/// </summary>
			virtual void				RedrawContent()=0;
		};

		/// <summary>
		/// Mouse message information.
		/// </summary>
		struct NativeWindowMouseInfo
		{
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the left mouse button is pressed.</summary>
			bool						left;
			/// <summary>True if the middle mouse button is pressed.</summary>
			bool						middle;
			/// <summary>True if the right mouse button is pressed.</summary>
			bool						right;
			/// <summary>The mouse position of x dimension.</summary>
			int							x;
			/// <summary>The mouse position of y dimension.</summary>
			int							y;
			/// <summary>The delta of the wheel.</summary>
			int							wheel;
		};
		
		/// <summary>
		/// Key message information.
		/// </summary>
		struct NativeWindowKeyInfo
		{
			/// <summary>Key code of the key that sends this message.</summary>
			int							code;
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the alt button is pressed.</summary>
			bool						alt;
			/// <summary>True if the capslock button is pressed.</summary>
			bool						capslock;
		};
		
		/// <summary>
		/// Character message information.
		/// </summary>
		struct NativeWindowCharInfo
		{
			/// <summary>Character that sends this message.</summary>
			wchar_t						code;
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the alt button is pressed.</summary>
			bool						alt;
			/// <summary>True if the capslock button is pressed.</summary>
			bool						capslock;
		};
		
		/// <summary>
		/// Represents a message listener to an <see cref="INativeWindow"/>.
		/// </summary>
		class INativeWindowListener : public Interface
		{
		public:
			/// <summary>
			/// Called when the window is moving.
			/// </summary>
			/// <param name="bounds">The bounds. Message handler can change the bounds.</param>
			/// <param name="fixSizeOnly">True if the message raise only want the message handler to change the size.</param>
			virtual void				Moving(Rect& bounds, bool fixSizeOnly);
			/// <summary>
			/// Called when the window is moved.
			/// </summary>
			virtual void				Moved();
			/// <summary>
			/// Called when the window is enabled.
			/// </summary>
			virtual void				Enabled();
			/// <summary>
			/// Called when the window is disabled.
			/// </summary>
			virtual void				Disabled();
			/// <summary>
			/// Called when the window got the focus.
			/// </summary>
			virtual void				GotFocus();
			/// <summary>
			/// Called when the window lost the focus.
			/// </summary>
			virtual void				LostFocus();
			/// <summary>
			/// Called when the window is activated.
			/// </summary>
			virtual void				Activated();
			/// <summary>
			/// Called when the window is deactivated.
			/// </summary>
			virtual void				Deactivated();
			/// <summary>
			/// Called when the window is opened.
			/// </summary>
			virtual void				Opened();
			/// <summary>
			/// Called when the window is closing.
			/// </summary>
			/// <param name="cancel">Change the value to true to prevent the windows from being closed.</param>
			virtual void				Closing(bool& cancel);
			/// <summary>
			/// Called when the window is closed.
			/// </summary>
			virtual void				Closed();
			/// <summary>
			/// Called when the window is painting.
			/// </summary>
			virtual void				Paint();
			/// <summary>
			/// Called when the window is destroying.
			/// </summary>
			virtual void				Destroying();
			/// <summary>
			/// Called when the window is destroyed.
			/// </summary>
			virtual void				Destroyed();
			
			/// <summary>
			/// Called when the left mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the left mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the left mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the horizontal mouse wheel scrolls.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				HorizontalWheel(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the horizontal vertical wheel scrolls.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				VerticalWheel(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the mouse is moving on the window.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MouseMoving(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the mouse entered the window.
			/// </summary>
			virtual void				MouseEntered();
			/// <summary>
			/// Called when the mouse leaved the window.
			/// </summary>
			virtual void				MouseLeaved();
			
			/// <summary>
			/// Called a key is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				KeyDown(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a key is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				KeyUp(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a system key is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				SysKeyDown(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a system key is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				SysKeyUp(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called an input character is generated.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				Char(const NativeWindowCharInfo& info);
		};

/***********************************************************************
Native Window Services
***********************************************************************/

		/// <summary>
		/// System resource service. To access this service, use [M:vl.presentation.INativeController.ResourceService].
		/// </summary>
		class INativeResourceService : public virtual Interface
		{
		public:
			/// <summary>
			/// Get a cached cursor object using a predefined system cursor type;
			/// </summary>
			/// <returns>The cached cursor object.</returns>
			/// <param name="type">The predefined system cursor type.</param>
			virtual INativeCursor*			GetSystemCursor(INativeCursor::SystemCursorType type)=0;
			/// <summary>
			/// Get a cached cursor object using a default system cursor type;
			/// </summary>
			/// <returns>The cached cursor object.</returns>
			virtual INativeCursor*			GetDefaultSystemCursor()=0;

			/// <summary>
			/// Get the default font configuration of the system.
			/// </summary>
			/// <returns>The default font configuration of the system.</returns>
			virtual FontProperties			GetDefaultFont()=0;
			/// <summary>
			/// Override the default font configuration for the current process, only available GacUI library.
			/// </summary>
			/// <param name="value">The font configuration to override.</param>
			virtual void					SetDefaultFont(const FontProperties& value)=0;
		};
		
		/// <summary>
		/// Asynchronized operation service. GacUI is not a thread safe library except for this service. To access this service, use [M:vl.presentation.INativeController.AsyncService].
		/// </summary>
		class INativeAsyncService : public virtual Interface
		{
		public:
			typedef void (AsyncTaskProc)(void* arguments);

			/// <summary>
			/// Test is the current thread the main thread.
			/// </summary>
			/// <returns>Returns true if the current thread is the main thread.</returns>
			virtual bool					IsInMainThread()=0;
			/// <summary>
			/// Invoke a specified function with an specified argument in the main thread.
			/// </summary>
			/// <param name="proc">The specified function.</param>
			/// <param name="argument">The specified argument.</param>
			virtual void					InvokeInMainThread(AsyncTaskProc* proc, void* argument)=0;
			/// <summary>
			/// Invoke a specified function with an specified argument in the main thread and wait for the function to complete or timeout.
			/// </summary>
			/// <returns>Return true if the function complete. Return false if the function has not completed during a specified period of time.</returns>
			/// <param name="proc">The specified function.</param>
			/// <param name="argument">The specified argument.</param>
			/// <param name="milliseconds">The specified period of time to wait. Set to -1 (default value) to wait forever until the function completed.</param>
			virtual bool					InvokeInMainThreadAndWait(AsyncTaskProc* proc, void* argument, int milliseconds=-1)=0;
		};
		
		/// <summary>
		/// Clipboard service. To access this service, use [M:vl.presentation.INativeController.ClipboardService].
		/// </summary>
		class INativeClipboardService : public virtual Interface
		{
		public:
			/// <summary>
			/// Test is there a text in the clipboard.
			/// </summary>
			/// <returns>Returns true if there is a text in the clipboard.</returns>
			virtual bool					ContainsText()=0;
			/// <summary>
			/// Get the text in the clipboard.
			/// </summary>
			/// <returns>The text in the clipboard.</returns>
			virtual WString					GetText()=0;
			/// <summary>
			/// Copy the text to the clipboard.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="value">The text to copy to the clipboard.</param>
			virtual bool					SetText(const WString& value)=0;
		};
		
		/// <summary>
		/// Screen information service. To access this service, use [M:vl.presentation.INativeController.ScreenService].
		/// </summary>
		class INativeScreenService : public virtual Interface
		{
		public:
			/// <summary>
			/// Get the number of all available screens.
			/// </summary>
			///  <returns>The number of all available screens.</returns>
			virtual int						GetScreenCount()=0;
			/// <summary>
			/// Get the screen object by a specified screen index.
			/// </summary>
			/// <returns>The screen object.</returns>
			/// <param name="index">The specified screen index.</param>
			virtual INativeScreen*			GetScreen(int index)=0;
			/// <summary>
			/// Get the screen object where the main part of the specified window is inside.
			/// </summary>
			/// <returns>The screen object.</returns>
			/// <param name="index">The specified window.</param>
			virtual INativeScreen*			GetScreen(INativeWindow* window)=0;
		};
		
		/// <summary>
		/// Window service. To access this service, use [M:vl.presentation.INativeController.WindowService].
		/// </summary>
		class INativeWindowService : public virtual Interface
		{
		public:
			/// <summary>
			/// Create a window.
			/// </summary>
			/// <returns>The created window.</returns>
			virtual INativeWindow*			CreateNativeWindow()=0;
			/// <summary>
			/// Destroy a window.
			/// </summary>
			/// <param name="window">The window to destroy.</param>
			virtual void					DestroyNativeWindow(INativeWindow* window)=0;
			/// <summary>
			/// Get the main window.
			/// </summary>
			/// <returns>The main window.</returns>
			virtual INativeWindow*			GetMainWindow()=0;
			/// <summary>
			/// Get the window that under a specified position in screen space.
			/// </summary>
			/// <returns>The window that under a specified position in screen space.</returns>
			/// <param name="location">The specified position in screen space.</param>
			virtual INativeWindow*			GetWindow(Point location)=0;
			/// <summary>
			/// Make the specified window a main window, show that window, and wait until the windows is closed.
			/// </summary>
			/// <param name="window">The specified window.</param>
			virtual void					Run(INativeWindow* window)=0;
		};
		
		/// <summary>
		/// User input service. To access this service, use [M:vl.presentation.INativeController.InputService].
		/// </summary>
		class INativeInputService : public virtual Interface
		{
		public:
			/// <summary>
			/// Start to reveive global mouse message.
			/// </summary>
			virtual void					StartHookMouse()=0;
			/// <summary>
			/// Stop to receive global mouse message.
			/// </summary>
			virtual void					StopHookMouse()=0;
			/// <summary>
			/// Test is the global mouse message receiving enabled.
			/// </summary>
			/// <returns>Returns true if the global mouse message receiving is enabled.</returns>
			virtual bool					IsHookingMouse()=0;
			
			/// <summary>
			/// Start to reveive global timer message.
			/// </summary>
			virtual void					StartTimer()=0;
			/// <summary>
			/// Stop to receive global timer message.
			/// </summary>
			virtual void					StopTimer()=0;
			/// <summary>
			/// Test is the global timer message receiving enabled.
			/// </summary>
			/// <returns>Returns true if the global timer message receiving is enabled.</returns>
			virtual bool					IsTimerEnabled()=0;
			
			/// <summary>
			/// Test is the specified key pressing.
			/// </summary>
			/// <returns>Returns true if the specified key is pressing.</returns>
			virtual bool					IsKeyPressing(int code)=0;
			/// <summary>
			/// Test is the specified key toggled.
			/// </summary>
			/// <returns>Returns true if the specified key is toggled.</returns>
			virtual bool					IsKeyToggled(int code)=0;
		};
		
		/// <summary>
		/// Callback service. To access this service, use [M:vl.presentation.INativeController.CallbackService].
		/// </summary>
		class INativeCallbackService : public virtual Interface
		{
		public:
			/// <summary>
			/// Install a global message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The global message listener to install.</param>
			virtual bool					InstallListener(INativeControllerListener* listener)=0;
			/// <summary>
			/// Uninstall a global message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The global message listener to uninstall.</param>
			virtual bool					UninstallListener(INativeControllerListener* listener)=0;
		};

/***********************************************************************
Native Window Controller
***********************************************************************/

		/// <summary>
		/// Global native system service controller. Use [M:vl.presentation.GetCurrentController] to access this controller.
		/// </summary>
		class INativeController : public virtual Interface
		{
		public:
			/// <summary>
			/// Get the callback service.
			/// </summary>
			/// <returns>The callback service</returns>
			virtual INativeCallbackService*			CallbackService()=0;
			/// <summary>
			/// Get the system resource service.
			/// </summary>
			/// <returns>The system resource service</returns>
			virtual INativeResourceService*			ResourceService()=0;
			/// <summary>
			/// Get the asynchronized operation service.
			/// </summary>
			/// <returns>The asynchronized operation service</returns>
			virtual INativeAsyncService*			AsyncService()=0;
			/// <summary>
			/// Get the clipboard service.
			/// </summary>
			/// <returns>The clipboard service</returns>
			virtual INativeClipboardService*		ClipboardService()=0;
			/// <summary>
			/// Get the image service.
			/// </summary>
			/// <returns>The image service</returns>
			virtual INativeImageService*			ImageService()=0;
			/// <summary>
			/// Get the screen information service.
			/// </summary>
			/// <returns>The screen information service</returns>
			virtual INativeScreenService*			ScreenService()=0;
			/// <summary>
			/// Get the window service.
			/// </summary>
			/// <returns>The window service</returns>
			virtual INativeWindowService*			WindowService()=0;
			/// <summary>
			/// Get the user input service.
			/// </summary>
			/// <returns>The user input service</returns>
			virtual INativeInputService*			InputService()=0;
		};
		
		/// <summary>
		/// Represents a global message listener to an <see cref="INativeController"/>.
		/// </summary>
		class INativeControllerListener : public Interface
		{
		public:
			/// <summary>
			/// Called when the left mouse button is pressed. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>.
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					LeftButtonDown(Point position);
			/// <summary>
			/// Called when the left mouse button is released. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					LeftButtonUp(Point position);
			/// <summary>
			/// Called when the right mouse button is pressed. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					RightButtonDown(Point position);
			/// <summary>
			/// Called when the right mouse button is released. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					RightButtonUp(Point position);
			/// <summary>
			/// Called when the mouse is moving. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			virtual void					MouseMoving(Point position);
			/// <summary>
			/// Called when the global timer message raised. To receive or not receive this message, use <see cref="INativeInputService::StartTimer"/> or <see cref="INativeInputService::StopTimer"/>
			/// </summary>
			virtual void					GlobalTimer();
			/// <summary>
			/// Called when the content of the clipboard is updated.
			/// </summary>
			virtual void					ClipboardUpdated();
			/// <summary>
			/// Called when a window is created.
			/// </summary>
			/// <param name="window">The created window.</param>
			virtual void					NativeWindowCreated(INativeWindow* window);
			/// <summary>
			/// Called when a window is destroying.
			/// </summary>
			/// <param name="window">The destroying window.</param>
			virtual void					NativeWindowDestroying(INativeWindow* window);
		};

		/// <summary>
		/// Get the global native system service controller.
		/// </summary>
		/// <returns>The global native system service controller.</returns>
		extern								INativeController* GetCurrentController();
		/// <summary>
		/// Set the global native system service controller.
		/// </summary>
		/// <param name="controller">The global native system service controller.</param>
		extern void							SetCurrentController(INativeController* controller);
	}
}

/***********************************************************************
Native Window Provider
***********************************************************************/

/*
 * Virtual Keys, Standard Set
 */
#define VKEY_LBUTTON        0x01
#define VKEY_RBUTTON        0x02
#define VKEY_CANCEL         0x03
#define VKEY_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VKEY_XBUTTON1       0x05    /* NOT contiguous with L & RBUTTON */
#define VKEY_XBUTTON2       0x06    /* NOT contiguous with L & RBUTTON */

/*
 * 0x07 : unassigned
 */

#define VKEY_BACK           0x08
#define VKEY_TAB            0x09

/*
 * 0x0A - 0x0B : reserved
 */

#define VKEY_CLEAR          0x0C
#define VKEY_RETURN         0x0D

#define VKEY_SHIFT          0x10
#define VKEY_CONTROL        0x11
#define VKEY_MENU           0x12
#define VKEY_PAUSE          0x13
#define VKEY_CAPITAL        0x14

#define VKEY_KANA           0x15
#define VKEY_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VKEY_HANGUL         0x15
#define VKEY_JUNJA          0x17
#define VKEY_FINAL          0x18
#define VKEY_HANJA          0x19
#define VKEY_KANJI          0x19

#define VKEY_ESCAPE         0x1B

#define VKEY_CONVERT        0x1C
#define VKEY_NONCONVERT     0x1D
#define VKEY_ACCEPT         0x1E
#define VKEY_MODECHANGE     0x1F

#define VKEY_SPACE          0x20
#define VKEY_PRIOR          0x21
#define VKEY_NEXT           0x22
#define VKEY_END            0x23
#define VKEY_HOME           0x24
#define VKEY_LEFT           0x25
#define VKEY_UP             0x26
#define VKEY_RIGHT          0x27
#define VKEY_DOWN           0x28
#define VKEY_SELECT         0x29
#define VKEY_PRINT          0x2A
#define VKEY_EXECUTE        0x2B
#define VKEY_SNAPSHOT       0x2C
#define VKEY_INSERT         0x2D
#define VKEY_DELETE         0x2E
#define VKEY_HELP           0x2F

/*
 * VKEY_0 - VKEY_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
 * 0x40 : unassigned
 * VKEY_A - VKEY_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
 */

#define VKEY_LWIN           0x5B
#define VKEY_RWIN           0x5C
#define VKEY_APPS           0x5D

/*
 * 0x5E : reserved
 */

#define VKEY_SLEEP          0x5F

#define VKEY_NUMPAD0        0x60
#define VKEY_NUMPAD1        0x61
#define VKEY_NUMPAD2        0x62
#define VKEY_NUMPAD3        0x63
#define VKEY_NUMPAD4        0x64
#define VKEY_NUMPAD5        0x65
#define VKEY_NUMPAD6        0x66
#define VKEY_NUMPAD7        0x67
#define VKEY_NUMPAD8        0x68
#define VKEY_NUMPAD9        0x69
#define VKEY_MULTIPLY       0x6A
#define VKEY_ADD            0x6B
#define VKEY_SEPARATOR      0x6C
#define VKEY_SUBTRACT       0x6D
#define VKEY_DECIMAL        0x6E
#define VKEY_DIVIDE         0x6F
#define VKEY_F1             0x70
#define VKEY_F2             0x71
#define VKEY_F3             0x72
#define VKEY_F4             0x73
#define VKEY_F5             0x74
#define VKEY_F6             0x75
#define VKEY_F7             0x76
#define VKEY_F8             0x77
#define VKEY_F9             0x78
#define VKEY_F10            0x79
#define VKEY_F11            0x7A
#define VKEY_F12            0x7B
#define VKEY_F13            0x7C
#define VKEY_F14            0x7D
#define VKEY_F15            0x7E
#define VKEY_F16            0x7F
#define VKEY_F17            0x80
#define VKEY_F18            0x81
#define VKEY_F19            0x82
#define VKEY_F20            0x83
#define VKEY_F21            0x84
#define VKEY_F22            0x85
#define VKEY_F23            0x86
#define VKEY_F24            0x87

/*
 * 0x88 - 0x8F : unassigned
 */

#define VKEY_NUMLOCK        0x90
#define VKEY_SCROLL         0x91

/*
 * NEC PC-9800 kbd definitions
 */
#define VKEY_OEM_NEC_EQUAL  0x92   // '=' key on numpad

/*
 * Fujitsu/OASYS kbd definitions
 */
#define VKEY_OEM_FJ_JISHO   0x92   // 'Dictionary' key
#define VKEY_OEM_FJ_MASSHOU 0x93   // 'Unregister word' key
#define VKEY_OEM_FJ_TOUROKU 0x94   // 'Register word' key
#define VKEY_OEM_FJ_LOYA    0x95   // 'Left OYAYUBI' key
#define VKEY_OEM_FJ_ROYA    0x96   // 'Right OYAYUBI' key

/*
 * 0x97 - 0x9F : unassigned
 */

/*
 * VKEY_L* & VKEY_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VKEY_LSHIFT         0xA0
#define VKEY_RSHIFT         0xA1
#define VKEY_LCONTROL       0xA2
#define VKEY_RCONTROL       0xA3
#define VKEY_LMENU          0xA4
#define VKEY_RMENU          0xA5

#define VKEY_BROWSER_BACK        0xA6
#define VKEY_BROWSER_FORWARD     0xA7
#define VKEY_BROWSER_REFRESH     0xA8
#define VKEY_BROWSER_STOP        0xA9
#define VKEY_BROWSER_SEARCH      0xAA
#define VKEY_BROWSER_FAVORITES   0xAB
#define VKEY_BROWSER_HOME        0xAC

#define VKEY_VOLUME_MUTE         0xAD
#define VKEY_VOLUME_DOWN         0xAE
#define VKEY_VOLUME_UP           0xAF
#define VKEY_MEDIA_NEXT_TRACK    0xB0
#define VKEY_MEDIA_PREV_TRACK    0xB1
#define VKEY_MEDIA_STOP          0xB2
#define VKEY_MEDIA_PLAY_PAUSE    0xB3
#define VKEY_LAUNCH_MAIL         0xB4
#define VKEY_LAUNCH_MEDIA_SELECT 0xB5
#define VKEY_LAUNCH_APP1         0xB6
#define VKEY_LAUNCH_APP2         0xB7

/*
 * 0xB8 - 0xB9 : reserved
 */

#define VKEY_OEM_1          0xBA   // ';:' for US
#define VKEY_OEM_PLUS       0xBB   // '+' any country
#define VKEY_OEM_COMMA      0xBC   // ',' any country
#define VKEY_OEM_MINUS      0xBD   // '-' any country
#define VKEY_OEM_PERIOD     0xBE   // '.' any country
#define VKEY_OEM_2          0xBF   // '/?' for US
#define VKEY_OEM_3          0xC0   // '`~' for US

/*
 * 0xC1 - 0xD7 : reserved
 */

/*
 * 0xD8 - 0xDA : unassigned
 */

#define VKEY_OEM_4          0xDB  //  '[{' for US
#define VKEY_OEM_5          0xDC  //  '\|' for US
#define VKEY_OEM_6          0xDD  //  ']}' for US
#define VKEY_OEM_7          0xDE  //  ''"' for US
#define VKEY_OEM_8          0xDF

/*
 * 0xE0 : reserved
 */

/*
 * Various extended or enhanced keyboards
 */

#define VKEY_OEM_AX         0xE1  //  'AX' key on Japanese AX kbd
#define VKEY_OEM_102        0xE2  //  "<>" or "\|" on RT 102-key kbd.
#define VKEY_ICO_HELP       0xE3  //  Help key on ICO
#define VKEY_ICO_00         0xE4  //  00 key on ICO

#define VKEY_PROCESSKEY     0xE5
#define VKEY_ICO_CLEAR      0xE6
#define VKEY_PACKET         0xE7

/*
 * 0xE8 : unassigned
 */

/*
 * Nokia/Ericsson definitions
 */
#define VKEY_OEM_RESET      0xE9
#define VKEY_OEM_JUMP       0xEA
#define VKEY_OEM_PA1        0xEB
#define VKEY_OEM_PA2        0xEC
#define VKEY_OEM_PA3        0xED
#define VKEY_OEM_WSCTRL     0xEE
#define VKEY_OEM_CUSEL      0xEF
#define VKEY_OEM_ATTN       0xF0
#define VKEY_OEM_FINISH     0xF1
#define VKEY_OEM_COPY       0xF2
#define VKEY_OEM_AUTO       0xF3
#define VKEY_OEM_ENLW       0xF4
#define VKEY_OEM_BACKTAB    0xF5

#define VKEY_ATTN           0xF6
#define VKEY_CRSEL          0xF7
#define VKEY_EXSEL          0xF8
#define VKEY_EREOF          0xF9
#define VKEY_PLAY           0xFA
#define VKEY_ZOOM           0xFB
#define VKEY_NONAME         0xFC
#define VKEY_PA1            0xFD
#define VKEY_OEM_CLEAR      0xFE

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\REFLECTION\GUITYPEDESCRIPTOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Reflection

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUITYPEDESCRIPTOR
#define VCZH_PRESENTATION_REFLECTION_GUITYPEDESCRIPTOR


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Attribute
***********************************************************************/

		class ITypeDescriptor;

		class DescriptableObject
		{
			template<typename T>
			friend class Description;

			friend class DescriptableValue;
		protected:
			size_t							objectSize;
			ITypeDescriptor**				typeDescriptor;
		public:
			DescriptableObject();
			virtual ~DescriptableObject();
		};

		class IDescriptable : public virtual Interface, public virtual DescriptableObject
		{
		public:
			~IDescriptable(){}
		};
		
		template<typename T>
		class Description : public virtual DescriptableObject
		{
		protected:
			static ITypeDescriptor*			associatedTypeDescriptor;
		public:
			Description()
			{
				if(objectSize<sizeof(T))
				{
					objectSize=sizeof(T);
					typeDescriptor=&associatedTypeDescriptor;
				}
			}

			static void SetTypeDescroptorByTypeProvider(ITypeDescriptor* typeDescroptor)
			{
				associatedTypeDescriptor=typeDescroptor;
			}
		};

		template<typename T>
		ITypeDescriptor* Description<T>::associatedTypeDescriptor=0;

/***********************************************************************
DescriptableValue
***********************************************************************/

		class IType;

		class DescriptableValue : public Object
		{
		protected:
			IType*								type;
			signed __int64						dataSInt;
			unsigned __int64					dataUInt;
			double								dataFloat;
			bool								dataBool;
			wchar_t								dataChar;
			WString								dataString;
			Ptr<DescriptableObject>				dataDescriptableObject;
			DescriptableObject*					dataDescriptableObjectPointer;
			Ptr<Object>							dataObject;
			Object*								dataObjectPointer;
			Ptr<Interface>						dataInterface;
			Interface*							dataInterfacePointer;
			void*								dataRawPointer;

			void								Initialize();
		public:
			static DescriptableValue			Null;

			DescriptableValue();									// null
			DescriptableValue(IType* type, signed __int64 value);	// enum
			DescriptableValue(signed __int64 value);				// SInt
			DescriptableValue(unsigned __int64 value);				// UInt
			DescriptableValue(double value);						// Float
			DescriptableValue(bool value);							// Bool
			DescriptableValue(wchar_t value);						// Char
			DescriptableValue(const WString& value);				// String
			DescriptableValue(Ptr<DescriptableObject> value);		// descriptable object
			DescriptableValue(DescriptableObject* value);			// descriptable object pointer
			DescriptableValue(IType* _type, Ptr<Object> value);		// object, ObjectBox-ed structure
			DescriptableValue(IType* _type, Object* value);			// object pointer
			DescriptableValue(IType* _type, Ptr<Interface> value);	// interface
			DescriptableValue(IType* _type, Interface* value);		// interface pointer
			DescriptableValue(IType* _type, void* value);			// pointer, pointer/reference to struct
			DescriptableValue(const DescriptableValue& value);		// copy

			IType*								GetType()const;
			signed __int64						GetSInt()const;
			unsigned __int64					GetUInt()const;
			double								GetFloat()const;
			bool								GetBool()const;
			wchar_t								GetChar()const;
			WString								GetString()const;
			
			Ptr<DescriptableObject>				GetDescriptableObject()const;
			DescriptableObject*					GetDescriptableObjectPoitner()const;
			Ptr<Object>							GetRawObject()const;
			Object*								GetRawObjectPointer()const;
			Ptr<Interface>						GetInterface()const;
			Interface*							GetInterfacePointer()const;
			void*								GetRawPointer()const;

			bool								CanDelete()const;
			void								Delete();
		};

/***********************************************************************
ITypeDescriptor
***********************************************************************/

		class IType : public virtual Interface
		{
		public:
			enum TypeEnum
			{
				Void,
				SInt8,
				UInt8,
				SInt16,
				UInt16,
				SInt32,
				UInt32,
				SInt64,
				UInt64,
				Float,
				Double,
				Bool,
				Char,
				String,
				Enum,
				Struct,
				Class,
				Interface,

				Pointer,
				SmartPointer,
				Reference,
				ConstReference,
				RValueReference,
				Array,
				Const,
				Volatile,
			};

			virtual TypeEnum					GetTypeEnum()=0;
			virtual WString						GetName()=0;
			virtual ITypeDescriptor*			GetTypeDescriptor()=0;
			virtual bool						CanConvertTo(IType* targetType)=0;

			virtual IType*						GetElementType()=0;
			virtual int							GetArrayLength()=0;
			virtual IType*						GetReturnType()=0;
			virtual int							GetParameterCount()=0;
			virtual IType*						GetParameterType(int index)=0;
		};

		class IMemberDescriptor : public virtual Interface
		{
		public:
			enum MemberTypeEnum
			{
				Static,
				Abstract,
				Virtual,
				Normal,
			};

			virtual WString						GetName()=0;
			virtual ITypeDescriptor*			GetOwnerTypeDescriptor()=0;
			virtual MemberTypeEnum				GetMemberTypeEnum()=0;
		};

		class IParameterDescriptor : public virtual Interface
		{
		public:
			virtual WString						GetName()=0;
			virtual IType*						GetType()=0;
		};

		class IMethodDescriptor : public virtual IMemberDescriptor
		{
		public:
			virtual IType*						GetReturnType()=0;
			virtual int							GetParameterCount()=0;
			virtual IParameterDescriptor*		GetParameter(int index)=0;
			virtual DescriptableValue			Invoke(const DescriptableValue& thisObject, const collections::IReadonlyList<DescriptableValue>& parameters)=0;
		}; 

		class IPropertyDescriptor : public virtual IMemberDescriptor
		{
		public:
			virtual bool						CanGet()=0;
			virtual bool						CanSet()=0;
			virtual IType*						GetPropertyType()=0;
			virtual IMethodDescriptor*			GetSetter()=0;
			virtual IMethodDescriptor*			GetGetter()=0;
		};

		class ITypeDescriptor : public virtual Interface
		{
		public:
			virtual IType*						GetType()=0;
			virtual int							GetBaseTypeCount()=0;
			virtual IType*						GetBaseType(int index)=0;

			virtual int							GetConstructorCount()=0;
			virtual IMethodDescriptor*			GetConstructor(int index)=0;
			virtual IMethodDescriptor*			GetDefaultConstructor()=0;
			virtual int							GetMethodCount()=0;
			virtual IMethodDescriptor*			GetMethod(int index)=0;
			virtual int							GetPropertyCount()=0;
			virtual IPropertyDescriptor*		GetProperty(int index)=0;

			virtual IMethodDescriptor*			FindMethod(const WString& name, bool searchParent, bool searchStatic, bool searchInstance)=0;
			virtual void						FindMethods(const WString& name, bool searchParent, bool searchStatic, bool searchInstance, collections::List<IMethodDescriptor*>& methods)=0;
			virtual IPropertyDescriptor*		FindProperty(const WString& name, bool searchParent, bool searchStatic, bool searchInstance)=0;
		};

/***********************************************************************
Helper Functions
***********************************************************************/

		class ITypeProvider : public virtual Interface
		{
		public:
			virtual IType*			Void()=0;
			virtual IType*			SInt8()=0;
			virtual IType*			UInt8()=0;
			virtual IType*			SInt16()=0;
			virtual IType*			UInt16()=0;
			virtual IType*			SInt32()=0;
			virtual IType*			UInt32()=0;
			virtual IType*			SInt64()=0;
			virtual IType*			UInt64()=0;
			virtual IType*			Float()=0;
			virtual IType*			Double()=0;
			virtual IType*			Bool()=0;
			virtual IType*			Char()=0;
			virtual IType*			String()=0;
			virtual IType*			Pointer(IType* elementType)=0;
			virtual IType*			SmartPointer(IType* elementType)=0;
			virtual IType*			Reference(IType* elementType)=0;
			virtual IType*			ConstReference(IType* elementType)=0;
			virtual IType*			RValueReference(IType* elementType)=0;
			virtual IType*			Array(IType* elementType, int length)=0;

			virtual int				GetDescriptableTypeCount()=0;
			virtual IType*			GetDescriptableType(int index)=0;
			virtual IType*			FindType(const WString& name)=0;
		};

		extern ITypeProvider*		GetTypeProvider();
		extern void					SetTypeProvider(ITypeProvider* value);
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			class IGuiGraphicsElement;
			class IGuiGraphicsElementFactory;
			class IGuiGraphicsRenderer;
			class IGuiGraphicsRendererFactory;
			class IGuiGraphicsRenderTarget;

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// This is the interface for graphics elements.
			/// Graphics elements usually contains some information and helper functions for visible things.
			/// An graphics elements should be created using ElementType::Create.
			/// </summary>
			class IGuiGraphicsElement : public virtual IDescriptable, public Description<IGuiGraphicsElement>
			{
			public:
				/// <summary>
				/// Access the <see cref="IGuiGraphicsElementFactory"></see> that is used to create this graphics elements.
				/// </summary>
				/// <returns>Returns the related factory.</returns>
				virtual IGuiGraphicsElementFactory*		GetFactory()=0;
				/// <summary>
				/// Access the associated <see cref="IGuiGraphicsRenderer"></see> for this graphics element.
				/// </summary>
				/// <returns>Returns the related renderer.</returns>
				virtual IGuiGraphicsRenderer*			GetRenderer()=0;
			};

			/// <summary>
			/// This is the interface for graphics element factories.
			/// Graphics element factories should be registered using [M:vl.presentation.elements.GuiGraphicsResourceManager.RegisterElementFactory].
			/// </summary>
			class IGuiGraphicsElementFactory : public Interface
			{
			public:
				/// <summary>
				/// Get the name representing the kind of graphics element to be created.
				/// </summary>
				/// <returns>Returns the name of graphics elements.</returns>
				virtual WString							GetElementTypeName()=0;
				/// <summary>
				/// Create a <see cref="IGuiGraphicsElement"></see>.
				/// </summary>
				/// <returns>Returns the created graphics elements.</returns>
				virtual IGuiGraphicsElement*			Create()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderers.
			/// </summary>
			class IGuiGraphicsRenderer : public Interface
			{
			public:
				/// <summary>
				/// Access the graphics <see cref="IGuiGraphicsRendererFactory"></see> that is used to create this graphics renderer.
				/// </summary>
				/// <returns>Returns the related factory.</returns>
				virtual IGuiGraphicsRendererFactory*	GetFactory()=0;

				/// <summary>
				/// Initialize the grpahics renderer by binding a <see cref="IGuiGraphicsElement"></see> to it.
				/// </summary>
				/// <param name="element">The graphics element to bind.</param>
				virtual void							Initialize(IGuiGraphicsElement* element)=0;
				/// <summary>
				/// Release all resources that used by this renderer.
				/// </summary>
				virtual void							Finalize()=0;
				/// <summary>
				/// Set a <see cref="IGuiGraphicsRenderTarget"></see> to this element.
				/// </summary>
				/// <param name="renderTarget">The graphics render target. It can be NULL.</param>
				virtual void							SetRenderTarget(IGuiGraphicsRenderTarget* renderTarget)=0;
				/// <summary>
				/// Render the graphics element using a specified bounds.
				/// </summary>
				/// <param name="bounds">Bounds to decide the size and position of the binded graphics element.</param>
				virtual void							Render(Rect bounds)=0;
				/// <summary>
				/// Notify that the state in the binded graphics element is changed. This function is usually called by the element itself.
				/// </summary>
				virtual void							OnElementStateChanged()=0;
				/// <summary>
				/// Calculate the minimum size using the binded graphics element and it's state.
				/// </summary>
				/// <returns>The minimum size.</returns>
				virtual Size							GetMinSize()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderer factories.
			/// Graphics renderers should be registered using [M:vl.presentation.elements.GuiGraphicsResourceManager.RegisterRendererFactory]. 
			/// </summary>
			class IGuiGraphicsRendererFactory : public Interface
			{
			public:
				/// <summary>
				/// Create a <see cref="IGuiGraphicsRenderer"></see>.
				/// </summary>
				/// <returns>Returns the created graphics renderer.</returns>
				virtual IGuiGraphicsRenderer*			Create()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderer targets.
			/// </summary>
			class IGuiGraphicsRenderTarget : public Interface
			{
			public:
				/// <summary>
				/// Notify the target to prepare for rendering.
				/// </summary>
				virtual void							StartRendering()=0;
				/// <summary>
				/// Notify the target to stop rendering.
				/// </summary>
				virtual void							StopRendering()=0;
				/// <summary>
				/// Apply a clipper to the render target.
				/// The result clipper is combined by all clippers in the clipper stack maintained by the render target.
				/// </summary>
				virtual void							PushClipper(Rect clipper)=0;
				/// <summary>
				/// Remove the last pushed clipper from the clipper stack.
				/// </summary>
				virtual void							PopClipper()=0;
				/// <summary>
				/// Get the combined clipper
				/// </summary>
				/// <returns>The combined clipper</returns>
				virtual Rect							GetClipper()=0;
				/// <summary>
				/// Test is the combined clipper is as large as the render target.
				/// </summary>
				/// <returns>Return true if the combined clipper is as large as the render target.</returns>
				virtual bool							IsClipperCoverWholeTarget()=0;
			};

/***********************************************************************
Resource Manager
***********************************************************************/

			/// <summary>
			/// This is a class for managing grpahics element factories and graphics renderer factories
			/// </summary>
			class GuiGraphicsResourceManager : public Object
			{
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsElementFactory>>		elementFactoryMap;
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsRendererFactory>>		rendererFactoryMap;
			protected:
				elementFactoryMap						elementFactories;
				rendererFactoryMap						rendererFactories;
			public:
				/// <summary>
				/// Create a graphics resource manager without any predefined factories
				/// </summary>
				GuiGraphicsResourceManager();
				~GuiGraphicsResourceManager();

				/// <summary>
				/// Register a <see cref="IGuiGraphicsElementFactory"></see> using the element type from <see cref="IGuiGraphicsElementFactory::GetElementTypeName"></see>.
				/// </summary>
				/// <param name="factory">The instance of the graphics element factory to register.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool							RegisterElementFactory(IGuiGraphicsElementFactory* factory);
				/// <summary>
				/// Register a <see cref="IGuiGraphicsRendererFactory"></see> and bind it to a registered <see cref="IGuiGraphicsElementFactory"></see>.
				/// </summary>
				/// <param name="elementTypeName">The element type to represent a graphics element factory.</param>
				/// <param name="factory">The instance of the graphics renderer factory to register.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool							RegisterRendererFactory(const WString& elementTypeName, IGuiGraphicsRendererFactory* factory);
				/// <summary>
				/// Get the instance of a registered <see cref="IGuiGraphicsElementFactory"></see> that is binded to a specified element type.
				/// </summary>
				/// <param name="elementTypeName">The element type to get a corresponding graphics element factory.</param>
				virtual IGuiGraphicsElementFactory*		GetElementFactory(const WString& elementTypeName);
				/// <summary>
				/// Get the instance of a registered <see cref="IGuiGraphicsRendererFactory"></see> that is binded to a specified element type.
				/// </summary>
				/// <param name="elementTypeName">The element type to get a corresponding graphics renderer factory.</param>
				virtual IGuiGraphicsRendererFactory*	GetRendererFactory(const WString& elementTypeName);
				/// <summary>
				/// Get the instance of a <see cref="IGuiGraphicsRenderTarget"></see> that is binded to an <see cref="INativeWindow"></see>.
				/// </summary>
				virtual IGuiGraphicsRenderTarget*		GetRenderTarget(INativeWindow* window)=0;
			};

			/// <summary>
			/// Get the current <see cref="GuiGraphicsResourceManager"></see>.
			/// </summary>
			/// <returns>Returns the current resource manager.</returns>
			extern GuiGraphicsResourceManager*			GetGuiGraphicsResourceManager();
			/// <summary>
			/// Set the current <see cref="GuiGraphicsResourceManager"></see>.
			/// </summary>
			/// <params name="resourceManager">The resource manager to set.</params>
			extern void									SetGuiGraphicsResourceManager(GuiGraphicsResourceManager* resourceManager);
			/// <summary>
			/// Helper function to register a <see cref="IGuiGraphicsElementFactory"></see> with a <see cref="IGuiGraphicsRendererFactory"></see> and bind them together.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			extern bool									RegisterFactories(IGuiGraphicsElementFactory* elementFactory, IGuiGraphicsRendererFactory* rendererFactory);

/***********************************************************************
Helpers
***********************************************************************/

#define DEFINE_GUI_GRAPHICS_ELEMENT(TELEMENT, ELEMENT_TYPE_NAME)\
			public:\
				class Factory : public Object, public IGuiGraphicsElementFactory\
				{\
				public:\
					WString GetElementTypeName()\
					{\
						return TELEMENT::GetElementTypeName();\
					}\
					IGuiGraphicsElement* Create()\
					{\
						TELEMENT* element=new TELEMENT;\
						element->factory=this;\
						element->renderer=GetGuiGraphicsResourceManager()->GetRendererFactory(GetElementTypeName())->Create();\
						element->renderer->Initialize(element);\
						return element;\
					}\
				};\
			protected:\
				IGuiGraphicsElementFactory*		factory;\
				Ptr<IGuiGraphicsRenderer>		renderer;\
			public:\
				static WString GetElementTypeName()\
				{\
					return ELEMENT_TYPE_NAME;\
				}\
				static TELEMENT* Create()\
				{\
					return dynamic_cast<TELEMENT*>(GetGuiGraphicsResourceManager()->GetElementFactory(TELEMENT::GetElementTypeName())->Create());\
				}\
				IGuiGraphicsElementFactory* GetFactory()override\
				{\
					return factory;\
				}\
				IGuiGraphicsRenderer* GetRenderer()override\
				{\
					return renderer.Obj();\
				}\

#define DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, TTARGET)\
			public:\
				class Factory : public Object, public IGuiGraphicsRendererFactory\
				{\
				public:\
					IGuiGraphicsRenderer* Create()\
					{\
						TRENDERER* renderer=new TRENDERER;\
						renderer->factory=this;\
						renderer->element=0;\
						renderer->renderTarget=0;\
						return renderer;\
					}\
				};\
			protected:\
				IGuiGraphicsRendererFactory*	factory;\
				TELEMENT*						element;\
				TTARGET*						renderTarget;\
				Size							minSize;\
			public:\
				static void Register()\
				{\
					RegisterFactories(new TELEMENT::Factory, new TRENDERER::Factory);\
				}\
				IGuiGraphicsRendererFactory* GetFactory()override\
				{\
					return factory;\
				}\
				void Initialize(IGuiGraphicsElement* _element)override\
				{\
					element=dynamic_cast<TELEMENT*>(_element);\
					InitializeInternal();\
				}\
				void Finalize()override\
				{\
					FinalizeInternal();\
				}\
				void SetRenderTarget(IGuiGraphicsRenderTarget* _renderTarget)override\
				{\
					TTARGET* oldRenderTarget=renderTarget;\
					renderTarget=dynamic_cast<TTARGET*>(_renderTarget);\
					RenderTargetChangedInternal(oldRenderTarget, renderTarget);\
				}\
				Size GetMinSize()override\
				{\
					return minSize;\
				}\

#define DEFINE_CACHED_RESOURCE_ALLOCATOR(TKEY, TVALUE)\
			public:\
				static const int DeadPackageMax=32;\
				struct Package\
				{\
					TVALUE							resource;\
					int								counter;\
					bool operator==(const Package& package)const{return false;}\
					bool operator!=(const Package& package)const{return true;}\
				};\
				struct DeadPackage\
				{\
					TKEY							key;\
					TVALUE							value;\
					bool operator==(const DeadPackage& package)const{return false;}\
					bool operator!=(const DeadPackage& package)const{return true;}\
				};\
				Dictionary<TKEY, Package>			aliveResources;\
				List<DeadPackage>					deadResources;\
			public:\
				TVALUE Create(const TKEY& key)\
				{\
					int index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values()[index];\
						package.counter++;\
						aliveResources.Set(key, package);\
						return package.resource;\
					}\
					TVALUE resource;\
					for(int i=0;i<deadResources.Count();i++)\
					{\
						if(deadResources[i].key==key)\
						{\
							DeadPackage deadPackage=deadResources[i];\
							deadResources.RemoveAt(i);\
							resource=deadPackage.value;\
							break;\
						}\
					}\
					if(!resource)\
					{\
						resource=CreateInternal(key);\
					}\
					Package package;\
					package.resource=resource;\
					package.counter=1;\
					aliveResources.Add(key, package);\
					return package.resource;\
				}\
				void Destroy(const TKEY& key)\
				{\
					int index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values()[index];\
						package.counter--;\
						if(package.counter==0)\
						{\
							aliveResources.Remove(key);\
							if(deadResources.Count()==DeadPackageMax)\
							{\
								deadResources.RemoveAt(DeadPackageMax-1);\
							}\
							DeadPackage deadPackage;\
							deadPackage.key=key;\
							deadPackage.value=package.resource;\
							deadResources.Insert(0, deadPackage);\
						}\
						else\
						{\
							aliveResources.Set(key, package);\
						}\
					}\
				}\

/***********************************************************************
Elements
***********************************************************************/

			namespace ElementShape
			{
				/// <summary>
				/// Defines an shape for some <see cref="IGuiGraphicsElement"></see>.
				/// </summary>
				enum Type
				{
					/// <summary>[T:vl.presentation.elements.ElementShape.Type]Rectangle shape.</summary>
					Rectangle,
					/// <summary>[T:vl.presentation.elements.ElementShape.Type]Ellipse shape.</summary>
					Ellipse,
				};
			};

			/// <summary>
			/// Defines a border element with a thickness of one pixel.
			/// </summary>
			class GuiSolidBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBorderElement, L"SolidBorder")
			protected:
				Color					color;
				ElementShape::Type		shape;

				GuiSolidBorderElement();
			public:
				~GuiSolidBorderElement();

				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape::Type		GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape::Type value);
			};
			
			/// <summary>
			/// Defines a rectangle border element with round corners and a thickness of one pixel.
			/// </summary>
			class GuiRoundBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiRoundBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiRoundBorderElement, L"RoundBorder")
			protected:
				Color					color;
				int						radius;

				GuiRoundBorderElement();
			public:
				~GuiRoundBorderElement();
				
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				
				/// <summary>
				/// Get the radius of round corners.
				/// </summary>
				/// <returns>The radius.</returns>
				int						GetRadius();
				/// <summary>
				/// Set the radius of round corners.
				/// </summary>
				/// <param name="value">The new radius.</param>
				void					SetRadius(int value);
			};
			
			/// <summary>
			/// Defines a 3D-like rectangle element with a thickness of two pixels.
			/// </summary>
			class Gui3DBorderElement : public Object, public IGuiGraphicsElement, public Description<Gui3DBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DBorderElement, L"3DBorder")
			protected:
				Color					color1;
				Color					color2;

				Gui3DBorderElement();
			public:
				~Gui3DBorderElement();
				
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Get the right-bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
			};
			
			/// <summary>
			/// Defines a 3D-like splitter element with a thickness of two pixels.
			/// </summary>
			class Gui3DSplitterElement : public Object, public IGuiGraphicsElement, public Description<Gui3DSplitterElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DSplitterElement, L"3DSplitter")
			public:
				/// <summary>
				/// Defines a direction of the <see cref="Gui3DSplitterElement"></see>.
				/// </summary>
				enum Direction
				{
					/// <summary>[T:vl.presentation.elements.Gui3DSplitterElement.Direction]Horizontal direction.</summary>
					Horizontal,
					/// <summary>[T:vl.presentation.elements.Gui3DSplitterElement.Direction]Vertical direction.</summary>
					Vertical,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;

				Gui3DSplitterElement();
			public:
				~Gui3DSplitterElement();
				
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Get the right-bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
				
				/// <summary>
				/// Get the direction.
				/// </summary>
				/// <returns>The direction.</returns>
				Direction				GetDirection();
				/// <summary>
				/// Set the direction.
				/// </summary>
				/// <param name="value">The new direction.</param>
				void					SetDirection(Direction value);
			};

			/// <summary>
			/// Defines a color-filled element without border.
			/// </summary>
			class GuiSolidBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBackgroundElement, L"SolidBackground")
			protected:
				Color					color;
				ElementShape::Type		shape;

				GuiSolidBackgroundElement();
			public:
				~GuiSolidBackgroundElement();
				
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape::Type		GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape::Type value);
			};
			
			/// <summary>
			/// Defines a color-filled gradient element without border.
			/// </summary>
			class GuiGradientBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiGradientBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiGradientBackgroundElement, L"GradientBackground")
			public:
				/// <summary>
				/// Defines a direction of the <see cref="Gui3DSplitterElement"></see>.
				/// </summary>
				enum Direction
				{
					/// <summary>[T:vl.presentation.elements.GuiGradientBackgroundElement.Direction]Horizontal direction.</summary>
					Horizontal,
					/// <summary>[T:vl.presentation.elements.GuiGradientBackgroundElement.Direction]vertical direction.</summary>
					Vertical,
					/// <summary>[T:vl.presentation.elements.GuiGradientBackgroundElement.Direction]Slash direction.</summary>
					Slash,
					/// <summary>[T:vl.presentation.elements.GuiGradientBackgroundElement.Direction]Back slash direction.</summary>
					Backslash,
				};
			protected:
				Color					color1, color2;
				Direction				direction;
				ElementShape::Type		shape;

				GuiGradientBackgroundElement();
			public:
				~GuiGradientBackgroundElement();
				
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Get the right bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
				
				/// <summary>
				/// Get the direction.
				/// </summary>
				/// <returns>The direction.</returns>
				Direction				GetDirection();
				/// <summary>
				/// Set the direction.
				/// </summary>
				/// <param name="value">The new direction.</param>
				void					SetDirection(Direction value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape::Type		GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape::Type value);
			};
			
			/// <summary>
			/// Defines an element of a plain text.
			/// </summary>
			class GuiSolidLabelElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidLabelElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidLabelElement, L"SolidLabel");
			protected:
				Color					color;
				FontProperties			fontProperties;
				WString					text;
				Alignment::Type			hAlignment;
				Alignment::Type			vAlignment;
				bool					wrapLine;
				bool					ellipse;
				bool					multiline;

				GuiSolidLabelElement();
			public:
				~GuiSolidLabelElement();
				
				/// <summary>
				/// Get the text color.
				/// </summary>
				/// <returns>The text color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the text color.
				/// </summary>
				/// <param name="value">The new text color.</param>
				void					SetColor(Color value);
				
				/// <summary>
				/// Get the text font.
				/// </summary>
				/// <returns>The text font.</returns>
				const FontProperties&	GetFont();
				/// <summary>
				/// Set the text font.
				/// </summary>
				/// <param name="value">The new text font.</param>
				void					SetFont(const FontProperties& value);
				
				/// <summary>
				/// Get the text.
				/// </summary>
				/// <returns>The text.</returns>
				const WString&			GetText();
				/// <summary>
				/// Set the text.
				/// </summary>
				/// <param name="value">The new text.</param>
				void					SetText(const WString& value);
				
				/// <summary>
				/// Get the horizontal alignment of the text.
				/// </summary>
				/// <returns>The horizontal alignment of the text.</returns>
				Alignment::Type			GetHorizontalAlignment();
				/// <summary>
				/// Get the vertical alignment of the text.
				/// </summary>
				/// <returns>The vertical alignment of the text.</returns>
				Alignment::Type			GetVerticalAlignment();
				/// <summary>
				/// Set alignments in both directions of the text.
				/// </summary>
				/// <param name="horizontal">The new horizontal alignment of the text.</param>
				/// <param name="vertical">The vertical alignment of the text.</param>
				void					SetAlignments(Alignment::Type horizontal, Alignment::Type vertical);
				
				/// <summary>
				/// Get if line auto-wrapping is enabled for this text.
				/// </summary>
				/// <returns>Return true if line auto-wrapping is enabled for this text.</returns>
				bool					GetWrapLine();
				/// <summary>
				/// Set if line auto-wrapping is enabled for this text.
				/// </summary>
				/// <param name="value">True if line auto-wrapping is enabled for this text.</param>
				void					SetWrapLine(bool value);
				
				/// <summary>
				/// Get if ellipse is enabled for this text. Ellipse will appear when the text is clipped.
				/// </summary>
				/// <returns>Return true if ellipse is enabled for this text.</returns>
				bool					GetEllipse();
				/// <summary>
				/// Set if ellipse is enabled for this text. Ellipse will appear when the text is clipped.
				/// </summary>
				/// <param name="value">True if ellipse is enabled for this text.</param>
				void					SetEllipse(bool value);
				
				/// <summary>
				/// Get if multiple lines is enabled for this text.
				/// </summary>
				/// <returns>Return true if multiple lines is enabled for this text.</returns>
				bool					GetMultiline();
				/// <summary>
				/// Set if multiple lines is enabled for this text.
				/// </summary>
				/// <param name="value">True if multiple lines is enabled for this text.</param>
				void					SetMultiline(bool value);
			};

			/// <summary>
			/// Defines an element containing an image.
			/// </summary>
			class GuiImageFrameElement : public Object, public IGuiGraphicsElement, public Description<GuiImageFrameElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiImageFrameElement, L"ImageFrame");
			protected:
				Ptr<INativeImage>		image;
				int						frameIndex;
				Alignment::Type			hAlignment;
				Alignment::Type			vAlignment;
				bool					stretch;

				GuiImageFrameElement();
			public:
				~GuiImageFrameElement();

				/// <summary>
				/// Get the containing image.
				/// </summary>
				/// <returns>The contining picture.</returns>
				Ptr<INativeImage>		GetImage();
				/// <summary>
				/// Get the index of the frame in the containing image.
				/// </summary>
				/// <returns>The index of the frame in the containing image</returns>
				int						GetFrameIndex();
				/// <summary>
				/// Set the containing image and the frame index.
				/// </summary>
				/// <param name="_image">The new containing image.</param>
				/// <param name="_frameIndex">The new frameIndex.</param>
				void					SetImage(Ptr<INativeImage> _image, int _frameIndex=0);
				
				/// <summary>
				/// Get the horizontal alignment of the image.
				/// </summary>
				/// <returns>The horizontal alignment of the image.</returns>
				Alignment::Type			GetHorizontalAlignment();
				/// <summary>
				/// Get the vertical alignment of the image.
				/// </summary>
				/// <returns>The vertical alignment of the image.</returns>
				Alignment::Type			GetVerticalAlignment();
				/// <summary>
				/// Set alignments in both directions of the image.
				/// </summary>
				/// <param name="horizontal">The new horizontal alignment of the image.</param>
				/// <param name="vertical">The vertical alignment of the image.</param>
				void					SetAlignments(Alignment::Type horizontal, Alignment::Type vertical);

				/// <summary>
				/// Get if stretching is enabled for this image.
				/// </summary>
				/// <returns>Return true if stretching is enabled for this image.</returns>
				bool					GetStretch();
				/// <summary>
				/// Set if stretching is enabled for this image.
				/// </summary>
				/// <param name="value">True if stretching is enabled for this image.</param>
				void					SetStretch(bool value);
			};

			/// <summary>
			/// Defines a polygon element with a thickness of one pixel.
			/// </summary>
			class GuiPolygonElement : public Object, public IGuiGraphicsElement, public Description<GuiPolygonElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiPolygonElement, L"Polygon");
			protected:
				Size							size;
				collections::Array<Point>		points;
				Color							borderColor;
				Color							backgroundColor;

				GuiPolygonElement();
			public:
				~GuiPolygonElement();

				/// <summary>
				/// Get a suggested size. The polygon element will be layouted to the center of the required bounds using this size.
				/// </summary>
				/// <returns>The suggested size.</returns>
				Size					GetSize();
				/// <summary>
				/// Set a suggested size. The polygon element will be layouted to the center of the required bounds using this size.
				/// </summary>
				/// <param name="value">The new size.</param>
				void					SetSize(Size value);

				/// <summary>
				/// Get a point of the polygon element using an index.
				/// </summary>
				/// <param name="index">The index to access a point.</param>
				/// <returns>The point of the polygon element associated with the index.</returns>
				const Point&			GetPoint(int index);
				/// <summary>
				/// Get the number of points
				/// </summary>
				/// <returns>The number of points.</returns>
				int						GetPointCount();
				/// <summary>
				/// Set all points to the polygon element.
				/// </summary>
				/// <param name="p">A pointer to a buffer that stores all points.</param>
				/// <param name="index">The number of points.</param>
				void					SetPoints(const Point* p, int count);
				
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetBorderColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetBorderColor(Color value);
				/// <summary>
				/// Get the background color.
				/// </summary>
				/// <returns>The background color.</returns>
				Color					GetBackgroundColor();
				/// <summary>
				/// Set the background color.
				/// </summary>
				/// <param name="value">The new background color.</param>
				void					SetBackgroundColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSTEXTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
ColorizedText
***********************************************************************/

			namespace text
			{
				/// <summary>
				/// Represents the extra information of a character to display.
				/// </summary>
				struct CharAtt
				{
					/// <summary>
					/// The distance from the head of the line to the right side of this character in pixel.
					/// </summary>
					unsigned __int32				rightOffset;
					/// <summary>
					/// The color index of the character. Use [M:vl.presentation.elements.GuiColorizedTextElement.GetColors] and [M:vl.presentation.elements.GuiColorizedTextElement.SetColors] to access the color table.
					/// </summary>
					unsigned __int32				colorIndex;
				};
				
				/// <summary>
				/// Represents a line of characters.
				/// </summary>
				struct TextLine
				{
					static const int				BlockSize=32;
					static const int				MaxWidth=0xFFFF;
					
					/// <summary>
					/// A character buffer starts from the first character of this line.
					/// </summary>
					wchar_t*						text;
					/// <summary>
					/// A extra information buffer starts from the first character of this line.
					/// </summary>
					CharAtt*						att;
					/// <summary>
					/// The number of available <see cref="CharAtt::rightOffset"/> in the buffer.
					/// </summary>
					int								availableOffsetCount;
					/// <summary>
					/// The number of elements in the allocated buffer memory.
					/// </summary>
					int								bufferLength;
					/// <summary>
					/// The number of available characters in the buffer.
					/// </summary>
					int								dataLength;

					TextLine();
					~TextLine();

					static int						CalculateBufferLength(int dataLength);
					bool							operator==(const TextLine& value)const{return false;}
					bool							operator!=(const TextLine& value)const{return true;}

					/// <summary>
					/// Initialize the <see cref="TextLine"/> instance to be an empty line.
					/// </summary>
					void							Initialize();
					/// <summary>
					/// Release all resources used in this line.
					/// </summary>
					void							Finalize();
					/// <summary>
					/// Test is the line initialized.
					/// </summary>
					/// <returns>Returns true if the line is initialized.</returns>
					bool							IsReady();
					/// <summary>
					/// Modify the characters in the line by replacing characters.
					/// </summary>
					/// <returns>Returns true if the modification succeeded.</returns>
					/// <param name="start">The position of the first character to be replaced.</param>
					/// <param name="count">The number of characters to be replaced.</param>
					/// <param name="input">The buffer to the characters to write into this line.</param>
					/// <param name="inputCount">The numbers of the characters to write into this line.</param>
					bool							Modify(int start, int count, const wchar_t* input, int inputCount);
					/// <summary>
					/// Split a text line into two by the position. The current line contains characters before this position. This function returns a new text line contains characters after this position.
					/// </summary>
					/// <returns>The new text line.</returns>
					/// <param name="index">.</param>
					TextLine						Split(int index);
					/// <summary>
					/// Append a text line after the this text line, and finalize the input text line.
					/// </summary>
					/// <param name="line">The text line that contains all characters and color indices to append and be finalized.</param>
					void							AppendAndFinalize(TextLine& line);
				};

				/// <summary>
				/// An abstract class for character size measuring in differect rendering technology.
				/// </summary>
				class CharMeasurer : public virtual IDescriptable
				{
				protected:
					IGuiGraphicsRenderTarget*		oldRenderTarget;
					int								rowHeight;
					int								widths[65536];
					
					/// <summary>
					/// Measure the width of a character.
					/// </summary>
					/// <returns>The width in pixel.</returns>
					/// <param name="character">The character to measure. This is a pure virtual member function to be overrided.</param>
					/// <param name="renderTarget">The render target which the character is going to be rendered. This is a pure virtual member function to be overrided.</param>
					virtual int						MeasureWidthInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)=0;
					/// <summary>
					/// Measure the height of a character.
					/// </summary>
					/// <returns>The height in pixel.</returns>
					/// <param name="renderTarget">The render target which the character is going to be rendered.</param>
					virtual int						GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)=0;
				public:

					/// <summary>
					/// Initialize a character measurer.
					/// </summary>
					/// <param name="_rowHeight">The default character height in pixel before the character measurer is binded to a render target.</param>
					CharMeasurer(int _rowHeight);
					~CharMeasurer();

					/// <summary>
					/// Bind a render target to this character measurer.
					/// </summary>
					/// <param name="value">The render target to bind.</param>
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					/// <summary>
					/// Measure the width of a character using the binded render target.
					/// </summary>
					/// <returns>The width of a character, in pixel.</returns>
					/// <param name="character">The character to measure.</param>
					int								MeasureWidth(wchar_t character);
					/// <summary>
					/// Measure the height of a character.
					/// </summary>
					/// <returns>The height of a character, in pixel.</returns>
					int								GetRowHeight();
				};

				/// <summary>
				/// A class to maintain multiple lines of text buffer.
				/// </summary>
				struct TextLines
				{
					typedef collections::List<TextLine>		TextLineList;
				protected:
					TextLineList					lines;
					CharMeasurer*					charMeasurer;
					IGuiGraphicsRenderTarget*		renderTarget;
					int								tabWidth;
					int								tabSpaceCount;
				public:
					TextLines();
					~TextLines();

					/// <summary>
					/// Returns the number of text lines.
					/// </summary>
					/// <returns>The number of text lines.</returns>
					int								GetCount();
					/// <summary>
					/// Returns the text line of a specified row number.
					/// </summary>
					/// <returns>The related text line object.</returns>
					/// <param name="row">The specified row number.</param>
					TextLine&						GetLine(int row);
					/// <summary>
					/// Returns the binded <see cref="CharMeasurer"/>.
					/// </summary>
					/// <returns>The binded <see cref="CharMeasurer"/>.</returns>
					CharMeasurer*					GetCharMeasurer();
					/// <summary>
					/// Binded a <see cref="CharMeasurer"/>.
					/// </summary>
					/// <param name="value">The <see cref="CharMeasurer"/> to bind.</param>
					void							SetCharMeasurer(CharMeasurer* value);
					/// <summary>
					/// Returns the binded <see cref="IGuiGraphicsRenderTarget"/>.
					/// </summary>
					/// <returns>The binded <see cref="IGuiGraphicsRenderTarget"/>.</returns>
					IGuiGraphicsRenderTarget*		GetRenderTarget();
					/// <summary>
					/// Binded a <see cref="IGuiGraphicsRenderTarget"/>.
					/// </summary>
					/// <param name="value">The <see cref="IGuiGraphicsRenderTarget"/> to bind.</param>
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					/// <summary>
					/// Returns a string from a specified range of the text lines.
					/// </summary>
					/// <returns>The string.</returns>
					/// <param name="start">The start position.</param>
					/// <param name="end">The end position.</param>
					WString							GetText(TextPos start, TextPos end);
					/// <summary>
					/// Returns the whole string in the text lines.
					/// </summary>
					/// <returns>The string.</returns>
					WString							GetText();
					/// <summary>
					/// Set the string to the text lines. This operation will modified every <see cref="TextLine"/> objects.
					/// </summary>
					/// <param name="value">The string to set into the text lines.</param>
					void							SetText(const WString& value);
					
					/// <summary>
					/// Remove text lines in a specified range.
					/// </summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="start">The first row number.</param>
					/// <param name="count">The number of text lines to be removed.</param>
					bool							RemoveLines(int start, int count);
					/// <summary>
					/// Test is a text position available in the text lines.
					/// </summary>
					/// <returns>Returns true if this position is available.</returns>
					/// <param name="pos">The text position to test.</param>
					bool							IsAvailable(TextPos pos);
					/// <summary>
					/// Normalize a text position to be available.
					/// </summary>
					/// <returns>The normalized text position.</returns>
					/// <param name="pos">The text position to normalize.</param>
					TextPos							Normalize(TextPos pos);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="inputs">The buffer to the string buffers to replace into the text lines.</param>
					/// <param name="inputCounts">The numbers of characters for each string buffer.</param>
					/// <param name="rows">The number of string buffers.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t** inputs, int* inputCounts, int rows);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The buffer to the string to replace into the text lines.</param>
					/// <param name="inputCount">The number of characters to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input, int inputCount);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The string to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The string to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const WString& input);
					/// <summary>
					/// Remove every text lines.
					/// </summary>
					void							Clear();
					
					/// <summary>
					/// Clear all cached <see cref="CharAtt::rightOffset"/>.
					/// </summary>
					void							ClearMeasurement();
					/// <summary>
					/// Returns the number of spaces to replace a tab character for rendering.
					/// </summary>
					/// <returns>The number of spaces to replace a tab character for rendering.</returns>
					int								GetTabSpaceCount();
					/// <summary>
					/// Set the number of spaces to replace a tab character for rendering.
					/// </summary>
					/// <param name="value">The number of spaces to replace a tab character for rendering.</param>
					void							SetTabSpaceCount(int value);
					/// <summary>
					/// Measure all characters in a specified row.
					/// </summary>
					/// <param name="row">The specified row number.</param>
					void							MeasureRow(int row);
					/// <summary>
					/// Returns the width of a specified row.
					/// </summary>
					/// <returns>The width of a specified row, in pixel.</returns>
					/// <param name="row">The specified row number.</param>
					int								GetRowWidth(int row);
					/// <summary>
					/// Returns the height of a row.
					/// </summary>
					/// <returns>The height of a row, in pixel.</returns>
					int								GetRowHeight();
					/// <summary>
					/// Returns the total width of the text lines.
					/// </summary>
					/// <returns>The width of the text lines, in pixel.</returns>
					int								GetMaxWidth();
					/// <summary>
					/// Returns the total height of the text lines.
					/// </summary>
					/// <returns>The height of the text lines, in pixel.</returns>
					int								GetMaxHeight();
					/// <summary>
					/// Get the text position near to specified point.
					/// </summary>
					/// <returns>The text position.</returns>
					/// <param name="row">The specified point, in pixel.</param>
					TextPos							GetTextPosFromPoint(Point point);
					/// <summary>
					/// Get the point of a specified text position.
					/// </summary>
					/// <returns>The point, in pixel. Returns (-1, -1) if the text position is not available.</returns>
					/// <param name="pos">The specified text position.</param>
					Point							GetPointFromTextPos(TextPos pos);
					/// <summary>
					/// Get the bounds of a specified text position.
					/// </summary>
					/// <returns>The bounds, in pixel. Returns (-1, -1, -1, -1) if the text position is not available.</returns>
					/// <param name="pos">The specified text position.</param>
					Rect							GetRectFromTextPos(TextPos pos);
				};
				
				/// <summary>
				/// Represents colors of a character.
				/// </summary>
				struct ColorItem
				{
					/// <summary>
					/// Text color.
					/// </summary>
					Color							text;
					/// <summary>
					/// Background color.
					/// </summary>
					Color							background;
				};
				
				/// <summary>
				/// Represents color entry in a color table. Use [M:vl.presentation.elements.GuiColorizedTextElement.GetColors] and [M:vl.presentation.elements.GuiColorizedTextElement.SetColors] to access the color table.
				/// </summary>
				struct ColorEntry
				{
					/// <summary>
					/// Colors in normal state.
					/// </summary>
					ColorItem						normal;
					/// <summary>
					/// Colors in focused and selected state.
					/// </summary>
					ColorItem						selectedFocused;
					/// <summary>
					/// Colors in not focused and selected state.
					/// </summary>
					ColorItem						selectedUnfocused;

					bool							operator==(const ColorEntry& value){return false;}
					bool							operator!=(const ColorEntry& value){return true;}
				};
			}
			
			/// <summary>
			/// Defines a text element with separate color configuration for each character.
			/// </summary>
			class GuiColorizedTextElement : public Object, public IGuiGraphicsElement, public Description<GuiColorizedTextElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiColorizedTextElement, L"ColorizedText");

				typedef collections::Array<text::ColorEntry>			ColorArray;
				typedef collections::IReadonlyList<text::ColorEntry>	IColorArray;
			public:
				/// <summary>
				/// An callback interface. Member functions will be called when colors or fonts of a <see cref="GuiColorizedTextElement"/> changed.
				/// </summary>
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					/// <summary>
					/// Called when the color table of a <see cref="GuiColorizedTextElement"/> changed.
					/// </summary>
					virtual void					ColorChanged()=0;
					/// <summary>
					/// Called when the font configuration of a <see cref="GuiColorizedTextElement"/> changed.
					/// </summary>
					virtual void					FontChanged()=0;
				};
			protected:
				ICallback*							callback;
				ColorArray							colors;
				FontProperties						font;
				Point								viewPosition;
				bool								isVisuallyEnabled;
				bool								isFocused;

				TextPos								caretBegin;
				TextPos								caretEnd;
				bool								caretVisible;
				Color								caretColor;

				text::TextLines						lines;

				GuiColorizedTextElement();
			public:
				~GuiColorizedTextElement();

				/// <summary>
				/// Get the internal <see cref="text::TextLines"/> object that stores all characters and colors.
				/// </summary>
				/// <returns>The internal <see cref="text::TextLines"/> object.</returns>
				text::TextLines&					GetLines();
				/// <summary>
				/// Get the binded callback object.
				/// </summary>
				/// <returns>The binded callback object.</returns>
				ICallback*							GetCallback();
				/// <summary>
				/// Bind a callback object.
				/// </summary>
				/// <param name="value">The callback object to bind.</param>
				void								SetCallback(ICallback* value);
				
				/// <summary>
				/// Get the binded color table. Use <see cref="text::CharAtt::colorIndex"/> to use colors in this color table.
				/// </summary>
				/// <returns>The binded color table.</returns>
				const IColorArray&					GetColors();
				/// <summary>
				/// Bind a color table. Use <see cref="text::CharAtt::colorIndex"/> to use colors in this color table. <see cref="ICallback::ColorChanged"/> will be called.
				/// </summary>
				/// <param name="value">The color table to bind.</param>
				void								SetColors(const ColorArray& value);
				/// <summary>
				/// Get the font configuration for all characters.
				/// </summary>
				/// <returns>The font configuration.</returns>
				const FontProperties&				GetFont();
				/// <summary>
				/// Set the font configuration for all characters. <see cref="ICallback::FontChanged"/> will be called.
				/// </summary>
				/// <param name="value">The font configuration.</param>
				void								SetFont(const FontProperties& value);
				/// <summary>
				/// Get the left-top position of the visible bounds of characters.
				/// </summary>
				/// <returns>The left-top position of the visible bounds of characters.</returns>
				Point								GetViewPosition();
				/// <summary>
				/// Set the left-top position of the visible bounds of characters.
				/// </summary>
				/// <param name="value">The left-top position of the visible bounds of characters.</param>
				void								SetViewPosition(Point value);
				/// <summary>
				/// Get the enabling state.
				/// </summary>
				/// <returns>Returns true if the element will be rendered as an enabled element.</returns>
				bool								GetVisuallyEnabled();
				/// <summary>
				/// Set the enabling state.
				/// </summary>
				/// <param name="value">True if the element will be rendered as an enabled element.</param>
				void								SetVisuallyEnabled(bool value);
				/// <summary>
				/// Get the focused state.
				/// </summary>
				/// <returns>Returns true if the element will be rendered as a focused element.</returns>
				bool								GetFocused();
				/// <summary>
				/// Set the focused state.
				/// </summary>
				/// <param name="value">True if the element will be rendered as a focused element.</param>
				void								SetFocused(bool value);
				
				/// <summary>
				/// Get the begin position of the selection area.
				/// </summary>
				/// <returns>The begin position of the selection area.</returns>
				TextPos								GetCaretBegin();
				/// <summary>
				/// Set the begin position of the selection area.
				/// </summary>
				/// <param name="value">The begin position of the selection area.</param>
				void								SetCaretBegin(TextPos value);
				/// <summary>
				/// Get the end position of the selection area.
				/// </summary>
				/// <returns>The end position of the selection area.</returns>
				TextPos								GetCaretEnd();
				/// <summary>
				/// Set the end position of the selection area.
				/// </summary>
				/// <param name="value">The end position of the selection area.</param>
				void								SetCaretEnd(TextPos value);
				/// <summary>
				/// Get the caret visibility.
				/// </summary>
				/// <returns>Returns true if characters in the selection range will be rendered using <see cref="text::ColorEntry::selectedFocused"/> or <see cref="text::ColorEntry::selectedUnfocused"/>.</returns>
				bool								GetCaretVisible();
				/// <summary>
				/// Set the caret visibility.
				/// </summary>
				/// <param name="value">True if characters in the selection range will be rendered using <see cref="text::ColorEntry::selectedFocused"/> or <see cref="text::ColorEntry::selectedUnfocused"/>.</param>
				void								SetCaretVisible(bool value);
				/// <summary>
				/// Get the color of the caret.
				/// </summary>
				/// <returns>The color of the caret.</returns>
				Color								GetCaretColor();
				/// <summary>
				/// Set the color of the caret.
				/// </summary>
				/// <param name="value">The color of the caret.</param>
				void								SetCaretColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSEVENTRECEIVER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Event Model

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiGraphicsComposition;

/***********************************************************************
Event
***********************************************************************/

			template<typename T>
			class GuiGraphicsEvent : public Object, public Description<GuiGraphicsEvent<T>>
			{
			public:
				typedef void(RawFunctionType)(GuiGraphicsComposition*, T&);
				typedef Func<RawFunctionType>						FunctionType;

				class IHandler : public virtual IDescriptable, public Description<IHandler>
				{
				public:
					virtual void			Execute(GuiGraphicsComposition* sender, T& argument)=0;
				};
				
				class FunctionHandler : public Object, public IHandler
				{
				protected:
					FunctionType		handler;
				public:
					FunctionHandler(const FunctionType& _handler)
						:handler(_handler)
					{
					}

					void Execute(GuiGraphicsComposition* sender, T& argument)override
					{
						handler(sender, argument);
					}
				};
			protected:
				struct HandlerNode
				{
					Ptr<IHandler>					handler;
					Ptr<HandlerNode>				next;
				};

				GuiGraphicsComposition*				sender;
				Ptr<HandlerNode>					handlers;
			public:
				GuiGraphicsEvent(GuiGraphicsComposition* _sender=0)
					:sender(_sender)
				{
				}

				~GuiGraphicsEvent()
				{
				}

				GuiGraphicsComposition* GetAssociatedComposition()
				{
					return sender;
				}

				void SetAssociatedComposition(GuiGraphicsComposition* _sender)
				{
					sender=_sender;
				}

				bool Attach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							return false;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					(*currentHandler)=new HandlerNode;
					(*currentHandler)->handler=handler;
					return true;
				}

				template<typename TClass, typename TMethod>
				Ptr<IHandler> AttachMethod(TClass* receiver, TMethod TClass::* method)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(receiver, method));
					Attach(handler);
					return handler;
				}

				Ptr<IHandler> AttachFunction(RawFunctionType* function)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(function));
					Attach(handler);
					return handler;
				}

				template<typename T>
				Ptr<IHandler> AttachLambda(const T& lambda)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(lambda));
					Attach(handler);
					return handler;
				}

				bool Detach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							Ptr<HandlerNode> next=(*currentHandler)->next;
							(*currentHandler)=next;
							return true;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					return false;
				}

				void Execute(T& argument)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						(*currentHandler)->handler->Execute(sender, argument);
						currentHandler=&(*currentHandler)->next;
					}
				}
			};

/***********************************************************************
Predefined Events
***********************************************************************/

			/// <summary>Notify event arguments.</summary>
			struct GuiEventArgs
			{
				/// <summary>The event raiser composition.</summary>
				GuiGraphicsComposition*		compositionSource;
				/// <summary>The nearest parent of the event raiser composition that contains an event receiver. If the event raiser composition contains an event receiver, it will be the event raiser composition.</summary>
				GuiGraphicsComposition*		eventSource;
				/// <summary>Set this field to true will stop the event routing. This is a signal that the event is properly handeled, and the event handler want to override the default behavior.</summary>
				bool						handled;

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiEventArgs()
					:compositionSource(0)
					,eventSource(0)
					,handled(false)
				{
				}

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiEventArgs(GuiGraphicsComposition* composition)
					:compositionSource(composition)
					,eventSource(composition)
					,handled(false)
				{
				}
			};
			
			/// <summary>Request event arguments.</summary>
			struct GuiRequestEventArgs : public GuiEventArgs
			{
				/// <summary>Set this field to false in event handlers will stop the corresponding action.</summary>
				bool		cancel;
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiRequestEventArgs()
					:cancel(false)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiRequestEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,cancel(false)
				{
				}
			};
			
			/// <summary>Keyboard event arguments.</summary>
			struct GuiKeyEventArgs : public GuiEventArgs, public NativeWindowKeyInfo
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiKeyEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiKeyEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			/// <summary>Char input event arguments.</summary>
			struct GuiCharEventArgs : public GuiEventArgs, public NativeWindowCharInfo
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiCharEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiCharEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			/// <summary>Mouse event arguments.</summary>
			struct GuiMouseEventArgs : public GuiEventArgs, public NativeWindowMouseInfo
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiMouseEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiEventArgs>				GuiNotifyEvent;
			typedef GuiGraphicsEvent<GuiRequestEventArgs>		GuiRequestEvent;
			typedef GuiGraphicsEvent<GuiKeyEventArgs>			GuiKeyEvent;
			typedef GuiGraphicsEvent<GuiCharEventArgs>			GuiCharEvent;
			typedef GuiGraphicsEvent<GuiMouseEventArgs>			GuiMouseEvent;

/***********************************************************************
Event Receiver
***********************************************************************/

			/// <summary>
			/// Contains all available user input events for a <see cref="GuiGraphicsComposition"/>. Almost all events are routed events. Routed events means, not only the activated composition receives the event, all it direct or indirect parents receives the event. The argument(all derives from <see cref="GuiEventArgs"/>) for the event will store the original event raiser composition.
			/// </summary>
			class GuiGraphicsEventReceiver : public Object
			{
			protected:
				GuiGraphicsComposition*			sender;
			public:
				GuiGraphicsEventReceiver(GuiGraphicsComposition* _sender);
				~GuiGraphicsEventReceiver();

				GuiGraphicsComposition*			GetAssociatedComposition();

				/// <summary>Left mouse button down event.</summary>
				GuiMouseEvent					leftButtonDown;
				/// <summary>Left mouse button up event.</summary>
				GuiMouseEvent					leftButtonUp;
				/// <summary>Left mouse button double click event.</summary>
				GuiMouseEvent					leftButtonDoubleClick;
				/// <summary>Middle mouse button down event.</summary>
				GuiMouseEvent					middleButtonDown;
				/// <summary>Middle mouse button up event.</summary>
				GuiMouseEvent					middleButtonUp;
				/// <summary>Middle mouse button double click event.</summary>
				GuiMouseEvent					middleButtonDoubleClick;
				/// <summary>Right mouse button down event.</summary>
				GuiMouseEvent					rightButtonDown;
				/// <summary>Right mouse button up event.</summary>
				GuiMouseEvent					rightButtonUp;
				/// <summary>Right mouse button double click event.</summary>
				GuiMouseEvent					rightButtonDoubleClick;
				/// <summary>Horizontal wheel scrolling event.</summary>
				GuiMouseEvent					horizontalWheel;
				/// <summary>Vertical wheel scrolling event.</summary>
				GuiMouseEvent					verticalWheel;
				/// <summary>Mouse move event.</summary>
				GuiMouseEvent					mouseMove;
				/// <summary>Mouse enter event.</summary>
				GuiNotifyEvent					mouseEnter;
				/// <summary>Mouse leave event.</summary>
				GuiNotifyEvent					mouseLeave;
				
				/// <summary>Preview key event.</summary>
				GuiKeyEvent						previewKey;
				/// <summary>Key down event.</summary>
				GuiKeyEvent						keyDown;
				/// <summary>Key up event.</summary>
				GuiKeyEvent						keyUp;
				/// <summary>System key down event.</summary>
				GuiKeyEvent						systemKeyDown;
				/// <summary>System key up event.</summary>
				GuiKeyEvent						systemKeyUp;
				/// <summary>Preview char input event.</summary>
				GuiCharEvent					previewCharInput;
				/// <summary>Char input event.</summary>
				GuiCharEvent					charInput;
				/// <summary>Got focus event.</summary>
				GuiNotifyEvent					gotFocus;
				/// <summary>Lost focus event.</summary>
				GuiNotifyEvent					lostFocus;
				/// <summary>Caret notify event. This event is raised when a caret graph need to change the visibility state.</summary>
				GuiNotifyEvent					caretNotify;
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{
			class GuiGraphicsHost;

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// Represents a composition for <see cref="elements::IGuiGraphicsElement"/>. A composition is a way to define the size and the position using the information from graphics elements and sub compositions.
			/// When a graphics composition is destroyed, all sub composition will be destroyed. The life cycle of the contained graphics element is partially controlled by the smart pointer to the graphics element inside the composition.
			/// </summary>
			class GuiGraphicsComposition : public Object, public Description<GuiGraphicsComposition>
			{
				typedef collections::IReadonlyList<GuiGraphicsComposition*> ICompositionList;
				typedef collections::List<GuiGraphicsComposition*> CompositionList;

				friend class controls::GuiControl;
				friend class GuiGraphicsHost;
			public:
				/// <summary>
				/// Minimum size limitation.
				/// </summary>
				enum MinSizeLimitation
				{
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.MinSizeLimitation]No limitation for the minimum size.</summary>
					NoLimit,
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.MinSizeLimitation]Minimum size of this composition is the minimum size of the contained graphics element.</summary>
					LimitToElement,
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.MinSizeLimitation]Minimum size of this composition is combiniation of sub compositions and the minimum size of the contained graphics element.</summary>
					LimitToElementAndChildren,
				};
				
				/// <summary>
				/// Relation between the composition size and the parent composition.
				/// </summary>
				enum ParentSizeAffection
				{
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.ParentSizeAffection]The size doesn't aware of the parent composition.</summary>
					NotAffectedByParent,
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.ParentSizeAffection]The size partially limited by the parent composition.</summary>
					AffectedByParent,
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.ParentSizeAffection]The size is decided by the parent composition.</summary>
					TotallyDecidedByParent,
				};
			protected:
				CompositionList								children;
				GuiGraphicsComposition*						parent;
				Ptr<elements::IGuiGraphicsElement>			ownedElement;
				bool										visible;
				elements::IGuiGraphicsRenderTarget*			renderTarget;
				MinSizeLimitation							minSizeLimitation;

				Ptr<compositions::GuiGraphicsEventReceiver>	eventReceiver;
				controls::GuiControl*						associatedControl;
				GuiGraphicsHost*							associatedHost;
				INativeCursor*								associatedCursor;

				Margin										margin;
				Margin										internalMargin;
				Size										preferredMinSize;

				virtual void								OnControlParentChanged(controls::GuiControl* control);
				virtual void								OnChildInserted(GuiGraphicsComposition* child);
				virtual void								OnChildRemoved(GuiGraphicsComposition* child);
				virtual void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent);
				virtual void								OnRenderTargetChanged();
				
				virtual void								SetAssociatedControl(controls::GuiControl* control);
				virtual void								SetAssociatedHost(GuiGraphicsHost* host);
			public:
				GuiGraphicsComposition();
				~GuiGraphicsComposition();

				/// <summary>Get the parent composition.</summary>
				/// <returns>The parent composition.</returns>
				GuiGraphicsComposition*						GetParent();
				/// <summary>Get all child compositions ordered by z-order from low to high.</summary>
				/// <returns>Child compositions.</returns>
				const ICompositionList&						Children();
				/// <summary>Add a composition as a child.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to add.</param>
				bool										AddChild(GuiGraphicsComposition* child);
				/// <summary>Add a composition as a child with a specified z-order.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The z-order. 0 means the lowest position.</param>
				/// <param name="child">The child composition to add.</param>
				bool										InsertChild(int index, GuiGraphicsComposition* child);
				/// <summary>Remove a child composition.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to remove.</param>
				bool										RemoveChild(GuiGraphicsComposition* child);
				/// <summary>Move a child composition to a new z-order.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to move.</param>
				/// <param name="newIndex">The new z-order. 0 means the lowest position.</param>
				bool										MoveChild(GuiGraphicsComposition* child, int newIndex);

				/// <summary>Get the contained graphics element.</summary>
				/// <returns>The contained graphics element.</returns>
				Ptr<elements::IGuiGraphicsElement>			GetOwnedElement();
				/// <summary>Set the contained graphics element.</summary>
				/// <param name="element">The new graphics element to set.</param>
				void										SetOwnedElement(Ptr<elements::IGuiGraphicsElement> element);
				/// <summary>Get the visibility of the composition.</summary>
				/// <returns>Returns true if the composition is visible.</returns>
				bool										GetVisible();
				/// <summary>Set the visibility of the composition.</summary>
				/// <param name="value">Set to true to make the composition visible.</param>
				void										SetVisible(bool value);
				/// <summary>Get the minimum size limitation of the composition.</summary>
				/// <returns>The minimum size limitation of the composition.</returns>
				MinSizeLimitation							GetMinSizeLimitation();
				/// <summary>Set the minimum size limitation of the composition.</summary>
				/// <param name="value">The minimum size limitation of the composition.</param>
				void										SetMinSizeLimitation(MinSizeLimitation value);
				/// <summary>Get the binded render target.</summary>
				/// <returns>The binded render target.</returns>
				elements::IGuiGraphicsRenderTarget*			GetRenderTarget();
				/// <summary>Set the binded render target. This function is designed for internal usage. Users are not suggested to call this function directly.</summary>
				/// <param name="value">The binded render target.</param>
				void										SetRenderTarget(elements::IGuiGraphicsRenderTarget* value);

				/// <summary>Render the composition using an offset.</summary>
				/// <param name="offset">The offset.</param>
				void										Render(Size offset);
				/// <summary>Get the event receiver object. All user input events can be found in this object. If an event receiver is never been requested from the composition, the event receiver will not be created, and all route events will not pass through this event receiver(performance will be better).</summary>
				/// <returns>The event receiver.</returns>
				compositions::GuiGraphicsEventReceiver*		GetEventReceiver();
				/// <summary>Test if any event receiver has already been requested.</summary>
				/// <returns>Returns true if any event receiver has already been requested.</returns>
				bool										HasEventReceiver();
				/// <summary>Find a deepest composition that under a specified location. If the location is inside a compsition but not hit any sub composition, this function will return this composition.</summary>
				/// <returns>The deepest composition that under a specified location.</returns>
				/// <param name="location">The specified location.</param>
				GuiGraphicsComposition*						FindComposition(Point location);
				/// <summary>Get the bounds in the top composition space.</summary>
				/// <returns>The bounds in the top composition space.</returns>
				Rect										GetGlobalBounds();

				/// <summary>Get the associated control. A control is associated to a composition only when the composition represents the bounds of this control. Such a composition usually comes from a control template.</summary>
				/// <returns>The associated control.</returns>
				controls::GuiControl*						GetAssociatedControl();
				/// <summary>Get the associated graphics host. A graphics host is associated to a composition only when the composition becomes the bounds of the graphics host.</summary>
				/// <returns>The associated graphics host.</returns>
				GuiGraphicsHost*							GetAssociatedHost();
				/// <summary>Get the associated cursor.</summary>
				/// <returns>The associated cursor.</returns>
				INativeCursor*								GetAssociatedCursor();
				/// <summary>Set the associated cursor.</summary>
				/// <param name="cursor">The associated cursor.</param>
				void										SetAssociatedCursor(INativeCursor* cursor);
				
				/// <summary>Get the related control. A related control is the deepest control that contains this composition.</summary>
				/// <returns>The related control.</returns>
				controls::GuiControl*						GetRelatedControl();
				/// <summary>Get the related graphics host. A related graphics host is the graphics host that contains this composition.</summary>
				/// <returns>The related graphics host.</returns>
				GuiGraphicsHost*							GetRelatedGraphicsHost();
				/// <summary>Get the related control host. A related control host is the control host that contains this composition.</summary>
				/// <returns>The related control host.</returns>
				controls::GuiControlHost*					GetRelatedControlHost();
				/// <summary>Get the related cursor. A related cursor is from the deepest composition that contains this composition and associated with a cursor.</summary>
				/// <returns>The related cursor.</returns>
				INativeCursor*								GetRelatedCursor();
				
				/// <summary>Get the margin.</summary>
				/// <returns>The margin.</returns>
				virtual Margin								GetMargin();
				/// <summary>Set the margin.</summary>
				/// <param name="value">The margin.</param>
				virtual void								SetMargin(Margin value);
				/// <summary>Get the internal margin.</summary>
				/// <returns>The internal margin.</returns>
				virtual Margin								GetInternalMargin();
				/// <summary>Set the internal margin.</summary>
				/// <param name="value">The internal margin.</param>
				virtual void								SetInternalMargin(Margin value);
				/// <summary>Get the preferred minimum size.</summary>
				/// <returns>The preferred minimum size.</returns>
				virtual Size								GetPreferredMinSize();
				/// <summary>Set the preferred minimum size.</summary>
				/// <param name="value">The preferred minimum size.</param>
				virtual void								SetPreferredMinSize(Size value);
				/// <summary>Get the client area.</summary>
				/// <returns>The client area.</returns>
				virtual Rect								GetClientArea();
				
				/// <summary>Get the parent size affection.</summary>
				/// <returns>The parent size affection.</returns>
				virtual ParentSizeAffection					GetAffectionFromParent()=0;
				/// <summary>Test is the size calculation affected by the parent.</summary>
				/// <returns>Returns true if the size calculation is affected by the parent.</returns>
				virtual bool								IsSizeAffectParent()=0;
				/// <summary>Get the preferred minimum client size.</summary>
				/// <returns>The preferred minimum client size.</returns>
				virtual Size								GetMinPreferredClientSize()=0;
				/// <summary>Get the preferred bounds.</summary>
				/// <returns>The preferred bounds.</returns>
				virtual Rect								GetPreferredBounds()=0;
				/// <summary>Get the bounds.</summary>
				/// <returns>The bounds.</returns>
				virtual Rect								GetBounds()=0;
			};

			/// <summary>
			/// A general implementation for <see cref="GuiGraphicsComposition"/>.
			/// </summary>
			class GuiGraphicsSite : public GuiGraphicsComposition, public Description<GuiGraphicsSite>
			{
			protected:

				/// <summary>Calculate the final bounds from an expected bounds.</summary>
				/// <returns>The final bounds according to some configuration like margin, minimum size, etc..</returns>
				/// <param name="expectedBounds">The expected bounds.</param>
				virtual Rect						GetBoundsInternal(Rect expectedBounds);
			public:
				GuiGraphicsSite();
				~GuiGraphicsSite();
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetPreferredBounds()override;
			};

/***********************************************************************
Basic Compositions
***********************************************************************/
			
			/// <summary>
			/// Represents a composition for the client area in an <see cref="INativeWindow"/>.
			/// </summary>
			class GuiWindowComposition : public GuiGraphicsSite, public Description<GuiWindowComposition>
			{
			protected:
				INativeWindow*						attachedWindow;
			public:
				GuiWindowComposition();
				~GuiWindowComposition();
				
				/// <summary>Get the attached native window object.</summary>
				/// <returns>The attached native window object.</returns>
				INativeWindow*						GetAttachedWindow();
				/// <summary>Attached a native window object.</summary>
				/// <param name="window">The native window object to attach.</param>
				void								SetAttachedWindow(INativeWindow* window);

				Rect								GetBounds()override;
				void								SetMargin(Margin value)override;
			};

			/// <summary>
			/// Represents a composition that is free to change the expected bounds.
			/// </summary>
			class GuiBoundsComposition : public GuiGraphicsSite, public Description<GuiBoundsComposition>
			{
			protected:
				Rect								compositionBounds;
				Rect								previousBounds;
				Margin								alignmentToParent;
				
			public:
				GuiBoundsComposition();
				~GuiBoundsComposition();

				/// <summary>Event that will be raised when the final bounds is changed.</summary>
				compositions::GuiNotifyEvent		BoundsChanged;
				
				ParentSizeAffection					GetAffectionFromParent()override;
				Rect								GetPreferredBounds()override;
				Rect								GetBounds()override;
				/// <summary>Set the expected bounds.</summary>
				/// <param name="value">The expected bounds.</param>
				void								SetBounds(Rect value);

				/// <summary>Make the composition not aligned to it's parent.</summary>
				void								ClearAlignmentToParent();
				/// <summary>Get the alignment to it's parent. -1 in each alignment component means that the corressponding side is not aligned to it's parent.</summary>
				/// <returns>The alignment to it's parent.</returns>
				Margin								GetAlignmentToParent();
				/// <summary>Set the alignment to it's parent. -1 in each alignment component means that the corressponding side is not aligned to it's parent.</summary>
				/// <param name="value">The alignment to it's parent.</param>
				void								SetAlignmentToParent(Margin value);
				/// <summary>Test is the composition aligned to it's parent.</summary>
				/// <returns>Returns true if the composition is aligned to it's parent.</returns>
				bool								IsAlignedToParent();
			};

/***********************************************************************
Table Compositions
***********************************************************************/

			class GuiTableComposition;
			class GuiCellComposition;

			/// <summary>
			/// Represnets a sizing configuration for a row or a column.
			/// </summary>
			struct GuiCellOption
			{
				/// <summary>Sizing algorithm</summary>
				enum ComposeType
				{
					/// <summary>[T:vl.presentation.compositions.GuiCellOption.ComposeType]Set the size to an absolute value.</summary>
					Absolute,
					/// <summary>[T:vl.presentation.compositions.GuiCellOption.ComposeType]Set the size to a percentage number of the whole table.</summary>
					Percentage,
					/// <summary>[T:vl.presentation.compositions.GuiCellOption.ComposeType]Set the size to the minimum size of the cell element.</summary>
					MinSize,
				};

				/// <summary>Sizing algorithm</summary>
				ComposeType		composeType;
				/// <summary>The absolute size when <see cref="GuiCellOption::composeType"/> is <see cref="ComposeType"/>::Absolute.</summary>
				int				absolute;
				/// <summary>The percentage number when <see cref="GuiCellOption::composeType"/> is <see cref="ComposeType"/>::Percentage.</summary>
				double			percentage;

				GuiCellOption()
					:composeType(Absolute)
					,absolute(20)
					,percentage(0)
				{
				}

				bool operator==(const GuiCellOption& value){return false;}
				bool operator!=(const GuiCellOption& value){return true;}

				/// <summary>Creates an absolute sizing option</summary>
				/// <returns>The created option.</returns>
				/// <param name="value">The absolute size.</param>
				static GuiCellOption AbsoluteOption(int value)
				{
					GuiCellOption option;
					option.composeType=Absolute;
					option.absolute=value;
					return option;
				}
				
				/// <summary>Creates an percantage sizing option</summary>
				/// <returns>The created option.</returns>
				/// <param name="value">The percentage number.</param>
				static GuiCellOption PercentageOption(double value)
				{
					GuiCellOption option;
					option.composeType=Percentage;
					option.percentage=value;
					return option;
				}
				
				/// <summary>Creates an minimum sizing option</summary>
				/// <returns>The created option.</returns>
				static GuiCellOption MinSizeOption()
				{
					GuiCellOption option;
					option.composeType=MinSize;
					return option;
				}
			};

			/// <summary>
			/// Represents a table composition.
			/// </summary>
			class GuiTableComposition : public GuiBoundsComposition, public Description<GuiTableComposition>
			{
				friend class GuiCellComposition;
			protected:
				int											rows;
				int											columns;
				int											cellPadding;
				int											rowExtending;
				int											columnExtending;
				collections::Array<GuiCellOption>			rowOptions;
				collections::Array<GuiCellOption>			columnOptions;
				collections::Array<GuiCellComposition*>		cellCompositions;
				collections::Array<Rect>					cellBounds;
				Rect										previousBounds;
				Size										previousContentMinSize;
				Size										tableContentMinSize;

				int									GetSiteIndex(int _rows, int _columns, int _row, int _column);
				void								SetSitedCell(int _row, int _column, GuiCellComposition* cell);

				void								UpdateCellBoundsInternal(
														collections::Array<int>& dimSizes,
														int& dimSize, 
														collections::Array<GuiCellOption>& dimOptions,
														int GuiTableComposition::* dim1,
														int GuiTableComposition::* dim2,
														int (*getSize)(Size),
														int (*getLocation)(GuiCellComposition*),
														int (*getSpan)(GuiCellComposition*),
														int (*getRow)(int, int),
														int (*getCol)(int, int),
														int maxPass
														);
				void								UpdateCellBoundsPercentages(
														collections::Array<int>& dimSizes,
														int dimSize,
														int maxDimSize,
														collections::Array<GuiCellOption>& dimOptions
														);
				int									UpdateCellBoundsOffsets(
														collections::Array<int>& offsets,
														collections::Array<int>& sizes,
														int start,
														int max
														);
				
				void								UpdateCellBoundsInternal();
				void								UpdateTableContentMinSize();
				void								OnRenderTargetChanged()override;
			public:
				GuiTableComposition();
				~GuiTableComposition();

				/// <summary>Get the number of rows.</summary>
				/// <returns>The number of rows.</returns>
				int									GetRows();
				/// <summary>Get the number of columns.</summary>
				/// <returns>The number of columns.</returns>
				int									GetColumns();
				/// <summary>Change the number of rows and columns.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="_rows">The number of rows.</param>
				/// <param name="_columns">The number of columns.</param>
				bool								SetRowsAndColumns(int _rows, int _columns);
				/// <summary>Get the cell composition that covers the specified cell location.</summary>
				/// <returns>The cell composition that covers the specified cell location.</returns>
				/// <param name="_rows">The number of rows.</param>
				/// <param name="_columns">The number of columns.</param>
				GuiCellComposition*					GetSitedCell(int _row, int _column);

				/// <summary>Get the sizing option of the specified row.</summary>
				/// <returns>The sizing option of the specified row.</returns>
				/// <param name="_rows">The specified row number.</param>
				GuiCellOption						GetRowOption(int _row);
				/// <summary>Set the sizing option of the specified row.</summary>
				/// <param name="_rows">The specified row number.</param>
				/// <param name="option">The sizing option of the specified row.</param>
				void								SetRowOption(int _row, GuiCellOption option);
				/// <summary>Get the sizing option of the specified column.</summary>
				/// <returns>The sizing option of the specified column.</returns>
				/// <param name="_column">The specified column number.</param>
				GuiCellOption						GetColumnOption(int _column);
				/// <summary>Set the sizing option of the specified column.</summary>
				/// <param name="_column">The specified column number.</param>
				/// <param name="option">The sizing option of the specified column.</param>
				void								SetColumnOption(int _column, GuiCellOption option);

				/// <summary>Get the cell padding. A cell padding is the distance between a table client area and a cell, or between two cells.</summary>
				/// <returns>The cell padding.</returns>
				int									GetCellPadding();
				/// <summary>Set the cell padding. A cell padding is the distance between a table client area and a cell, or between two cells.</summary>
				/// <param name="_column">The cell padding.</param>
				void								SetCellPadding(int value);
				/// <summary>Get the cell area in the space of the table's parent composition's client area.</summary>
				/// <returns>The cell area.</returns>
				Rect								GetCellArea();
				/// <summary>Update the sizing of the table and cells after all rows' and columns' sizing options are prepared.</summary>
				void								UpdateCellBounds();
				
				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
			};

			/// <summary>
			/// Represents a cell composition of a <see cref="GuiTableComposition"/>.
			/// </summary>
			class GuiCellComposition : public GuiGraphicsSite, public Description<GuiCellComposition>
			{
				friend class GuiTableComposition;
			protected:
				int									row;
				int									rowSpan;
				int									column;
				int									columnSpan;
				GuiTableComposition*				tableParent;
				
				void								ClearSitedCells(GuiTableComposition* table);
				void								SetSitedCells(GuiTableComposition* table);
				void								ResetSiteInternal();
				bool								SetSiteInternal(int _row, int _column, int _rowSpan, int _columnSpan);
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnTableRowsAndColumnsChanged();
			public:
				GuiCellComposition();
				~GuiCellComposition();

				/// <summary>Get the owner table composition.</summary>
				/// <returns>The owner table composition.</returns>
				GuiTableComposition*				GetTableParent();

				/// <summary>Get the row number for this cell composition.</summary>
				/// <returns>The row number for this cell composition.</returns>
				int									GetRow();
				/// <summary>Get the total numbers of acrossed rows for this cell composition.</summary>
				/// <returns>The total numbers of acrossed rows for this cell composition.</returns>
				int									GetRowSpan();
				/// <summary>Get the column number for this cell composition.</summary>
				/// <returns>The column number for this cell composition.</returns>
				int									GetColumn();
				/// <summary>Get the total numbers of acrossed columns for this cell composition.</summary>
				/// <returns>The total numbers of acrossed columns for this cell composition.</returns>
				int									GetColumnSpan();
				/// <summary>Set the position for this cell composition in the table.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="_row">The row number for this cell composition.</param>
				/// <param name="_column">The column number for this cell composition.</param>
				/// <param name="_rowSpan">The total numbers of acrossed rows for this cell composition.</param>
				/// <param name="_columnSpan">The total numbers of acrossed columns for this cell composition.</param>
				bool								SetSite(int _row, int _column, int _rowSpan, int _columnSpan);

				Rect								GetBounds()override;
			};

/***********************************************************************
Stack Compositions
***********************************************************************/

			class GuiStackComposition;
			class GuiStackItemComposition;

			/// <summary>
			/// Represents a stack composition.
			/// </summary>
			class GuiStackComposition : public GuiBoundsComposition, public Description<GuiStackComposition>
			{
				friend class GuiStackItemComposition;

				typedef collections::List<GuiStackItemComposition*>				ItemCompositionList;
				typedef collections::IReadonlyList<GuiStackItemComposition*>	IItemCompositionList;
			public:
				/// <summary>Stack item layout direction.</summary>
				enum Direction
				{
					/// <summary>[T:vl.presentation.compositions.GuiStackComposition.Direction]Stack items is layouted horizontally.</summary>
					Horizontal,
					/// <summary>[T:vl.presentation.compositions.GuiStackComposition.Direction]Stack items is layouted vertically.</summary>
					Vertical,
				};
			protected:
				Direction							direction;
				ItemCompositionList					stackItems;
				collections::Array<Rect>			stackItemBounds;
				Size								stackItemTotalSize;
				int									padding;
				Rect								previousBounds;
				Margin								extraMargin;

				void								UpdateStackItemBounds();
				void								FixStackItemSizes();
				void								OnChildInserted(GuiGraphicsComposition* child)override;
				void								OnChildRemoved(GuiGraphicsComposition* child)override;
			public:
				GuiStackComposition();
				~GuiStackComposition();

				/// <summary>Get all stack items inside the stack composition.</summary>
				/// <returns>All stack items inside the stack composition.</returns>
				const IItemCompositionList&			GetStackItems();
				/// <summary>Insert an stack item at a specified position.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The position.</param>
				/// <param name="item">The statck item to insert.</param>
				bool								InsertStackItem(int index, GuiStackItemComposition* item);
				
				/// <summary>Get the stack item layout direction.</summary>
				/// <returns>The stack item layout direction.</returns>
				Direction							GetDirection();
				/// <summary>Set the stack item layout direction.</summary>
				/// <param name="value">The stack item layout direction.</param>
				void								SetDirection(Direction value);
				/// <summary>Get the stack item padding.</summary>
				/// <returns>The stack item padding.</returns>
				int									GetPadding();
				/// <summary>Set the stack item padding.</summary>
				/// <param name="value">The stack item padding.</param>
				void								SetPadding(int value);

				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
				
				/// <summary>Get the extra margin inside the stack composition.</summary>
				/// <returns>The extra margin inside the stack composition.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin inside the stack composition.</summary>
				/// <param name="value">The extra margin inside the stack composition.</param>
				void								SetExtraMargin(Margin value);
			};
			
			/// <summary>
			/// Represents a stack item composition of a <see cref="GuiStackComposition"/>.
			/// </summary>
			class GuiStackItemComposition : public GuiGraphicsSite, public Description<GuiStackItemComposition>
			{
				friend class GuiStackComposition;
			protected:
				GuiStackComposition*				stackParent;
				Rect								bounds;
				Margin								extraMargin;

				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				Size								GetMinSize();
			public:
				GuiStackItemComposition();
				~GuiStackItemComposition();
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
				/// <summary>Set the expected bounds of a stack item. In most of the cases only the size of the bounds is used.</summary>
				/// <param name="value">The expected bounds of a stack item.</param>
				void								SetBounds(Rect value);
				
				/// <summary>Get the extra margin for this stack item. An extra margin is used to enlarge the bounds of the stack item, but only the non-extra part will be used for decide the stack item layout.</summary>
				/// <returns>The extra margin for this stack item.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin for this stack item. An extra margin is used to enlarge the bounds of the stack item, but only the non-extra part will be used for decide the stack item layout.</summary>
				/// <param name="value">The extra margin for this stack item.</param>
				void								SetExtraMargin(Margin value);
			};

/***********************************************************************
Specialized Compositions
***********************************************************************/

			/// <summary>
			/// Represents a composition that is aligned to one border of the parent composition.
			/// </summary>
			class GuiSideAlignedComposition : public GuiGraphicsSite, public Description<GuiSideAlignedComposition>
			{
			public:
				/// <summary>The border to align.</summary>
				enum Direction
				{
					/// <summary>[T:vl.presentation.compositions.GuiSideAlignedComposition.Direction]The left border.</summary>
					Left,
					/// <summary>[T:vl.presentation.compositions.GuiSideAlignedComposition.Direction]The top border.</summary>
					Top,
					/// <summary>[T:vl.presentation.compositions.GuiSideAlignedComposition.Direction]The right border.</summary>
					Right,
					/// <summary>[T:vl.presentation.compositions.GuiSideAlignedComposition.Direction]The bottom border.</summary>
					Bottom,
				};
			protected:
				Direction							direction;
				int									maxLength;
				double								maxRatio;
			public:
				GuiSideAlignedComposition();
				~GuiSideAlignedComposition();
				
				/// <summary>Get the border to align.</summary>
				/// <returns>The border to align.</returns>
				Direction							GetDirection();
				/// <summary>Set the border to align.</summary>
				/// <param name="value">The border to align.</param>
				void								SetDirection(Direction value);
				/// <summary>Get the maximum length of this composition.</summary>
				/// <returns>The maximum length of this composition.</returns>
				int									GetMaxLength();
				/// <summary>Set the maximum length of this composition.</summary>
				/// <param name="value">The maximum length of this composition.</param>
				void								SetMaxLength(int value);
				/// <summary>Get the maximum ratio to limit the size according to the size of the parent.</summary>
				/// <returns>The maximum ratio to limit the size according to the size of the parent.</returns>
				double								GetMaxRatio();
				/// <summary>Set the maximum ratio to limit the size according to the size of the parent.</summary>
				/// <param name="value">The maximum ratio to limit the size according to the size of the parent.</param>
				void								SetMaxRatio(double value);
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};

			/// <summary>
			/// Represents a composition that it's location and size are decided by the client area of the parent composition by setting ratios.
			/// </summary>
			class GuiPartialViewComposition : public GuiGraphicsSite, public Description<GuiPartialViewComposition>
			{
			protected:
				double								wRatio;
				double								wPageSize;
				double								hRatio;
				double								hPageSize;

			public:
				GuiPartialViewComposition();
				~GuiPartialViewComposition();
				
				/// <summary>Get the width ratio to decided the horizontal location. Value in [0, 1-pageSize].</summary>
				/// <returns>The width ratio to decided the horizontal location.</returns>
				double								GetWidthRatio();
				/// <summary>Get the page size to decide the horizontal size. Value in [0, 1].</summary>
				/// <returns>The page size to decide the horizontal size.</returns>
				double								GetWidthPageSize();
				/// <summary>Get the height ratio to decided the vertical location. Value in [0, 1-pageSize].</summary>
				/// <returns>The height ratio to decided the vertical location.</returns>
				double								GetHeightRatio();
				/// <summary>Get the page size to decide the vertical size. Value in [0, 1].</summary>
				/// <returns>The page size to decide the vertical size.</returns>
				double								GetHeightPageSize();
				/// <summary>Set the width ratio to decided the horizontal location. Value in [0, 1-pageSize].</summary>
				/// <param name="value">The width ratio to decided the horizontal location.</param>
				void								SetWidthRatio(double value);
				/// <summary>Set the page size to decide the horizontal size. Value in [0, 1].</summary>
				/// <param name="value">The page size to decide the horizontal size.</param>
				void								SetWidthPageSize(double value);
				/// <summary>Set the height ratio to decided the vertical location. Value in [0, 1-pageSize].</summary>
				/// <param name="value">The height ratio to decided the vertical location.</param>
				void								SetHeightRatio(double value);
				/// <summary>Set the page size to decide the vertical size. Value in [0, 1].</summary>
				/// <param name="value">The page size to decide the vertical size.</param>
				void								SetHeightPageSize(double value);
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSHOST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Animation
***********************************************************************/

			/// <summary>
			/// Represents an animation. Use [M:vl.presentation.compositions.GuiGraphicsHost.GetAnimationManager] to access this object.
			/// </summary>
			class IGuiGraphicsAnimation : public virtual IDescriptable, public Description<IGuiGraphicsAnimation>
			{
			public:
				/// <summary>Get the total length.</summary>
				/// <returns>The total length.</returns>
				virtual int						GetTotalLength()=0;
				/// <summary>Get the current position. Value in [0, TotalLength-1]. This function doesn't return a internal state. It return the suggested current position at the moment this function is called.</summary>
				/// <returns>The current position.</returns>
				virtual int						GetCurrentPosition()=0;
				/// <summary>Display a state in the animation with the specified current position and the specified total length.</summary>
				/// <param name="currentPosition">The current position. When this function is called by [T:vl.presentation.compositions.GuiGraphicsAnimationManager], this value comes from <see cref="IGuiGraphicsAnimation::GetCurrentPosition"/>.</param>
				/// <param name="totalLength">The total length. When this function is called by [T:vl.presentation.compositions.GuiGraphicsAnimationManager], this value comes from <see cref="IGuiGraphicsAnimation::GetTotalLength"/>.</param>
				virtual void					Play(int currentPosition, int totalLength)=0;
				/// <summary>Stop the animation.</summary>
				virtual void					Stop()=0;
			};

			/// <summary>
			/// Animation manager.
			/// </summary>
			class GuiGraphicsAnimationManager : public Object
			{
				typedef collections::List<Ptr<IGuiGraphicsAnimation>>		AnimationList;
			protected:
				AnimationList					playingAnimations;
			public:
				GuiGraphicsAnimationManager();
				~GuiGraphicsAnimationManager();

				/// <summary>Add a new animation.</summary>
				/// <param name="animation">The new animation to add.</param>
				void							AddAnimation(Ptr<IGuiGraphicsAnimation> animation);
				/// <summary>Test is the animation manager contains any alive animation.</summary>
				/// <returns>Returns true if the animation manager contains any alive animation.</returns>
				bool							HasAnimation();
				/// <summary>Play all alive animations. Any animation that comes to the end will be removed.</summary>
				void							Play();
			};

/***********************************************************************
Host
***********************************************************************/

			/// <summary>
			/// GuiGraphicsHost hosts an <see cref="GuiWindowComposition"/> in an <see cref="INativeWindow"/>. The composition will fill the whole window.
			/// </summary>
			class GuiGraphicsHost : public Object, private INativeWindowListener, private INativeControllerListener, public Description<GuiGraphicsHost>
			{
				typedef collections::List<GuiGraphicsComposition*>		CompositionList;
			public:
				static const unsigned __int64	CaretInterval=500;
			protected:
				INativeWindow*					nativeWindow;
				GuiWindowComposition*			windowComposition;
				GuiGraphicsComposition*			focusedComposition;
				Size							previousClientSize;
				Size							minSize;
				Point							caretPoint;
				unsigned __int64				lastCaretTime;

				GuiGraphicsAnimationManager		animationManager;
				GuiGraphicsComposition*			mouseCaptureComposition;
				CompositionList					mouseEnterCompositions;

				void							MouseCapture(const NativeWindowMouseInfo& info);
				void							MouseUncapture(const NativeWindowMouseInfo& info);
				void							OnCharInput(const NativeWindowCharInfo& info, GuiGraphicsComposition* composition, GuiCharEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							OnKeyInput(const NativeWindowKeyInfo& info, GuiGraphicsComposition* composition, GuiKeyEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							RaiseMouseEvent(GuiMouseEventArgs& arguments, GuiGraphicsComposition* composition, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							OnMouseInput(const NativeWindowMouseInfo& info, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				
			private:
				void							Moving(Rect& bounds, bool fixSizeOnly)override;
				void							Moved()override;

				void							LeftButtonDown(const NativeWindowMouseInfo& info)override;
				void							LeftButtonUp(const NativeWindowMouseInfo& info)override;
				void							LeftButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							RightButtonDown(const NativeWindowMouseInfo& info)override;
				void							RightButtonUp(const NativeWindowMouseInfo& info)override;
				void							RightButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonDown(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonUp(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							HorizontalWheel(const NativeWindowMouseInfo& info)override;
				void							VerticalWheel(const NativeWindowMouseInfo& info)override;
				void							MouseMoving(const NativeWindowMouseInfo& info)override;
				void							MouseEntered()override;
				void							MouseLeaved()override;

				void							KeyDown(const NativeWindowKeyInfo& info)override;
				void							KeyUp(const NativeWindowKeyInfo& info)override;
				void							SysKeyDown(const NativeWindowKeyInfo& info)override;
				void							SysKeyUp(const NativeWindowKeyInfo& info)override;
				void							Char(const NativeWindowCharInfo& info)override;

				void							GlobalTimer()override;
			public:
				GuiGraphicsHost();
				~GuiGraphicsHost();

				/// <summary>Get the associated window.</summary>
				/// <returns>The associated window.</returns>
				INativeWindow*					GetNativeWindow();
				/// <summary>Associate a window. A <see cref="GuiWindowComposition"/> will fill and appear in the window.</summary>
				/// <param name="_nativeWindow">The window to associated.</param>
				void							SetNativeWindow(INativeWindow* _nativeWindow);
				/// <summary>Get the main <see cref="GuiWindowComposition"/>. If a window is associated, everything that put into the main composition will be shown in the window.</summary>
				/// <returns>The main compositoin.</returns>
				GuiGraphicsComposition*			GetMainComposition();
				/// <summary>Render the main composition and all content to the associated window.</summary>
				void							Render();

				/// <summary>Set the focus composition. A focused composition will receive keyboard messages.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="composition">The composition to set focus. This composition should be or in the main composition.</param>
				bool							SetFocus(GuiGraphicsComposition* composition);
				/// <summary>Get the focus composition. A focused composition will receive keyboard messages.</summary>
				/// <returns>The focus composition.</returns>
				GuiGraphicsComposition*			GetFocusedComposition();
				/// <summary>Get the caret point. A caret point is the position to place the edit box of the activated input method editor.</summary>
				/// <returns>The caret point.</returns>
				Point							GetCaretPoint();
				/// <summary>Set the caret point. A caret point is the position to place the edit box of the activated input method editor.</summary>
				/// <param name="value">The caret point.</param>
				/// <param name="referenceComposition">The point space. If this argument is null, the "value" argument will use the point space of the client area in the main composition.</param>
				void							SetCaretPoint(Point value, GuiGraphicsComposition* referenceComposition=0);

				/// <summary>Get the animation manager.</summary>
				/// <returns>The animation manager.</returns>
				GuiGraphicsAnimationManager*	GetAnimationManager();
			};

/***********************************************************************
Helpers
***********************************************************************/
			
			/// <summary>
			/// Represents a time based animation.
			/// </summary>
			class GuiTimeBasedAnimation : public IGuiGraphicsAnimation, public Description<GuiTimeBasedAnimation>
			{
			protected:
				unsigned __int64				startTime;
				int								length;
			public:
				/// <summary>Create an animation with a specified length in milliseconds.</summary>
				/// <param name="totalMilliseconds">The specified length in milliseconds.</param>
				GuiTimeBasedAnimation(int totalMilliseconds);
				~GuiTimeBasedAnimation();

				/// <summary>Restart an animation with a specified length in milliseconds.</summary>
				/// <param name="totalMilliseconds">The specified length in milliseconds. If the value is -1, it will use the previous length.</param>
				void							Restart(int totalMilliseconds=-1);
				int								GetTotalLength()override;
				int								GetCurrentPosition()override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\GUIBASICCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// The base class of all controls.
			/// When the control is destroyed, it automatically destroys sub controls, and the bounds composition from the style controller.
			/// If you want to manually destroy a control, you should first remove it from it's parent.
			/// The only way to remove a control from a parent control, is to remove the bounds composition from it's parent composition. The same to inserting a control.
			/// </summary>
			class GuiControl : public Object, public Description<GuiControl>
			{
				friend class compositions::GuiGraphicsComposition;
				typedef collections::List<GuiControl*>		ControlList;
			public:
				/// <summary>
				/// Represents a style for a control. A style is something like a skin, but contains some default action handlers.
				/// </summary>
				class IStyleController : public virtual IDescriptable, public Description<IStyleController>
				{
				public:
					/// <summary>Get the bounds composition. A bounds composition represents all visible contents of a control.</summary>
					/// <returns>The bounds composition.</returns>
					virtual compositions::GuiBoundsComposition*		GetBoundsComposition()=0;
					/// <summary>Get the container composition. A container composition is where to place all bounds compositions for child controls.</summary>
					/// <returns>The container composition.</returns>
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					/// <summary>Set the focusable composition. A focusable composition is the composition to be focused when the control is focused.</summary>
					/// <param name="value">The focusable composition.</param>
					virtual void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					/// <summary>Set the text to display on the control.</summary>
					/// <param name="value">The text to display.</param>
					virtual void									SetText(const WString& value)=0;
					/// <summary>Set the font to render the text.</summary>
					/// <param name="value">The font to render the text.</param>
					virtual void									SetFont(const FontProperties& value)=0;
					/// <summary>Set the enableing state to affect the rendering of the control.</summary>
					/// <param name="value">The enableing state.</param>
					virtual void									SetVisuallyEnabled(bool value)=0;
				};

				/// <summary>
				/// A style provider is a callback interface for some control that already provides a style controller, but the controller need callbacks to create sub compositions or handle actions.
				/// </summary>
				class IStyleProvider : public virtual IDescriptable, public Description<IStyleProvider>
				{
				public:
					/// <summary>Called when a style provider is associated with a style controller.</summary>
					/// <param name="controller">The style controller that is associated.</param>
					virtual void								AssociateStyleController(IStyleController* controller)=0;
					/// <summary>Set the focusable composition. A focusable composition is the composition to be focused when the control is focused.</summary>
					/// <param name="value">The focusable composition.</param>
					virtual void								SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					/// <summary>Set the text to display on the control.</summary>
					/// <param name="value">The text to display.</param>
					virtual void								SetText(const WString& value)=0;
					/// <summary>Set the font to render the text.</summary>
					/// <param name="value">The font to render the text.</param>
					virtual void								SetFont(const FontProperties& value)=0;
					/// <summary>Set the enableing state to affect the rendering of the control.</summary>
					/// <param name="value">The enableing state.</param>
					virtual void								SetVisuallyEnabled(bool value)=0;
				};
			protected:
				Ptr<IStyleController>							styleController;
				compositions::GuiBoundsComposition*				boundsComposition;
				compositions::GuiGraphicsComposition*			focusableComposition;
				compositions::GuiGraphicsEventReceiver*			eventReceiver;

				bool									isEnabled;
				bool									isVisuallyEnabled;
				bool									isVisible;
				WString									text;
				FontProperties							font;

				GuiControl*								parent;
				ControlList								children;

				virtual void							OnChildInserted(GuiControl* control);
				virtual void							OnChildRemoved(GuiControl* control);
				virtual void							OnParentChanged(GuiControl* oldParent, GuiControl* newParent);
				virtual void							OnParentLineChanged();
				virtual void							OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget);
				virtual void							OnBeforeReleaseGraphicsHost();
				virtual void							UpdateVisuallyEnabled();
				void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);
			public:
				/// <summary>Create a control with a specified style controller.</summary>
				/// <param name="_styleController">The style controller.</param>
				GuiControl(IStyleController* _styleController);
				~GuiControl();

				/// <summary>Visible event. This event will be raised when the visibility state of the control is changed.</summary>
				compositions::GuiNotifyEvent			VisibleChanged;
				/// <summary>Enabled event. This event will be raised when the enabling state of the control is changed.</summary>
				compositions::GuiNotifyEvent			EnabledChanged;
				/// <summary>
				/// Enabled event. This event will be raised when the visually enabling state of the control is changed. A visually enabling is combined by the enabling state and the parent's visually enabling state.
				/// A control is rendered as disabled, not only when the control itself is disabled, but also when the parent control is rendered as disabled.
				/// </summary>
				compositions::GuiNotifyEvent			VisuallyEnabledChanged;
				/// <summary>Text changed event. This event will be raised when the text of the control is changed.</summary>
				compositions::GuiNotifyEvent			TextChanged;
				/// <summary>Font changed event. This event will be raised when the font of the control is changed.</summary>
				compositions::GuiNotifyEvent			FontChanged;

				/// <summary>A function to create the argument for notify events that raised by itself.</summary>
				/// <returns>The created argument.</returns>
				compositions::GuiEventArgs				GetNotifyEventArguments();
				/// <summary>Get the associated style controller.</summary>
				/// <returns>The associated style controller.</returns>
				IStyleController*						GetStyleController();
				/// <summary>Get the bounds composition for the control. The value is from <see cref="IStyleController::GetBoundsComposition"/>.</summary>
				/// <returns>The bounds composition.</returns>
				compositions::GuiBoundsComposition*		GetBoundsComposition();
				/// <summary>Get the container composition for the control. The value is from <see cref="IStyleController::GetContainerComposition"/>.</summary>
				/// <returns>The container composition.</returns>
				compositions::GuiGraphicsComposition*	GetContainerComposition();
				/// <summary>Get the focusable composition for the control. A focusable composition is the composition to be focused when the control is focused.</summary>
				/// <returns>The focusable composition.</returns>
				compositions::GuiGraphicsComposition*	GetFocusableComposition();
				/// <summary>Get the event receiver from the bounds composition.</summary>
				/// <returns>The event receiver.</returns>
				compositions::GuiGraphicsEventReceiver*	GetEventReceiver();
				/// <summary>Get the parent control.</summary>
				/// <returns>The parent control.</returns>
				GuiControl*								GetParent();
				/// <summary>Get the number of child controls.</summary>
				/// <returns>The number of child controls.</returns>
				int										GetChildrenCount();
				/// <summary>Get the child control using a specified index.</summary>
				/// <returns>The child control.</returns>
				/// <param name="index">The specified index.</param>
				GuiControl*								GetChild(int index);
				
				/// <summary>Get the <see cref="GuiControlHost"/> that contains this control.</summary>
				/// <returns>The <see cref="GuiControlHost"/> that contains this control.</returns>
				virtual GuiControlHost*					GetRelatedControlHost();
				/// <summary>Test if this control is rendered as enabled.</summary>
				/// <returns>Returns true if this control is rendered as enabled.</returns>
				virtual bool							GetVisuallyEnabled();
				/// <summary>Test if this control is enabled.</summary>
				/// <returns>Returns true if this control is enabled.</returns>
				virtual bool							GetEnabled();
				/// <summary>Make the control enabled or disabled.</summary>
				/// <param name="value">Set to true to make the control enabled.</param>
				virtual void							SetEnabled(bool value);
				/// <summary>Test if this visible or invisible.</summary>
				/// <returns>Returns true if this control is visible.</returns>
				virtual bool							GetVisible();
				/// <summary>Make the control visible or invisible.</summary>
				/// <param name="value">Set to true to make the visible enabled.</param>
				virtual void							SetVisible(bool value);
				/// <summary>Get the text to display on the control.</summary>
				/// <returns>The text to display on the control.</returns>
				virtual const WString&					GetText();
				/// <summary>Set the text to display on the control.</summary>
				/// <param name="value">The text to display on the control.</param>
				virtual void							SetText(const WString& value);
				/// <summary>Get the font to render the text.</summary>
				/// <returns>The font to render the text.</returns>
				virtual const FontProperties&			GetFont();
				/// <summary>Set the font to render the text.</summary>
				/// <param name="value">The font to render the text.</param>
				virtual void							SetFont(const FontProperties& value);

				/// <summary>Query a service using an identifier. If you want to get a service of type IXXX, use IXXX::Identifier as the identifier.</summary>
				/// <returns>The requested service. If the control doesn't support this service, it will be null.</returns>
				virtual IDescriptable*					QueryService(const WString& identifier);

				template<typename T>
				T* QueryService()
				{
					return dynamic_cast<T*>(QueryService(T::Identifier));
				}
			};

			/// <summary>
			/// Represnets a component.
			/// </summary>
			class GuiComponent : public Object, public Description<GuiComponent>
			{
			public:
				GuiComponent();
				~GuiComponent();
			};
			
			/// <summary>
			/// Represnets an image to display.
			/// </summary>
			class GuiImageData
			{
			protected:
				Ptr<INativeImage>				image;
				int								frameIndex;

			public:
				/// <summary>Create an empty image data.</summary>
				GuiImageData();
				/// <summary>Create an image data with a specified image and a frame index.</summary>
				/// <param name="_image">The specified image.</param>
				/// <param name="_frameIndex">The specified frame index.</param>
				GuiImageData(Ptr<INativeImage> _image, int _frameIndex);
				~GuiImageData();

				/// <summary>Get the specified image.</summary>
				/// <returns>The specified image.</returns>
				Ptr<INativeImage>				GetImage();
				/// <summary>Get the specified frame index.</summary>
				/// <returns>The specified frame index.</returns>
				int								GetFrameIndex();
			};

/***********************************************************************
Buttons
***********************************************************************/

			/// <summary>A control with 3 phases state transffering when mouse click happens.</summary>
			class GuiButton : public GuiControl, public Description<GuiButton>
			{
			public:
				/// <summary>The visual state.</summary>
				enum ControlState
				{
					/// <summary>[T:vl.presentation.controls.GuiButton.ControlState]Normal state.</summary>
					Normal,
					/// <summary>[T:vl.presentation.controls.GuiButton.ControlState]Active state.</summary>
					Active,
					/// <summary>[T:vl.presentation.controls.GuiButton.ControlState]Pressed state.</summary>
					Pressed,
				};

				/// <summary>Style controller interface for <see cref="GuiButton"/>.</summary>
				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					/// <summary>Called when the control state changed.</summary>
					/// <param name="value">The new control state.</param>
					virtual void						Transfer(ControlState value)=0;
				};
			protected:
				IStyleController*						styleController;
				bool									mousePressing;
				bool									mouseHoving;
				ControlState							controlState;
				
				void									OnParentLineChanged()override;
				void									UpdateControlState();
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style controller.</summary>
				/// <param name="_styleController">The style controller.</param>
				GuiButton(IStyleController* _styleController);
				~GuiButton();

				/// <summary>Mouse click event.</summary>
				compositions::GuiNotifyEvent			Clicked;
			};

			/// <summary>A <see cref="GuiButton"/> with a selection state.</summary>
			class GuiSelectableButton : public GuiButton, public Description<GuiSelectableButton>
			{
			public:
				/// <summary>Style controller interface for <see cref="GuiSelectableButton"/>.</summary>
				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					/// <summary>Called when the selection state changed.</summary>
					/// <param name="value">The new control state.</param>
					virtual void						SetSelected(bool value)=0;
				};

				/// <summary>Selection group controller. Control the selection state of all attached button.</summary>
				class GroupController : public GuiComponent, public Description<GroupController>
				{
				protected:
					collections::List<GuiSelectableButton*>	buttons;
				public:
					GroupController();
					~GroupController();

					/// <summary>Called when the group controller is attached to a <see cref="GuiSelectableButton"/>. use [M:vl.presentation.controls.GuiSelectableButton.SetGroupController] to attach or detach a group controller to or from a selectable button.</summary>
					virtual void						Attach(GuiSelectableButton* button);
					/// <summary>Called when the group controller is deteched to a <see cref="GuiSelectableButton"/>. use [M:vl.presentation.controls.GuiSelectableButton.SetGroupController] to attach or detach a group controller to or from a selectable button.</summary>
					virtual void						Detach(GuiSelectableButton* button);
					/// <summary>Called when the selection state of any <see cref="GuiSelectableButton"/> changed.</summary>
					virtual void						OnSelectedChanged(GuiSelectableButton* button)=0;
				};

				/// <summary>A mutex group controller, usually for radio buttons.</summary>
				class MutexGroupController : public GroupController, public Description<MutexGroupController>
				{
				protected:
					bool								suppress;
				public:
					MutexGroupController();
					~MutexGroupController();

					void								OnSelectedChanged(GuiSelectableButton* button)override;
				};

			protected:
				IStyleController*						styleController;
				GroupController*						groupController;
				bool									autoSelection;
				bool									isSelected;

				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style controller.</summary>
				/// <param name="_styleController">The style controller.</param>
				GuiSelectableButton(IStyleController* _styleController);
				~GuiSelectableButton();

				/// <summary>Group controller changed event.</summary>
				compositions::GuiNotifyEvent			GroupControllerChanged;
				/// <summary>Auto selection changed event.</summary>
				compositions::GuiNotifyEvent			AutoSelectionChanged;
				/// <summary>Selected changed event.</summary>
				compositions::GuiNotifyEvent			SelectedChanged;

				/// <summary>Get the attached group controller.</summary>
				/// <returns>The attached group controller.</returns>
				virtual GroupController*				GetGroupController();
				/// <summary>Set the attached group controller.</summary>
				/// <param name="value">The attached group controller.</param>
				virtual void							SetGroupController(GroupController* value);
				
				/// <summary>Get the auto selection state. True if the button is automatically selected or unselected when the button is clicked.</summary>
				/// <returns>The auto selection state.</returns>
				virtual bool							GetAutoSelection();
				/// <summary>Set the auto selection state. True if the button is automatically selected or unselected when the button is clicked.</summary>
				/// <param name="value">The auto selection state.</param>
				virtual void							SetAutoSelection(bool value);
				
				/// <summary>Get the selected state.</summary>
				/// <returns>The selected state.</returns>
				virtual bool							GetSelected();
				/// <summary>Set the selected state.</summary>
				/// <param name="value">The selected state.</param>
				virtual void							SetSelected(bool value);
			};

/***********************************************************************
Scrolls
***********************************************************************/

			/// <summary>A scroll control, which represents a one dimension sub range of a whole range.</summary>
			class GuiScroll : public GuiControl, public Description<GuiScroll>
			{
			public:
				/// <summary>A command executor for the style controller to change the control state.</summary>
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					/// <summary>Do small decrement.</summary>
					virtual void						SmallDecrease()=0;
					/// <summary>Do small increment.</summary>
					virtual void						SmallIncrease()=0;
					/// <summary>Do big decrement.</summary>
					virtual void						BigDecrease()=0;
					/// <summary>Do big increment.</summary>
					virtual void						BigIncrease()=0;

					/// <summary>Change to total size of the scroll.</summary>
					/// <param name="value">The total size.</param>
					virtual void						SetTotalSize(int value)=0;
					/// <summary>Change to page size of the scroll.</summary>
					/// <param name="value">The page size.</param>
					virtual void						SetPageSize(int value)=0;
					/// <summary>Change to position of the scroll.</summary>
					/// <param name="value">The position.</param>
					virtual void						SetPosition(int value)=0;
				};
				
				/// <summary>Style controller interface for <see cref="GuiScroll"/>.</summary>
				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					/// <summary>Called when the command executor is changed.</summary>
					/// <param name="value">The command executor.</param>
					virtual void						SetCommandExecutor(ICommandExecutor* value)=0;
					/// <summary>Called when the total size is changed.</summary>
					/// <param name="value">The total size.</param>
					virtual void						SetTotalSize(int value)=0;
					/// <summary>Called when the page size is changed.</summary>
					/// <param name="value">The page size.</param>
					virtual void						SetPageSize(int value)=0;
					/// <summary>Called when the position is changed.</summary>
					/// <param name="value">The position.</param>
					virtual void						SetPosition(int value)=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiScroll*							scroll;
				public:
					CommandExecutor(GuiScroll* _scroll);
					~CommandExecutor();

					void								SmallDecrease()override;
					void								SmallIncrease()override;
					void								BigDecrease()override;
					void								BigIncrease()override;

					void								SetTotalSize(int value)override;
					void								SetPageSize(int value)override;
					void								SetPosition(int value)override;
				};

				IStyleController*						styleController;
				Ptr<CommandExecutor>					commandExecutor;
				int										totalSize;
				int										pageSize;
				int										position;
				int										smallMove;
				int										bigMove;
			public:
				/// <summary>Create a control with a specified style controller.</summary>
				/// <param name="_styleController">The style controller.</param>
				GuiScroll(IStyleController* _styleController);
				~GuiScroll();
				
				/// <summary>Total size changed event.</summary>
				compositions::GuiNotifyEvent			TotalSizeChanged;
				/// <summary>Page size changed event.</summary>
				compositions::GuiNotifyEvent			PageSizeChanged;
				/// <summary>Position changed event.</summary>
				compositions::GuiNotifyEvent			PositionChanged;
				/// <summary>Small move changed event.</summary>
				compositions::GuiNotifyEvent			SmallMoveChanged;
				/// <summary>Big move changed event.</summary>
				compositions::GuiNotifyEvent			BigMoveChanged;
				
				/// <summary>Get the total size.</summary>
				/// <returns>The total size.</returns>
				virtual int								GetTotalSize();
				/// <summary>Set the total size.</summary>
				/// <param name="value">The total size.</param>
				virtual void							SetTotalSize(int value);
				/// <summary>Get the page size.</summary>
				/// <returns>The page size.</returns>
				virtual int								GetPageSize();
				/// <summary>Set the page size.</summary>
				/// <param name="value">The page size.</param>
				virtual void							SetPageSize(int value);
				/// <summary>Get the position.</summary>
				/// <returns>The position.</returns>
				virtual int								GetPosition();
				/// <summary>Set the position.</summary>
				/// <param name="value">The position.</param>
				virtual void							SetPosition(int value);
				/// <summary>Get the small move.</summary>
				/// <returns>The small move.</returns>
				virtual int								GetSmallMove();
				/// <summary>Set the small move.</summary>
				/// <param name="value">The small move.</param>
				virtual void							SetSmallMove(int value);
				/// <summary>Get the big move.</summary>
				/// <returns>The big move.</returns>
				virtual int								GetBigMove();
				/// <summary>Set the big move.</summary>
				/// <param name="value">The big move.</param>
				virtual void							SetBigMove(int value);
				
				/// <summary>Get the minimum possible position.</summary>
				/// <returns>The minimum possible position.</returns>
				int										GetMinPosition();
				/// <summary>Get the maximum possible position.</summary>
				/// <returns>The maximum possible position.</returns>
				int										GetMaxPosition();
			};

			/// <summary>A control with a vertical scroll bar and a horizontal scroll bar to perform partial viewing.</summary>
			class GuiScrollView : public GuiControl, public Description<GuiScrollView>
			{
			public:
				/// <summary>Style provider interface for <see cref="GuiScrollView"/>.</summary>
				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					/// <summary>Create a control style for the horizontal scroll bar.</summary>
					/// <returns>The created control style for the horizontal scroll bar.</returns>
					virtual GuiScroll::IStyleController*			CreateHorizontalScrollStyle()=0;
					/// <summary>Create a control style for the vertical scroll bar.</summary>
					/// <returns>The created control style for the vertical scroll bar.</returns>
					virtual GuiScroll::IStyleController*			CreateVerticalScrollStyle()=0;
					/// <summary>Get the default scroll size for scroll bars, width for vertical, height for horizontal.</summary>
					/// <returns>The default scroll size.</returns>
					virtual int										GetDefaultScrollSize()=0;
					/// <summary>Called when the control begins to initialize. The control pass the bounds composition, and the style provider can put background compositions and elements on it, and return a container composition to contain content and scroll bars.</summary>
					/// <returns>A container composition to contain content and scroll bars</returns>
					/// <param name="boundsComposition">The bounds composition to install background.</param>
					virtual compositions::GuiGraphicsComposition*	InstallBackground(compositions::GuiBoundsComposition* boundsComposition)=0;
				};
				
				/// <summary>Style controller for <see cref="GuiScrollView"/>.</summary>
				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>						styleProvider;
					GuiScrollView*							scrollView;
					GuiScroll*								horizontalScroll;
					GuiScroll*								verticalScroll;
					compositions::GuiBoundsComposition*		boundsComposition;
					compositions::GuiTableComposition*		tableComposition;
					compositions::GuiCellComposition*		containerCellComposition;
					compositions::GuiBoundsComposition*		containerComposition;
					bool									horizontalAlwaysVisible;
					bool									verticalAlwaysVisible;

					void									UpdateTable();
				public:
					/// <summary>Create a style controller with a specified style provider.</summary>
					/// <param name="_styleProvider">The style provider.</param>
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					/// <summary>Called when the style controller is attched to a <see cref="GuiScrollView"/>.</summary>
					/// <param name="_scrollView">The scroll view control that attached to.</param>
					void									SetScrollView(GuiScrollView* _scrollView);
					/// <summary>Called when the view size of the scroll view changed. Scroll bars will be adjusted.</summary>
					/// <param name="fullSize">The view size.</param>
					void									AdjustView(Size fullSize);
					/// <summary>Get the attached style provider.</summary>
					/// <returns>The attached style provider.</returns>
					IStyleProvider*							GetStyleProvider();

					/// <summary>Get the horizontal scroll control.</summary>
					/// <returns>The horizontal scroll control.</returns>
					GuiScroll*								GetHorizontalScroll();
					/// <summary>Get the vertical scroll control.</summary>
					/// <returns>The vertical scroll control.</returns>
					GuiScroll*								GetVerticalScroll();
					compositions::GuiTableComposition*		GetInternalTableComposition();
					compositions::GuiBoundsComposition*		GetInternalContainerComposition();

					/// <summary>Test is the horizontal scroll bar always visible even the content doesn't exceed the view bounds.</summary>
					/// <returns>Returns true if the horizontal scroll bar always visible even the content doesn't exceed the view bounds</returns>
					bool									GetHorizontalAlwaysVisible();
					/// <summary>Set is the horizontal scroll bar always visible even the content doesn't exceed the view bounds.</summary>
					/// <param name="value">Set to true if the horizontal scroll bar always visible even the content doesn't exceed the view bounds</param>
					void									SetHorizontalAlwaysVisible(bool value);
					/// <summary>Test is the vertical scroll bar always visible even the content doesn't exceed the view bounds.</summary>
					/// <returns>Returns true if the vertical scroll bar always visible even the content doesn't exceed the view bounds</returns>
					bool									GetVerticalAlwaysVisible();
					/// <summary>Set is the vertical scroll bar always visible even the content doesn't exceed the view bounds.</summary>
					/// <param name="value">Set to true if the vertical scroll bar always visible even the content doesn't exceed the view bounds</param>
					void									SetVerticalAlwaysVisible(bool value);

					compositions::GuiBoundsComposition*		GetBoundsComposition()override;
					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};
			protected:

				StyleController*						styleController;
				bool									supressScrolling;

				void									OnContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnVerticalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									CallUpdateView();
				void									Initialize();

				/// <summary>Calculate the full size of the content.</summary>
				/// <returns>The full size of the content.</returns>
				virtual Size							QueryFullSize()=0;
				/// <summary>Update the visible content using a view bounds. The view bounds is in the space from (0,0) to full size.</summary>
				/// <param name="viewBounds">The view bounds.</param>
				virtual void							UpdateView(Rect viewBounds)=0;
				
				/// <summary>Create a control with a specified style controller.</summary>
				/// <param name="_styleController">The style controller.</param>
				GuiScrollView(StyleController* _styleController);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="styleProvider">The style provider.</param>
				GuiScrollView(IStyleProvider* styleProvider);
				~GuiScrollView();

				/// <summary>Force to update contents and scroll bars.</summary>
				void									CalculateView();
				/// <summary>Get the view size.</summary>
				/// <returns>The view size.</returns>
				Size									GetViewSize();
				/// <summary>Get the view bounds.</summary>
				/// <returns>The view bounds.</returns>
				Rect									GetViewBounds();
				
				/// <summary>Get the horizontal scroll control.</summary>
				/// <returns>The horizontal scroll control.</returns>
				GuiScroll*								GetHorizontalScroll();
				/// <summary>Get the vertical scroll control.</summary>
				/// <returns>The vertical scroll control.</returns>
				GuiScroll*								GetVerticalScroll();
				/// <summary>Test is the horizontal scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <returns>Returns true if the horizontal scroll bar always visible even the content doesn't exceed the view bounds</returns>
				bool									GetHorizontalAlwaysVisible();
				/// <summary>Set is the horizontal scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <param name="value">Set to true if the horizontal scroll bar always visible even the content doesn't exceed the view bounds</param>
				void									SetHorizontalAlwaysVisible(bool value);
				/// <summary>Test is the vertical scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <returns>Returns true if the vertical scroll bar always visible even the content doesn't exceed the view bounds</returns>
				bool									GetVerticalAlwaysVisible();
				/// <summary>Set is the vertical scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <param name="value">Set to true if the vertical scroll bar always visible even the content doesn't exceed the view bounds</param>
				void									SetVerticalAlwaysVisible(bool value);
			};
			
			/// <summary>A control container with a vertical scroll bar and a horizontal scroll bar to perform partial viewing. When controls are added, removed, moved or resized, the scroll bars will adjust automatically.</summary>
			class GuiScrollContainer : public GuiScrollView, public Description<GuiScrollContainer>
			{
			public:
				/// <summary>Style controller for <see cref="GuiScrollContainer"/>.</summary>
				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					compositions::GuiBoundsComposition*		controlContainerComposition;
				public:
					/// <summary>Create a style controller with a specified style provider.</summary>
					/// <param name="_styleProvider">The style provider.</param>
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					/// <summary>Update sub controls using a specified left-top position of the view bounds.</summary>
					/// <param name="leftTop">The specified left-top position of the view bounds.</param>
					void									MoveContainer(Point leftTop);
				};

			protected:
				StyleController*						styleController;

				void									OnControlContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				Size									QueryFullSize()override;
				void									UpdateView(Rect viewBounds)override;
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="styleProvider">The style provider.</param>
				GuiScrollContainer(GuiScrollContainer::IStyleProvider* styleProvider);
				~GuiScrollContainer();
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\GUIWINDOWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Control Host
***********************************************************************/

			/// <summary>
			/// Represents a control that host by a <see cref="INativeWindow"/>.
			/// </summary>
			class GuiControlHost : public GuiControl, private INativeWindowListener, public Description<GuiControlHost>
			{
			protected:
				compositions::GuiGraphicsHost*			host;
				collections::List<GuiComponent*>		components;

			private:
				void									Enabled()override;
				void									Disabled()override;
				void									GotFocus()override;
				void									LostFocus()override;
				void									Activated()override;
				void									Deactivated()override;
				void									Opened()override;
				void									Closing(bool& cancel)override;
				void									Closed()override;
				void									Destroying()override;
			public:
				/// <summary>Create a control with a specified style controller.</summary>
				/// <param name="_styleController">The style controller.</param>
				GuiControlHost(GuiControl::IStyleController* _styleController);
				~GuiControlHost();
				
				/// <summary>Window got focus event.</summary>
				compositions::GuiNotifyEvent			WindowGotFocus;
				/// <summary>Window lost focus event.</summary>
				compositions::GuiNotifyEvent			WindowLostFocus;
				/// <summary>Window activated event.</summary>
				compositions::GuiNotifyEvent			WindowActivated;
				/// <summary>Window deactivated event.</summary>
				compositions::GuiNotifyEvent			WindowDeactivated;
				/// <summary>Window opened event.</summary>
				compositions::GuiNotifyEvent			WindowOpened;
				/// <summary>Window closing event.</summary>
				compositions::GuiRequestEvent			WindowClosing;
				/// <summary>Window closed event.</summary>
				compositions::GuiNotifyEvent			WindowClosed;
				/// <summary>Window destroying event.</summary>
				compositions::GuiNotifyEvent			WindowDestroying;

				/// <summary>Get the internal <see cref="compositions::GuiGraphicsHost"/> object to host the window content.</summary>
				/// <returns>The internal <see cref="compositions::GuiGraphicsHost"/> object to host the window content.</returns>
				compositions::GuiGraphicsHost*			GetGraphicsHost();
				/// <summary>Get the main composition to host the window content.</summary>
				/// <returns>The main composition to host the window content.</returns>
				compositions::GuiGraphicsComposition*	GetMainComposition();
				/// <summary>Get the internal <see cref="INativeWindow"/> object to host the content.</summary>
				/// <returns>The the internal <see cref="INativeWindow"/> object to host the content.</returns>
				INativeWindow*							GetNativeWindow();
				/// <summary>Set the internal <see cref="INativeWindow"/> object to host the content.</summary>
				/// <param name="window">The the internal <see cref="INativeWindow"/> object to host the content.</param>
				void									SetNativeWindow(INativeWindow* window);
				/// <summary>Render the window content.</summary>
				void									Render();
				
				/// <summary>Test is the window enabled.</summary>
				/// <returns>Returns true if the window is enabled.</returns>
				bool									GetEnabled()override;
				/// <summary>Enable or disable the window.</summary>
				/// <param name="value">Set to true to enable the window.</param>
				void									SetEnabled(bool value)override;
				/// <summary>Test is the window focused.</summary>
				/// <returns>Returns true if the window is focused.</returns>
				bool									GetFocused();
				/// <summary>Focus the window.</summary>
				void									SetFocused();
				/// <summary>Test is the window activated.</summary>
				/// <returns>Returns true if the window is activated.</returns>
				bool									GetActivated();
				/// <summary>Activate the window.</summary>
				void									SetActivated();
				/// <summary>Test is the window icon shown in the task bar.</summary>
				/// <returns>Returns true if the window is icon shown in the task bar.</returns>
				bool									GetShowInTaskBar();
				/// <summary>Show or hide the window icon in the task bar.</summary>
				/// <param name="value">Set to true to show the window icon in the task bar.</param>
				void									SetShowInTaskBar(bool value);
				/// <summary>Test is the window allowed to be activated.</summary>
				/// <returns>Returns true if the window is allowed to be activated.</returns>
				bool									GetEnabledActivate();
				/// <summary>Allow or forbid the window to be activated.</summary>
				/// <param name="value">Set to true to allow the window to be activated.</param>
				void									SetEnabledActivate(bool value);
				
				/// <summary>
				/// Test is the maximize box visible.
				/// </summary>
				/// <returns>Returns true if the maximize box is visible.</returns>
				bool									GetMaximizedBox();
				/// <summary>
				/// Make the maximize box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the maximize box visible.</param>
				void									SetMaximizedBox(bool visible);
				/// <summary>
				/// Test is the minimize box visible.
				/// </summary>
				/// <returns>Returns true if the minimize box is visible.</returns>
				bool									GetMinimizedBox();
				/// <summary>
				/// Make the minimize box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the minimize box visible.</param>
				void									SetMinimizedBox(bool visible);
				/// <summary>
				/// Test is the border visible.
				/// </summary>
				/// <returns>Returns true if the border is visible.</returns>
				bool									GetBorder();
				/// <summary>
				/// Make the border visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the border visible.</param>
				void									SetBorder(bool visible);
				/// <summary>
				/// Test is the size box visible.
				/// </summary>
				/// <returns>Returns true if the size box is visible.</returns>
				bool									GetSizeBox();
				/// <summary>
				/// Make the size box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the size box visible.</param>
				void									SetSizeBox(bool visible);
				/// <summary>
				/// Test is the icon visible.
				/// </summary>
				/// <returns>Returns true if the icon is visible.</returns>
				bool									GetIconVisible();
				/// <summary>
				/// Make the icon visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the icon visible.</param>
				void									SetIconVisible(bool visible);
				/// <summary>
				/// Test is the title bar visible.
				/// </summary>
				/// <returns>Returns true if the title bar is visible.</returns>
				bool									GetTitleBar();
				/// <summary>
				/// Make the title bar visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the title bar visible.</param>
				void									SetTitleBar(bool visible);
				/// <summary>
				/// Test is the window always on top of the desktop.
				/// </summary>
				/// <returns>Returns true if the window is always on top of the desktop.</returns>
				bool									GetTopMost();
				/// <summary>
				/// Make the window always or never on top of the desktop.
				/// </summary>
				/// <param name="topmost">True to make the window always  on top of the desktop.</param>
				void									SetTopMost(bool topmost);

				/// <summary>Add a component.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool									AddComponent(GuiComponent* component);
				/// <summary>Remove a component.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool									RemoveComponent(GuiComponent* component);
				/// <summary>Test does the window contain the component.</summary>
				/// <returns>Returns true if the window contains the component.</returns>
				/// <param name="component">The component to test.</param>
				bool									ContainsComponent(GuiComponent* component);

				/// <summary>Get the client size of the window.</summary>
				/// <returns>The client size of the window.</returns>
				Size									GetClientSize();
				/// <summary>Set the client size of the window.</summary>
				/// <param name="value">The client size of the window.</param>
				void									SetClientSize(Size value);
				/// <summary>Get the bounds of the window in screen space.</summary>
				/// <returns>The bounds of the window.</returns>
				Rect									GetBounds();
				/// <summary>Set the bounds of the window in screen space.</summary>
				/// <param name="value">The bounds of the window.</param>
				void									SetBounds(Rect value);
				GuiControlHost*							GetRelatedControlHost()override;
				const WString&							GetText()override;
				void									SetText(const WString& value)override;

				/// <summary>Get the screen that contains the window.</summary>
				/// <returns>The screen that contains the window.</returns>
				INativeScreen*							GetRelatedScreen();
				/// <summary>
				/// Show the window.
				/// </summary>
				void									Show();
				/// <summary>
				/// Show the window without activation.
				/// </summary>
				void									ShowDeactivated();
				/// <summary>
				/// Restore the window.
				/// </summary>
				void									ShowRestored();
				/// <summary>
				/// Maximize the window.
				/// </summary>
				void									ShowMaximized();
				/// <summary>
				/// Minimize the window.
				/// </summary>
				void									ShowMinimized();
				/// <summary>
				/// Hide the window.
				/// </summary>
				void									Hide();
				/// <summary>
				/// Close the window and destroy the internal <see cref="INativeWindow"/> object.
				/// </summary>
				void									Close();
				/// <summary>Test is the window opened.</summary>
				/// <returns>Returns true if the window is opened.</returns>
				bool									GetOpening();
			};

/***********************************************************************
Window
***********************************************************************/

			/// <summary>
			/// Represents a normal window.
			/// </summary>
			class GuiWindow : public GuiControlHost, public Description<GuiWindow>
			{
				friend class GuiApplication;
			protected:
				virtual void							MouseClickedOnOtherWindow(GuiWindow* window);
			public:
				/// <summary>Create a control with a specified style controller.</summary>
				/// <param name="_styleController">The style controller.</param>
				GuiWindow(GuiControl::IStyleController* _styleController);
				~GuiWindow();
			};
			
			/// <summary>
			/// Represents a popup window. When the mouse click on other window or the desktop, the popup window will be closed automatically.
			/// </summary>
			class GuiPopup : public GuiWindow, public Description<GuiPopup>
			{
			protected:
				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
			public:
				/// <summary>Create a control with a specified style controller.</summary>
				/// <param name="_styleController">The style controller.</param>
				GuiPopup(GuiControl::IStyleController* _styleController);
				~GuiPopup();

				/// <summary>Test will the whole popup window be in the screen if the popup's left-top position is set to a specified value.</summary>
				/// <returns>Returns true if the whole popup window will be in the screen.</returns>
				/// <param name="location">The specified left-top position.</param>
				bool									IsClippedByScreen(Point location);
				/// <summary>Show the popup window with the left-top position set to a specified value. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="location">The specified left-top position.</param>
				void									ShowPopup(Point location);
				/// <summary>Show the popup window aligned with a specified control. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="preferredTopBottomSide">Set to true if the popup window is expected to be opened at the top or bottom side of that control.</param>
				void									ShowPopup(GuiControl* control, bool preferredTopBottomSide);
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\GUITEXTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Operations
***********************************************************************/

			class GuiTextBoxCommonInterface;

			class GuiTextElementOperator : public Object, public Description<GuiTextElementOperator>
			{
			public:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual TextPos							GetLeftWord(TextPos pos)=0;
					virtual TextPos							GetRightWord(TextPos pos)=0;
					virtual void							GetWord(TextPos pos, TextPos& begin, TextPos& end)=0;
					virtual int								GetPageRows()=0;
					virtual bool							BeforeModify(TextPos& start, TextPos& end, const WString& originalText, WString& inputText)=0;
					virtual void							AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
					virtual void							ScrollToView(Point point)=0;
					virtual int								GetTextMargin()=0;
				};

				class DefaultCallback : public Object, public ICallback, public Description<DefaultCallback>
				{
				protected:
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiGraphicsComposition*	textComposition;
					bool									readonly;
				public:
					DefaultCallback(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition);
					~DefaultCallback();

					TextPos									GetLeftWord(TextPos pos)override;
					TextPos									GetRightWord(TextPos pos)override;
					void									GetWord(TextPos pos, TextPos& begin, TextPos& end)override;
					int										GetPageRows()override;
					bool									BeforeModify(TextPos& start, TextPos& end, const WString& originalText, WString& inputText)override;
				};
			protected:
				elements::GuiColorizedTextElement*			textElement;
				compositions::GuiGraphicsComposition*		textComposition;
				GuiControl*									textControl;
				GuiTextBoxCommonInterface*					textBoxCommonInterface;
				ICallback*									callback;
				bool										dragging;

				void										UpdateCaretPoint();
				void										Move(TextPos pos, bool shift);
				void										Modify(TextPos start, TextPos end, const WString& input);
				void										ProcessKey(int code, bool shift, bool ctrl);
					
				void										OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void										OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void										OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);
			public:
				GuiTextElementOperator();
				~GuiTextElementOperator();

				void										Install(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition, GuiControl* _textControl);
				ICallback*									GetCallback();
				void										SetCallback(ICallback* value);
				GuiTextBoxCommonInterface*					GetTextBoxCommonInterface();
				void										SetTextBoxCommonInterface(GuiTextBoxCommonInterface* value);

				elements::GuiColorizedTextElement*			GetTextElement();
				compositions::GuiGraphicsComposition*		GetTextComposition();
				TextPos										GetNearestTextPos(Point point);
				void										Select(TextPos begin, TextPos end);
				WString										GetSelectionText();
				void										SetSelectionText(const WString& value);

				bool										CanCut();
				bool										CanCopy();
				bool										CanPaste();
				void										SelectAll();
				bool										Cut();
				bool										Copy();
				bool										Paste();
			};

			class GuiTextBoxCommonInterface : public Description<GuiTextBoxCommonInterface>
			{
				friend class GuiTextElementOperator;
			protected:
				GuiTextElementOperator*						textElementOperator;
				GuiControl*									textControl;

				void										RaiseTextChanged();
				void										RaiseSelectionChanged();
				void										InitializeCommonInterface(GuiControl* _textControl, GuiTextElementOperator* _textElementOperator);
			public:
				GuiTextBoxCommonInterface();
				~GuiTextBoxCommonInterface();

				compositions::GuiNotifyEvent				SelectionChanged;

				compositions::GuiGraphicsComposition*		GetTextComposition();

				bool										CanCut();
				bool										CanCopy();
				bool										CanPaste();
				void										SelectAll();
				bool										Cut();
				bool										Copy();
				bool										Paste();
				
				WString										GetRowText(int row);
				WString										GetFragmentText(TextPos start, TextPos end);
				int											GetRowWidth(int row);
				int											GetRowHeight();
				int											GetMaxWidth();
				int											GetMaxHeight();
				TextPos										GetTextPosFromPoint(Point point);
				Point										GetPointFromTextPos(TextPos pos);
				Rect										GetRectFromTextPos(TextPos pos);
				TextPos										GetNearestTextPos(Point point);

				TextPos										GetCaretBegin();
				TextPos										GetCaretEnd();
				TextPos										GetCaretSmall();
				TextPos										GetCaretLarge();
				void										Select(TextPos begin, TextPos end);

				WString										GetSelectionText();
				void										SetSelectionText(const WString& value);
			};

/***********************************************************************
TextBox
***********************************************************************/

			class GuiMultilineTextBox : public GuiScrollView, public GuiTextBoxCommonInterface, public Description<GuiMultilineTextBox>
			{
			public:
				static const int							TextMargin=3;

				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiBoundsComposition*		textComposition;
					GuiTextElementOperator					textElementOperator;
					Ptr<GuiTextElementOperator::ICallback>	defaultCallback;

				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					GuiTextElementOperator*					GetTextElementOperator();
					void									SetViewPosition(Point value);
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;

					WString									GetText();
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};

				class TextElementOperatorCallback : public GuiTextElementOperator::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiMultilineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiMultilineTextBox* _textControl);

					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					int										GetTextMargin()override;
				};

			protected:
				StyleController*							styleController;

				void										CalculateViewAndSetScroll();
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				Size										QueryFullSize()override;
				void										UpdateView(Rect viewBounds)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiMultilineTextBox(GuiMultilineTextBox::IStyleProvider* styleProvider);
				~GuiMultilineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
			};

			class GuiSinglelineTextBox : public GuiControl, public GuiTextBoxCommonInterface, public Description<GuiSinglelineTextBox>
			{
			public:
				static const int							TextMargin=3;

				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* background)=0;
				};

				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>						styleProvider;
					compositions::GuiBoundsComposition*		boundsComposition;
					compositions::GuiGraphicsComposition*	containerComposition;

					GuiSinglelineTextBox*					textBox;
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiTableComposition*		textCompositionTable;
					compositions::GuiCellComposition*		textComposition;
					GuiTextElementOperator					textElementOperator;
					Ptr<GuiTextElementOperator::ICallback>	defaultCallback;

				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetTextBox(GuiSinglelineTextBox* value);
					void									RearrangeTextElement();
					compositions::GuiBoundsComposition*		GetBoundsComposition();
					compositions::GuiGraphicsComposition*	GetContainerComposition();
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);

					WString									GetText();
					void									SetText(const WString& value);
					void									SetFont(const FontProperties& value);
					void									SetVisuallyEnabled(bool value);

					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					GuiTextElementOperator*					GetTextElementOperator();
					void									SetViewPosition(Point value);
				};

				class TextElementOperatorCallback : public GuiTextElementOperator::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiSinglelineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiSinglelineTextBox* _textControl);

					bool									BeforeModify(TextPos& start, TextPos& end, const WString& originalText, WString& inputText)override;
					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					int										GetTextMargin()override;
				};
			protected:
				StyleController*							styleController;
				
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiSinglelineTextBox(GuiSinglelineTextBox::IStyleProvider* styleProvider);
				~GuiSinglelineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\GUILISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
List Control
***********************************************************************/

			class GuiListControl : public GuiScrollView, public Description<GuiListControl>
			{
			public:
				class IItemProvider;
				class IItemStyleController;
				class IItemStyleProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class IItemProviderCallback : public virtual IDescriptable, public Description<IItemProviderCallback>
				{
				public:
					virtual void								OnAttached(IItemProvider* provider)=0;
					virtual void								OnItemModified(int start, int count, int newCount)=0;
				};

				class IItemArrangerCallback : public virtual IDescriptable, public Description<IItemArrangerCallback>
				{
				public:
					virtual IItemStyleController*					RequestItem(int itemIndex)=0;
					virtual void									ReleaseItem(IItemStyleController* style)=0;
					virtual void									SetViewLocation(Point value)=0;
					virtual Size									GetStylePreferredSize(IItemStyleController* style)=0;
					virtual void									SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)=0;
					virtual void									SetStyleBounds(IItemStyleController* style, Rect bounds)=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void									OnTotalSizeChanged()=0;
				};

				//-----------------------------------------------------------
				// Common Views
				//-----------------------------------------------------------

				class IItemPrimaryTextView : public virtual IDescriptable, public Description<IItemPrimaryTextView>
				{
				public:
					static const wchar_t* const					Identifier;

					virtual WString								GetPrimaryTextViewText(int itemIndex)=0;
					virtual bool								ContainsPrimaryText(int itemIndex)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				class IItemProvider : public virtual IDescriptable, public Description<IItemProvider>
				{
				public:
					virtual bool								AttachCallback(IItemProviderCallback* value)=0;
					virtual bool								DetachCallback(IItemProviderCallback* value)=0;
					virtual int									Count()=0;
					virtual IDescriptable*						RequestView(const WString& identifier)=0;
					virtual void								ReleaseView(IDescriptable* view)=0;
				};

				class IItemStyleController : public virtual IDescriptable, public Description<IItemStyleController>
				{
				public:
					virtual IItemStyleProvider*					GetStyleProvider()=0;
					virtual int									GetItemStyleId()=0;
					virtual compositions::GuiBoundsComposition*	GetBoundsComposition()=0;
					virtual bool								IsCacheable()=0;
					virtual bool								IsInstalled()=0;
					virtual void								OnInstalled()=0;
					virtual void								OnUninstalled()=0;
				};

				class IItemStyleProvider : public virtual IDescriptable, public Description<IItemStyleProvider>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual int									GetItemStyleId(int itemIndex)=0;
					virtual IItemStyleController*				CreateItemStyle(int styleId)=0;
					virtual void								DestroyItemStyle(IItemStyleController* style)=0;
					virtual void								Install(IItemStyleController* style, int itemIndex)=0;
				};

				class IItemArranger : public virtual IItemProviderCallback, public Description<IItemArranger>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual IItemArrangerCallback*				GetCallback()=0;
					virtual void								SetCallback(IItemArrangerCallback* value)=0;
					virtual Size								GetTotalSize()=0;
					virtual IItemStyleController*				GetVisibleStyle(int itemIndex)=0;
					virtual int									GetVisibleIndex(IItemStyleController* style)=0;
					virtual void								OnViewChanged(Rect bounds)=0;
				};

				class IItemCoordinateTransformer : public virtual IDescriptable, public Description<IItemCoordinateTransformer>
				{
				public:
					virtual Size								RealSizeToVirtualSize(Size size)=0;
					virtual Size								VirtualSizeToRealSize(Size size)=0;
					virtual Point								RealPointToVirtualPoint(Size realFullSize, Point point)=0;
					virtual Point								VirtualPointToRealPoint(Size realFullSize, Point point)=0;
					virtual Rect								RealRectToVirtualRect(Size realFullSize, Rect rect)=0;
					virtual Rect								VirtualRectToRealRect(Size realFullSize, Rect rect)=0;
					virtual Margin								RealMarginToVirtualMargin(Margin margin)=0;
					virtual Margin								VirtualMarginToRealMargin(Margin margin)=0;
				};

			protected:
				class ItemCallback : public IItemProviderCallback, public IItemArrangerCallback
				{
					typedef collections::List<IItemStyleController*>			StyleList;
				protected:
					GuiListControl*								listControl;
					IItemProvider*								itemProvider;
					StyleList									cachedStyles;
					StyleList									installedStyles;

				public:
					ItemCallback(GuiListControl* _listControl);
					~ItemCallback();

					void										ClearCache();

					void										OnAttached(IItemProvider* provider)override;
					void										OnItemModified(int start, int count, int newCount)override;
					IItemStyleController*						RequestItem(int itemIndex)override;
					void										ReleaseItem(IItemStyleController* style)override;
					void										SetViewLocation(Point value)override;
					Size										GetStylePreferredSize(IItemStyleController* style);
					void										SetStyleAlignmentToParent(IItemStyleController* style, Margin margin);
					void										SetStyleBounds(IItemStyleController* style, Rect bounds);
					compositions::GuiGraphicsComposition*		GetContainerComposition()override;
					void										OnTotalSizeChanged()override;
				};

				Ptr<ItemCallback>								callback;
				Ptr<IItemProvider>								itemProvider;
				Ptr<IItemStyleProvider>							itemStyleProvider;
				Ptr<IItemArranger>								itemArranger;
				Ptr<IItemCoordinateTransformer>					itemCoordinateTransformer;
				Size											fullSize;

				virtual void									OnItemModified(int start, int count, int newCount);
				virtual void									OnStyleInstalled(int itemIndex, IItemStyleController* style);
				virtual void									OnStyleUninstalled(IItemStyleController* style);
				
				void											OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void											OnBeforeReleaseGraphicsHost()override;
				Size											QueryFullSize()override;
				void											UpdateView(Rect viewBounds)override;
				
				void											OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											SetStyleProviderAndArranger(Ptr<IItemStyleProvider> styleProvider, Ptr<IItemArranger> arranger);
			public:
				GuiListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider, bool acceptFocus=false);
				~GuiListControl();

				compositions::GuiNotifyEvent					StyleProviderChanged;
				compositions::GuiNotifyEvent					ArrangerChanged;
				compositions::GuiNotifyEvent					CoordinateTransformerChanged;

				virtual IItemProvider*							GetItemProvider();
				virtual IItemStyleProvider*						GetStyleProvider();
				virtual Ptr<IItemStyleProvider>					SetStyleProvider(Ptr<IItemStyleProvider> value);
				virtual IItemArranger*							GetArranger();
				virtual Ptr<IItemArranger>						SetArranger(Ptr<IItemArranger> value);
				virtual IItemCoordinateTransformer*				GetCoordinateTransformer();
				virtual Ptr<IItemCoordinateTransformer>			SetCoordinateTransformer(Ptr<IItemCoordinateTransformer> value);
			};

/***********************************************************************
Selectable List Control
***********************************************************************/

			class GuiSelectableListControl : public GuiListControl, public Description<GuiSelectableListControl>
			{
			public:
				class IItemStyleProvider : public virtual GuiListControl::IItemStyleProvider, public Description<IItemStyleProvider>
				{
				public:
					virtual void								SetStyleSelected(IItemStyleController* style, bool value)=0;
				};

			protected:
				class StyleEvents
				{
				protected:
					GuiSelectableListControl*					listControl;
					IItemStyleController*						style;
					Ptr<compositions::GuiMouseEvent::IHandler>	leftButtonDownHandler;

					void										OnBoundsLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				public:
					StyleEvents(GuiSelectableListControl* _listControl, IItemStyleController* _style);
					~StyleEvents();

					void										AttachEvents();
					void										DetachEvents();
				};

				friend class collections::ReadonlyListEnumerator<Ptr<StyleEvents>>;
				typedef collections::Dictionary<IItemStyleController*, Ptr<StyleEvents>>	VisibleStyleMap;

			protected:

				Ptr<IItemStyleProvider>							selectableStyleProvider;
				collections::SortedList<int>					selectedItems;
				VisibleStyleMap									visibleStyles;
				bool											multiSelect;

				void											OnItemModified(int start, int count, int newCount)override;
				void											OnStyleInstalled(int itemIndex, IItemStyleController* style)override;
				void											OnStyleUninstalled(IItemStyleController* style)override;
				virtual void									OnItemSelectionChanged(int itemIndex, bool value);
				virtual void									OnItemSelectionCleared();
			public:
				GuiSelectableListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider);
				~GuiSelectableListControl();

				compositions::GuiNotifyEvent					SelectionChanged;

				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;

				bool											GetMultiSelect();
				void											SetMultiSelect(bool value);
				
				const collections::IReadonlyList<int>&			GetSelectedItems();
				bool											GetSelected(int itemIndex);
				void											SetSelected(int itemIndex, bool value);
				void											ClearSelection();
			};

/***********************************************************************
Predefined ItemCoordinateTransformer
***********************************************************************/

			namespace list
			{
				class DefaultItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<DefaultItemCoordinateTransformer>
				{
				public:
					DefaultItemCoordinateTransformer();
					~DefaultItemCoordinateTransformer();

					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
				};

				class AxisAlignedItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<AxisAlignedItemCoordinateTransformer>
				{
				public:
					enum Alignment
					{
						LeftDown,
						RightDown,
						LeftUp,
						RightUp,
						DownLeft,
						DownRight,
						UpLeft,
						UpRight,
					};
				protected:
					Alignment									alignment;

				public:
					AxisAlignedItemCoordinateTransformer(Alignment _alignment);
					~AxisAlignedItemCoordinateTransformer();

					Alignment									GetAlignment();
					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
				};
			};

/***********************************************************************
Predefined ItemArranger
***********************************************************************/

			namespace list
			{
				class RangedItemArrangerBase : public Object, virtual public GuiListControl::IItemArranger, public Description<RangedItemArrangerBase>
				{
					typedef collections::List<GuiListControl::IItemStyleController*>		StyleList;
				protected:
					GuiListControl::IItemArrangerCallback*		callback;
					GuiListControl::IItemProvider*				itemProvider;
					Rect										viewBounds;
					int											startIndex;
					StyleList									visibleStyles;

					virtual void								ClearStyles();
					virtual void								OnStylesCleared()=0;
					virtual Size								OnCalculateTotalSize()=0;
					virtual void								OnViewChangedInternal(Rect oldBounds, Rect newBounds)=0;
				public:
					RangedItemArrangerBase();
					~RangedItemArrangerBase();

					void										OnAttached(GuiListControl::IItemProvider* provider)override;
					void										OnItemModified(int start, int count, int newCount)override;
					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemArrangerCallback*		GetCallback()override;
					void										SetCallback(GuiListControl::IItemArrangerCallback* value)override;
					Size										GetTotalSize()override;
					GuiListControl::IItemStyleController*		GetVisibleStyle(int itemIndex)override;
					int											GetVisibleIndex(GuiListControl::IItemStyleController* style)override;
					void										OnViewChanged(Rect bounds)override;
				};

				class FixedHeightItemArranger : public RangedItemArrangerBase, public Description<FixedHeightItemArranger>
				{
				protected:
					int											rowHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					virtual int									GetWidth();
					virtual int									GetYOffset();
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightItemArranger();
					~FixedHeightItemArranger();
				};

				class FixedSizeMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedSizeMultiColumnItemArranger>
				{
				protected:
					Size										itemSize;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(Size itemSize, Rect bounds, int count, int& start, int& end);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedSizeMultiColumnItemArranger();
					~FixedSizeMultiColumnItemArranger();
				};

				class FixedHeightMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedHeightMultiColumnItemArranger>
				{
				protected:
					int											itemHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(int itemHeight, Rect bounds, int& rows, int& startColumn);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightMultiColumnItemArranger();
					~FixedHeightMultiColumnItemArranger();
				};
			}

/***********************************************************************
Predefined ItemStyleController
***********************************************************************/

			namespace list
			{
				class ItemStyleControllerBase : public Object, public virtual GuiListControl::IItemStyleController, public Description<ItemStyleControllerBase>
				{
				protected:
					GuiListControl::IItemStyleProvider*			provider;
					int											styleId;
					compositions::GuiBoundsComposition*			boundsComposition;
					GuiControl*									associatedControl;
					bool										isInstalled;

					void										Initialize(compositions::GuiBoundsComposition* _boundsComposition, GuiControl* _associatedControl);
					void										Finalize();

					ItemStyleControllerBase(GuiListControl::IItemStyleProvider* _provider, int _styleId);
				public:
					~ItemStyleControllerBase();
					
					GuiListControl::IItemStyleProvider*			GetStyleProvider()override;
					int											GetItemStyleId()override;
					compositions::GuiBoundsComposition*			GetBoundsComposition()override;
					bool										IsCacheable()override;
					bool										IsInstalled()override;
					void										OnInstalled()override;
					void										OnUninstalled()override;
				};
			}

/***********************************************************************
Predefined ItemProvider
***********************************************************************/

			namespace list
			{
				class ItemProviderBase : public Object, public virtual GuiListControl::IItemProvider, public Description<ItemProviderBase>
				{
				protected:
					collections::List<GuiListControl::IItemProviderCallback*>	callbacks;

					virtual void								InvokeOnItemModified(int start, int count, int newCount);
				public:
					ItemProviderBase();
					~ItemProviderBase();

					bool										AttachCallback(GuiListControl::IItemProviderCallback* value);
					bool										DetachCallback(GuiListControl::IItemProviderCallback* value);
				};

				template<typename T, typename K=typename KeyType<T>::Type>
				class ListWrapperProvider : public ItemProviderBase, public collections::IList<T, K>
				{
				protected:
					collections::IList<T, K>*			proxy;

					ListWrapperProvider()
						:proxy(0)
					{
					}
				public:
					ListWrapperProvider(collections::IList<T, K>* _proxy)
						:proxy(_proxy)
					{
					}

					~ListWrapperProvider()
					{
					}

					bool NotifyUpdate(int start, int count=1)
					{
						if(start<0 || start>=proxy->Count() || count<=0 || start+count>proxy->Count())
						{
							return false;
						}
						else
						{
							InvokeOnItemModified(start, count, count);
							return true;
						}
					}

					collections::IEnumerator<T>* CreateEnumerator()const
					{
						return proxy->CreateEnumerator();
					}

					bool Contains(const K& item)const
					{
						return proxy->Contains(item);
					}

					vint Count()const
					{
						return proxy->Count();
					}

					vint Count()
					{
						return proxy->Count();
					}

					const T& Get(vint index)const
					{
						return proxy->Get(index);
					}

					const T& operator[](vint index)const
					{
						return (*proxy)[index];
					}

					vint IndexOf(const K& item)const
					{
						return proxy->IndexOf(item);
					}

					vint Add(const T& item)
					{
						return Insert(proxy->Count(), item);
					}

					bool Remove(const K& item)
					{
						vint index=proxy->IndexOf(item);
						if(index==-1) return false;
						return RemoveAt(index);
					}

					bool RemoveAt(vint index)
					{
						if(proxy->RemoveAt(index))
						{
							InvokeOnItemModified(index, 1, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					bool RemoveRange(vint index, vint count)
					{
						if(proxy->RemoveRange(index, count))
						{
							InvokeOnItemModified(index, count, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					bool Clear()
					{
						vint count=proxy->Count();
						if(proxy->Clear())
						{
							InvokeOnItemModified(0, count, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					vint Insert(vint index, const T& item)
					{
						vint result=proxy->Insert(index, item);
						InvokeOnItemModified(index, 0, 1);
						return result;
					}

					bool Set(vint index, const T& item)
					{
						if(proxy->Set(index, item))
						{
							InvokeOnItemModified(index, 1, 1);
							return true;
						}
						else
						{
							return false;
						}
					}
				};

				template<typename T>
				class ListProvider : public ListWrapperProvider<T>
				{
				protected:
					collections::List<T>		list;

				public:
					ListProvider()
					{
						proxy=&list.Wrap();
					}

					~ListProvider()
					{
					}
				};
			}
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUICONTAINERCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
/***********************************************************************
Tab Control
***********************************************************************/

			class GuiTab;

			class GuiTabPage : public Object, public Description<GuiTabPage>
			{
				friend class GuiTab;
				friend class Ptr<GuiTabPage>;
			protected:
				GuiControl*										container;
				GuiTab*											owner;
				WString											text;
				
				GuiTabPage();
				~GuiTabPage();

				bool											AssociateTab(GuiTab* _owner, GuiControl::IStyleController* _styleController);
			public:
				compositions::GuiNotifyEvent					TextChanged;

				GuiControl*										GetContainer();
				GuiTab*											GetOwnerTab();
				const WString&									GetText();
				void											SetText(const WString& value);
				bool											GetSelected();
			};

			class GuiTab : public GuiControl, public Description<GuiTab>
			{
				friend class GuiTabPage;
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void								ShowTab(int index)=0;
				};

				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void								SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void								InsertTab(int index)=0;
					virtual void								SetTabText(int index, const WString& value)=0;
					virtual void								RemoveTab(int index)=0;
					virtual void								MoveTab(int oldIndex, int newIndex)=0;
					virtual void								SetSelectedTab(int index)=0;
					virtual GuiControl::IStyleController*		CreateTabPageStyleController()=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiTab*										tab;
				public:
					CommandExecutor(GuiTab* _tab);
					~CommandExecutor();

					void										ShowTab(int index)override;
				};

				Ptr<CommandExecutor>							commandExecutor;
				IStyleController*								styleController;
				collections::List<GuiTabPage*>					tabPages;
				GuiTabPage*										selectedPage;
			public:
				GuiTab(IStyleController* _styleController);
				~GuiTab();

				compositions::GuiNotifyEvent					SelectedPageChanged;

				GuiTabPage*										CreatePage(int index=-1);
				bool											CreatePage(GuiTabPage* page, int index=-1);
				bool											RemovePage(GuiTabPage* value);
				bool											MovePage(GuiTabPage* page, int newIndex);
				const collections::IReadonlyList<GuiTabPage*>&	GetPages();

				GuiTabPage*										GetSelectedPage();
				bool											SetSelectedPage(GuiTabPage* value);
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUITEXTLISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualTextList;

			namespace list
			{

/***********************************************************************
TextList Style Provider
***********************************************************************/

				class TextItemStyleProvider : public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<TextItemStyleProvider>
				{
				public:
					class ITextItemStyleProvider : public virtual IDescriptable, public Description<ITextItemStyleProvider>
					{
					public:
						virtual GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()=0;
						virtual GuiSelectableButton::IStyleController*		CreateBulletStyleController()=0;
					};

					class ITextItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<ITextItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual WString							GetText(int itemIndex)=0;
						virtual bool							GetChecked(int itemIndex)=0;
						virtual void							SetCheckedSilently(int itemIndex, bool value)=0;
					};

					class TextItemStyleController : public ItemStyleControllerBase, public Description<TextItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						GuiSelectableButton*					bulletButton;
						elements::GuiSolidLabelElement*			textElement;
						TextItemStyleProvider*					textItemStyleProvider;

						void									OnBulletSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						TextItemStyleController(TextItemStyleProvider* provider);
						~TextItemStyleController();

						bool									GetSelected();
						void									SetSelected(bool value);
						bool									GetChecked();
						void									SetChecked(bool value);
						const WString&							GetText();
						void									SetText(const WString& value);
					};

				protected:
					Ptr<ITextItemStyleProvider>					textItemStyleProvider;
					ITextItemView*								textItemView;
					GuiListControl*								listControl;

					void										OnStyleCheckedChanged(TextItemStyleController* style);
				public:
					TextItemStyleProvider(ITextItemStyleProvider* _textItemStyleProvider);
					~TextItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					int											GetItemStyleId(int itemIndex)override;
					GuiListControl::IItemStyleController*		CreateItemStyle(int styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, int itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};

/***********************************************************************
TextList Data Source
***********************************************************************/

				class TextItem
				{
					friend class TextItemProvider;
				protected:
					WString										text;
					bool										checked;
				public:
					TextItem();
					TextItem(const TextItem& item);
					TextItem(const WString& _text, bool _checked=false);
					TextItem(const wchar_t* _text, bool _checked=false);
					~TextItem();

					bool										operator==(const TextItem& value)const;
					bool										operator!=(const TextItem& value)const;

					const WString&								GetText()const;
					bool										GetChecked()const;
				};

				class TextItemProvider : public ListProvider<TextItem>, protected TextItemStyleProvider::ITextItemView, public Description<TextItemProvider>
				{
				protected:
					bool										ContainsPrimaryText(int itemIndex)override;
					WString										GetPrimaryTextViewText(int itemIndex)override;
					WString										GetText(int itemIndex)override;
					bool										GetChecked(int itemIndex)override;
					void										SetCheckedSilently(int itemIndex, bool value)override;
				public:
					TextItemProvider();
					~TextItemProvider();
					
					void										SetText(int itemIndex, const WString& value);
					void										SetChecked(int itemIndex, bool value);

					IDescriptable*								RequestView(const WString& identifier)override;
					void										ReleaseView(IDescriptable* view)override;
				};
			}

/***********************************************************************
TextList Control
***********************************************************************/

			class GuiVirtualTextList : public GuiSelectableListControl, public Description<GuiVirtualTextList>
			{
			public:
				GuiVirtualTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualTextList();
				
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value);
				Ptr<GuiListControl::IItemStyleProvider>			ChangeItemStyle(list::TextItemStyleProvider::ITextItemStyleProvider* itemStyleProvider);
			};

			class GuiTextList : public GuiVirtualTextList, public Description<GuiTextList>
			{
			protected:
				list::TextItemProvider*							items;
			public:
				GuiTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider);
				~GuiTextList();

				list::TextItemProvider&							GetItems();
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUILISTVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiListViewBase;

			namespace list
			{

/***********************************************************************
ListView Base
***********************************************************************/

				class ListViewItemStyleProviderBase: public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<ListViewItemStyleProviderBase>
				{
				public:
					class ListViewItemStyleController : public ItemStyleControllerBase, public Description<ListViewItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						ListViewItemStyleProviderBase*			listViewItemStyleProvider;

					public:
						ListViewItemStyleController(ListViewItemStyleProviderBase* provider);
						~ListViewItemStyleController();

						bool									GetSelected();
						void									SetSelected(bool value);
					};

				protected:
					GuiListViewBase*							listControl;

				public:
					ListViewItemStyleProviderBase();
					~ListViewItemStyleProviderBase();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					int											GetItemStyleId(int itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

			class GuiListViewBase : public GuiSelectableListControl, public Description<GuiListViewBase>
			{
			public:
				class IStyleProvider : public virtual GuiSelectableListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiSelectableButton::IStyleController*		CreateColumnStyle()=0;
					virtual Color										GetPrimaryTextColor()=0;
					virtual Color										GetSecondaryTextColor()=0;
					virtual Color										GetItemSeparatorColor()=0;
				};

			protected:
				IStyleProvider*									styleProvider;

			public:
				GuiListViewBase(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiListViewBase();
				
				IStyleProvider*									GetListViewStyleProvider();
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value);
			};

/***********************************************************************
ListView ItemStyleProvider
***********************************************************************/

			namespace list
			{
				class ListViewItemStyleProvider : public ListViewItemStyleProviderBase, public Description<ListViewItemStyleProvider>
				{
				public:
					class IListViewItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<IListViewItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual Ptr<GuiImageData>				GetSmallImage(int itemIndex)=0;
						virtual Ptr<GuiImageData>				GetLargeImage(int itemIndex)=0;
						virtual WString							GetText(int itemIndex)=0;
						virtual WString							GetSubItem(int itemIndex, int index)=0;

						virtual int								GetDataColumnCount()=0;
						virtual int								GetDataColumn(int index)=0;

						virtual int								GetColumnCount()=0;
						virtual WString							GetColumnText(int index)=0;
					};

					class IListViewItemContent : public virtual IDescriptable, public Description<IListViewItemContent>
					{
					public:
						virtual compositions::GuiBoundsComposition*	GetContentComposition()=0;
						virtual compositions::GuiBoundsComposition*	GetBackgroundDecorator()=0;
						virtual void								Install(GuiListViewBase::IStyleProvider* styleProvider, IListViewItemView* view, int itemIndex)=0;
					};

					class IListViewItemContentProvider : public virtual IDescriptable, public Description<IListViewItemContentProvider>
					{
					public:
						virtual GuiListControl::IItemCoordinateTransformer*		CreatePreferredCoordinateTransformer()=0;
						virtual GuiListControl::IItemArranger*					CreatePreferredArranger()=0;
						virtual IListViewItemContent*							CreateItemContent(const FontProperties& font)=0;
						virtual void											AttachListControl(GuiListControl* value)=0;
						virtual void											DetachListControl()=0;
					};

					class ListViewContentItemStyleController : public ListViewItemStyleController, public Description<ListViewContentItemStyleController>
					{
					protected:
						ListViewItemStyleProvider*				listViewItemStyleProvider;
						Ptr<IListViewItemContent>				content;
					public:
						ListViewContentItemStyleController(ListViewItemStyleProvider* provider);
						~ListViewContentItemStyleController();

						IListViewItemContent*					GetItemContent();
						void									Install(IListViewItemView* view, int itemIndex);
					};

				protected:

					typedef collections::List<GuiListControl::IItemStyleController*>				ItemStyleList;
					typedef collections::IReadonlyList<GuiListControl::IItemStyleController*>		IItemStyleList;

					IListViewItemView*							listViewItemView;
					Ptr<IListViewItemContentProvider>			listViewItemContentProvider;
					ItemStyleList								itemStyles;
				public:
					ListViewItemStyleProvider(IListViewItemContentProvider* itemContentProvider);
					~ListViewItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemStyleController*		CreateItemStyle(int styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, int itemIndex)override;

					const IItemStyleList&						GetCreatedItemStyles();
					bool										IsItemStyleAttachedToListView(GuiListControl::IItemStyleController* itemStyle);
				};
			}

/***********************************************************************
ListView ItemContentProvider
***********************************************************************/

			namespace list
			{
				class ListViewBigIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewBigIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewBigIconContentProvider(Size _iconSize=Size(32, 32));
					~ListViewBigIconContentProvider();

					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewSmallIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewSmallIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewSmallIconContentProvider(Size _iconSize=Size(16, 16));
					~ListViewSmallIconContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewListContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewListContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewListContentProvider(Size _iconSize=Size(16, 16));
					~ListViewListContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewTileContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewTileContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						void											RemoveTextElement(int textRow);
						elements::GuiSolidLabelElement*					CreateTextElement(int textRow, const FontProperties& font);
						void											ResetTextTable(int textRows);
					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewTileContentProvider(Size _iconSize=Size(32, 32));
					~ListViewTileContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewInformationContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewInformationContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						FontProperties									baselineFont;
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						elements::GuiSolidBackgroundElement*			bottomLine;
						compositions::GuiBoundsComposition*				bottomLineComposition;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewInformationContentProvider(Size _iconSize=Size(32, 32));
					~ListViewInformationContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};

/***********************************************************************
ListView ItemContentProvider(Detailed)
***********************************************************************/

				class ListViewColumnItemArranger : public FixedHeightItemArranger, public Description<ListViewColumnItemArranger>
				{
					typedef collections::List<GuiButton*>								ColumnHeaderButtonList;
					typedef collections::List<compositions::GuiBoundsComposition*>		ColumnHeaderSplitterList;
				public:
					static const int							SplitterWidth=8;

					class IColumnItemViewCallback : public virtual IDescriptable, public Description<IColumnItemViewCallback>
					{
					public:
						virtual void							OnColumnChanged()=0;
						virtual void							OnColumnSizeChanged(int index)=0;
					};

					class IColumnItemView : public virtual IDescriptable, public Description<IColumnItemView>
					{
					public:
						static const wchar_t* const				Identifier;
						
						virtual bool							AttachCallback(IColumnItemViewCallback* value)=0;
						virtual bool							DetachCallback(IColumnItemViewCallback* value)=0;
						virtual int								GetColumnCount()=0;
						virtual WString							GetColumnText(int index)=0;
						virtual int								GetColumnSize(int index)=0;
						virtual void							SetColumnSize(int index, int value)=0;
					};
				protected:
					class ColumnItemViewCallback : public Object, public virtual IColumnItemViewCallback
					{
					protected:
						ListViewColumnItemArranger*				arranger;
					public:
						ColumnItemViewCallback(ListViewColumnItemArranger* _arranger);
						~ColumnItemViewCallback();

						void									OnColumnChanged();
						void									OnColumnSizeChanged(int index);
					};

					GuiListViewBase*							listView;
					GuiListViewBase::IStyleProvider*			styleProvider;
					IColumnItemView*							columnItemView;
					Ptr<ColumnItemViewCallback>					columnItemViewCallback;
					compositions::GuiStackComposition*			columnHeaders;
					ColumnHeaderButtonList						columnHeaderButtons;
					ColumnHeaderSplitterList					columnHeaderSplitters;
					bool										splitterDragging;
					int											splitterLatestX;

					void										ColumnHeaderSplitterLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);

					void										RearrangeItemBounds()override;
					int											GetWidth()override;
					int											GetYOffset()override;
					Size										OnCalculateTotalSize()override;
					void										DeleteColumnButtons();
					void										RebuildColumns();
					void										UpdateColumnSize(int index);
				public:
					ListViewColumnItemArranger();
					~ListViewColumnItemArranger();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
				};
				
				class ListViewDetailContentProvider
					: public Object
					, public virtual ListViewItemStyleProvider::IListViewItemContentProvider
					, protected virtual ListViewColumnItemArranger::IColumnItemViewCallback
					, public Description<ListViewDetailContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::List<elements::GuiSolidLabelElement*>		SubItemList;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						SubItemList										subItems;

						GuiListControl::IItemProvider*					itemProvider;
						ListViewColumnItemArranger::IColumnItemView*	columnItemView;

					public:
						ItemContent(Size iconSize, const FontProperties& font, GuiListControl::IItemProvider* _itemProvider);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											UpdateSubItemSize();
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
					GuiListControl::IItemProvider*						itemProvider;
					ListViewColumnItemArranger::IColumnItemView*		columnItemView;
					ListViewItemStyleProvider*							listViewItemStyleProvider;

					void												OnColumnChanged()override;
					void												OnColumnSizeChanged(int index)override;
				public:
					ListViewDetailContentProvider(Size _iconSize=Size(16, 16));
					~ListViewDetailContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
			}

/***********************************************************************
ListView
***********************************************************************/

			namespace list
			{
				class ListViewItem
				{
				public:
					Ptr<GuiImageData>							smallImage;
					Ptr<GuiImageData>							largeImage;
					WString										text;
					collections::List<WString>					subItems;
				};

				class ListViewColumn
				{
				public:
					WString										text;
					int											size;

					ListViewColumn(const WString& _text=L"", int _size=160);
				};

				class ListViewItemProvider
					: public ListProvider<Ptr<ListViewItem>>
					, protected virtual ListViewItemStyleProvider::IListViewItemView
					, protected virtual ListViewColumnItemArranger::IColumnItemView
					, public Description<ListViewItemProvider>
				{
					typedef collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					collections::List<int>						dataColumns;
					collections::List<Ptr<ListViewColumn>>		columns;
					ColumnItemViewCallbackList					columnItemViewCallbacks;

					bool										ContainsPrimaryText(int itemIndex)override;
					WString										GetPrimaryTextViewText(int itemIndex)override;
					Ptr<GuiImageData>							GetSmallImage(int itemIndex)override;
					Ptr<GuiImageData>							GetLargeImage(int itemIndex)override;
					WString										GetText(int itemIndex)override;
					WString										GetSubItem(int itemIndex, int index)override;
					int											GetDataColumnCount()override;
					int											GetDataColumn(int index)override;

					bool										AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool										DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					int											GetColumnCount()override;
					WString										GetColumnText(int index)override;
					int											GetColumnSize(int index)override;
					void										SetColumnSize(int index, int value)override;
				public:
					ListViewItemProvider();
					~ListViewItemProvider();

					IDescriptable*								RequestView(const WString& identifier)override;
					void										ReleaseView(IDescriptable* view)override;

					collections::IList<int>&					GetDataColumns();
					void										NotifyDataColumnsUpdated();
					collections::IList<Ptr<ListViewColumn>>&	GetColumns();
					void										NotifyColumnsUpdated();
				};
			}

			class GuiVirtualListView : public GuiListViewBase, public Description<GuiVirtualListView>
			{
			public:
				GuiVirtualListView(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualListView();
				
				void											ChangeItemStyle(list::ListViewItemStyleProvider::IListViewItemContentProvider* contentProvider);
			};

			class GuiListView : public GuiVirtualListView, public Description<GuiListView>
			{
			protected:
				list::ListViewItemProvider*						items;
			public:
				GuiListView(IStyleProvider* _styleProvider);
				~GuiListView();
				
				list::ListViewItemProvider&						GetItems();
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUITREEVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiVirtualTreeListControl NodeProvider
***********************************************************************/

			namespace tree
			{
				class INodeProvider;
				class INodeRootProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class INodeProviderCallback : public virtual IDescriptable, public Description<INodeProviderCallback>
				{
				public:
					virtual void					OnAttached(INodeRootProvider* provider)=0;
					virtual void					OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)=0;
					virtual void					OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)=0;
					virtual void					OnItemExpanded(INodeProvider* node)=0;
					virtual void					OnItemCollapsed(INodeProvider* node)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				class INodeProvider : public virtual IDescriptable, public Description<INodeProvider>
				{
				public:
					virtual bool					GetExpanding()=0;
					virtual void					SetExpanding(bool value)=0;
					virtual int						CalculateTotalVisibleNodes()=0;

					virtual int						GetChildCount()=0;
					virtual INodeProvider*			GetParent()=0;
					virtual INodeProvider*			RequestChild(int index)=0;
					virtual void					ReleaseChild(INodeProvider* node)=0;
				};

				class INodeRootProvider : public virtual IDescriptable, public Description<INodeRootProvider>
				{
				public:
					virtual INodeProvider*			GetRootNode()=0;
					virtual bool					CanGetNodeByVisibleIndex()=0;
					virtual INodeProvider*			GetNodeByVisibleIndex(int index)=0;
					virtual bool					AttachCallback(INodeProviderCallback* value)=0;
					virtual bool					DetachCallback(INodeProviderCallback* value)=0;
					virtual IDescriptable*			RequestView(const WString& identifier)=0;
					virtual void					ReleaseView(IDescriptable* view)=0;
				};
			}

			namespace tree
			{
				//-----------------------------------------------------------
				// Tree to ListControl (IItemProvider)
				//-----------------------------------------------------------

				class INodeItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<INodeItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual INodeProvider*			RequestNode(int index)=0;
					virtual void					ReleaseNode(INodeProvider* node)=0;
					virtual int						CalculateNodeVisibilityIndex(INodeProvider* node)=0;
				};

				class INodeItemPrimaryTextView : public virtual IDescriptable, public Description<INodeItemPrimaryTextView>
				{
				public:
					static const wchar_t* const		Identifier;
					
					virtual WString					GetPrimaryTextViewText(INodeProvider* node)=0;
				};

				class NodeItemProvider
					: public list::ItemProviderBase
					, protected virtual INodeProviderCallback
					, protected virtual INodeItemView
					, public Description<NodeItemProvider>
				{
				protected:
					Ptr<INodeRootProvider>			root;
					INodeItemPrimaryTextView*		nodeItemPrimaryTextView;
					int								offsetBeforeChildModified;

					INodeProvider*					GetNodeByOffset(INodeProvider* provider, int offset);
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
					int								CalculateNodeVisibilityIndexInternal(INodeProvider* node);
					int								CalculateNodeVisibilityIndex(INodeProvider* node)override;
					
					bool							ContainsPrimaryText(int itemIndex)override;
					WString							GetPrimaryTextViewText(int itemIndex)override;
					INodeProvider*					RequestNode(int index)override;
					void							ReleaseNode(INodeProvider* node)override;
				public:
					NodeItemProvider(INodeRootProvider* _root);
					~NodeItemProvider();

					Ptr<INodeRootProvider>			GetRoot();
					int								Count()override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};

				//-----------------------------------------------------------
				// Tree to ListControl (IItemStyleProvider)
				//-----------------------------------------------------------

				class INodeItemStyleProvider;

				class INodeItemStyleController : public virtual GuiListControl::IItemStyleController, public Description<INodeItemStyleController>
				{
				public:
					virtual INodeItemStyleProvider*					GetNodeStyleProvider()=0;
				};

				class INodeItemStyleProvider : public virtual IDescriptable, public Description<INodeItemStyleProvider>
				{
				public:
					virtual void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)=0;
					virtual GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()=0;
					virtual void									AttachListControl(GuiListControl* value)=0;
					virtual void									DetachListControl()=0;
					virtual int										GetItemStyleId(INodeProvider* node)=0;
					virtual INodeItemStyleController*				CreateItemStyle(int styleId)=0;
					virtual void									DestroyItemStyle(INodeItemStyleController* style)=0;
					virtual void									Install(INodeItemStyleController* style, INodeProvider* node)=0;
					virtual void									SetStyleSelected(INodeItemStyleController* style, bool value)=0;
				};

				class NodeItemStyleProvider : public Object, public virtual GuiSelectableListControl::IItemStyleProvider, public Description<NodeItemStyleProvider>
				{
				protected:
					Ptr<INodeItemStyleProvider>						nodeItemStyleProvider;
					GuiListControl*									listControl;
					INodeItemView*									nodeItemView;
				public:
					NodeItemStyleProvider(Ptr<INodeItemStyleProvider> provider);
					~NodeItemStyleProvider();

					void											AttachListControl(GuiListControl* value)override;
					void											DetachListControl()override;
					int												GetItemStyleId(int itemIndex)override;
					GuiListControl::IItemStyleController*			CreateItemStyle(int styleId)override;
					void											DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void											Install(GuiListControl::IItemStyleController* style, int itemIndex)override;
					void											SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

/***********************************************************************
GuiVirtualTreeListControl Predefined NodeProvider
***********************************************************************/

			namespace tree
			{
				class MemoryNodeProvider
					: public Object
					, public virtual INodeProvider
					, private collections::IList<Ptr<MemoryNodeProvider>>
					, public Description<MemoryNodeProvider>
				{
					typedef collections::List<Ptr<MemoryNodeProvider>> ChildList;
					typedef collections::IList<Ptr<MemoryNodeProvider>> IChildList;
					typedef collections::IEnumerator<Ptr<MemoryNodeProvider>> ChildListEnumerator;
				protected:
					MemoryNodeProvider*				parent;
					bool							expanding;
					int								childCount;
					int								totalVisibleNodeCount;
					int								offsetBeforeChildModified;
					Ptr<DescriptableObject>			data;
					ChildList						children;

					virtual INodeProviderCallback*	GetCallbackProxyInternal();
					void							OnChildTotalVisibleNodesChanged(int offset);
					void							OnBeforeChildModified(int start, int count, int newCount);
					void							OnAfterChildModified(int start, int count, int newCount);
					bool							OnRequestRemove(MemoryNodeProvider* child);
					bool							OnRequestInsert(MemoryNodeProvider* child);
				private:
					
					ChildListEnumerator*			CreateEnumerator()const;
					bool							Contains(const KeyType<Ptr<MemoryNodeProvider>>::Type& item)const;
					vint							Count()const;
					vint							Count();
					const							Ptr<MemoryNodeProvider>& Get(vint index)const;
					const							Ptr<MemoryNodeProvider>& operator[](vint index)const;
					vint							IndexOf(const KeyType<Ptr<MemoryNodeProvider>>::Type& item)const;
					vint							Add(const Ptr<MemoryNodeProvider>& item);
					bool							Remove(const KeyType<Ptr<MemoryNodeProvider>>::Type& item);
					bool							RemoveAt(vint index);
					bool							RemoveRange(vint index, vint count);
					bool							Clear();
					vint							Insert(vint index, const Ptr<MemoryNodeProvider>& item);
					bool							Set(vint index, const Ptr<MemoryNodeProvider>& item);
				public:
					MemoryNodeProvider();
					MemoryNodeProvider(const Ptr<DescriptableObject>& _data);
					~MemoryNodeProvider();

					Ptr<DescriptableObject>			GetData();
					void							SetData(const Ptr<DescriptableObject>& value);
					void							NotifyDataModified();
					IChildList&						Children();

					bool							GetExpanding()override;
					void							SetExpanding(bool value)override;
					int								CalculateTotalVisibleNodes()override;

					int								GetChildCount()override;
					INodeProvider*					GetParent()override;
					INodeProvider*					RequestChild(int index)override;
					void							ReleaseChild(INodeProvider* node)override;
				};

				class NodeRootProviderBase : public virtual INodeRootProvider, protected virtual INodeProviderCallback, public Description<NodeRootProviderBase>
				{
					collections::List<INodeProviderCallback*>			callbacks;
				protected:
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
				public:
					NodeRootProviderBase();
					~NodeRootProviderBase();
					
					bool							CanGetNodeByVisibleIndex()override;
					INodeProvider*					GetNodeByVisibleIndex(int index)override;
					bool							AttachCallback(INodeProviderCallback* value)override;
					bool							DetachCallback(INodeProviderCallback* value)override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};

				class MemoryNodeRootProvider
					: public MemoryNodeProvider
					, public NodeRootProviderBase
					, public Description<MemoryNodeRootProvider>
				{
				protected:
					INodeProviderCallback*			GetCallbackProxyInternal()override;
				public:
					MemoryNodeRootProvider();
					~MemoryNodeRootProvider();

					INodeProvider*					GetRootNode()override;
				};
			}

/***********************************************************************
GuiVirtualTreeListControl
***********************************************************************/

			class GuiVirtualTreeListControl : public GuiSelectableListControl, public Description<GuiVirtualTreeListControl>
			{
			protected:
				tree::NodeItemProvider*				nodeItemProvider;
				tree::INodeItemView*				nodeItemView;
				Ptr<tree::INodeItemStyleProvider>	nodeStyleProvider;
			public:
				GuiVirtualTreeListControl(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider);
				~GuiVirtualTreeListControl();

				tree::INodeItemView*				GetNodeItemView();
				tree::INodeRootProvider*			GetNodeRootProvider();
				tree::INodeItemStyleProvider*		GetNodeStyleProvider();
				Ptr<tree::INodeItemStyleProvider>	SetNodeStyleProvider(Ptr<tree::INodeItemStyleProvider> styleProvider);
			};

/***********************************************************************
TreeView
***********************************************************************/

			namespace tree
			{
				class ITreeViewItemView : public virtual INodeItemPrimaryTextView, public Description<ITreeViewItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual Ptr<GuiImageData>		GetNodeImage(INodeProvider* node)=0;
					virtual WString					GetNodeText(INodeProvider* node)=0;
				};

				class TreeViewItem : public Object, public Description<TreeViewItem>
				{
				public:
					Ptr<GuiImageData>				image;
					WString							text;

					TreeViewItem();
					TreeViewItem(const Ptr<GuiImageData>& _image, const WString& _text);
				};

				class TreeViewItemRootProvider
					: public MemoryNodeRootProvider
					, protected virtual ITreeViewItemView
					, public Description<TreeViewItemRootProvider>
				{
				protected:

					WString							GetPrimaryTextViewText(INodeProvider* node)override;
					Ptr<GuiImageData>				GetNodeImage(INodeProvider* node)override;
					WString							GetNodeText(INodeProvider* node)override;
				public:
					TreeViewItemRootProvider();
					~TreeViewItemRootProvider();

					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};
			}
			
			class GuiTreeView : public GuiVirtualTreeListControl, public Description<GuiTreeView>
			{
			public:
				class IStyleProvider : public virtual GuiVirtualTreeListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()=0;
					virtual Color										GetTextColor()=0;
				};
			protected:
				IStyleProvider*								styleProvider;
				Ptr<tree::TreeViewItemRootProvider>			nodes;
			public:
				GuiTreeView(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider=0);
				~GuiTreeView();

				IStyleProvider*								GetTreeViewStyleProvider();
				Ptr<tree::TreeViewItemRootProvider>			Nodes();
			};

			namespace tree
			{
				class TreeViewNodeItemStyleProvider
					: public Object
					, public virtual INodeItemStyleProvider
					, protected virtual INodeProviderCallback
					, public Description<TreeViewNodeItemStyleProvider>
				{
				protected:
#pragma warning(push)
#pragma warning(disable:4250)
					class ItemController : public list::ItemStyleControllerBase, public virtual INodeItemStyleController
					{
					protected:
						TreeViewNodeItemStyleProvider*		styleProvider;
						GuiSelectableButton*				backgroundButton;
						GuiSelectableButton*				expandingButton;
						compositions::GuiTableComposition*	table;
						elements::GuiImageFrameElement*		image;
						elements::GuiSolidLabelElement*		text;

						void								SwitchNodeExpanding();
						void								OnBackgroundButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						ItemController(TreeViewNodeItemStyleProvider* _styleProvider);

						INodeItemStyleProvider*				GetNodeStyleProvider()override;
						void								Install(INodeProvider* node);

						bool								GetSelected();
						void								SetSelected(bool value);
						void								UpdateExpandingButton(INodeProvider* associatedNode);
					};
#pragma warning(pop)

					GuiTreeView*							treeControl;
					GuiListControl::IItemStyleProvider*		bindedItemStyleProvider;
					ITreeViewItemView*						treeViewItemView;

				protected:
					ItemController*							GetRelatedController(INodeProvider* node);
					void									UpdateExpandingButton(INodeProvider* node);
					void									OnAttached(INodeRootProvider* provider)override;
					void									OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void									OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void									OnItemExpanded(INodeProvider* node)override;
					void									OnItemCollapsed(INodeProvider* node)override;
				public:
					TreeViewNodeItemStyleProvider();
					~TreeViewNodeItemStyleProvider();

					void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)override;
					GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()override;
					void									AttachListControl(GuiListControl* value)override;
					void									DetachListControl()override;
					int										GetItemStyleId(INodeProvider* node)override;
					INodeItemStyleController*				CreateItemStyle(int styleId)override;
					void									DestroyItemStyle(INodeItemStyleController* style)override;
					void									Install(INodeItemStyleController* style, INodeProvider* node)override;
					void									SetStyleSelected(INodeItemStyleController* style, bool value)override;
				};
			}
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUIMENUCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Menu Service
***********************************************************************/

			class GuiMenu;

			class IGuiMenuService : public virtual IDescriptable, public Description<IGuiMenuService>
			{
			public:
				static const wchar_t* const				Identifier;

				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				GuiMenu*								openingMenu;
			public:
				IGuiMenuService();

				virtual IGuiMenuService*				GetParent()=0;
				virtual Direction						GetPreferredDirection()=0;
				virtual bool							IsActiveState()=0;

				virtual void							MenuItemExecuted();
				virtual GuiMenu*						GetOpeningMenu();
				virtual void							MenuOpened(GuiMenu* menu);
				virtual void							MenuClosed(GuiMenu* menu);
			};

/***********************************************************************
Menu
***********************************************************************/

			class GuiMenu : public GuiPopup, private IGuiMenuService, public Description<GuiMenu>
			{
			private:
				IGuiMenuService*						parentMenuService;

				IGuiMenuService*						GetParent();
				Direction								GetPreferredDirection();
				bool									IsActiveState();
			protected:
				GuiControl*								owner;

				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
				void									OnWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenu(GuiControl::IStyleController* _styleController, GuiControl* _owner);
				~GuiMenu();

				void									UpdateMenuService();
				IDescriptable*							QueryService(const WString& identifier)override;
			};

			class GuiMenuBar : public GuiControl, private IGuiMenuService, public Description<GuiMenuBar>
			{
			private:
				IGuiMenuService*						GetParent();
				Direction								GetPreferredDirection();
				bool									IsActiveState();
			public:
				GuiMenuBar(GuiControl::IStyleController* _styleController);
				~GuiMenuBar();
				
				IDescriptable*							QueryService(const WString& identifier)override;
			};

/***********************************************************************
MenuButton
***********************************************************************/

			class GuiMenuButton : public GuiButton, public Description<GuiMenuButton>
			{
			public:
				class IStyleController : public GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual GuiMenu::IStyleController*	CreateSubMenuStyleController()=0;
					virtual void						SetSubMenuExisting(bool value)=0;
					virtual void						SetSubMenuOpening(bool value)=0;
				};
			protected:
				IStyleController*						styleController;
				GuiMenu*								subMenu;
				Size									preferredMenuClientSize;
				IGuiMenuService*						ownerMenuService;

				void									OpenSubMenuInternal();
				void									OnParentLineChanged()override;
				void									OnSubMenuWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnSubMenuWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenuButton(IStyleController* _styleController);
				~GuiMenuButton();

				compositions::GuiNotifyEvent			SubMenuOpeningChanged;

				bool									IsSubMenuExists();
				GuiMenu*								GetSubMenu();
				void									CreateSubMenu(GuiMenu::IStyleController* subMenuStyleController=0);
				void									DestroySubMenu();

				bool									GetSubMenuOpening();
				void									SetSubMenuOpening(bool value);

				Size									GetPreferredMenuClientSize();
				void									SetPreferredMenuClientSize(Size value);
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUICOMBOCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ComboBox Base
***********************************************************************/

			class GuiComboBoxBase : public GuiButton, public Description<GuiComboBoxBase>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void							ShowPopup()=0;
					virtual void							SelectItem()=0;
				};

				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void							SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void							OnClicked()=0;
					virtual void							OnPopupOpened()=0;
					virtual void							OnPopupClosed()=0;
					virtual void							OnItemSelected()=0;
					virtual GuiControl::IStyleController*	CreatePopupStyle()=0;
				};
			protected:

				class CommandExecutor : public Object, public virtual ICommandExecutor
				{
				protected:
					GuiComboBoxBase*						combo;

				public:
					CommandExecutor(GuiComboBoxBase* _combo);
					~CommandExecutor();

					void									ShowPopup()override;
					void									SelectItem()override;
				};

				Ptr<CommandExecutor>						commandExecutor;
				IStyleController*							styleController;
				GuiPopup*									popup;

				virtual void								SelectItem();
				void										OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnPopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnPopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxBase(IStyleController* _styleController);
				~GuiComboBoxBase();

				compositions::GuiNotifyEvent				PopupOpened;
				compositions::GuiNotifyEvent				PopupClosed;
				compositions::GuiNotifyEvent				ItemSelecting;
				compositions::GuiNotifyEvent				ItemSelected;

				void										ShowPopup();
				GuiPopup*									GetPopup();
			};

/***********************************************************************
ComboBox with GuiListControl
***********************************************************************/

			class GuiComboBoxListControl : public GuiComboBoxBase, public Description<GuiComboBoxListControl>
			{
			protected:
				GuiSelectableListControl*					containedListControl;
				GuiListControl::IItemPrimaryTextView*		primaryTextView;

				virtual void								DisplaySelectedContent(int itemIndex);
				void										OnListControlSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxListControl(IStyleController* _styleController, GuiSelectableListControl* _containedListControl);
				~GuiComboBoxListControl();

				compositions::GuiNotifyEvent				SelectedIndexChanged;
				
				void										SetFont(const FontProperties& value)override;
				GuiSelectableListControl*					GetContainedListControl();

				int											GetSelectedIndex();
				void										SetSelectedIndex(int value);
				GuiListControl::IItemProvider*				GetItemProvider();
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\GUIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION
#define VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			/// <summary>Represents an GacUI application, for window management and asynchronized operation supporting. Use [M:vl.presentation.controls.GetApplication] to access the instance of this class.</summary>
			class GuiApplication : public Object, private INativeControllerListener
			{
				friend void GuiApplicationInitialize();
				friend class GuiWindow;
				friend class Ptr<GuiApplication>;
			private:
				void											LeftButtonDown(Point position)override;
				void											LeftButtonUp(Point position)override;
				void											RightButtonDown(Point position)override;
				void											RightButtonUp(Point position)override;
			protected:
				GuiWindow*										mainWindow;
				collections::List<GuiWindow*>					windows;

				GuiApplication();
				~GuiApplication();

				void											RegisterWindow(GuiWindow* window);
				void											UnregisterWindow(GuiWindow* window);
				void											OnMouseDown(Point location);
			public:
				/// <summary>Run a <see cref="GuiWindow"/> as the main window and show it. This function can only be called once in the entry point. When the main window is closed or hiden, the Run function will finished, and the application should prepare for finalization.</summary>
				/// <param name="_mainWindow">The main window.</param>
				void											Run(GuiWindow* _mainWindow);
				/// <summary>Get all created <see cref="GuiWindow"/> instances. This contains normal windows, popup windows, menus, or other types of windows that inherits from <see cref="GuiWindow"/>.</summary>
				/// <returns>All created <see cref="GuiWindow"/> instances.</returns>
				const collections::IReadonlyList<GuiWindow*>&	GetWindows();
				/// <summary>Get the <see cref="GuiWindow"/> instance that the mouse cursor are directly in.</summary>
				/// <returns>The <see cref="GuiWindow"/> instance that the mouse cursor are directly in.</returns>
				/// <param name="location">The mouse cursor.</param>
				GuiWindow*										GetWindow(Point location);

				/// <summary>Test is the current thread the main thread for GUI.</summary>
				/// <returns>Returns true if the current thread is the main thread for GUI.</returns>
				bool											IsInMainThread();
				/// <summary>Invoke a specified function with an specified argument in the main thread.</summary>
				/// <param name="proc">The specified function.</param>
				/// <param name="argument">The specified argument.</param>
				void											InvokeInMainThread(INativeAsyncService::AsyncTaskProc* proc, void* argument);
				/// <summary>Invoke a specified function with an specified argument in the main thread and wait for the function to complete or timeout.</summary>
				/// <returns>Return true if the function complete. Return false if the function has not completed during a specified period of time.</returns>
				/// <param name="proc">The specified function.</param>
				/// <param name="argument">The specified argument.</param>
				/// <param name="milliseconds">The specified period of time to wait. Set to -1 (default value) to wait forever until the function completed.</param>
				bool											InvokeInMainThreadAndWait(INativeAsyncService::AsyncTaskProc* proc, void* argument, int milliseconds=-1);
				/// <summary>Invoke a specified function in the main thread.</summary>
				/// <param name="proc">The specified function.</param>
				void											InvokeInMainThread(const Func<void()>& proc);
				/// <summary>Invoke a specified function in the main thread and wait for the function to complete or timeout.</summary>
				/// <returns>Return true if the function complete. Return false if the function has not completed during a specified period of time.</returns>
				/// <param name="proc">The specified function.</param>
				/// <param name="milliseconds">The specified period of time to wait. Set to -1 (default value) to wait forever until the function completed.</param>
				bool											InvokeInMainThreadAndWait(const Func<void()>& proc, int milliseconds=-1);

				template<typename T>
				void InvokeLambdaInMainThread(const T& proc)
				{
					InvokeInMainThread(Func<void()>(proc));
				}
				
				template<typename T>
				bool InvokeLambdaInMainThreadAndWait(const T& proc, int milliseconds=-1)
				{
					return InvokeInMainThreadAndWait(Func<void()>(proc), milliseconds);
				}
			};

			/// <summary>Get the global <see cref="GuiApplication"/> object.</summary>
			/// <returns>The global <see cref="GuiApplication"/> object.</returns>
			extern GuiApplication*								GetApplication();
		}
	}
}

extern void GuiApplicationMain();

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\STYLES\GUICOMMONSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMMONSTYLES
#define VCZH_PRESENTATION_CONTROLS_GUICOMMONSTYLES


namespace vl
{
	namespace presentation
	{
		namespace common_styles
		{

/***********************************************************************
Scrolls
***********************************************************************/

			class CommonScrollStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<CommonScrollStyle>
			{
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction											direction;
				controls::GuiScroll::ICommandExecutor*				commandExecutor;
				controls::GuiButton*								decreaseButton;
				controls::GuiButton*								increaseButton;
				controls::GuiButton*								handleButton;
				compositions::GuiPartialViewComposition*			handleComposition;
				compositions::GuiBoundsComposition*					boundsComposition;

				int													totalSize;
				int													pageSize;
				int													position;
				Point												draggingStartLocation;
				bool												draggingHandle;

				void												UpdateHandle();
				void												OnDecreaseButtonClicked(compositions::GuiGraphicsComposition* sender,compositions::GuiEventArgs& arguments);
				void												OnIncreaseButtonClicked(compositions::GuiGraphicsComposition* sender,compositions::GuiEventArgs& arguments);
				void												OnHandleMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseMove(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseUp(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);;
				void												OnBigMoveMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);

				virtual controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction)=0;
				virtual controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction)=0;
				virtual controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)=0;
				virtual void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)=0;
				void												BuildStyle(int defaultSize, int arrowSize);
			public:
				CommonScrollStyle(Direction _direction);
				~CommonScrollStyle();

				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*				GetContainerComposition()override;
				void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void												SetText(const WString& value)override;
				void												SetFont(const FontProperties& value)override;
				void												SetVisuallyEnabled(bool value)override;
				void												SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void												SetTotalSize(int value)override;
				void												SetPageSize(int value)override;
				void												SetPosition(int value)override;
			};

			class CommonTrackStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<CommonTrackStyle>
			{
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction											direction;
				controls::GuiScroll::ICommandExecutor*				commandExecutor;
				compositions::GuiBoundsComposition*					boundsComposition;
				controls::GuiButton*								handleButton;
				compositions::GuiTableComposition*					handleComposition;

				int													totalSize;
				int													pageSize;
				int													position;
				Point												draggingStartLocation;
				bool												draggingHandle;

				void												UpdateHandle();
				void												OnHandleMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseMove(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseUp(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				
				virtual controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)=0;
				virtual void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)=0;
				virtual void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)=0;
				void												BuildStyle(int trackThickness, int trackPadding, int handleLong, int handleShort);
			public:
				CommonTrackStyle(Direction _direction);
				~CommonTrackStyle();

				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*				GetContainerComposition()override;
				void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void												SetText(const WString& value)override;
				void												SetFont(const FontProperties& value)override;
				void												SetVisuallyEnabled(bool value)override;
				void												SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void												SetTotalSize(int value)override;
				void												SetPageSize(int value)override;
				void												SetPosition(int value)override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\VCZH_SHARED\CODE\OTHERS\GAC\LIBRARIES\GACUI\SOURCE\CONTROLS\STYLES\GUIWIN7STYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
	GuiControl::IStyleController
		Win7EmptyStyle
		Win7WindowStyle
		Win7MenuStyle
		Win7MenuBarStyle
		Win7MenuSplitterStyle
		Win7GroupBoxStyle
	GuiTab::IStyleController
		Win7TabStyle
	GuiSelectableButton::IStyleController
		Win7ButtonStyle(vertical|horizontal)
		Win7ToolstripButtonStyle
		Win7CheckBoxStyle(check|radio)
		Win7SelectableItemStyle
		Win7TabPageHeaderStyle
		Win7ListViewColumnDropDownStyle
		Win7ListViewColumnHeaderStyle
		Win7TreeViewExpandingButtonStyle
	GuiComboBoxBase::IStyleController
		Win7DropDownComboBoxStyle
	GuiMenuButton::IStyleController
		Win7MenuBarButtonStyle
		Win7MenuItemButtonStyle
	GuiScroll::IStyleController
		Win7ScrollStyle
		Win7TrackStyle
	GuiScrollView::IStyleProvider
		Win7ScrollViewProvider
		Win7MultilineTextBoxProvider
	GuiSinglelineTextBox::IStyleProvider
		Win7SinglelineTextBoxProvider
	list::TextItemStyleProvider::ITextItemStyleProvider
		Win7TextListProvider
		Win7CheckTextListProvider
		Win7RadioTextListProvider
	GuiListView::IStyleProvider
		Win7ListViewProvider
	GuiTreeView::IStyleProvider
		Win7TreeViewProvider
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES
#define VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Button Configuration
***********************************************************************/
			
			struct Win7ButtonColors
			{
				Color										borderColor;
				Color										backgroundColor;
				Color										g1;
				Color										g2;
				Color										g3;
				Color										g4;
				Color										textColor;
				Color										bulletLight;
				Color										bulletDark;

				bool operator==(const Win7ButtonColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor &&
						g1 == colors.g1 &&
						g2 == colors.g2 &&
						g3 == colors.g3 &&
						g4 == colors.g4 &&
						textColor == colors.textColor &&
						bulletLight == colors.bulletLight &&
						bulletDark == colors.bulletDark;
				}

				bool operator!=(const Win7ButtonColors& colors)
				{
					return !(*this==colors);
				}

				void										SetAlphaWithoutText(unsigned char a);

				static Win7ButtonColors						Blend(const Win7ButtonColors& c1, const Win7ButtonColors& c2, int ratio, int total);

				static Win7ButtonColors						ButtonNormal();
				static Win7ButtonColors						ButtonActive();
				static Win7ButtonColors						ButtonPressed();
				static Win7ButtonColors						ButtonDisabled();
				
				static Win7ButtonColors						ItemNormal();
				static Win7ButtonColors						ItemActive();
				static Win7ButtonColors						ItemSelected();
				static Win7ButtonColors						ItemDisabled();
				
				static Win7ButtonColors						CheckedNormal(bool selected);
				static Win7ButtonColors						CheckedActive(bool selected);
				static Win7ButtonColors						CheckedPressed(bool selected);
				static Win7ButtonColors						CheckedDisabled(bool selected);

				static Win7ButtonColors						ToolstripButtonNormal();
				static Win7ButtonColors						ToolstripButtonActive();
				static Win7ButtonColors						ToolstripButtonPressed();
				static Win7ButtonColors						ToolstripButtonDisabled();

				static Win7ButtonColors						MenuBarButtonNormal();
				static Win7ButtonColors						MenuBarButtonActive();
				static Win7ButtonColors						MenuBarButtonPressed();
				static Win7ButtonColors						MenuBarButtonDisabled();

				static Win7ButtonColors						MenuItemButtonNormal();
				static Win7ButtonColors						MenuItemButtonNormalActive();
				static Win7ButtonColors						MenuItemButtonDisabled();
				static Win7ButtonColors						MenuItemButtonDisabledActive();

				static Win7ButtonColors						TabPageHeaderNormal();
				static Win7ButtonColors						TabPageHeaderActive();
				static Win7ButtonColors						TabPageHeaderSelected();
			};

			struct Win7ButtonElements
			{
				elements::GuiSolidBorderElement*			rectBorderElement;
				elements::GuiRoundBorderElement*			roundBorderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		topGradientElement;
				elements::GuiGradientBackgroundElement*		bottomGradientElement;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			backgroundComposition;
				compositions::GuiTableComposition*			gradientComposition;

				static Win7ButtonElements					Create(bool verticalGradient, bool roundBorder, Alignment::Type horizontal=Alignment::Center, Alignment::Type vertical=Alignment::Center);
				void										Apply(const Win7ButtonColors& colors);
			};

			struct Win7CheckedButtonElements
			{
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		outerGradientElement;
				elements::GuiGradientBackgroundElement*		innerGradientElement;
				elements::GuiSolidLabelElement*				textElement;
				elements::GuiSolidLabelElement*				bulletTextElement;
				elements::GuiSolidBackgroundElement*		bulletBackgroundElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win7CheckedButtonElements			Create(elements::ElementShape::Type shape, bool backgroundVisible);
				void										Apply(const Win7ButtonColors& colors);
			};

			struct Win7MenuItemButtonElements
			{
				elements::GuiRoundBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::Gui3DSplitterElement*				splitterElement;
				compositions::GuiCellComposition*			splitterComposition;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				elements::GuiSolidLabelElement*				subMenuTextElement;
				compositions::GuiGraphicsComposition*		subMenuTextComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win7MenuItemButtonElements			Create();
				void										Apply(const Win7ButtonColors& colors);
				void										SetActive(bool value);
				void										SetSubMenuExisting(bool value);
			};

			struct Win7TextBoxColors
			{
				Color										borderColor;
				Color										backgroundColor;

				bool operator==(const Win7TextBoxColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor;
				}

				bool operator!=(const Win7TextBoxColors& colors)
				{
					return !(*this==colors);
				}

				static Win7TextBoxColors					Blend(const Win7TextBoxColors& c1, const Win7TextBoxColors& c2, int ratio, int total);

				static Win7TextBoxColors					Normal();
				static Win7TextBoxColors					Active();
				static Win7TextBoxColors					Focused();
				static Win7TextBoxColors					Disabled();
			};

/***********************************************************************
Helper Functions
***********************************************************************/
			
			extern int										Win7GetColorAnimationLength();
			extern Color									Win7GetSystemWindowColor();
			extern Color									Win7GetSystemTabContentColor();
			extern Color									Win7GetSystemBorderColor();
			extern Color									Win7GetSystemTextColor(bool enabled);
			extern void										Win7SetFont(elements::GuiSolidLabelElement* element, compositions::GuiBoundsComposition* composition, const FontProperties& fontProperties);
			extern void										Win7CreateSolidLabelElement(elements::GuiSolidLabelElement*& element, compositions::GuiBoundsComposition*& composition, Alignment::Type horizontal, Alignment::Type vertical);

/***********************************************************************
Animation
***********************************************************************/

#define DEFINE_TRANSFERRING_ANIMATION(TSTATE, TSTYLECONTROLLER)\
				class TransferringAnimation : public compositions::GuiTimeBasedAnimation\
				{\
				protected:\
					TSTATE									colorBegin;\
					TSTATE									colorEnd;\
					TSTATE									colorCurrent;\
					TSTYLECONTROLLER*						style;\
					bool									stopped;\
					bool									enableAnimation;\
				public:\
					TransferringAnimation(TSTYLECONTROLLER* _style, const TSTATE& begin);\
					void									Play(int currentPosition, int totalLength)override;\
					void									Stop()override;\
					bool									GetEnableAnimation();\
					void									SetEnableAnimation(bool value);\
					void									Transfer(const TSTATE& end);\
				};\

/***********************************************************************
Container
***********************************************************************/

			class Win7EmptyStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7EmptyStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7EmptyStyle(Color color);
				~Win7EmptyStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7WindowStyle : public Win7EmptyStyle, public Description<Win7WindowStyle>
			{
			public:
				Win7WindowStyle();
				~Win7WindowStyle();
			};

			class Win7MenuStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win7MenuStyle();
				~Win7MenuStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7MenuBarStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuBarStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7MenuBarStyle();
				~Win7MenuBarStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7GroupBoxStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7GroupBoxStyle>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Color, Win7GroupBoxStyle)

				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			sinkBorderComposition;
				compositions::GuiBoundsComposition*			raisedBorderComposition;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			textBackgroundComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				elements::GuiSolidLabelElement*				textElement;
				Ptr<TransferringAnimation>					transferringAnimation;

				void										SetMargins(int fontSize);
			public:
				Win7GroupBoxStyle();
				~Win7GroupBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7TabStyle : public Object, public virtual controls::GuiTab::IStyleController, public Description<Win7TabStyle>
			{
			protected:
				compositions::GuiTableComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				compositions::GuiStackComposition*			tabHeaderComposition;
				compositions::GuiBoundsComposition*			tabContentTopLineComposition;
				FontProperties								headerFont;
				controls::GuiTab::ICommandExecutor*			commandExecutor;

				Ptr<controls::GuiSelectableButton::MutexGroupController>	headerController;
				collections::List<controls::GuiSelectableButton*>			headerButtons;

				void										OnHeaderButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										UpdateHeaderZOrder();
			public:
				Win7TabStyle();
				~Win7TabStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;

				void										SetCommandExecutor(controls::GuiTab::ICommandExecutor* value)override;
				void										InsertTab(int index)override;
				void										SetTabText(int index, const WString& value)override;
				void										RemoveTab(int index)override;
				void										MoveTab(int oldIndex, int newIndex)override;
				void										SetSelectedTab(int index)override;
				controls::GuiControl::IStyleController*		CreateTabPageStyleController()override;
			};

/***********************************************************************
Button
***********************************************************************/

			class Win7ButtonStyleBase : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ButtonStyleBase>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7ButtonStyleBase)

				Win7ButtonElements							elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;
				bool										transparentWhenInactive;
				bool										transparentWhenDisabled;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)=0;
			public:
				Win7ButtonStyleBase(bool verticalGradient, bool roundBorder, const Win7ButtonColors& initialColor, Alignment::Type horizontal, Alignment::Type vertical);
				~Win7ButtonStyleBase();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;

				bool										GetTransparentWhenInactive();
				void										SetTransparentWhenInactive(bool value);
				bool										GetTransparentWhenDisabled();
				void										SetTransparentWhenDisabled(bool value);
				bool										GetAutoSizeForText();
				void										SetAutoSizeForText(bool value);
			};

			class Win7ButtonStyle : public Win7ButtonStyleBase, public Description<Win7ButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7ButtonStyle(bool verticalGradient=true);
				~Win7ButtonStyle();
			};

			class Win7ToolstripButtonStyle : public Win7ButtonStyleBase, public Description<Win7ToolstripButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7ToolstripButtonStyle(bool transparent);
				~Win7ToolstripButtonStyle();
			};

			class Win7CheckBoxStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7CheckBoxStyle>
			{
			public:
				enum BulletStyle
				{
					CheckBox,
					RadioButton,
				};
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7CheckBoxStyle)

				Win7CheckedButtonElements					elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7CheckBoxStyle(BulletStyle bulletStyle, bool backgroundVisible=true);
				~Win7CheckBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

/***********************************************************************
Misc Buttons
***********************************************************************/

			class Win7SelectableItemStyle : public Win7ButtonStyleBase, public Description<Win7SelectableItemStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7SelectableItemStyle();
				~Win7SelectableItemStyle();
			};

			class Win7TabPageHeaderStyle : public Win7ButtonStyleBase, public Description<Win7TabPageHeaderStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7TabPageHeaderStyle();
				~Win7TabPageHeaderStyle();

				void										SetFont(const FontProperties& value)override;
			};

			class Win7ListViewColumnDropDownStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ListViewColumnDropDownStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			leftBorderComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			gradientComposition;
				compositions::GuiBoundsComposition*			textComposition;

				elements::GuiGradientBackgroundElement*		leftBorderElement;
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::GuiSolidLabelElement*				textElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7ListViewColumnDropDownStyle();
				~Win7ListViewColumnDropDownStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7ListViewColumnHeaderStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ListViewColumnHeaderStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			rightBorderComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			gradientComposition;
				compositions::GuiBoundsComposition*			textComposition;

				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		rightBorderElement;
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::GuiSolidLabelElement*				textElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7ListViewColumnHeaderStyle();
				~Win7ListViewColumnHeaderStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7TreeViewExpandingButtonStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7TreeViewExpandingButtonStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				elements::GuiPolygonElement*				polygonElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7TreeViewExpandingButtonStyle();
				~Win7TreeViewExpandingButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

/***********************************************************************
Menu Button
***********************************************************************/

			class Win7MenuBarButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7MenuBarButtonStyle>
			{
			protected:
				Win7ButtonElements							elements;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isOpening;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool opening);
			public:
				Win7MenuBarButtonStyle();
				~Win7MenuBarButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				controls::GuiMenu::IStyleController*		CreateSubMenuStyleController()override;
				void										SetSubMenuExisting(bool value)override;
				void										SetSubMenuOpening(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7MenuItemButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7MenuItemButtonStyle>
			{
			protected:
				Win7MenuItemButtonElements					elements;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isOpening;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool opening);
			public:
				Win7MenuItemButtonStyle();
				~Win7MenuItemButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				controls::GuiMenu::IStyleController*		CreateSubMenuStyleController()override;
				void										SetSubMenuExisting(bool value)override;
				void										SetSubMenuOpening(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7MenuSplitterStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuSplitterStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7MenuSplitterStyle();
				~Win7MenuSplitterStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

/***********************************************************************
ComboBox
***********************************************************************/
			
#pragma warning(push)
#pragma warning(disable:4250)
			class Win7DropDownComboBoxStyle : public Win7ButtonStyle, public virtual controls::GuiComboBoxBase::IStyleController, public Description<Win7DropDownComboBoxStyle>
			{
			protected:
				controls::GuiComboBoxBase::ICommandExecutor*	commandExecutor;
				compositions::GuiTableComposition*				table;
				compositions::GuiCellComposition*				textComposition;
				compositions::GuiCellComposition*				dropDownComposition;
				elements::GuiSolidLabelElement*					dropDownElement;

				void											TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7DropDownComboBoxStyle();
				~Win7DropDownComboBoxStyle();
				
				compositions::GuiGraphicsComposition*			GetContainerComposition()override;

				void											SetCommandExecutor(controls::GuiComboBoxBase::ICommandExecutor* value)override;
				void											OnClicked()override;
				void											OnPopupOpened()override;
				void											OnPopupClosed()override;
				void											OnItemSelected()override;
				controls::GuiControl::IStyleController*			CreatePopupStyle()override;
			};
#pragma warning(pop)

/***********************************************************************
Scroll
***********************************************************************/

			class Win7ScrollStyle : public common_styles::CommonScrollStyle, public Description<Win7ScrollStyle>
			{
			public:
				static const int							DefaultSize=18;
				static const int							ArrowSize=10;
			protected:
				controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction);
				controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction);
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction);
				void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)override;
			public:
				Win7ScrollStyle(Direction _direction);
				~Win7ScrollStyle();
			};

			class Win7TrackStyle : public common_styles::CommonTrackStyle, public Description<Win7TrackStyle>
			{
			public:
				static const int							TrackThickness=4;
				static const int							TrackPadding=8;
				static const int							HandleLong=21;
				static const int							HandleShort=10;

			protected:
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)override;
				void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)override;
				void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)override;
			public:
				Win7TrackStyle(Direction _direction);
				~Win7TrackStyle();
			};

/***********************************************************************
ScrollView
***********************************************************************/

			class Win7ScrollViewProvider : public Object, public virtual controls::GuiScrollView::IStyleProvider, public Description<Win7ScrollViewProvider>
			{
			public:
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;

				controls::GuiScroll::IStyleController*		CreateHorizontalScrollStyle()override;
				controls::GuiScroll::IStyleController*		CreateVerticalScrollStyle()override;
				int											GetDefaultScrollSize()override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

/***********************************************************************
TextBox
***********************************************************************/

			class Win7TextBoxBackground : public Object, public Description<Win7TextBoxBackground>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7TextBoxColors, Win7TextBoxBackground)
					
				elements::GuiRoundBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				compositions::GuiGraphicsComposition*		focusableComposition;
				bool										isMouseEnter;
				bool										isFocused;
				bool										isVisuallyEnabled;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiControl::IStyleController*		styleController;
				elements::GuiColorizedTextElement*			textElement;

				void										UpdateStyle();
				void										Apply(const Win7TextBoxColors& colors);

				void										OnBoundsMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				Win7TextBoxBackground();
				~Win7TextBoxBackground();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller);
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value);
				void										SetVisuallyEnabled(bool value);
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition);
				void										InitializeTextElement(elements::GuiColorizedTextElement* _textElement);
			};

			class Win7MultilineTextBoxProvider : public Win7ScrollViewProvider, public Description<Win7MultilineTextBoxProvider>
			{
			protected:
				Win7TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win7MultilineTextBoxProvider();
				~Win7MultilineTextBoxProvider();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

			class Win7SinglelineTextBoxProvider : public Object, public virtual controls::GuiSinglelineTextBox::IStyleProvider, public Description<Win7SinglelineTextBoxProvider>
			{
			protected:
				Win7TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win7SinglelineTextBoxProvider();
				~Win7SinglelineTextBoxProvider();

				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

/***********************************************************************
List
***********************************************************************/

			class Win7TextListProvider : public Object, public virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider, public Description<Win7TextListProvider>
			{
			public:
				Win7TextListProvider();
				~Win7TextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()override;
				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

			class Win7CheckTextListProvider : public Win7TextListProvider, public Description<Win7CheckTextListProvider>
			{
			public:
				Win7CheckTextListProvider();
				~Win7CheckTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

			class Win7RadioTextListProvider : public Win7TextListProvider, public Description<Win7RadioTextListProvider>
			{
			public:
				Win7RadioTextListProvider();
				~Win7RadioTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

#pragma warning(push)
#pragma warning(disable:4250)
			class Win7ListViewProvider : public Win7MultilineTextBoxProvider, public virtual controls::GuiListView::IStyleProvider, public Description<Win7ListViewProvider>
			{
			public:
				Win7ListViewProvider();
				~Win7ListViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiSelectableButton::IStyleController*		CreateColumnStyle()override;
				Color													GetPrimaryTextColor()override;
				Color													GetSecondaryTextColor()override;
				Color													GetItemSeparatorColor()override;
			};
			
			class Win7TreeViewProvider : public Win7MultilineTextBoxProvider, public virtual controls::GuiTreeView::IStyleProvider, public Description<Win7TreeViewProvider>
			{
			public:
				Win7TreeViewProvider();
				~Win7TreeViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()override;
				Color													GetTextColor()override;
			};
#pragma warning(pop)
		}
	}
}

#endif

/***********************************************************************
E:\Vczh_Shared\Code\Others\gac\Libraries\GacUI\Source\GacUI.h
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: 陈梓瀚(vczh)
GacUI Header Files and Common Namespaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUI
#define VCZH_PRESENTATION_GACUI



using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;

extern int SetupWindowsGDIRenderer();
extern int SetupWindowsDirect2DRenderer();

#endif
