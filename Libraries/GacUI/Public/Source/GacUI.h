/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: ³Âè÷å«(vczh)
***********************************************************************/
#include "Vlpp.h"

/***********************************************************************
GACVLPPREFERENCES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI Vczh Library++ 3.0 References

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACVLPPREFERENCES
#define VCZH_PRESENTATION_GACVLPPREFERENCES


#endif

/***********************************************************************
NATIVEWINDOW\GUITYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Common Types

Classes:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUITYPES
#define VCZH_PRESENTATION_GUITYPES


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Enumerations
***********************************************************************/
		
		namespace Alignment
		{
			enum Type
			{
				Left=0,
				Top=0,
				Center=1,
				Right=2,
				Bottom=2,
			};
		}

/***********************************************************************
TextPos
***********************************************************************/
		
		struct TextPos
		{
			int			row;
			int			column;

			TextPos()
				:row(0) ,column(0)
			{
			}

			TextPos(int _row, int _column)
				:row(_row) ,column(_column)
			{
			}

			int Compare(const TextPos& value)const
			{
				if(row<value.row) return -1;
				if(row>value.row) return 1;
				if(column<value.column) return -1;
				if(column>value.column) return 1;
				return 0;
			}

			bool operator==(const TextPos& value)const {return Compare(value)==0;}
			bool operator!=(const TextPos& value)const {return Compare(value)!=0;}
			bool operator<(const TextPos& value)const {return Compare(value)<0;}
			bool operator<=(const TextPos& value)const {return Compare(value)<=0;}
			bool operator>(const TextPos& value)const {return Compare(value)>0;}
			bool operator>=(const TextPos& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
Point
***********************************************************************/
		
		struct Point
		{
			int			x;
			int			y;

			Point()
				:x(0) ,y(0)
			{
			}

			Point(int _x, int _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Point point)const
			{
				return x==point.x && y==point.y;
			}

			bool operator!=(Point point)const
			{
				return x!=point.x || y!=point.y;
			}
		};

/***********************************************************************
Size
***********************************************************************/
		
		struct Size
		{
			int			x;
			int			y;

			Size()
				:x(0) ,y(0)
			{
			}

			Size(int _x, int _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Size size)const
			{
				return x==size.x && y==size.y;
			}

			bool operator!=(Size size)const
			{
				return x!=size.x || y!=size.y;
			}
		};

/***********************************************************************
Rectangle
***********************************************************************/
		
		struct Rect
		{
			int		x1;
			int		y1;
			int		x2;
			int		y2;

			Rect()
				:x1(0), y1(0), x2(0), y2(0)
			{
			}

			Rect(int _x1, int _y1, int _x2, int _y2)
				:x1(_x1), y1(_y1), x2(_x2), y2(_y2)
			{
			}

			Rect(Point p, Size s)
				:x1(p.x), y1(p.y), x2(p.x+s.x), y2(p.y+s.y)
			{
			}

			bool operator==(Rect rect)const
			{
				return x1==rect.x1 && y1==rect.y1 && x2==rect.x2 && y2==rect.y2;
			}

			bool operator!=(Rect rect)const
			{
				return x1!=rect.x1 || y1!=rect.y1 || x2!=rect.x2 || y2!=rect.y2;
			}

			Point LeftTop()const
			{
				return Point(x1, y1);
			}

			Point RightBottom()const
			{
				return Point(x2, y2);
			}

			Size GetSize()const
			{
				return Size(x2-x1, y2-y1);
			}

			int Left()const
			{
				return x1;
			}

			int Right()const
			{
				return x2;
			}

			int Width()const
			{
				return x2-x1;
			}

			int Top()const
			{
				return y1;
			}

			int Bottom()const
			{
				return y2;
			}

			int Height()const
			{
				return y2-y1;
			}

			void Expand(int x, int y)
			{
				x1-=x;
				y1-=y;
				x2+=x;
				y2+=y;
			}

			void Expand(Size s)
			{
				x1-=s.x;
				y1-=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			void Move(int x, int y)
			{
				x1+=x;
				y1+=y;
				x2+=x;
				y2+=y;
			}

			void Move(Size s)
			{
				x1+=s.x;
				y1+=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			bool Contains(Point p)
			{
				return x1<=p.x && p.x<x2 && y1<=p.y && p.y<y2;
			}
		};

/***********************************************************************
2D operations
***********************************************************************/

		inline Point operator+(Point p, Size s)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator+(Size s, Point p)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator-(Point p, Size s)
		{
			return Point(p.x-s.x, p.y-s.y);
		}

		inline Size operator-(Point p1, Point p2)
		{
			return Size(p1.x-p2.x, p1.y-p2.y);
		}

		inline Size operator+(Size s1, Size s2)
		{
			return Size(s1.x+s2.x, s1.y+s2.y);
		}

		inline Size operator-(Size s1, Size s2)
		{
			return Size(s1.x-s2.x, s1.y-s2.y);
		}

		inline Size operator*(Size s, int i)
		{
			return Size(s.x*i, s.y*i);
		}

		inline Size operator/(Size s, int i)
		{
			return Size(s.x/i, s.y/i);
		}

		inline Point operator+=(Point& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Point operator-=(Point& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

		inline Size operator+=(Size& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Size operator-=(Size& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

/***********************************************************************
Color
***********************************************************************/
		
		struct Color
		{
			union
			{
				struct
				{
					unsigned char r;
					unsigned char g;
					unsigned char b;
					unsigned char a;
				};
				unsigned __int32 value;
			};

			Color()
				:r(0), g(0), b(0), a(255)
			{
			}

			Color(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a=255)
				:r(_r), g(_g), b(_b), a(_a)
			{
			}

			int Compare(Color color)const
			{
				return value-color.value;
			}

			bool operator==(Color color)const {return Compare(color)==0;}
			bool operator!=(Color color)const {return Compare(color)!=0;}
			bool operator<(Color color)const {return Compare(color)<0;}
			bool operator<=(Color color)const {return Compare(color)<=0;}
			bool operator>(Color color)const {return Compare(color)>0;}
			bool operator>=(Color color)const {return Compare(color)>=0;}
		};

/***********************************************************************
Margin
***********************************************************************/
		
		struct Margin
		{
			int		left;
			int		top;
			int		right;
			int		bottom;

			Margin()
				:left(0), top(0), right(0), bottom(0)
			{
			}

			Margin(int _left, int _top, int _right, int _bottom)
				:left(_left), top(_top), right(_right), bottom(_bottom)
			{
			}

			bool operator==(Margin margin)const
			{
				return left==margin.left && top==margin.top && right==margin.right && bottom==margin.bottom;
			}

			bool operator!=(Margin margin)const
			{
				return left!=margin.left || top!=margin.top || right!=margin.right || bottom!=margin.bottom;
			}
		};

/***********************************************************************
Resources
***********************************************************************/
		
		struct FontProperties
		{
			WString				fontFamily;
			int					size;
			bool				bold;
			bool				italic;
			bool				underline;
			bool				strikeline;
			bool				antialias;
			bool				verticalAntialias;

			FontProperties()
				:size(0)
				,bold(false)
				,italic(false)
				,underline(false)
				,strikeline(false)
				,antialias(true)
				,verticalAntialias(false)
			{
			}
			
			int Compare(const FontProperties& value)const
			{
				int result=0;
				
				result=WString::Compare(fontFamily, value.fontFamily);
				if(result!=0) return result;

				result=size-value.size;
				if(result!=0) return result;

				result=(int)bold-(int)value.bold;
				if(result!=0) return result;

				result=(int)italic-(int)value.italic;
				if(result!=0) return result;

				result=(int)underline-(int)value.underline;
				if(result!=0) return result;

				result=(int)strikeline-(int)value.strikeline;
				if(result!=0) return result;

				result=(int)antialias-(int)value.antialias;
				if(result!=0) return result;

				return 0;
			}

			bool operator==(const FontProperties& value)const {return Compare(value)==0;}
			bool operator!=(const FontProperties& value)const {return Compare(value)!=0;}
			bool operator<(const FontProperties& value)const {return Compare(value)<0;}
			bool operator<=(const FontProperties& value)const {return Compare(value)<=0;}
			bool operator>(const FontProperties& value)const {return Compare(value)>0;}
			bool operator>=(const FontProperties& value)const {return Compare(value)>=0;}
		};
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\GUINATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window

Interfaces:
  INativeWindow							£º´°¿ÚÊÊÅäÆ÷
  INativeWindowListener					£º´°¿ÚÊÂ¼þ¼àÌýÆ÷
  INativeController						£ºÈ«¾Ö¿ØÖÆÆ÷
  INativeControllerListener				£ºÈ«¾ÖÊÂ¼þ¼àÌýÆ÷

Renderers:
  GUI_GRAPHICS_RENDERER_GDI
  GUI_GRAPHICS_RENDERER_DIRECT2D
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUINATIVEWINDOW
#define VCZH_PRESENTATION_GUINATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		class INativeWindow;
		class INativeWindowListener;
		class INativeController;
		class INativeControllerListener;

/***********************************************************************
System Object
***********************************************************************/

		class INativeScreen : public Interface
		{
		public:
			virtual Rect				GetBounds()=0;
			virtual Rect				GetClientBounds()=0;
			virtual WString				GetName()=0;
			virtual bool				IsPrimary()=0;
		};
		
		class INativeCursor : public Interface
		{
		public:
			enum SystemCursorType
			{
				SmallWaiting,
				LargeWaiting,
				Arrow,
				Cross,
				Hand,
				Help,
				IBeam,
				SizeAll,
				SizeNESW,
				SizeNS,
				SizeNWSE,
				SizeWE,
				LastSystemCursor=SizeWE,
			};

			static const int			SystemCursorCount=LastSystemCursor+1;
		public:
			virtual bool				IsSystemCursor()=0;
			virtual SystemCursorType	GetSystemCursorType()=0;
		};

/***********************************************************************
Image Object
***********************************************************************/

		class INativeImageService;
		class INativeImage;
		class INativeImageFrame;
		
		class INativeImageFrameCache : public Interface
		{
		public:
			virtual void						OnAttach(INativeImageFrame* frame)=0;
			virtual void						OnDetach(INativeImageFrame* frame)=0;
		};

		class INativeImageFrame : public Interface
		{
		public:
			virtual INativeImage*				GetImage()=0;
			virtual Size						GetSize()=0;

			virtual bool						SetCache(void* key, Ptr<INativeImageFrameCache> cache)=0;
			virtual Ptr<INativeImageFrameCache>	GetCache(void* key)=0;
			virtual Ptr<INativeImageFrameCache>	RemoveCache(void* key)=0;
		};
		
		class INativeImage : public Interface
		{
		public:
			enum FormatType
			{
				Bmp,
				Gif,
				Icon,
				Jpeg,
				Png,
				Tiff,
				Wmp,
				Unknown,
			};
			
			virtual INativeImageService*		GetImageService()=0;
			virtual FormatType					GetFormat()=0;
			virtual int							GetFrameCount()=0;
			virtual INativeImageFrame*			GetFrame(int index)=0;
		};
		
		class INativeImageService : public Interface
		{
		public:
			virtual Ptr<INativeImage>			CreateImageFromFile(const WString& path)=0;
		};

/***********************************************************************
Native Window
***********************************************************************/
		
		class INativeWindow : public Interface
		{
		public:
			virtual Rect				GetBounds()=0;
			virtual void				SetBounds(const Rect& bounds)=0;
			virtual Size				GetClientSize()=0;
			virtual void				SetClientSize(Size size)=0;
			virtual Rect				GetClientBoundsInScreen()=0;
			
			virtual WString				GetTitle()=0;
			virtual void				SetTitle(WString title)=0;
			virtual INativeCursor*		GetWindowCursor()=0;
			virtual void				SetWindowCursor(INativeCursor* cursor)=0;
			virtual Point				GetCaretPoint()=0;
			virtual void				SetCaretPoint(Point point)=0;
			
			virtual INativeWindow*		GetParent()=0;
			virtual void				SetParent(INativeWindow* parent)=0;
			virtual bool				GetAlwaysPassFocusToParent()=0;
			virtual void				SetAlwaysPassFocusToParent(bool value)=0;

			virtual void				Show()=0;
			virtual void				ShowDeactivated()=0;
			virtual void				ShowRestored()=0;
			virtual void				ShowMaximized()=0;
			virtual void				ShowMinimized()=0;
			virtual void				Hide()=0;
			virtual bool				IsVisible()=0;

			virtual void				Enable()=0;
			virtual void				Disable()=0;
			virtual bool				IsEnabled()=0;
			
			virtual void				SetFocus()=0;
			virtual bool				IsFocused()=0;
			virtual void				SetActivate()=0;
			virtual bool				IsActivated()=0;
			
			virtual void				ShowInTaskBar()=0;
			virtual void				HideInTaskBar()=0;
			virtual bool				IsAppearedInTaskBar()=0;
			
			virtual void				EnableActivate()=0;
			virtual void				DisableActivate()=0;
			virtual bool				IsEnabledActivate()=0;
			
			virtual bool				RequireCapture()=0;
			virtual bool				ReleaseCapture()=0;

			virtual bool				GetMaximizedBox()=0;
			virtual void				SetMaximizedBox(bool visible)=0;
			virtual bool				GetMinimizedBox()=0;
			virtual void				SetMinimizedBox(bool visible)=0;
			virtual bool				GetBorder()=0;
			virtual void				SetBorder(bool visible)=0;
			virtual bool				GetSizeBox()=0;
			virtual void				SetSizeBox(bool visible)=0;
			virtual bool				GetIconVisible()=0;
			virtual void				SetIconVisible(bool visible)=0;
			virtual bool				GetTitleBar()=0;
			virtual void				SetTitleBar(bool visible)=0;
			virtual bool				GetTopMost()=0;
			virtual void				SetTopMost(bool topmost)=0;
			
			virtual bool				InstallListener(INativeWindowListener* listener)=0;
			virtual bool				UninstallListener(INativeWindowListener* listener)=0;
			virtual void				RedrawContent()=0;
		};

		struct NativeWindowMouseInfo
		{
			bool						ctrl;
			bool						shift;
			bool						left;
			bool						middle;
			bool						right;
			int							x;
			int							y;
			int							wheel;
		};
		
		struct NativeWindowKeyInfo
		{
			int							code;
			bool						ctrl;
			bool						shift;
			bool						alt;
			bool						capslock;
		};
		
		struct NativeWindowCharInfo
		{
			wchar_t						code;
			bool						ctrl;
			bool						shift;
			bool						alt;
			bool						capslock;
		};
		
		class INativeWindowListener : public Interface
		{
		public:
			virtual void				Moving(Rect& bounds, bool fixSizeOnly);
			virtual void				Moved();
			virtual void				Enabled();
			virtual void				Disabled();
			virtual void				GotFocus();
			virtual void				LostFocus();
			virtual void				Activated();
			virtual void				Deactivated();
			virtual void				Opened();
			virtual void				Closing(bool& cancel);
			virtual void				Closed();
			virtual void				Paint();
			virtual void				Destroying();
			virtual void				Destroyed();
			
			virtual void				LeftButtonDown(const NativeWindowMouseInfo& info);
			virtual void				LeftButtonUp(const NativeWindowMouseInfo& info);
			virtual void				LeftButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				RightButtonDown(const NativeWindowMouseInfo& info);
			virtual void				RightButtonUp(const NativeWindowMouseInfo& info);
			virtual void				RightButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonDown(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonUp(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				HorizontalWheel(const NativeWindowMouseInfo& info);
			virtual void				VerticalWheel(const NativeWindowMouseInfo& info);
			virtual void				MouseMoving(const NativeWindowMouseInfo& info);
			virtual void				MouseEntered();
			virtual void				MouseLeaved();
			
			virtual void				KeyDown(const NativeWindowKeyInfo& info);
			virtual void				KeyUp(const NativeWindowKeyInfo& info);
			virtual void				SysKeyDown(const NativeWindowKeyInfo& info);
			virtual void				SysKeyUp(const NativeWindowKeyInfo& info);
			virtual void				Char(const NativeWindowCharInfo& info);
		};

/***********************************************************************
Native Window Services
***********************************************************************/

		class INativeResourceService : public virtual Interface
		{
		public:
			virtual INativeCursor*			GetSystemCursor(INativeCursor::SystemCursorType type)=0;
			virtual INativeCursor*			GetDefaultSystemCursor()=0;

			virtual FontProperties			GetDefaultFont()=0;
			virtual void					SetDefaultFont(const FontProperties& value)=0;
		};
		
		class INativeAsyncService : public virtual Interface
		{
		public:
			typedef void (AsyncTaskProc)(void* arguments);

			virtual bool					IsInMainThread()=0;
			virtual void					InvokeAsync(AsyncTaskProc* proc, void* argument)=0;
			virtual void					InvokeInMainThread(AsyncTaskProc* proc, void* argument)=0;
			virtual bool					InvokeInMainThreadAndWait(AsyncTaskProc* proc, void* argument, int milliseconds=-1)=0;
		};
		
		class INativeClipboardService : public virtual Interface
		{
		public:
			virtual bool					ContainsText()=0;
			virtual WString					GetText()=0;
			virtual bool					SetText(const WString& value)=0;
		};
		
		class INativeScreenService : public virtual Interface
		{
		public:
			virtual int						GetScreenCount()=0;
			virtual INativeScreen*			GetScreen(int index)=0;
			virtual INativeScreen*			GetScreen(INativeWindow* window)=0;
		};
		
		class INativeWindowService : public virtual Interface
		{
		public:
			virtual INativeWindow*			CreateNativeWindow()=0;
			virtual void					DestroyNativeWindow(INativeWindow* window)=0;
			virtual INativeWindow*			GetMainWindow()=0;
			virtual INativeWindow*			GetWindow(Point location)=0;
			virtual void					Run(INativeWindow* window)=0;
		};
		
		class INativeInputService : public virtual Interface
		{
		public:
			virtual void					StartHookMouse()=0;
			virtual void					StopHookMouse()=0;
			virtual bool					IsHookingMouse()=0;
			
			virtual void					StartTimer()=0;
			virtual void					StopTimer()=0;
			virtual bool					IsTimerEnabled()=0;
			
			virtual bool					IsKeyPressing(int code)=0;
			virtual bool					IsKeyToggled(int code)=0;
		};
		
		class INativeCallbackService : public virtual Interface
		{
		public:
			virtual bool					InstallListener(INativeControllerListener* listener)=0;
			virtual bool					UninstallListener(INativeControllerListener* listener)=0;
		};

/***********************************************************************
Native Window Controller
***********************************************************************/

		class INativeController : public virtual Interface
		{
		public:
			virtual INativeCallbackService*			CallbackService()=0;
			virtual INativeResourceService*			ResourceService()=0;
			virtual INativeAsyncService*			AsyncService()=0;
			virtual INativeClipboardService*		ClipboardService()=0;
			virtual INativeImageService*			ImageService()=0;
			virtual INativeScreenService*			ScreenService()=0;
			virtual INativeWindowService*			WindowService()=0;
			virtual INativeInputService*			InputService()=0;
		};
		
		class INativeControllerListener : public Interface
		{
		public:
			virtual void					LeftButtonDown(Point position);
			virtual void					LeftButtonUp(Point position);
			virtual void					RightButtonDown(Point position);
			virtual void					RightButtonUp(Point position);
			virtual void					MouseMoving(Point position);
			virtual void					GlobalTimer();
			virtual void					ClipboardUpdated();
			virtual void					NativeWindowCreated(INativeWindow* window);
			virtual void					NativeWindowDestroying(INativeWindow* window);
		};

		extern								INativeController* GetCurrentController();
		extern void							SetCurrentController(INativeController* controller);
	}
}

/***********************************************************************
Native Window Provider
***********************************************************************/

/*
 * Virtual Keys, Standard Set
 */
#define VKEY_LBUTTON        0x01
#define VKEY_RBUTTON        0x02
#define VKEY_CANCEL         0x03
#define VKEY_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VKEY_XBUTTON1       0x05    /* NOT contiguous with L & RBUTTON */
#define VKEY_XBUTTON2       0x06    /* NOT contiguous with L & RBUTTON */

/*
 * 0x07 : unassigned
 */

#define VKEY_BACK           0x08
#define VKEY_TAB            0x09

/*
 * 0x0A - 0x0B : reserved
 */

#define VKEY_CLEAR          0x0C
#define VKEY_RETURN         0x0D

#define VKEY_SHIFT          0x10
#define VKEY_CONTROL        0x11
#define VKEY_MENU           0x12
#define VKEY_PAUSE          0x13
#define VKEY_CAPITAL        0x14

#define VKEY_KANA           0x15
#define VKEY_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VKEY_HANGUL         0x15
#define VKEY_JUNJA          0x17
#define VKEY_FINAL          0x18
#define VKEY_HANJA          0x19
#define VKEY_KANJI          0x19

#define VKEY_ESCAPE         0x1B

#define VKEY_CONVERT        0x1C
#define VKEY_NONCONVERT     0x1D
#define VKEY_ACCEPT         0x1E
#define VKEY_MODECHANGE     0x1F

#define VKEY_SPACE          0x20
#define VKEY_PRIOR          0x21
#define VKEY_NEXT           0x22
#define VKEY_END            0x23
#define VKEY_HOME           0x24
#define VKEY_LEFT           0x25
#define VKEY_UP             0x26
#define VKEY_RIGHT          0x27
#define VKEY_DOWN           0x28
#define VKEY_SELECT         0x29
#define VKEY_PRINT          0x2A
#define VKEY_EXECUTE        0x2B
#define VKEY_SNAPSHOT       0x2C
#define VKEY_INSERT         0x2D
#define VKEY_DELETE         0x2E
#define VKEY_HELP           0x2F

/*
 * VKEY_0 - VKEY_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
 * 0x40 : unassigned
 * VKEY_A - VKEY_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
 */

#define VKEY_LWIN           0x5B
#define VKEY_RWIN           0x5C
#define VKEY_APPS           0x5D

/*
 * 0x5E : reserved
 */

#define VKEY_SLEEP          0x5F

#define VKEY_NUMPAD0        0x60
#define VKEY_NUMPAD1        0x61
#define VKEY_NUMPAD2        0x62
#define VKEY_NUMPAD3        0x63
#define VKEY_NUMPAD4        0x64
#define VKEY_NUMPAD5        0x65
#define VKEY_NUMPAD6        0x66
#define VKEY_NUMPAD7        0x67
#define VKEY_NUMPAD8        0x68
#define VKEY_NUMPAD9        0x69
#define VKEY_MULTIPLY       0x6A
#define VKEY_ADD            0x6B
#define VKEY_SEPARATOR      0x6C
#define VKEY_SUBTRACT       0x6D
#define VKEY_DECIMAL        0x6E
#define VKEY_DIVIDE         0x6F
#define VKEY_F1             0x70
#define VKEY_F2             0x71
#define VKEY_F3             0x72
#define VKEY_F4             0x73
#define VKEY_F5             0x74
#define VKEY_F6             0x75
#define VKEY_F7             0x76
#define VKEY_F8             0x77
#define VKEY_F9             0x78
#define VKEY_F10            0x79
#define VKEY_F11            0x7A
#define VKEY_F12            0x7B
#define VKEY_F13            0x7C
#define VKEY_F14            0x7D
#define VKEY_F15            0x7E
#define VKEY_F16            0x7F
#define VKEY_F17            0x80
#define VKEY_F18            0x81
#define VKEY_F19            0x82
#define VKEY_F20            0x83
#define VKEY_F21            0x84
#define VKEY_F22            0x85
#define VKEY_F23            0x86
#define VKEY_F24            0x87

/*
 * 0x88 - 0x8F : unassigned
 */

#define VKEY_NUMLOCK        0x90
#define VKEY_SCROLL         0x91

/*
 * NEC PC-9800 kbd definitions
 */
#define VKEY_OEM_NEC_EQUAL  0x92   // '=' key on numpad

/*
 * Fujitsu/OASYS kbd definitions
 */
#define VKEY_OEM_FJ_JISHO   0x92   // 'Dictionary' key
#define VKEY_OEM_FJ_MASSHOU 0x93   // 'Unregister word' key
#define VKEY_OEM_FJ_TOUROKU 0x94   // 'Register word' key
#define VKEY_OEM_FJ_LOYA    0x95   // 'Left OYAYUBI' key
#define VKEY_OEM_FJ_ROYA    0x96   // 'Right OYAYUBI' key

/*
 * 0x97 - 0x9F : unassigned
 */

/*
 * VKEY_L* & VKEY_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VKEY_LSHIFT         0xA0
#define VKEY_RSHIFT         0xA1
#define VKEY_LCONTROL       0xA2
#define VKEY_RCONTROL       0xA3
#define VKEY_LMENU          0xA4
#define VKEY_RMENU          0xA5

#define VKEY_BROWSER_BACK        0xA6
#define VKEY_BROWSER_FORWARD     0xA7
#define VKEY_BROWSER_REFRESH     0xA8
#define VKEY_BROWSER_STOP        0xA9
#define VKEY_BROWSER_SEARCH      0xAA
#define VKEY_BROWSER_FAVORITES   0xAB
#define VKEY_BROWSER_HOME        0xAC

#define VKEY_VOLUME_MUTE         0xAD
#define VKEY_VOLUME_DOWN         0xAE
#define VKEY_VOLUME_UP           0xAF
#define VKEY_MEDIA_NEXT_TRACK    0xB0
#define VKEY_MEDIA_PREV_TRACK    0xB1
#define VKEY_MEDIA_STOP          0xB2
#define VKEY_MEDIA_PLAY_PAUSE    0xB3
#define VKEY_LAUNCH_MAIL         0xB4
#define VKEY_LAUNCH_MEDIA_SELECT 0xB5
#define VKEY_LAUNCH_APP1         0xB6
#define VKEY_LAUNCH_APP2         0xB7

/*
 * 0xB8 - 0xB9 : reserved
 */

#define VKEY_OEM_1          0xBA   // ';:' for US
#define VKEY_OEM_PLUS       0xBB   // '+' any country
#define VKEY_OEM_COMMA      0xBC   // ',' any country
#define VKEY_OEM_MINUS      0xBD   // '-' any country
#define VKEY_OEM_PERIOD     0xBE   // '.' any country
#define VKEY_OEM_2          0xBF   // '/?' for US
#define VKEY_OEM_3          0xC0   // '`~' for US

/*
 * 0xC1 - 0xD7 : reserved
 */

/*
 * 0xD8 - 0xDA : unassigned
 */

#define VKEY_OEM_4          0xDB  //  '[{' for US
#define VKEY_OEM_5          0xDC  //  '\|' for US
#define VKEY_OEM_6          0xDD  //  ']}' for US
#define VKEY_OEM_7          0xDE  //  ''"' for US
#define VKEY_OEM_8          0xDF

/*
 * 0xE0 : reserved
 */

/*
 * Various extended or enhanced keyboards
 */

#define VKEY_OEM_AX         0xE1  //  'AX' key on Japanese AX kbd
#define VKEY_OEM_102        0xE2  //  "<>" or "\|" on RT 102-key kbd.
#define VKEY_ICO_HELP       0xE3  //  Help key on ICO
#define VKEY_ICO_00         0xE4  //  00 key on ICO

#define VKEY_PROCESSKEY     0xE5
#define VKEY_ICO_CLEAR      0xE6
#define VKEY_PACKET         0xE7

/*
 * 0xE8 : unassigned
 */

/*
 * Nokia/Ericsson definitions
 */
#define VKEY_OEM_RESET      0xE9
#define VKEY_OEM_JUMP       0xEA
#define VKEY_OEM_PA1        0xEB
#define VKEY_OEM_PA2        0xEC
#define VKEY_OEM_PA3        0xED
#define VKEY_OEM_WSCTRL     0xEE
#define VKEY_OEM_CUSEL      0xEF
#define VKEY_OEM_ATTN       0xF0
#define VKEY_OEM_FINISH     0xF1
#define VKEY_OEM_COPY       0xF2
#define VKEY_OEM_AUTO       0xF3
#define VKEY_OEM_ENLW       0xF4
#define VKEY_OEM_BACKTAB    0xF5

#define VKEY_ATTN           0xF6
#define VKEY_CRSEL          0xF7
#define VKEY_EXSEL          0xF8
#define VKEY_EREOF          0xF9
#define VKEY_PLAY           0xFA
#define VKEY_ZOOM           0xFB
#define VKEY_NONAME         0xFC
#define VKEY_PA1            0xFD
#define VKEY_OEM_CLEAR      0xFE

#endif

/***********************************************************************
REFLECTION\GUITYPEDESCRIPTOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Reflection

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUITYPEDESCRIPTOR
#define VCZH_PRESENTATION_REFLECTION_GUITYPEDESCRIPTOR


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Attribute
***********************************************************************/
		namespace description
		{
			class ITypeDescriptor;
		}

		class DescriptableObject
		{
			template<typename T>
			friend class Description;

			friend class DescriptableValue;
		protected:
			size_t									objectSize;
			description::ITypeDescriptor**			typeDescriptor;
		public:
			DescriptableObject();
			virtual ~DescriptableObject();
		};

		class IDescriptable : public virtual Interface, public virtual DescriptableObject
		{
		public:
			~IDescriptable(){}
		};
		
		template<typename T>
		class Description : public virtual DescriptableObject
		{
		protected:
			static description::ITypeDescriptor*		associatedTypeDescriptor;
		public:
			Description()
			{
				if(objectSize<sizeof(T))
				{
					objectSize=sizeof(T);
					typeDescriptor=&associatedTypeDescriptor;
				}
			}

			static void SetTypeDescroptor(description::ITypeDescriptor* typeDescroptor)
			{
				if(!associatedTypeDescriptor)
				{
					associatedTypeDescriptor=typeDescroptor;
				}
			}
		};

		template<typename T>
		description::ITypeDescriptor* Description<T>::associatedTypeDescriptor=0;

/***********************************************************************
Value
***********************************************************************/

		namespace description
		{
			class Value : public Object
			{
			public:
				enum ValueType
				{
					Null,
					DescriptableObjectRef,
					DescriptableObjectPtr,
					Text,
				};
			protected:
				ValueType						valueType;
				DescriptableObject*				descriptableObjectRef;
				Ptr<DescriptableObject>			descriptableObjectPtr;
				WString							text;
			public:
				Value();
				Value(DescriptableObject* value);
				Value(Ptr<DescriptableObject> value);
				Value(const WString& value);
				Value(const Value& value);

				Value&							operator=(const Value& value);

				ValueType						GetValueType()const;
				DescriptableObject*				GetDescriptableObjectRef()const;
				Ptr<DescriptableObject>			GetDescriptableObjectPtr()const;
				const WString&					GetText()const;
			};

			class IValueSerializer : public Interface
			{
			public:
				virtual WString					GetName()=0;
				virtual bool					Validate(const Value& value)=0;
			};

			template<typename T>
			class ITypedValueSerializer : public IValueSerializer
			{
				virtual bool					Serialize(const T& input, Value& value)=0;
				virtual bool					Deserialize(T& output, const Value& value)=0;
			};

/***********************************************************************
ITypeDescriptor
***********************************************************************/

			class IMethodInfo;
			class IMethodGroupInfo;

			class IMemberInfo : public Interface
			{
			public:
				virtual ITypeDescriptor*		GetOwnerTypeDescriptor()=0;
				virtual const WString&			GetName()=0;
			};

			class IValueInfo : public Interface
			{
			public:
				virtual Value::ValueType		GetExpectedValueType()=0;
				virtual IValueSerializer*		GetExpectedValueSerializer()=0;
				virtual ITypeDescriptor*		GetExpectedTypeDescriptor()=0;
				virtual bool					CanBeNull()=0;
			};

			class IPropertyInfo : public IMemberInfo, public IValueInfo
			{
			public:
				virtual Value					GetValue(Value thisObject)=0;
				virtual void					SetValue(Value thisObject, Value newValue)=0;
			};

			class IParameterInfo : public IMemberInfo, public IValueInfo
			{
			public:
				virtual IMethodInfo*			GetOwnerMethod()=0;
				virtual bool					CanOutput()=0;
			};

			class IMethodInfo : public IMemberInfo
			{
			public:
				virtual IMethodGroupInfo*		GetOwnerMethodGroup()=0;
				virtual int						GetParameterCount()=0;
				virtual IParameterInfo*			GetParameter(int index)=0;
				virtual IValueInfo*				GetReturn()=0;
				virtual Value					Invoke(Value thisObject, const collections::IReadonlyList<Value>& arguments)=0;
			};

			class IMethodGroupInfo : public IMemberInfo
			{
			public:
				virtual const WString&			GetName()=0;
				virtual int						GetMethodCount()=0;
				virtual IMethodInfo*			GetMethod(int index)=0;
			};

			class ITypeDescriptor : public Interface
			{
			public:
				virtual int						GetBaseTypeDescriptorCount()=0;
				virtual ITypeDescriptor*		GetBaseTypeDescriptor(int index)=0;

				virtual int						GetPropertyCount()=0;
				virtual IPropertyInfo*			GetProperty(int index)=0;
				virtual bool					IsPropertyExists(const WString& name, bool inheritance)=0;
				virtual IPropertyInfo*			GetPropertyByName(const WString& name, bool inheritance)=0;

				virtual int						GetMethodGroupCount()=0;
				virtual IMethodGroupInfo*		GetMethodGroup(int index)=0;
				virtual bool					IsMethodGroupExists(const WString& name, bool inheritance)=0;
				virtual IMethodGroupInfo*		GetMethodGroupByName(const WString& name, bool inheritance)=0;
				virtual IMethodGroupInfo*		GetConstructorGroup()=0;
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			class IGuiGraphicsElement;
			class IGuiGraphicsElementFactory;
			class IGuiGraphicsRenderer;
			class IGuiGraphicsRendererFactory;
			class IGuiGraphicsRenderTarget;

/***********************************************************************
Basic Construction
***********************************************************************/

			class IGuiGraphicsElement : public virtual IDescriptable, public Description<IGuiGraphicsElement>
			{
			public:
				virtual IGuiGraphicsElementFactory*		GetFactory()=0;
				virtual IGuiGraphicsRenderer*			GetRenderer()=0;
			};

			class IGuiGraphicsElementFactory : public Interface
			{
			public:
				virtual WString							GetElementTypeName()=0;
				virtual IGuiGraphicsElement*			Create()=0;
			};

			class IGuiGraphicsRenderer : public Interface
			{
			public:
				virtual IGuiGraphicsRendererFactory*	GetFactory()=0;

				virtual void							Initialize(IGuiGraphicsElement* element)=0;
				virtual void							Finalize()=0;
				virtual void							SetRenderTarget(IGuiGraphicsRenderTarget* renderTarget)=0;
				virtual void							Render(Rect bounds)=0;
				virtual void							OnElementStateChanged()=0;
				virtual Size							GetMinSize()=0;
			};

			class IGuiGraphicsRendererFactory : public Interface
			{
			public:
				virtual IGuiGraphicsRenderer*			Create()=0;
			};

			class IGuiGraphicsRenderTarget : public Interface
			{
			public:
				virtual void							StartRendering()=0;
				virtual void							StopRendering()=0;
				virtual void							PushClipper(Rect clipper)=0;
				virtual void							PopClipper()=0;
				virtual Rect							GetClipper()=0;
				virtual bool							IsClipperCoverWholeTarget()=0;
			};

/***********************************************************************
Resource Manager
***********************************************************************/

			class GuiGraphicsResourceManager : public Object
			{
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsElementFactory>>		elementFactoryMap;
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsRendererFactory>>		rendererFactoryMap;
			protected:
				elementFactoryMap						elementFactories;
				rendererFactoryMap						rendererFactories;
			public:
				GuiGraphicsResourceManager();
				~GuiGraphicsResourceManager();

				virtual bool							RegisterElementFactory(IGuiGraphicsElementFactory* factory);
				virtual bool							RegisterRendererFactory(const WString& elementTypeName, IGuiGraphicsRendererFactory* factory);
				virtual IGuiGraphicsElementFactory*		GetElementFactory(const WString& elementTypeName);
				virtual IGuiGraphicsRendererFactory*	GetRendererFactory(const WString& elementTypeName);
				virtual IGuiGraphicsRenderTarget*		GetRenderTarget(INativeWindow* window)=0;
			};

			extern GuiGraphicsResourceManager*			GetGuiGraphicsResourceManager();
			extern void									SetGuiGraphicsResourceManager(GuiGraphicsResourceManager* resourceManager);
			extern bool									RegisterFactories(IGuiGraphicsElementFactory* elementFactory, IGuiGraphicsRendererFactory* rendererFactory);

/***********************************************************************
Helpers
***********************************************************************/

#define DEFINE_GUI_GRAPHICS_ELEMENT(TELEMENT, ELEMENT_TYPE_NAME)\
			public:\
				class Factory : public Object, public IGuiGraphicsElementFactory\
				{\
				public:\
					WString GetElementTypeName()\
					{\
						return TELEMENT::GetElementTypeName();\
					}\
					IGuiGraphicsElement* Create()\
					{\
						TELEMENT* element=new TELEMENT;\
						element->factory=this;\
						element->renderer=GetGuiGraphicsResourceManager()->GetRendererFactory(GetElementTypeName())->Create();\
						element->renderer->Initialize(element);\
						return element;\
					}\
				};\
			protected:\
				IGuiGraphicsElementFactory*		factory;\
				Ptr<IGuiGraphicsRenderer>		renderer;\
			public:\
				static WString GetElementTypeName()\
				{\
					return ELEMENT_TYPE_NAME;\
				}\
				static TELEMENT* Create()\
				{\
					return dynamic_cast<TELEMENT*>(GetGuiGraphicsResourceManager()->GetElementFactory(TELEMENT::GetElementTypeName())->Create());\
				}\
				IGuiGraphicsElementFactory* GetFactory()override\
				{\
					return factory;\
				}\
				IGuiGraphicsRenderer* GetRenderer()override\
				{\
					return renderer.Obj();\
				}\

#define DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, TTARGET)\
			public:\
				class Factory : public Object, public IGuiGraphicsRendererFactory\
				{\
				public:\
					IGuiGraphicsRenderer* Create()\
					{\
						TRENDERER* renderer=new TRENDERER;\
						renderer->factory=this;\
						renderer->element=0;\
						renderer->renderTarget=0;\
						return renderer;\
					}\
				};\
			protected:\
				IGuiGraphicsRendererFactory*	factory;\
				TELEMENT*						element;\
				TTARGET*						renderTarget;\
				Size							minSize;\
			public:\
				static void Register()\
				{\
					RegisterFactories(new TELEMENT::Factory, new TRENDERER::Factory);\
				}\
				IGuiGraphicsRendererFactory* GetFactory()override\
				{\
					return factory;\
				}\
				void Initialize(IGuiGraphicsElement* _element)override\
				{\
					element=dynamic_cast<TELEMENT*>(_element);\
					InitializeInternal();\
				}\
				void Finalize()override\
				{\
					FinalizeInternal();\
				}\
				void SetRenderTarget(IGuiGraphicsRenderTarget* _renderTarget)override\
				{\
					TTARGET* oldRenderTarget=renderTarget;\
					renderTarget=dynamic_cast<TTARGET*>(_renderTarget);\
					RenderTargetChangedInternal(oldRenderTarget, renderTarget);\
				}\
				Size GetMinSize()override\
				{\
					return minSize;\
				}\

#define DEFINE_CACHED_RESOURCE_ALLOCATOR(TKEY, TVALUE)\
			public:\
				static const int DeadPackageMax=32;\
				struct Package\
				{\
					TVALUE							resource;\
					int								counter;\
					bool operator==(const Package& package)const{return false;}\
					bool operator!=(const Package& package)const{return true;}\
				};\
				struct DeadPackage\
				{\
					TKEY							key;\
					TVALUE							value;\
					bool operator==(const DeadPackage& package)const{return false;}\
					bool operator!=(const DeadPackage& package)const{return true;}\
				};\
				Dictionary<TKEY, Package>			aliveResources;\
				List<DeadPackage>					deadResources;\
			public:\
				TVALUE Create(const TKEY& key)\
				{\
					int index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values()[index];\
						package.counter++;\
						aliveResources.Set(key, package);\
						return package.resource;\
					}\
					TVALUE resource;\
					for(int i=0;i<deadResources.Count();i++)\
					{\
						if(deadResources[i].key==key)\
						{\
							DeadPackage deadPackage=deadResources[i];\
							deadResources.RemoveAt(i);\
							resource=deadPackage.value;\
							break;\
						}\
					}\
					if(!resource)\
					{\
						resource=CreateInternal(key);\
					}\
					Package package;\
					package.resource=resource;\
					package.counter=1;\
					aliveResources.Add(key, package);\
					return package.resource;\
				}\
				void Destroy(const TKEY& key)\
				{\
					int index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values()[index];\
						package.counter--;\
						if(package.counter==0)\
						{\
							aliveResources.Remove(key);\
							if(deadResources.Count()==DeadPackageMax)\
							{\
								deadResources.RemoveAt(DeadPackageMax-1);\
							}\
							DeadPackage deadPackage;\
							deadPackage.key=key;\
							deadPackage.value=package.resource;\
							deadResources.Insert(0, deadPackage);\
						}\
						else\
						{\
							aliveResources.Set(key, package);\
						}\
					}\
				}\

/***********************************************************************
Elements
***********************************************************************/

			namespace ElementShape
			{
				enum Type
				{
					Rectangle,
					Ellipse,
				};
			};

			class GuiSolidBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBorderElement, L"SolidBorder")
			protected:
				Color					color;
				ElementShape::Type		shape;

				GuiSolidBorderElement();
			public:
				~GuiSolidBorderElement();

				Color					GetColor();
				void					SetColor(Color value);
				ElementShape::Type		GetShape();
				void					SetShape(ElementShape::Type value);
			};
			
			class GuiRoundBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiRoundBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiRoundBorderElement, L"RoundBorder")
			protected:
				Color					color;
				int						radius;

				GuiRoundBorderElement();
			public:
				~GuiRoundBorderElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				
				int						GetRadius();
				void					SetRadius(int value);
			};
			
			class Gui3DBorderElement : public Object, public IGuiGraphicsElement, public Description<Gui3DBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DBorderElement, L"3DBorder")
			protected:
				Color					color1;
				Color					color2;

				Gui3DBorderElement();
			public:
				~Gui3DBorderElement();
				
				Color					GetColor1();
				Color					GetColor2();
				void					SetColors(Color value1, Color value2);
			};
			
			class Gui3DSplitterElement : public Object, public IGuiGraphicsElement, public Description<Gui3DSplitterElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DSplitterElement, L"3DSplitter")
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;

				Gui3DSplitterElement();
			public:
				~Gui3DSplitterElement();
				
				Color					GetColor1();
				Color					GetColor2();
				void					SetColors(Color value1, Color value2);
				
				Direction				GetDirection();
				void					SetDirection(Direction value);
			};

			class GuiSolidBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBackgroundElement, L"SolidBackground")
			protected:
				Color					color;
				ElementShape::Type		shape;

				GuiSolidBackgroundElement();
			public:
				~GuiSolidBackgroundElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				ElementShape::Type		GetShape();
				void					SetShape(ElementShape::Type value);
			};
			
			class GuiGradientBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiGradientBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiGradientBackgroundElement, L"GradientBackground")
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
					Slash,
					Backslash,
				};
			protected:
				Color					color1, color2;
				Direction				direction;
				ElementShape::Type		shape;

				GuiGradientBackgroundElement();
			public:
				~GuiGradientBackgroundElement();
				
				Color					GetColor1();
				Color					GetColor2();
				void					SetColors(Color value1, Color value2);
				
				Direction				GetDirection();
				void					SetDirection(Direction value);
				ElementShape::Type		GetShape();
				void					SetShape(ElementShape::Type value);
			};
			
			class GuiSolidLabelElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidLabelElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidLabelElement, L"SolidLabel");
			protected:
				Color					color;
				FontProperties			fontProperties;
				WString					text;
				Alignment::Type			hAlignment;
				Alignment::Type			vAlignment;
				bool					wrapLine;
				bool					ellipse;
				bool					multiline;

				GuiSolidLabelElement();
			public:
				~GuiSolidLabelElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				
				const FontProperties&	GetFont();
				void					SetFont(const FontProperties& value);
				
				const WString&			GetText();
				void					SetText(const WString& value);
				
				Alignment::Type			GetHorizontalAlignment();
				Alignment::Type			GetVerticalAlignment();
				void					SetAlignments(Alignment::Type horizontal, Alignment::Type vertical);
				
				bool					GetWrapLine();
				void					SetWrapLine(bool value);
				
				bool					GetEllipse();
				void					SetEllipse(bool value);
				
				bool					GetMultiline();
				void					SetMultiline(bool value);
			};

			class GuiImageFrameElement : public Object, public IGuiGraphicsElement, public Description<GuiImageFrameElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiImageFrameElement, L"ImageFrame");
			protected:
				Ptr<INativeImage>		image;
				int						frameIndex;
				Alignment::Type			hAlignment;
				Alignment::Type			vAlignment;
				bool					stretch;

				GuiImageFrameElement();
			public:
				~GuiImageFrameElement();

				Ptr<INativeImage>		GetImage();
				int						GetFrameIndex();
				void					SetImage(Ptr<INativeImage> _image, int _frameIndex=0);
				
				Alignment::Type			GetHorizontalAlignment();
				Alignment::Type			GetVerticalAlignment();
				void					SetAlignments(Alignment::Type horizontal, Alignment::Type vertical);

				bool					GetStretch();
				void					SetStretch(bool value);
			};

			class GuiPolygonElement : public Object, public IGuiGraphicsElement, public Description<GuiPolygonElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiPolygonElement, L"Polygon");
			protected:
				Size							size;
				collections::Array<Point>		points;
				Color							borderColor;
				Color							backgroundColor;

				GuiPolygonElement();
			public:
				~GuiPolygonElement();

				Size					GetSize();
				void					SetSize(Size value);

				const Point&			GetPoint(int index);
				int						GetPointCount();
				void					SetPoints(const Point* p, int count);
				
				Color					GetBorderColor();
				void					SetBorderColor(Color value);
				Color					GetBackgroundColor();
				void					SetBackgroundColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSTEXTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
ColorizedText
***********************************************************************/

			namespace text
			{
				struct CharAtt
				{
					unsigned __int32				rightOffset;
					unsigned __int32				colorIndex;
				};
				
				struct TextLine
				{
					static const int				BlockSize=32;
					static const int				MaxWidth=0xFFFF;
					
					wchar_t*						text;
					CharAtt*						att;
					int								availableOffsetCount;
					int								bufferLength;
					int								dataLength;
					int								lexerFinalState;
					int								contextFinalState;

					TextLine();
					~TextLine();

					static int						CalculateBufferLength(int dataLength);
					bool							operator==(const TextLine& value)const{return false;}
					bool							operator!=(const TextLine& value)const{return true;}

					void							Initialize();
					void							Finalize();
					bool							IsReady();
					bool							Modify(int start, int count, const wchar_t* input, int inputCount);
					TextLine						Split(int index);
					void							AppendAndFinalize(TextLine& line);
				};

				class CharMeasurer : public virtual IDescriptable
				{
				protected:
					IGuiGraphicsRenderTarget*		oldRenderTarget;
					int								rowHeight;
					int								widths[65536];
					
					virtual int						MeasureWidthInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)=0;
					virtual int						GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)=0;
				public:

					CharMeasurer(int _rowHeight);
					~CharMeasurer();

					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					int								MeasureWidth(wchar_t character);
					int								GetRowHeight();
				};

				struct TextLines
				{
					typedef collections::List<TextLine>		TextLineList;
				protected:
					TextLineList					lines;
					CharMeasurer*					charMeasurer;
					IGuiGraphicsRenderTarget*		renderTarget;
					int								tabWidth;
					int								tabSpaceCount;
					int								availableColorizedLines;
				public:
					TextLines();
					~TextLines();

					int								GetCount();
					TextLine&						GetLine(int row);
					int								GetAvailableColorizedLines();
					void							SetAvailableColorizedLines(int value);
					CharMeasurer*					GetCharMeasurer();
					void							SetCharMeasurer(CharMeasurer* value);
					IGuiGraphicsRenderTarget*		GetRenderTarget();
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					WString							GetText(TextPos start, TextPos end);
					WString							GetText();
					void							SetText(const WString& value);
					
					bool							RemoveLines(int start, int count);
					bool							IsAvailable(TextPos pos);
					TextPos							Normalize(TextPos pos);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t** inputs, int* inputCounts, int rows);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input, int inputCount);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input);
					TextPos							Modify(TextPos start, TextPos end, const WString& input);
					void							Clear();
					
					void							ClearMeasurement();
					int								GetTabSpaceCount();
					void							SetTabSpaceCount(int value);
					void							MeasureRow(int row);
					int								GetRowWidth(int row);
					int								GetRowHeight();
					int								GetMaxWidth();
					int								GetMaxHeight();
					TextPos							GetTextPosFromPoint(Point point);
					Point							GetPointFromTextPos(TextPos pos);
					Rect							GetRectFromTextPos(TextPos pos);
				};
				
				struct ColorItem
				{
					Color							text;
					Color							background;
				};
				
				struct ColorEntry
				{
					ColorItem						normal;
					ColorItem						selectedFocused;
					ColorItem						selectedUnfocused;

					bool							operator==(const ColorEntry& value){return false;}
					bool							operator!=(const ColorEntry& value){return true;}
				};
			}
			
			class GuiColorizedTextElement : public Object, public IGuiGraphicsElement, public Description<GuiColorizedTextElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiColorizedTextElement, L"ColorizedText");

				typedef collections::Array<text::ColorEntry>			ColorArray;
				typedef collections::IReadonlyList<text::ColorEntry>	IColorArray;
			public:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual void					ColorChanged()=0;
					virtual void					FontChanged()=0;
				};
			protected:
				ICallback*							callback;
				ColorArray							colors;
				FontProperties						font;
				Point								viewPosition;
				bool								isVisuallyEnabled;
				bool								isFocused;

				TextPos								caretBegin;
				TextPos								caretEnd;
				bool								caretVisible;
				Color								caretColor;

				text::TextLines						lines;

				GuiColorizedTextElement();
			public:
				~GuiColorizedTextElement();

				text::TextLines&					GetLines();
				ICallback*							GetCallback();
				void								SetCallback(ICallback* value);
				
				const IColorArray&					GetColors();
				void								SetColors(const ColorArray& value);
				const FontProperties&				GetFont();
				void								SetFont(const FontProperties& value);
				Point								GetViewPosition();
				void								SetViewPosition(Point value);
				bool								GetVisuallyEnabled();
				void								SetVisuallyEnabled(bool value);
				bool								GetFocused();
				void								SetFocused(bool value);
				
				TextPos								GetCaretBegin();
				void								SetCaretBegin(TextPos value);
				TextPos								GetCaretEnd();
				void								SetCaretEnd(TextPos value);
				bool								GetCaretVisible();
				void								SetCaretVisible(bool value);
				Color								GetCaretColor();
				void								SetCaretColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSEVENTRECEIVER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Event Model

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiGraphicsComposition;

/***********************************************************************
Event
***********************************************************************/

			template<typename T>
			class GuiGraphicsEvent : public Object, public Description<GuiGraphicsEvent<T>>
			{
			public:
				typedef void(RawFunctionType)(GuiGraphicsComposition*, T&);
				typedef Func<RawFunctionType>						FunctionType;

				class IHandler : public virtual IDescriptable, public Description<IHandler>
				{
				public:
					virtual void			Execute(GuiGraphicsComposition* sender, T& argument)=0;
				};
				
				class FunctionHandler : public Object, public IHandler
				{
				protected:
					FunctionType		handler;
				public:
					FunctionHandler(const FunctionType& _handler)
						:handler(_handler)
					{
					}

					void Execute(GuiGraphicsComposition* sender, T& argument)override
					{
						handler(sender, argument);
					}
				};
			protected:
				struct HandlerNode
				{
					Ptr<IHandler>					handler;
					Ptr<HandlerNode>				next;
				};

				GuiGraphicsComposition*				sender;
				Ptr<HandlerNode>					handlers;
			public:
				GuiGraphicsEvent(GuiGraphicsComposition* _sender=0)
					:sender(_sender)
				{
				}

				~GuiGraphicsEvent()
				{
				}

				GuiGraphicsComposition* GetAssociatedComposition()
				{
					return sender;
				}

				void SetAssociatedComposition(GuiGraphicsComposition* _sender)
				{
					sender=_sender;
				}

				bool Attach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							return false;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					(*currentHandler)=new HandlerNode;
					(*currentHandler)->handler=handler;
					return true;
				}

				template<typename TClass, typename TMethod>
				Ptr<IHandler> AttachMethod(TClass* receiver, TMethod TClass::* method)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(receiver, method));
					Attach(handler);
					return handler;
				}

				Ptr<IHandler> AttachFunction(RawFunctionType* function)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(function));
					Attach(handler);
					return handler;
				}

				Ptr<IHandler> AttachFunction(const FunctionType& function)
				{
					Ptr<IHandler> handler=new FunctionHandler(function);
					Attach(handler);
					return handler;
				}

				template<typename T>
				Ptr<IHandler> AttachLambda(const T& lambda)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(lambda));
					Attach(handler);
					return handler;
				}

				bool Detach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							Ptr<HandlerNode> next=(*currentHandler)->next;
							(*currentHandler)=next;
							return true;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					return false;
				}

				void Execute(T& argument)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						(*currentHandler)->handler->Execute(sender, argument);
						currentHandler=&(*currentHandler)->next;
					}
				}
			};

/***********************************************************************
Predefined Events
***********************************************************************/

			struct GuiEventArgs
			{
				GuiGraphicsComposition*		compositionSource;
				GuiGraphicsComposition*		eventSource;
				bool						handled;

				GuiEventArgs()
					:compositionSource(0)
					,eventSource(0)
					,handled(false)
				{
				}

				GuiEventArgs(GuiGraphicsComposition* composition)
					:compositionSource(composition)
					,eventSource(composition)
					,handled(false)
				{
				}
			};
			
			struct GuiRequestEventArgs : public GuiEventArgs
			{
				bool		cancel;
				
				GuiRequestEventArgs()
					:cancel(false)
				{
				}
				
				GuiRequestEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,cancel(false)
				{
				}
			};
			
			struct GuiKeyEventArgs : public GuiEventArgs, public NativeWindowKeyInfo
			{
				GuiKeyEventArgs()
				{
				}
				
				GuiKeyEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			struct GuiCharEventArgs : public GuiEventArgs, public NativeWindowCharInfo
			{
				GuiCharEventArgs()
				{
				}
				
				GuiCharEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			struct GuiMouseEventArgs : public GuiEventArgs, public NativeWindowMouseInfo
			{
				GuiMouseEventArgs()
				{
				}
				
				GuiMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiEventArgs>				GuiNotifyEvent;
			typedef GuiGraphicsEvent<GuiRequestEventArgs>		GuiRequestEvent;
			typedef GuiGraphicsEvent<GuiKeyEventArgs>			GuiKeyEvent;
			typedef GuiGraphicsEvent<GuiCharEventArgs>			GuiCharEvent;
			typedef GuiGraphicsEvent<GuiMouseEventArgs>			GuiMouseEvent;

/***********************************************************************
Predefined Item Events
***********************************************************************/
			
			struct GuiItemEventArgs : public GuiEventArgs
			{
				int			itemIndex;

				GuiItemEventArgs()
					:itemIndex(-1)
				{
				}
				
				GuiItemEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			struct GuiItemMouseEventArgs : public GuiMouseEventArgs
			{
				int			itemIndex;

				GuiItemMouseEventArgs()
					:itemIndex(-1)
				{
				}
				
				GuiItemMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiItemEventArgs>			GuiItemNotifyEvent;
			typedef GuiGraphicsEvent<GuiItemMouseEventArgs>		GuiItemMouseEvent;

/***********************************************************************
Event Receiver
***********************************************************************/

			class GuiGraphicsEventReceiver : public Object
			{
			protected:
				GuiGraphicsComposition*			sender;
			public:
				GuiGraphicsEventReceiver(GuiGraphicsComposition* _sender);
				~GuiGraphicsEventReceiver();

				GuiGraphicsComposition*			GetAssociatedComposition();

				GuiMouseEvent					leftButtonDown;
				GuiMouseEvent					leftButtonUp;
				GuiMouseEvent					leftButtonDoubleClick;
				GuiMouseEvent					middleButtonDown;
				GuiMouseEvent					middleButtonUp;
				GuiMouseEvent					middleButtonDoubleClick;
				GuiMouseEvent					rightButtonDown;
				GuiMouseEvent					rightButtonUp;
				GuiMouseEvent					rightButtonDoubleClick;
				GuiMouseEvent					horizontalWheel;
				GuiMouseEvent					verticalWheel;
				GuiMouseEvent					mouseMove;
				GuiNotifyEvent					mouseEnter;
				GuiNotifyEvent					mouseLeave;
				
				GuiKeyEvent						previewKey;
				GuiKeyEvent						keyDown;
				GuiKeyEvent						keyUp;
				GuiKeyEvent						systemKeyDown;
				GuiKeyEvent						systemKeyUp;
				GuiCharEvent					previewCharInput;
				GuiCharEvent					charInput;
				GuiNotifyEvent					gotFocus;
				GuiNotifyEvent					lostFocus;
				GuiNotifyEvent					caretNotify;
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{
			class GuiGraphicsHost;

/***********************************************************************
Basic Construction
***********************************************************************/

			class GuiGraphicsComposition : public Object, public Description<GuiGraphicsComposition>
			{
				typedef collections::IReadonlyList<GuiGraphicsComposition*> ICompositionList;
				typedef collections::List<GuiGraphicsComposition*> CompositionList;

				friend class controls::GuiControl;
				friend class GuiGraphicsHost;
			public:
				enum MinSizeLimitation
				{
					NoLimit,
					LimitToElement,
					LimitToElementAndChildren,
				};
				
				enum ParentSizeAffection
				{
					NotAffectedByParent,
					AffectedByParent,
					TotallyDecidedByParent,
				};
			protected:
				CompositionList								children;
				GuiGraphicsComposition*						parent;
				Ptr<elements::IGuiGraphicsElement>			ownedElement;
				bool										visible;
				elements::IGuiGraphicsRenderTarget*			renderTarget;
				MinSizeLimitation							minSizeLimitation;

				Ptr<compositions::GuiGraphicsEventReceiver>	eventReceiver;
				controls::GuiControl*						associatedControl;
				GuiGraphicsHost*							associatedHost;
				INativeCursor*								associatedCursor;

				Margin										margin;
				Margin										internalMargin;
				Size										preferredMinSize;

				virtual void								OnControlParentChanged(controls::GuiControl* control);
				virtual void								OnChildInserted(GuiGraphicsComposition* child);
				virtual void								OnChildRemoved(GuiGraphicsComposition* child);
				virtual void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent);
				virtual void								OnRenderTargetChanged();
				
				virtual void								SetAssociatedControl(controls::GuiControl* control);
				virtual void								SetAssociatedHost(GuiGraphicsHost* host);
			public:
				GuiGraphicsComposition();
				~GuiGraphicsComposition();

				GuiGraphicsComposition*						GetParent();
				const ICompositionList&						Children();
				bool										AddChild(GuiGraphicsComposition* child);
				bool										InsertChild(int index, GuiGraphicsComposition* child);
				bool										RemoveChild(GuiGraphicsComposition* child);
				bool										MoveChild(GuiGraphicsComposition* child, int newIndex);

				Ptr<elements::IGuiGraphicsElement>			GetOwnedElement();
				void										SetOwnedElement(Ptr<elements::IGuiGraphicsElement> element);
				bool										GetVisible();
				void										SetVisible(bool value);
				MinSizeLimitation							GetMinSizeLimitation();
				void										SetMinSizeLimitation(MinSizeLimitation value);
				elements::IGuiGraphicsRenderTarget*			GetRenderTarget();
				void										SetRenderTarget(elements::IGuiGraphicsRenderTarget* value);

				void										Render(Size offset);
				compositions::GuiGraphicsEventReceiver*		GetEventReceiver();
				bool										HasEventReceiver();
				GuiGraphicsComposition*						FindComposition(Point location);
				Rect										GetGlobalBounds();

				controls::GuiControl*						GetAssociatedControl();
				GuiGraphicsHost*							GetAssociatedHost();
				INativeCursor*								GetAssociatedCursor();
				void										SetAssociatedCursor(INativeCursor* cursor);
				
				controls::GuiControl*						GetRelatedControl();
				GuiGraphicsHost*							GetRelatedGraphicsHost();
				controls::GuiControlHost*					GetRelatedControlHost();
				INativeCursor*								GetRelatedCursor();
				
				virtual Margin								GetMargin();
				virtual void								SetMargin(Margin value);
				virtual Margin								GetInternalMargin();
				virtual void								SetInternalMargin(Margin value);
				virtual Size								GetPreferredMinSize();
				virtual void								SetPreferredMinSize(Size value);
				virtual Rect								GetClientArea();
				virtual void								ForceCalculateSizeImmediately();
				
				virtual ParentSizeAffection					GetAffectionFromParent()=0;
				virtual bool								IsSizeAffectParent()=0;
				virtual Size								GetMinPreferredClientSize()=0;
				virtual Rect								GetPreferredBounds()=0;
				virtual Rect								GetBounds()=0;
			};

			class GuiGraphicsSite : public GuiGraphicsComposition, public Description<GuiGraphicsSite>
			{
			protected:

				virtual Rect						GetBoundsInternal(Rect expectedBounds);
			public:
				GuiGraphicsSite();
				~GuiGraphicsSite();
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetPreferredBounds()override;
			};

/***********************************************************************
Basic Compositions
***********************************************************************/
			
			class GuiWindowComposition : public GuiGraphicsSite, public Description<GuiWindowComposition>
			{
			protected:
				INativeWindow*						attachedWindow;
			public:
				GuiWindowComposition();
				~GuiWindowComposition();
				
				INativeWindow*						GetAttachedWindow();
				void								SetAttachedWindow(INativeWindow* window);

				Rect								GetBounds()override;
				void								SetMargin(Margin value)override;
			};

			class GuiBoundsComposition : public GuiGraphicsSite, public Description<GuiBoundsComposition>
			{
			protected:
				Rect								compositionBounds;
				Rect								previousBounds;
				Margin								alignmentToParent;
				
			public:
				GuiBoundsComposition();
				~GuiBoundsComposition();

				compositions::GuiNotifyEvent		BoundsChanged;
				
				ParentSizeAffection					GetAffectionFromParent()override;
				Rect								GetPreferredBounds()override;
				Rect								GetBounds()override;
				void								SetBounds(Rect value);

				void								ClearAlignmentToParent();
				Margin								GetAlignmentToParent();
				void								SetAlignmentToParent(Margin value);
				bool								IsAlignedToParent();
			};

/***********************************************************************
Table Compositions
***********************************************************************/

			class GuiTableComposition;
			class GuiCellComposition;

			struct GuiCellOption
			{
				enum ComposeType
				{
					Absolute,
					Percentage,
					MinSize,
				};

				ComposeType		composeType;
				int				absolute;
				double			percentage;

				GuiCellOption()
					:composeType(Absolute)
					,absolute(20)
					,percentage(0)
				{
				}

				bool operator==(const GuiCellOption& value){return false;}
				bool operator!=(const GuiCellOption& value){return true;}

				static GuiCellOption AbsoluteOption(int value)
				{
					GuiCellOption option;
					option.composeType=Absolute;
					option.absolute=value;
					return option;
				}
				
				static GuiCellOption PercentageOption(double value)
				{
					GuiCellOption option;
					option.composeType=Percentage;
					option.percentage=value;
					return option;
				}
				
				static GuiCellOption MinSizeOption()
				{
					GuiCellOption option;
					option.composeType=MinSize;
					return option;
				}
			};

			class GuiTableComposition : public GuiBoundsComposition, public Description<GuiTableComposition>
			{
				friend class GuiCellComposition;
			protected:
				int											rows;
				int											columns;
				int											cellPadding;
				int											rowExtending;
				int											columnExtending;
				collections::Array<GuiCellOption>			rowOptions;
				collections::Array<GuiCellOption>			columnOptions;
				collections::Array<GuiCellComposition*>		cellCompositions;
				collections::Array<Rect>					cellBounds;
				Rect										previousBounds;
				Size										previousContentMinSize;
				Size										tableContentMinSize;

				int									GetSiteIndex(int _rows, int _columns, int _row, int _column);
				void								SetSitedCell(int _row, int _column, GuiCellComposition* cell);

				void								UpdateCellBoundsInternal(
														collections::Array<int>& dimSizes,
														int& dimSize, 
														int& dimSizeWithPercentage,
														collections::Array<GuiCellOption>& dimOptions,
														int GuiTableComposition::* dim1,
														int GuiTableComposition::* dim2,
														int (*getSize)(Size),
														int (*getLocation)(GuiCellComposition*),
														int (*getSpan)(GuiCellComposition*),
														int (*getRow)(int, int),
														int (*getCol)(int, int),
														int maxPass
														);
				void								UpdateCellBoundsPercentages(
														collections::Array<int>& dimSizes,
														int dimSize,
														int maxDimSize,
														collections::Array<GuiCellOption>& dimOptions
														);
				int									UpdateCellBoundsOffsets(
														collections::Array<int>& offsets,
														collections::Array<int>& sizes,
														int start,
														int max
														);
				
				void								UpdateCellBoundsInternal();
				void								UpdateTableContentMinSize();
				void								OnRenderTargetChanged()override;
			public:
				GuiTableComposition();
				~GuiTableComposition();

				int									GetRows();
				int									GetColumns();
				bool								SetRowsAndColumns(int _rows, int _columns);
				GuiCellComposition*					GetSitedCell(int _row, int _column);

				GuiCellOption						GetRowOption(int _row);
				void								SetRowOption(int _row, GuiCellOption option);
				GuiCellOption						GetColumnOption(int _column);
				void								SetColumnOption(int _column, GuiCellOption option);

				int									GetCellPadding();
				void								SetCellPadding(int value);
				Rect								GetCellArea();
				void								UpdateCellBounds();
				
				void								ForceCalculateSizeImmediately()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
			};

			class GuiCellComposition : public GuiGraphicsSite, public Description<GuiCellComposition>
			{
				friend class GuiTableComposition;
			protected:
				int									row;
				int									rowSpan;
				int									column;
				int									columnSpan;
				GuiTableComposition*				tableParent;
				
				void								ClearSitedCells(GuiTableComposition* table);
				void								SetSitedCells(GuiTableComposition* table);
				void								ResetSiteInternal();
				bool								SetSiteInternal(int _row, int _column, int _rowSpan, int _columnSpan);
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnTableRowsAndColumnsChanged();
			public:
				GuiCellComposition();
				~GuiCellComposition();

				GuiTableComposition*				GetTableParent();

				int									GetRow();
				int									GetRowSpan();
				int									GetColumn();
				int									GetColumnSpan();
				bool								SetSite(int _row, int _column, int _rowSpan, int _columnSpan);

				Rect								GetBounds()override;
			};

/***********************************************************************
Stack Compositions
***********************************************************************/

			class GuiStackComposition;
			class GuiStackItemComposition;

			class GuiStackComposition : public GuiBoundsComposition, public Description<GuiStackComposition>
			{
				friend class GuiStackItemComposition;

				typedef collections::List<GuiStackItemComposition*>				ItemCompositionList;
				typedef collections::IReadonlyList<GuiStackItemComposition*>	IItemCompositionList;
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction							direction;
				ItemCompositionList					stackItems;
				collections::Array<Rect>			stackItemBounds;
				Size								stackItemTotalSize;
				int									padding;
				Rect								previousBounds;
				Margin								extraMargin;

				void								UpdateStackItemBounds();
				void								FixStackItemSizes();
				void								OnChildInserted(GuiGraphicsComposition* child)override;
				void								OnChildRemoved(GuiGraphicsComposition* child)override;
			public:
				GuiStackComposition();
				~GuiStackComposition();

				const IItemCompositionList&			GetStackItems();
				bool								InsertStackItem(int index, GuiStackItemComposition* item);
				
				Direction							GetDirection();
				void								SetDirection(Direction value);
				int									GetPadding();
				void								SetPadding(int value);

				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
				
				Margin								GetExtraMargin();
				void								SetExtraMargin(Margin value);
				bool								IsStackItemClipped();
			};
			
			class GuiStackItemComposition : public GuiGraphicsSite, public Description<GuiStackItemComposition>
			{
				friend class GuiStackComposition;
			protected:
				GuiStackComposition*				stackParent;
				Rect								bounds;
				Margin								extraMargin;

				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				Size								GetMinSize();
			public:
				GuiStackItemComposition();
				~GuiStackItemComposition();
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
				void								SetBounds(Rect value);
				
				Margin								GetExtraMargin();
				void								SetExtraMargin(Margin value);
			};

/***********************************************************************
Specialized Compositions
***********************************************************************/

			class GuiSideAlignedComposition : public GuiGraphicsSite, public Description<GuiSideAlignedComposition>
			{
			public:
				enum Direction
				{
					Left,
					Top,
					Right,
					Bottom,
				};
			protected:
				Direction							direction;
				int									maxLength;
				double								maxRatio;
			public:
				GuiSideAlignedComposition();
				~GuiSideAlignedComposition();
				
				Direction							GetDirection();
				void								SetDirection(Direction value);
				int									GetMaxLength();
				void								SetMaxLength(int value);
				double								GetMaxRatio();
				void								SetMaxRatio(double value);
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};

			class GuiPartialViewComposition : public GuiGraphicsSite, public Description<GuiPartialViewComposition>
			{
			protected:
				double								wRatio;
				double								wPageSize;
				double								hRatio;
				double								hPageSize;

			public:
				GuiPartialViewComposition();
				~GuiPartialViewComposition();
				
				double								GetWidthRatio();
				double								GetWidthPageSize();
				double								GetHeightRatio();
				double								GetHeightPageSize();
				void								SetWidthRatio(double value);
				void								SetWidthPageSize(double value);
				void								SetHeightRatio(double value);
				void								SetHeightPageSize(double value);
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSHOST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Animation
***********************************************************************/

			class IGuiGraphicsAnimation : public virtual IDescriptable, public Description<IGuiGraphicsAnimation>
			{
			public:
				virtual int						GetTotalLength()=0;
				virtual int						GetCurrentPosition()=0;
				virtual void					Play(int currentPosition, int totalLength)=0;
				virtual void					Stop()=0;
			};

			class GuiGraphicsAnimationManager : public Object
			{
				typedef collections::List<Ptr<IGuiGraphicsAnimation>>		AnimationList;
			protected:
				AnimationList					playingAnimations;
			public:
				GuiGraphicsAnimationManager();
				~GuiGraphicsAnimationManager();

				void							AddAnimation(Ptr<IGuiGraphicsAnimation> animation);
				bool							HasAnimation();
				void							Play();
			};

/***********************************************************************
Host
***********************************************************************/

			class GuiGraphicsHost : public Object, private INativeWindowListener, private INativeControllerListener, public Description<GuiGraphicsHost>
			{
				typedef collections::List<GuiGraphicsComposition*>		CompositionList;
			public:
				static const unsigned __int64	CaretInterval=500;
			protected:
				INativeWindow*					nativeWindow;
				GuiWindowComposition*			windowComposition;
				GuiGraphicsComposition*			focusedComposition;
				Size							previousClientSize;
				Size							minSize;
				Point							caretPoint;
				unsigned __int64				lastCaretTime;

				GuiGraphicsAnimationManager		animationManager;
				GuiGraphicsComposition*			mouseCaptureComposition;
				CompositionList					mouseEnterCompositions;

				void							DisconnectCompositionInternal(GuiGraphicsComposition* composition);

				void							MouseCapture(const NativeWindowMouseInfo& info);
				void							MouseUncapture(const NativeWindowMouseInfo& info);
				void							OnCharInput(const NativeWindowCharInfo& info, GuiGraphicsComposition* composition, GuiCharEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							OnKeyInput(const NativeWindowKeyInfo& info, GuiGraphicsComposition* composition, GuiKeyEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							RaiseMouseEvent(GuiMouseEventArgs& arguments, GuiGraphicsComposition* composition, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							OnMouseInput(const NativeWindowMouseInfo& info, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				
			private:
				void							Moving(Rect& bounds, bool fixSizeOnly)override;
				void							Moved()override;

				void							LeftButtonDown(const NativeWindowMouseInfo& info)override;
				void							LeftButtonUp(const NativeWindowMouseInfo& info)override;
				void							LeftButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							RightButtonDown(const NativeWindowMouseInfo& info)override;
				void							RightButtonUp(const NativeWindowMouseInfo& info)override;
				void							RightButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonDown(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonUp(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							HorizontalWheel(const NativeWindowMouseInfo& info)override;
				void							VerticalWheel(const NativeWindowMouseInfo& info)override;
				void							MouseMoving(const NativeWindowMouseInfo& info)override;
				void							MouseEntered()override;
				void							MouseLeaved()override;

				void							KeyDown(const NativeWindowKeyInfo& info)override;
				void							KeyUp(const NativeWindowKeyInfo& info)override;
				void							SysKeyDown(const NativeWindowKeyInfo& info)override;
				void							SysKeyUp(const NativeWindowKeyInfo& info)override;
				void							Char(const NativeWindowCharInfo& info)override;

				void							GlobalTimer()override;
			public:
				GuiGraphicsHost();
				~GuiGraphicsHost();

				INativeWindow*					GetNativeWindow();
				void							SetNativeWindow(INativeWindow* _nativeWindow);
				GuiGraphicsComposition*			GetMainComposition();
				void							Render();

				bool							SetFocus(GuiGraphicsComposition* composition);
				GuiGraphicsComposition*			GetFocusedComposition();
				Point							GetCaretPoint();
				void							SetCaretPoint(Point value, GuiGraphicsComposition* referenceComposition=0);

				GuiGraphicsAnimationManager*	GetAnimationManager();
				void							DisconnectComposition(GuiGraphicsComposition* composition);
			};

/***********************************************************************
Helpers
***********************************************************************/
			
			class GuiTimeBasedAnimation : public IGuiGraphicsAnimation, public Description<GuiTimeBasedAnimation>
			{
			protected:
				unsigned __int64				startTime;
				int								length;
			public:
				GuiTimeBasedAnimation(int totalMilliseconds);
				~GuiTimeBasedAnimation();

				void							Restart(int totalMilliseconds=-1);
				int								GetTotalLength()override;
				int								GetCurrentPosition()override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\GUIBASICCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Basic Construction
***********************************************************************/

			class GuiControl : public Object, public Description<GuiControl>
			{
				friend class compositions::GuiGraphicsComposition;
				typedef collections::List<GuiControl*>		ControlList;
			public:
				class IStyleController : public virtual IDescriptable, public Description<IStyleController>
				{
				public:
					virtual compositions::GuiBoundsComposition*		GetBoundsComposition()=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					virtual void									SetText(const WString& value)=0;
					virtual void									SetFont(const FontProperties& value)=0;
					virtual void									SetVisuallyEnabled(bool value)=0;
				};

				class IStyleProvider : public virtual IDescriptable, public Description<IStyleProvider>
				{
				public:
					virtual void								AssociateStyleController(IStyleController* controller)=0;
					virtual void								SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					virtual void								SetText(const WString& value)=0;
					virtual void								SetFont(const FontProperties& value)=0;
					virtual void								SetVisuallyEnabled(bool value)=0;
				};
			protected:
				Ptr<IStyleController>							styleController;
				compositions::GuiBoundsComposition*				boundsComposition;
				compositions::GuiGraphicsComposition*			focusableComposition;
				compositions::GuiGraphicsEventReceiver*			eventReceiver;

				bool									isEnabled;
				bool									isVisuallyEnabled;
				bool									isVisible;
				WString									text;
				FontProperties							font;

				GuiControl*								parent;
				ControlList								children;

				virtual void							OnChildInserted(GuiControl* control);
				virtual void							OnChildRemoved(GuiControl* control);
				virtual void							OnParentChanged(GuiControl* oldParent, GuiControl* newParent);
				virtual void							OnParentLineChanged();
				virtual void							OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget);
				virtual void							OnBeforeReleaseGraphicsHost();
				virtual void							UpdateVisuallyEnabled();
				void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);
			public:
				GuiControl(IStyleController* _styleController);
				~GuiControl();

				compositions::GuiNotifyEvent			VisibleChanged;
				compositions::GuiNotifyEvent			EnabledChanged;
				compositions::GuiNotifyEvent			VisuallyEnabledChanged;
				compositions::GuiNotifyEvent			TextChanged;
				compositions::GuiNotifyEvent			FontChanged;

				compositions::GuiEventArgs				GetNotifyEventArguments();
				IStyleController*						GetStyleController();
				compositions::GuiBoundsComposition*		GetBoundsComposition();
				compositions::GuiGraphicsComposition*	GetContainerComposition();
				compositions::GuiGraphicsComposition*	GetFocusableComposition();
				compositions::GuiGraphicsEventReceiver*	GetEventReceiver();
				GuiControl*								GetParent();
				int										GetChildrenCount();
				GuiControl*								GetChild(int index);
				bool									AddChild(GuiControl* control);
				
				virtual GuiControlHost*					GetRelatedControlHost();
				virtual bool							GetVisuallyEnabled();
				virtual bool							GetEnabled();
				virtual void							SetEnabled(bool value);
				virtual bool							GetVisible();
				virtual void							SetVisible(bool value);
				virtual const WString&					GetText();
				virtual void							SetText(const WString& value);
				virtual const FontProperties&			GetFont();
				virtual void							SetFont(const FontProperties& value);
				virtual void							SetFocus();

				virtual IDescriptable*					QueryService(const WString& identifier);

				template<typename T>
				T* QueryService()
				{
					return dynamic_cast<T*>(QueryService(T::Identifier));
				}
			};

			class GuiComponent : public Object, public Description<GuiComponent>
			{
			public:
				GuiComponent();
				~GuiComponent();
			};
			
			class GuiImageData
			{
			protected:
				Ptr<INativeImage>				image;
				int								frameIndex;

			public:
				GuiImageData();
				GuiImageData(Ptr<INativeImage> _image, int _frameIndex);
				~GuiImageData();

				Ptr<INativeImage>				GetImage();
				int								GetFrameIndex();
			};

/***********************************************************************
Label
***********************************************************************/

			class GuiLabel : public GuiControl, public Description<GuiLabel>
			{
			public:
				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual Color						GetDefaultTextColor()=0;
					virtual void						SetTextColor(Color value)=0;
				};
			protected:
				Color									textColor;
				IStyleController*						styleController;
			public:
				GuiLabel(IStyleController* _styleController);
				~GuiLabel();
				
				Color									GetTextColor();
				void									SetTextColor(Color value);
			};

/***********************************************************************
Buttons
***********************************************************************/

			class GuiButton : public GuiControl, public Description<GuiButton>
			{
			public:
				enum ControlState
				{
					Normal,
					Active,
					Pressed,
				};

				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						Transfer(ControlState value)=0;
				};
			protected:
				IStyleController*						styleController;
				bool									clickOnMouseUp;
				bool									mousePressing;
				bool									mouseHoving;
				ControlState							controlState;
				
				void									OnParentLineChanged()override;
				void									UpdateControlState();
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiButton(IStyleController* _styleController);
				~GuiButton();

				compositions::GuiNotifyEvent			Clicked;

				bool									GetClickOnMouseUp();
				void									SetClickOnMouseUp(bool value);
			};

			class GuiSelectableButton : public GuiButton, public Description<GuiSelectableButton>
			{
			public:
				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						SetSelected(bool value)=0;
				};

				class GroupController : public GuiComponent, public Description<GroupController>
				{
				protected:
					collections::List<GuiSelectableButton*>	buttons;
				public:
					GroupController();
					~GroupController();

					virtual void						Attach(GuiSelectableButton* button);
					virtual void						Detach(GuiSelectableButton* button);
					virtual void						OnSelectedChanged(GuiSelectableButton* button)=0;
				};

				class MutexGroupController : public GroupController, public Description<MutexGroupController>
				{
				protected:
					bool								suppress;
				public:
					MutexGroupController();
					~MutexGroupController();

					void								OnSelectedChanged(GuiSelectableButton* button)override;
				};

			protected:
				IStyleController*						styleController;
				GroupController*						groupController;
				bool									autoSelection;
				bool									isSelected;

				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiSelectableButton(IStyleController* _styleController);
				~GuiSelectableButton();

				compositions::GuiNotifyEvent			GroupControllerChanged;
				compositions::GuiNotifyEvent			AutoSelectionChanged;
				compositions::GuiNotifyEvent			SelectedChanged;

				virtual GroupController*				GetGroupController();
				virtual void							SetGroupController(GroupController* value);
				
				virtual bool							GetAutoSelection();
				virtual void							SetAutoSelection(bool value);
				
				virtual bool							GetSelected();
				virtual void							SetSelected(bool value);
			};

/***********************************************************************
Scrolls
***********************************************************************/

			class GuiScroll : public GuiControl, public Description<GuiScroll>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void						SmallDecrease()=0;
					virtual void						SmallIncrease()=0;
					virtual void						BigDecrease()=0;
					virtual void						BigIncrease()=0;

					virtual void						SetTotalSize(int value)=0;
					virtual void						SetPageSize(int value)=0;
					virtual void						SetPosition(int value)=0;
				};
				
				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void						SetTotalSize(int value)=0;
					virtual void						SetPageSize(int value)=0;
					virtual void						SetPosition(int value)=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiScroll*							scroll;
				public:
					CommandExecutor(GuiScroll* _scroll);
					~CommandExecutor();

					void								SmallDecrease()override;
					void								SmallIncrease()override;
					void								BigDecrease()override;
					void								BigIncrease()override;

					void								SetTotalSize(int value)override;
					void								SetPageSize(int value)override;
					void								SetPosition(int value)override;
				};

				IStyleController*						styleController;
				Ptr<CommandExecutor>					commandExecutor;
				int										totalSize;
				int										pageSize;
				int										position;
				int										smallMove;
				int										bigMove;
			public:
				GuiScroll(IStyleController* _styleController);
				~GuiScroll();
				
				compositions::GuiNotifyEvent			TotalSizeChanged;
				compositions::GuiNotifyEvent			PageSizeChanged;
				compositions::GuiNotifyEvent			PositionChanged;
				compositions::GuiNotifyEvent			SmallMoveChanged;
				compositions::GuiNotifyEvent			BigMoveChanged;
				
				virtual int								GetTotalSize();
				virtual void							SetTotalSize(int value);
				virtual int								GetPageSize();
				virtual void							SetPageSize(int value);
				virtual int								GetPosition();
				virtual void							SetPosition(int value);
				virtual int								GetSmallMove();
				virtual void							SetSmallMove(int value);
				virtual int								GetBigMove();
				virtual void							SetBigMove(int value);
				
				int										GetMinPosition();
				int										GetMaxPosition();
			};

			class GuiScrollView : public GuiControl, public Description<GuiScrollView>
			{
			public:
				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiScroll::IStyleController*			CreateHorizontalScrollStyle()=0;
					virtual GuiScroll::IStyleController*			CreateVerticalScrollStyle()=0;
					virtual int										GetDefaultScrollSize()=0;
					virtual compositions::GuiGraphicsComposition*	InstallBackground(compositions::GuiBoundsComposition* boundsComposition)=0;
				};
				
				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>						styleProvider;
					GuiScrollView*							scrollView;
					GuiScroll*								horizontalScroll;
					GuiScroll*								verticalScroll;
					compositions::GuiBoundsComposition*		boundsComposition;
					compositions::GuiTableComposition*		tableComposition;
					compositions::GuiCellComposition*		containerCellComposition;
					compositions::GuiBoundsComposition*		containerComposition;
					bool									horizontalAlwaysVisible;
					bool									verticalAlwaysVisible;

					void									UpdateTable();
				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetScrollView(GuiScrollView* _scrollView);
					void									AdjustView(Size fullSize);
					IStyleProvider*							GetStyleProvider();

					GuiScroll*								GetHorizontalScroll();
					GuiScroll*								GetVerticalScroll();
					compositions::GuiTableComposition*		GetInternalTableComposition();
					compositions::GuiBoundsComposition*		GetInternalContainerComposition();

					bool									GetHorizontalAlwaysVisible();
					void									SetHorizontalAlwaysVisible(bool value);
					bool									GetVerticalAlwaysVisible();
					void									SetVerticalAlwaysVisible(bool value);

					compositions::GuiBoundsComposition*		GetBoundsComposition()override;
					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};
			protected:

				StyleController*						styleController;
				bool									supressScrolling;

				void									OnContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnVerticalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									CallUpdateView();
				void									Initialize();

				virtual Size							QueryFullSize()=0;
				virtual void							UpdateView(Rect viewBounds)=0;
				
				GuiScrollView(StyleController* _styleController);
			public:
				GuiScrollView(IStyleProvider* styleProvider);
				~GuiScrollView();

				void									CalculateView();
				Size									GetViewSize();
				Rect									GetViewBounds();
				
				GuiScroll*								GetHorizontalScroll();
				GuiScroll*								GetVerticalScroll();
				bool									GetHorizontalAlwaysVisible();
				void									SetHorizontalAlwaysVisible(bool value);
				bool									GetVerticalAlwaysVisible();
				void									SetVerticalAlwaysVisible(bool value);
			};
			
			class GuiScrollContainer : public GuiScrollView, public Description<GuiScrollContainer>
			{
			public:
				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					compositions::GuiBoundsComposition*		controlContainerComposition;
				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									MoveContainer(Point leftTop);
				};

			protected:
				StyleController*						styleController;

				void									OnControlContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				Size									QueryFullSize()override;
				void									UpdateView(Rect viewBounds)override;
			public:
				GuiScrollContainer(GuiScrollContainer::IStyleProvider* styleProvider);
				~GuiScrollContainer();
			};
			
			namespace list
			{
/***********************************************************************
List interface common implementation
***********************************************************************/

				template<typename T, typename K=typename KeyType<T>::Type>
				class ItemsBase : public Object, public collections::IList<T, K>
				{
				protected:
					collections::List<T, K>					items;

					virtual void							NotifyUpdateInternal(int start, int count, int newCount)=0;
					
				public:
					ItemsBase()
					{
					}

					~ItemsBase()
					{
					}

					bool NotifyUpdate(int start, int count=1)
					{
						if(start<0 || start>=items.Count() || count<=0 || start+count>items.Count())
						{
							return false;
						}
						else
						{
							NotifyUpdateInternal(start, count, count);
							return true;
						}
					}

					collections::IEnumerator<T>* CreateEnumerator()const
					{
						return items.Wrap().CreateEnumerator();
					}

					bool Contains(const K& item)const
					{
						return items.Contains(item);
					}

					vint Count()const
					{
						return items.Count();
					}

					vint Count()
					{
						return items.Count();
					}

					const T& Get(vint index)const
					{
						return items.Get(index);
					}

					const T& operator[](vint index)const
					{
						return items.Get(index);
					}

					vint IndexOf(const K& item)const
					{
						return items.IndexOf(item);
					}

					vint Add(const T& item)
					{
						return Insert(items.Count(), item);
					}

					bool Remove(const K& item)
					{
						vint index=items.IndexOf(item);
						if(index==-1) return false;
						return RemoveAt(index);
					}

					bool RemoveAt(vint index)
					{
						if(items.RemoveAt(index))
						{
							NotifyUpdateInternal(index, 1, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					bool RemoveRange(vint index, vint count)
					{
						if(items.RemoveRange(index, count))
						{
							NotifyUpdateInternal(index, count, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					bool Clear()
					{
						vint count=items.Count();
						if(items.Clear())
						{
							NotifyUpdateInternal(0, count, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					vint Insert(vint index, const T& item)
					{
						vint result=items.Insert(index, item);
						NotifyUpdateInternal(index, 0, 1);
						return result;
					}

					bool Set(vint index, const T& item)
					{
						if(items.Set(index, item))
						{
							NotifyUpdateInternal(index, 1, 1);
							return true;
						}
						else
						{
							return false;
						}
					}
				};
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\GUIWINDOWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Control Host
***********************************************************************/

			class GuiControlHost : public GuiControl, private INativeWindowListener, public Description<GuiControlHost>
			{
			protected:
				compositions::GuiGraphicsHost*			host;
				collections::List<GuiComponent*>		components;

			private:
				void									Enabled()override;
				void									Disabled()override;
				void									GotFocus()override;
				void									LostFocus()override;
				void									Activated()override;
				void									Deactivated()override;
				void									Opened()override;
				void									Closing(bool& cancel)override;
				void									Closed()override;
				void									Destroying()override;
			public:
				GuiControlHost(GuiControl::IStyleController* _styleController);
				~GuiControlHost();
				
				compositions::GuiNotifyEvent			WindowGotFocus;
				compositions::GuiNotifyEvent			WindowLostFocus;
				compositions::GuiNotifyEvent			WindowActivated;
				compositions::GuiNotifyEvent			WindowDeactivated;
				compositions::GuiNotifyEvent			WindowOpened;
				compositions::GuiRequestEvent			WindowClosing;
				compositions::GuiNotifyEvent			WindowClosed;
				compositions::GuiNotifyEvent			WindowDestroying;

				compositions::GuiGraphicsHost*			GetGraphicsHost();
				compositions::GuiGraphicsComposition*	GetMainComposition();
				INativeWindow*							GetNativeWindow();
				void									SetNativeWindow(INativeWindow* window);
				void									ForceCalculateSizeImmediately();
				void									Render();
				
				bool									GetEnabled()override;
				void									SetEnabled(bool value)override;
				bool									GetFocused();
				void									SetFocused();
				bool									GetActivated();
				void									SetActivated();
				bool									GetShowInTaskBar();
				void									SetShowInTaskBar(bool value);
				bool									GetEnabledActivate();
				void									SetEnabledActivate(bool value);
				
				bool									GetMaximizedBox();
				void									SetMaximizedBox(bool visible);
				bool									GetMinimizedBox();
				void									SetMinimizedBox(bool visible);
				bool									GetBorder();
				void									SetBorder(bool visible);
				bool									GetSizeBox();
				void									SetSizeBox(bool visible);
				bool									GetIconVisible();
				void									SetIconVisible(bool visible);
				bool									GetTitleBar();
				void									SetTitleBar(bool visible);
				bool									GetTopMost();
				void									SetTopMost(bool topmost);

				bool									AddComponent(GuiComponent* component);
				bool									RemoveComponent(GuiComponent* component);
				bool									ContainsComponent(GuiComponent* component);

				Size									GetClientSize();
				void									SetClientSize(Size value);
				Rect									GetBounds();
				void									SetBounds(Rect value);
				GuiControlHost*							GetRelatedControlHost()override;
				const WString&							GetText()override;
				void									SetText(const WString& value)override;

				INativeScreen*							GetRelatedScreen();
				void									Show();
				void									ShowDeactivated();
				void									ShowRestored();
				void									ShowMaximized();
				void									ShowMinimized();
				void									Hide();
				void									Close();
				bool									GetOpening();
			};

/***********************************************************************
Window
***********************************************************************/

			class GuiWindow : public GuiControlHost, public Description<GuiWindow>
			{
				friend class GuiApplication;
			protected:
				virtual void							MouseClickedOnOtherWindow(GuiWindow* window);
			public:
				GuiWindow(GuiControl::IStyleController* _styleController);
				~GuiWindow();

				compositions::GuiNotifyEvent			ClipboardUpdated;

				void									MoveToScreenCenter();
			};
			
			class GuiPopup : public GuiWindow, public Description<GuiPopup>
			{
			protected:
				void									MouseClickedOnOtherWindow(GuiWindow* window)override;

				void									PopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									PopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiPopup(GuiControl::IStyleController* _styleController);
				~GuiPopup();

				bool									IsClippedByScreen(Point location);
				void									ShowPopup(Point location);
				void									ShowPopup(GuiControl* control, bool preferredTopBottomSide);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\GUILISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
List Control
***********************************************************************/

			class GuiListControl : public GuiScrollView, public Description<GuiListControl>
			{
			public:
				class IItemProvider;
				class IItemStyleController;
				class IItemStyleProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class IItemProviderCallback : public virtual IDescriptable, public Description<IItemProviderCallback>
				{
				public:
					virtual void								OnAttached(IItemProvider* provider)=0;
					virtual void								OnItemModified(int start, int count, int newCount)=0;
				};

				class IItemArrangerCallback : public virtual IDescriptable, public Description<IItemArrangerCallback>
				{
				public:
					virtual IItemStyleController*					RequestItem(int itemIndex)=0;
					virtual void									ReleaseItem(IItemStyleController* style)=0;
					virtual void									SetViewLocation(Point value)=0;
					virtual Size									GetStylePreferredSize(IItemStyleController* style)=0;
					virtual void									SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)=0;
					virtual Rect									GetStyleBounds(IItemStyleController* style)=0;
					virtual void									SetStyleBounds(IItemStyleController* style, Rect bounds)=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void									OnTotalSizeChanged()=0;
				};

				//-----------------------------------------------------------
				// Common Views
				//-----------------------------------------------------------

				class IItemPrimaryTextView : public virtual IDescriptable, public Description<IItemPrimaryTextView>
				{
				public:
					static const wchar_t* const					Identifier;

					virtual WString								GetPrimaryTextViewText(int itemIndex)=0;
					virtual bool								ContainsPrimaryText(int itemIndex)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				enum KeyDirection
				{
					Up,
					Down,
					Left,
					Right,
					Home,
					End,
					PageUp,
					PageDown,
					PageLeft,
					PageRight,
				};

				class IItemProvider : public virtual IDescriptable, public Description<IItemProvider>
				{
				public:
					virtual bool								AttachCallback(IItemProviderCallback* value)=0;
					virtual bool								DetachCallback(IItemProviderCallback* value)=0;
					virtual int									Count()=0;
					virtual IDescriptable*						RequestView(const WString& identifier)=0;
					virtual void								ReleaseView(IDescriptable* view)=0;
				};
				
				class IItemStyleController : public virtual IDescriptable, public Description<IItemStyleController>
				{
				public:
					virtual IItemStyleProvider*					GetStyleProvider()=0;
					virtual int									GetItemStyleId()=0;
					virtual compositions::GuiBoundsComposition*	GetBoundsComposition()=0;
					virtual bool								IsCacheable()=0;
					virtual bool								IsInstalled()=0;
					virtual void								OnInstalled()=0;
					virtual void								OnUninstalled()=0;
				};
				
				class IItemStyleProvider : public virtual IDescriptable, public Description<IItemStyleProvider>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual int									GetItemStyleId(int itemIndex)=0;
					virtual IItemStyleController*				CreateItemStyle(int styleId)=0;
					virtual void								DestroyItemStyle(IItemStyleController* style)=0;
					virtual void								Install(IItemStyleController* style, int itemIndex)=0;
				};
				
				class IItemArranger : public virtual IItemProviderCallback, public Description<IItemArranger>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual IItemArrangerCallback*				GetCallback()=0;
					virtual void								SetCallback(IItemArrangerCallback* value)=0;
					virtual Size								GetTotalSize()=0;
					virtual IItemStyleController*				GetVisibleStyle(int itemIndex)=0;
					virtual int									GetVisibleIndex(IItemStyleController* style)=0;
					virtual void								OnViewChanged(Rect bounds)=0;
					virtual int									FindItem(int itemIndex, KeyDirection key)=0;
					virtual bool								EnsureItemVisible(int itemIndex)=0;
				};
				
				class IItemCoordinateTransformer : public virtual IDescriptable, public Description<IItemCoordinateTransformer>
				{
				public:
					virtual Size								RealSizeToVirtualSize(Size size)=0;
					virtual Size								VirtualSizeToRealSize(Size size)=0;
					virtual Point								RealPointToVirtualPoint(Size realFullSize, Point point)=0;
					virtual Point								VirtualPointToRealPoint(Size realFullSize, Point point)=0;
					virtual Rect								RealRectToVirtualRect(Size realFullSize, Rect rect)=0;
					virtual Rect								VirtualRectToRealRect(Size realFullSize, Rect rect)=0;
					virtual Margin								RealMarginToVirtualMargin(Margin margin)=0;
					virtual Margin								VirtualMarginToRealMargin(Margin margin)=0;
					virtual KeyDirection						RealKeyDirectionToVirtualKeyDirection(KeyDirection key)=0;
				};

			protected:

				//-----------------------------------------------------------
				// ItemCallback
				//-----------------------------------------------------------

				class ItemCallback : public IItemProviderCallback, public IItemArrangerCallback
				{
					typedef collections::List<IItemStyleController*>			StyleList;
				protected:
					GuiListControl*								listControl;
					IItemProvider*								itemProvider;
					StyleList									cachedStyles;
					StyleList									installedStyles;

				public:
					ItemCallback(GuiListControl* _listControl);
					~ItemCallback();

					void										ClearCache();

					void										OnAttached(IItemProvider* provider)override;
					void										OnItemModified(int start, int count, int newCount)override;
					IItemStyleController*						RequestItem(int itemIndex)override;
					void										ReleaseItem(IItemStyleController* style)override;
					void										SetViewLocation(Point value)override;
					Size										GetStylePreferredSize(IItemStyleController* style)override;
					void										SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)override;
					Rect										GetStyleBounds(IItemStyleController* style)override;
					void										SetStyleBounds(IItemStyleController* style, Rect bounds)override;
					compositions::GuiGraphicsComposition*		GetContainerComposition()override;
					void										OnTotalSizeChanged()override;
				};

				//-----------------------------------------------------------
				// State management
				//-----------------------------------------------------------

				Ptr<ItemCallback>								callback;
				Ptr<IItemProvider>								itemProvider;
				Ptr<IItemStyleProvider>							itemStyleProvider;
				Ptr<IItemArranger>								itemArranger;
				Ptr<IItemCoordinateTransformer>					itemCoordinateTransformer;
				Size											fullSize;

				virtual void									OnItemModified(int start, int count, int newCount);
				virtual void									OnStyleInstalled(int itemIndex, IItemStyleController* style);
				virtual void									OnStyleUninstalled(IItemStyleController* style);
				
				void											OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void											OnBeforeReleaseGraphicsHost()override;
				Size											QueryFullSize()override;
				void											UpdateView(Rect viewBounds)override;
				
				void											OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											SetStyleProviderAndArranger(Ptr<IItemStyleProvider> styleProvider, Ptr<IItemArranger> arranger);

				//-----------------------------------------------------------
				// Item event management
				//-----------------------------------------------------------

				class VisibleStyleHelper
				{
				public:
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		mouseMoveHandler;
					Ptr<compositions::GuiNotifyEvent::IHandler>		mouseEnterHandler;
					Ptr<compositions::GuiNotifyEvent::IHandler>		mouseLeaveHandler;
				};
				
				friend class collections::ReadonlyListEnumerator<Ptr<VisibleStyleHelper>>;
				collections::Dictionary<IItemStyleController*, Ptr<VisibleStyleHelper>>		visibleStyles;

				void											OnItemMouseEvent(compositions::GuiItemMouseEvent& itemEvent, IItemStyleController* style, compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											OnItemNotifyEvent(compositions::GuiItemNotifyEvent& itemEvent, IItemStyleController* style, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											AttachItemEvents(IItemStyleController* style);
				void											DetachItemEvents(IItemStyleController* style);
			public:
				GuiListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider, bool acceptFocus=false);
				~GuiListControl();

				compositions::GuiNotifyEvent					StyleProviderChanged;
				compositions::GuiNotifyEvent					ArrangerChanged;
				compositions::GuiNotifyEvent					CoordinateTransformerChanged;

				compositions::GuiItemMouseEvent					ItemLeftButtonDown;
				compositions::GuiItemMouseEvent					ItemLeftButtonUp;
				compositions::GuiItemMouseEvent					ItemLeftButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemMiddleButtonDown;
				compositions::GuiItemMouseEvent					ItemMiddleButtonUp;
				compositions::GuiItemMouseEvent					ItemMiddleButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemRightButtonDown;
				compositions::GuiItemMouseEvent					ItemRightButtonUp;
				compositions::GuiItemMouseEvent					ItemRightButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemMouseMove;
				compositions::GuiItemNotifyEvent				ItemMouseEnter;
				compositions::GuiItemNotifyEvent				ItemMouseLeave;

				virtual IItemProvider*							GetItemProvider();
				virtual IItemStyleProvider*						GetStyleProvider();
				virtual Ptr<IItemStyleProvider>					SetStyleProvider(Ptr<IItemStyleProvider> value);
				virtual IItemArranger*							GetArranger();
				virtual Ptr<IItemArranger>						SetArranger(Ptr<IItemArranger> value);
				virtual IItemCoordinateTransformer*				GetCoordinateTransformer();
				virtual Ptr<IItemCoordinateTransformer>			SetCoordinateTransformer(Ptr<IItemCoordinateTransformer> value);
				virtual bool									EnsureItemVisible(int itemIndex);
			};

/***********************************************************************
Selectable List Control
***********************************************************************/

			class GuiSelectableListControl : public GuiListControl, public Description<GuiSelectableListControl>
			{
			public:
				class IItemStyleProvider : public virtual GuiListControl::IItemStyleProvider, public Description<IItemStyleProvider>
				{
				public:
					virtual void								SetStyleSelected(IItemStyleController* style, bool value)=0;
				};
			protected:

				Ptr<IItemStyleProvider>							selectableStyleProvider;
				collections::SortedList<int>					selectedItems;
				bool											multiSelect;
				int												selectedItemIndexStart;
				int												selectedItemIndexEnd;

				void											OnItemModified(int start, int count, int newCount)override;
				void											OnStyleInstalled(int itemIndex, IItemStyleController* style)override;
				void											OnStyleUninstalled(IItemStyleController* style)override;
				virtual void									OnItemSelectionChanged(int itemIndex, bool value);
				virtual void									OnItemSelectionCleared();
				void											OnItemLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);

				void											NormalizeSelectedItemIndexStartEnd();
				void											SetMultipleItemsSelectedSilently(int start, int end, bool selected);
				void											OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
			public:
				GuiSelectableListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider);
				~GuiSelectableListControl();

				compositions::GuiNotifyEvent					SelectionChanged;

				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;

				bool											GetMultiSelect();
				void											SetMultiSelect(bool value);
				
				const collections::IReadonlyList<int>&			GetSelectedItems();
				bool											GetSelected(int itemIndex);
				void											SetSelected(int itemIndex, bool value);
				bool											SelectItemsByClick(int itemIndex, bool ctrl, bool shift);
				bool											SelectItemsByKey(int code, bool ctrl, bool shift);
				void											ClearSelection();
			};

/***********************************************************************
Predefined ItemCoordinateTransformer
***********************************************************************/

			namespace list
			{
				class DefaultItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<DefaultItemCoordinateTransformer>
				{
				public:
					DefaultItemCoordinateTransformer();
					~DefaultItemCoordinateTransformer();

					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
					GuiListControl::KeyDirection				RealKeyDirectionToVirtualKeyDirection(GuiListControl::KeyDirection key)override;
				};
				
				class AxisAlignedItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<AxisAlignedItemCoordinateTransformer>
				{
				public:
					enum Alignment
					{
						LeftDown,
						RightDown,
						LeftUp,
						RightUp,
						DownLeft,
						DownRight,
						UpLeft,
						UpRight,
					};
				protected:
					Alignment									alignment;

				public:
					AxisAlignedItemCoordinateTransformer(Alignment _alignment);
					~AxisAlignedItemCoordinateTransformer();

					Alignment									GetAlignment();
					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
					GuiListControl::KeyDirection				RealKeyDirectionToVirtualKeyDirection(GuiListControl::KeyDirection key)override;
				};
			};

/***********************************************************************
Predefined ItemArranger
***********************************************************************/

			namespace list
			{
				class RangedItemArrangerBase : public Object, virtual public GuiListControl::IItemArranger, public Description<RangedItemArrangerBase>
				{
					typedef collections::List<GuiListControl::IItemStyleController*>		StyleList;
				protected:
					GuiListControl::IItemArrangerCallback*		callback;
					GuiListControl::IItemProvider*				itemProvider;
					Rect										viewBounds;
					int											startIndex;
					StyleList									visibleStyles;

					virtual void								ClearStyles();
					virtual void								OnStylesCleared()=0;
					virtual Size								OnCalculateTotalSize()=0;
					virtual void								OnViewChangedInternal(Rect oldBounds, Rect newBounds)=0;
				public:
					RangedItemArrangerBase();
					~RangedItemArrangerBase();

					void										OnAttached(GuiListControl::IItemProvider* provider)override;
					void										OnItemModified(int start, int count, int newCount)override;
					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemArrangerCallback*		GetCallback()override;
					void										SetCallback(GuiListControl::IItemArrangerCallback* value)override;
					Size										GetTotalSize()override;
					GuiListControl::IItemStyleController*		GetVisibleStyle(int itemIndex)override;
					int											GetVisibleIndex(GuiListControl::IItemStyleController* style)override;
					void										OnViewChanged(Rect bounds)override;
				};
				
				class FixedHeightItemArranger : public RangedItemArrangerBase, public Description<FixedHeightItemArranger>
				{
				protected:
					int											rowHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					virtual int									GetWidth();
					virtual int									GetYOffset();
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightItemArranger();
					~FixedHeightItemArranger();

					int											FindItem(int itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(int itemIndex)override;
				};

				class FixedSizeMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedSizeMultiColumnItemArranger>
				{
				protected:
					Size										itemSize;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(Size itemSize, Rect bounds, int count, int& start, int& end);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedSizeMultiColumnItemArranger();
					~FixedSizeMultiColumnItemArranger();

					int											FindItem(int itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(int itemIndex)override;
				};
				
				class FixedHeightMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedHeightMultiColumnItemArranger>
				{
				protected:
					int											itemHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(int itemHeight, Rect bounds, int& rows, int& startColumn);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightMultiColumnItemArranger();
					~FixedHeightMultiColumnItemArranger();

					int											FindItem(int itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(int itemIndex)override;
				};
			}

/***********************************************************************
Predefined ItemStyleController
***********************************************************************/

			namespace list
			{
				class ItemStyleControllerBase : public Object, public virtual GuiListControl::IItemStyleController, public Description<ItemStyleControllerBase>
				{
				protected:
					GuiListControl::IItemStyleProvider*			provider;
					int											styleId;
					compositions::GuiBoundsComposition*			boundsComposition;
					GuiControl*									associatedControl;
					bool										isInstalled;

					void										Initialize(compositions::GuiBoundsComposition* _boundsComposition, GuiControl* _associatedControl);
					void										Finalize();

					ItemStyleControllerBase(GuiListControl::IItemStyleProvider* _provider, int _styleId);
				public:
					~ItemStyleControllerBase();
					
					GuiListControl::IItemStyleProvider*			GetStyleProvider()override;
					int											GetItemStyleId()override;
					compositions::GuiBoundsComposition*			GetBoundsComposition()override;
					bool										IsCacheable()override;
					bool										IsInstalled()override;
					void										OnInstalled()override;
					void										OnUninstalled()override;
				};
			}

/***********************************************************************
Predefined ItemProvider
***********************************************************************/

			namespace list
			{
				class ItemProviderBase : public Object, public virtual GuiListControl::IItemProvider, public Description<ItemProviderBase>
				{
				protected:
					collections::List<GuiListControl::IItemProviderCallback*>	callbacks;

					virtual void								InvokeOnItemModified(int start, int count, int newCount);
				public:
					ItemProviderBase();
					~ItemProviderBase();

					bool										AttachCallback(GuiListControl::IItemProviderCallback* value);
					bool										DetachCallback(GuiListControl::IItemProviderCallback* value);
				};

				template<typename T>
				class ListProvider : public ItemProviderBase, public ItemsBase<T>
				{
				protected:
					void NotifyUpdateInternal(int start, int count, int newCount)
					{
						InvokeOnItemModified(start, count, newCount);
					}
				public:
					int Count()override
					{
						return items.Count();
					}
				};
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\EXTENDEDCONTROLS\GUITEXTLISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualTextList;

			namespace list
			{

/***********************************************************************
TextList Style Provider
***********************************************************************/

				class TextItemStyleProvider : public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<TextItemStyleProvider>
				{
				public:
					class ITextItemStyleProvider : public virtual IDescriptable, public Description<ITextItemStyleProvider>
					{
					public:
						virtual GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()=0;
						virtual GuiSelectableButton::IStyleController*		CreateBulletStyleController()=0;
					};

					class ITextItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<ITextItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual WString							GetText(int itemIndex)=0;
						virtual bool							GetChecked(int itemIndex)=0;
						virtual void							SetCheckedSilently(int itemIndex, bool value)=0;
					};

					class TextItemStyleController : public ItemStyleControllerBase, public Description<TextItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						GuiSelectableButton*					bulletButton;
						elements::GuiSolidLabelElement*			textElement;
						TextItemStyleProvider*					textItemStyleProvider;

						void									OnBulletSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						TextItemStyleController(TextItemStyleProvider* provider);
						~TextItemStyleController();
						
						bool									GetSelected();
						void									SetSelected(bool value);
						bool									GetChecked();
						void									SetChecked(bool value);
						const WString&							GetText();
						void									SetText(const WString& value);
					};

				protected:
					Ptr<ITextItemStyleProvider>					textItemStyleProvider;
					ITextItemView*								textItemView;
					GuiListControl*								listControl;

					void										OnStyleCheckedChanged(TextItemStyleController* style);
				public:
					TextItemStyleProvider(ITextItemStyleProvider* _textItemStyleProvider);
					~TextItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					int											GetItemStyleId(int itemIndex)override;
					GuiListControl::IItemStyleController*		CreateItemStyle(int styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, int itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};

/***********************************************************************
TextList Data Source
***********************************************************************/

				class TextItem
				{
					friend class TextItemProvider;
				protected:
					WString										text;
					bool										checked;
				public:
					TextItem();
					TextItem(const TextItem& item);
					TextItem(const WString& _text, bool _checked=false);
					TextItem(const wchar_t* _text, bool _checked=false);
					~TextItem();

					bool										operator==(const TextItem& value)const;
					bool										operator!=(const TextItem& value)const;
					
					const WString&								GetText()const;
					bool										GetChecked()const;
				};

				class TextItemProvider : public ListProvider<TextItem>, protected TextItemStyleProvider::ITextItemView, public Description<TextItemProvider>
				{
				protected:
					bool										ContainsPrimaryText(int itemIndex)override;
					WString										GetPrimaryTextViewText(int itemIndex)override;
					WString										GetText(int itemIndex)override;
					bool										GetChecked(int itemIndex)override;
					void										SetCheckedSilently(int itemIndex, bool value)override;
				public:
					TextItemProvider();
					~TextItemProvider();
					
					void										SetText(int itemIndex, const WString& value);
					void										SetChecked(int itemIndex, bool value);

					IDescriptable*								RequestView(const WString& identifier)override;
					void										ReleaseView(IDescriptable* view)override;
				};
			}

/***********************************************************************
TextList Control
***********************************************************************/

			class GuiVirtualTextList : public GuiSelectableListControl, public Description<GuiVirtualTextList>
			{
			public:
				GuiVirtualTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualTextList();
				
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;
				Ptr<GuiListControl::IItemStyleProvider>			ChangeItemStyle(list::TextItemStyleProvider::ITextItemStyleProvider* itemStyleProvider);
			};
			
			class GuiTextList : public GuiVirtualTextList, public Description<GuiTextList>
			{
			protected:
				list::TextItemProvider*							items;
			public:
				GuiTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider);
				~GuiTextList();

				list::TextItemProvider&							GetItems();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\EXTENDEDCONTROLS\GUIMENUCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Menu Service
***********************************************************************/

			class GuiMenu;

			class IGuiMenuService : public virtual IDescriptable, public Description<IGuiMenuService>
			{
			public:
				static const wchar_t* const				Identifier;

				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				GuiMenu*								openingMenu;
			public:
				IGuiMenuService();

				virtual IGuiMenuService*				GetParentMenuService()=0;
				virtual Direction						GetPreferredDirection()=0;
				virtual bool							IsActiveState()=0;

				virtual void							MenuItemExecuted();
				virtual GuiMenu*						GetOpeningMenu();
				virtual void							MenuOpened(GuiMenu* menu);
				virtual void							MenuClosed(GuiMenu* menu);
			};

/***********************************************************************
Menu
***********************************************************************/

			class GuiMenu : public GuiPopup, private IGuiMenuService, public Description<GuiMenu>
			{
			private:
				IGuiMenuService*						parentMenuService;

				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				void									MenuItemExecuted()override;
			protected:
				GuiControl*								owner;

				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
				void									OnWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenu(GuiControl::IStyleController* _styleController, GuiControl* _owner);
				~GuiMenu();

				void									UpdateMenuService();
				IDescriptable*							QueryService(const WString& identifier)override;
			};
			
			class GuiMenuBar : public GuiControl, private IGuiMenuService, public Description<GuiMenuBar>
			{
			private:
				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
			public:
				GuiMenuBar(GuiControl::IStyleController* _styleController);
				~GuiMenuBar();
				
				IDescriptable*							QueryService(const WString& identifier)override;
			};

/***********************************************************************
MenuButton
***********************************************************************/

			class GuiMenuButton : public GuiButton, public Description<GuiMenuButton>
			{
			public:
				class IStyleController : public GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual GuiMenu::IStyleController*	CreateSubMenuStyleController()=0;
					virtual void						SetSubMenuExisting(bool value)=0;
					virtual void						SetSubMenuOpening(bool value)=0;
					virtual GuiButton*					GetSubMenuHost()=0;
				};
			protected:
				IStyleController*						styleController;
				GuiMenu*								subMenu;
				bool									ownedSubMenu;
				Size									preferredMenuClientSize;
				IGuiMenuService*						ownerMenuService;

				GuiButton*								GetSubMenuHost();
				void									OpenSubMenuInternal();
				void									OnParentLineChanged()override;
				void									OnSubMenuWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnSubMenuWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenuButton(IStyleController* _styleController);
				~GuiMenuButton();

				compositions::GuiNotifyEvent			SubMenuOpeningChanged;

				bool									IsSubMenuExists();
				GuiMenu*								GetSubMenu();
				void									CreateSubMenu(GuiMenu::IStyleController* subMenuStyleController=0);
				void									SetSubMenu(GuiMenu* value);
				void									DestroySubMenu();
				bool									GetOwnedSubMenu();

				bool									GetSubMenuOpening();
				void									SetSubMenuOpening(bool value);

				Size									GetPreferredMenuClientSize();
				void									SetPreferredMenuClientSize(Size value);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\EXTENDEDCONTROLS\GUILISTVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiListViewBase;

			namespace list
			{

/***********************************************************************
ListView Base
***********************************************************************/

				class ListViewItemStyleProviderBase: public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<ListViewItemStyleProviderBase>
				{
				public:
					class ListViewItemStyleController : public ItemStyleControllerBase, public Description<ListViewItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						ListViewItemStyleProviderBase*			listViewItemStyleProvider;

					public:
						ListViewItemStyleController(ListViewItemStyleProviderBase* provider);
						~ListViewItemStyleController();

						bool									GetSelected();
						void									SetSelected(bool value);
					};

				protected:
					GuiListViewBase*							listControl;

				public:
					ListViewItemStyleProviderBase();
					~ListViewItemStyleProviderBase();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					int											GetItemStyleId(int itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

			class GuiListViewColumnHeader : public GuiMenuButton, public Description<GuiListViewColumnHeader>
			{
			public:
				enum ColumnSortingState
				{
					NotSorted,
					Ascending,
					Descending,
				};
				
				class IStyleController : public virtual GuiMenuButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void								SetColumnSortingState(ColumnSortingState value)=0;
				};

			protected:
				IStyleController*								styleController;
				ColumnSortingState								columnSortingState;

			public:
				GuiListViewColumnHeader(IStyleController* _styleController);
				~GuiListViewColumnHeader();

				ColumnSortingState								GetColumnSortingState();
				void											SetColumnSortingState(ColumnSortingState value);
			};

			class GuiListViewBase : public GuiSelectableListControl, public Description<GuiListViewBase>
			{
			public:
				class IStyleProvider : public virtual GuiSelectableListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiListViewColumnHeader::IStyleController*	CreateColumnStyle()=0;
					virtual Color										GetPrimaryTextColor()=0;
					virtual Color										GetSecondaryTextColor()=0;
					virtual Color										GetItemSeparatorColor()=0;
				};

			protected:
				IStyleProvider*									styleProvider;

			public:
				GuiListViewBase(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiListViewBase();

				compositions::GuiItemNotifyEvent				ColumnClicked;
				
				IStyleProvider*									GetListViewStyleProvider();
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;
			};

/***********************************************************************
ListView ItemStyleProvider
***********************************************************************/

			namespace list
			{
				class ListViewItemStyleProvider : public ListViewItemStyleProviderBase, public Description<ListViewItemStyleProvider>
				{
				public:
					class IListViewItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<IListViewItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual Ptr<GuiImageData>				GetSmallImage(int itemIndex)=0;
						virtual Ptr<GuiImageData>				GetLargeImage(int itemIndex)=0;
						virtual WString							GetText(int itemIndex)=0;
						virtual WString							GetSubItem(int itemIndex, int index)=0;

						virtual int								GetDataColumnCount()=0;
						virtual int								GetDataColumn(int index)=0;

						virtual int								GetColumnCount()=0;
						virtual WString							GetColumnText(int index)=0;
					};

					class IListViewItemContent : public virtual IDescriptable, public Description<IListViewItemContent>
					{
					public:
						virtual compositions::GuiBoundsComposition*				GetContentComposition()=0;
						virtual compositions::GuiBoundsComposition*				GetBackgroundDecorator()=0;
						virtual void											Install(GuiListViewBase::IStyleProvider* styleProvider, IListViewItemView* view, int itemIndex)=0;
					};

					class IListViewItemContentProvider : public virtual IDescriptable, public Description<IListViewItemContentProvider>
					{
					public:
						virtual GuiListControl::IItemCoordinateTransformer*		CreatePreferredCoordinateTransformer()=0;
						virtual GuiListControl::IItemArranger*					CreatePreferredArranger()=0;
						virtual IListViewItemContent*							CreateItemContent(const FontProperties& font)=0;
						virtual void											AttachListControl(GuiListControl* value)=0;
						virtual void											DetachListControl()=0;
					};

					class ListViewContentItemStyleController : public ListViewItemStyleController, public Description<ListViewContentItemStyleController>
					{
					protected:
						ListViewItemStyleProvider*				listViewItemStyleProvider;
						Ptr<IListViewItemContent>				content;
					public:
						ListViewContentItemStyleController(ListViewItemStyleProvider* provider);
						~ListViewContentItemStyleController();

						IListViewItemContent*					GetItemContent();
						void									Install(IListViewItemView* view, int itemIndex);
					};

				protected:

					typedef collections::List<GuiListControl::IItemStyleController*>				ItemStyleList;
					typedef collections::IReadonlyList<GuiListControl::IItemStyleController*>		IItemStyleList;

					IListViewItemView*							listViewItemView;
					Ptr<IListViewItemContentProvider>			listViewItemContentProvider;
					ItemStyleList								itemStyles;
				public:
					ListViewItemStyleProvider(IListViewItemContentProvider* itemContentProvider);
					~ListViewItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemStyleController*		CreateItemStyle(int styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, int itemIndex)override;

					const IItemStyleList&						GetCreatedItemStyles();
					bool										IsItemStyleAttachedToListView(GuiListControl::IItemStyleController* itemStyle);
				};
			}

/***********************************************************************
ListView ItemContentProvider
***********************************************************************/

			namespace list
			{
				class ListViewBigIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewBigIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewBigIconContentProvider(Size _iconSize=Size(32, 32));
					~ListViewBigIconContentProvider();

					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewSmallIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewSmallIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewSmallIconContentProvider(Size _iconSize=Size(16, 16));
					~ListViewSmallIconContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewListContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewListContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewListContentProvider(Size _iconSize=Size(16, 16));
					~ListViewListContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewTileContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewTileContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						void											RemoveTextElement(int textRow);
						elements::GuiSolidLabelElement*					CreateTextElement(int textRow, const FontProperties& font);
						void											ResetTextTable(int textRows);
					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewTileContentProvider(Size _iconSize=Size(32, 32));
					~ListViewTileContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewInformationContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewInformationContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						FontProperties									baselineFont;
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						elements::GuiSolidBackgroundElement*			bottomLine;
						compositions::GuiBoundsComposition*				bottomLineComposition;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewInformationContentProvider(Size _iconSize=Size(32, 32));
					~ListViewInformationContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};

/***********************************************************************
ListView ItemContentProvider(Detailed)
***********************************************************************/

				class ListViewColumnItemArranger : public FixedHeightItemArranger, public Description<ListViewColumnItemArranger>
				{
					typedef collections::List<GuiListViewColumnHeader*>					ColumnHeaderButtonList;
					typedef collections::List<compositions::GuiBoundsComposition*>		ColumnHeaderSplitterList;
				public:
					static const int							SplitterWidth=8;
					
					class IColumnItemViewCallback : public virtual IDescriptable, public Description<IColumnItemViewCallback>
					{
					public:
						virtual void							OnColumnChanged()=0;
					};
					
					class IColumnItemView : public virtual IDescriptable, public Description<IColumnItemView>
					{
					public:
						static const wchar_t* const								Identifier;
						
						virtual bool											AttachCallback(IColumnItemViewCallback* value)=0;
						virtual bool											DetachCallback(IColumnItemViewCallback* value)=0;
						virtual int												GetColumnCount()=0;
						virtual WString											GetColumnText(int index)=0;
						virtual int												GetColumnSize(int index)=0;
						virtual void											SetColumnSize(int index, int value)=0;
						virtual GuiMenu*										GetDropdownPopup(int index)=0;
						virtual GuiListViewColumnHeader::ColumnSortingState		GetSortingState(int index)=0;
					};
				protected:
					class ColumnItemViewCallback : public Object, public virtual IColumnItemViewCallback
					{
					protected:
						ListViewColumnItemArranger*				arranger;
					public:
						ColumnItemViewCallback(ListViewColumnItemArranger* _arranger);
						~ColumnItemViewCallback();

						void									OnColumnChanged();
					};

					GuiListViewBase*							listView;
					GuiListViewBase::IStyleProvider*			styleProvider;
					IColumnItemView*							columnItemView;
					Ptr<ColumnItemViewCallback>					columnItemViewCallback;
					compositions::GuiStackComposition*			columnHeaders;
					ColumnHeaderButtonList						columnHeaderButtons;
					ColumnHeaderSplitterList					columnHeaderSplitters;
					bool										splitterDragging;
					int											splitterLatestX;

					void										ColumnClicked(int index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);

					void										RearrangeItemBounds()override;
					int											GetWidth()override;
					int											GetYOffset()override;
					Size										OnCalculateTotalSize()override;
					void										DeleteColumnButtons();
					void										RebuildColumns();
				public:
					ListViewColumnItemArranger();
					~ListViewColumnItemArranger();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
				};
				
				class ListViewDetailContentProvider
					: public Object
					, public virtual ListViewItemStyleProvider::IListViewItemContentProvider
					, protected virtual ListViewColumnItemArranger::IColumnItemViewCallback
					, public Description<ListViewDetailContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::List<elements::GuiSolidLabelElement*>		SubItemList;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						SubItemList										subItems;

						GuiListControl::IItemProvider*					itemProvider;
						ListViewColumnItemArranger::IColumnItemView*	columnItemView;

					public:
						ItemContent(Size iconSize, const FontProperties& font, GuiListControl::IItemProvider* _itemProvider);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											UpdateSubItemSize();
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
					GuiListControl::IItemProvider*						itemProvider;
					ListViewColumnItemArranger::IColumnItemView*		columnItemView;
					ListViewItemStyleProvider*							listViewItemStyleProvider;

					void												OnColumnChanged()override;
				public:
					ListViewDetailContentProvider(Size _iconSize=Size(16, 16));
					~ListViewDetailContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
			}

/***********************************************************************
ListView
***********************************************************************/

			namespace list
			{
				class ListViewItem
				{
				public:
					Ptr<GuiImageData>							smallImage;
					Ptr<GuiImageData>							largeImage;
					WString										text;
					collections::List<WString>					subItems;
				};
				
				class ListViewColumn
				{
				public:
					WString											text;
					int												size;
					GuiMenu*										dropdownPopup;
					GuiListViewColumnHeader::ColumnSortingState		sortingState;

					ListViewColumn(const WString& _text=L"", int _size=160);
				};

				class ListViewDataColumns : public ItemsBase<int>
				{
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*						itemProvider;

					void NotifyUpdateInternal(int start, int count, int newCount)override;
				public:
					ListViewDataColumns();
					~ListViewDataColumns();
				};
				
				class ListViewColumns : public ItemsBase<Ptr<ListViewColumn>>
				{
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*						itemProvider;

					void NotifyUpdateInternal(int start, int count, int newCount)override;
				public:
					ListViewColumns();
					~ListViewColumns();
				};
				
				class ListViewItemProvider
					: public ListProvider<Ptr<ListViewItem>>
					, protected virtual ListViewItemStyleProvider::IListViewItemView
					, protected virtual ListViewColumnItemArranger::IColumnItemView
					, public Description<ListViewItemProvider>
				{
					friend class ListViewColumns;
					friend class ListViewDataColumns;
					typedef collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					ListViewDataColumns									dataColumns;
					ListViewColumns										columns;
					ColumnItemViewCallbackList							columnItemViewCallbacks;

					bool												ContainsPrimaryText(int itemIndex)override;
					WString												GetPrimaryTextViewText(int itemIndex)override;
					Ptr<GuiImageData>									GetSmallImage(int itemIndex)override;
					Ptr<GuiImageData>									GetLargeImage(int itemIndex)override;
					WString												GetText(int itemIndex)override;
					WString												GetSubItem(int itemIndex, int index)override;
					int													GetDataColumnCount()override;
					int													GetDataColumn(int index)override;

					bool												AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool												DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					int													GetColumnCount()override;
					WString												GetColumnText(int index)override;
					int													GetColumnSize(int index)override;
					void												SetColumnSize(int index, int value)override;
					GuiMenu*											GetDropdownPopup(int index)override;
					GuiListViewColumnHeader::ColumnSortingState			GetSortingState(int index)override;
				public:
					ListViewItemProvider();
					~ListViewItemProvider();

					IDescriptable*										RequestView(const WString& identifier)override;
					void												ReleaseView(IDescriptable* view)override;

					ListViewDataColumns&								GetDataColumns();
					ListViewColumns&									GetColumns();
				};
			}
			
			class GuiVirtualListView : public GuiListViewBase, public Description<GuiVirtualListView>
			{
			public:
				GuiVirtualListView(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualListView();
				
				void											ChangeItemStyle(list::ListViewItemStyleProvider::IListViewItemContentProvider* contentProvider);
			};
			
			class GuiListView : public GuiVirtualListView, public Description<GuiListView>
			{
			protected:
				list::ListViewItemProvider*						items;
			public:
				GuiListView(IStyleProvider* _styleProvider);
				~GuiListView();
				
				list::ListViewItemProvider&						GetItems();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\EXTENDEDCONTROLS\GUITREEVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiVirtualTreeListControl NodeProvider
***********************************************************************/

			namespace tree
			{
				class INodeProvider;
				class INodeRootProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class INodeProviderCallback : public virtual IDescriptable, public Description<INodeProviderCallback>
				{
				public:
					virtual void					OnAttached(INodeRootProvider* provider)=0;
					virtual void					OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)=0;
					virtual void					OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)=0;
					virtual void					OnItemExpanded(INodeProvider* node)=0;
					virtual void					OnItemCollapsed(INodeProvider* node)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				class INodeProvider : public virtual IDescriptable, public Description<INodeProvider>
				{
				public:
					virtual bool					GetExpanding()=0;
					virtual void					SetExpanding(bool value)=0;
					virtual int						CalculateTotalVisibleNodes()=0;

					virtual int						GetChildCount()=0;
					virtual INodeProvider*			GetParent()=0;
					virtual INodeProvider*			RequestChild(int index)=0;
					virtual void					ReleaseChild(INodeProvider* node)=0;
				};
				
				class INodeRootProvider : public virtual IDescriptable, public Description<INodeRootProvider>
				{
				public:
					virtual INodeProvider*			GetRootNode()=0;
					virtual bool					CanGetNodeByVisibleIndex()=0;
					virtual INodeProvider*			GetNodeByVisibleIndex(int index)=0;
					virtual bool					AttachCallback(INodeProviderCallback* value)=0;
					virtual bool					DetachCallback(INodeProviderCallback* value)=0;
					virtual IDescriptable*			RequestView(const WString& identifier)=0;
					virtual void					ReleaseView(IDescriptable* view)=0;
				};
			}

			namespace tree
			{
				//-----------------------------------------------------------
				// Tree to ListControl (IItemProvider)
				//-----------------------------------------------------------

				class INodeItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<INodeItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual INodeProvider*			RequestNode(int index)=0;
					virtual void					ReleaseNode(INodeProvider* node)=0;
					virtual int						CalculateNodeVisibilityIndex(INodeProvider* node)=0;
				};

				class INodeItemPrimaryTextView : public virtual IDescriptable, public Description<INodeItemPrimaryTextView>
				{
				public:
					static const wchar_t* const		Identifier;
					
					virtual WString					GetPrimaryTextViewText(INodeProvider* node)=0;
				};

				class NodeItemProvider
					: public list::ItemProviderBase
					, protected virtual INodeProviderCallback
					, protected virtual INodeItemView
					, public Description<NodeItemProvider>
				{
				protected:
					Ptr<INodeRootProvider>			root;
					INodeItemPrimaryTextView*		nodeItemPrimaryTextView;
					int								offsetBeforeChildModified;

					INodeProvider*					GetNodeByOffset(INodeProvider* provider, int offset);
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
					int								CalculateNodeVisibilityIndexInternal(INodeProvider* node);
					int								CalculateNodeVisibilityIndex(INodeProvider* node)override;
					
					bool							ContainsPrimaryText(int itemIndex)override;
					WString							GetPrimaryTextViewText(int itemIndex)override;
					INodeProvider*					RequestNode(int index)override;
					void							ReleaseNode(INodeProvider* node)override;
				public:
					NodeItemProvider(INodeRootProvider* _root);
					~NodeItemProvider();
					
					Ptr<INodeRootProvider>			GetRoot();
					int								Count()override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};

				//-----------------------------------------------------------
				// Tree to ListControl (IItemStyleProvider)
				//-----------------------------------------------------------

				class INodeItemStyleProvider;

				class INodeItemStyleController : public virtual GuiListControl::IItemStyleController, public Description<INodeItemStyleController>
				{
				public:
					virtual INodeItemStyleProvider*					GetNodeStyleProvider()=0;
				};
				
				class INodeItemStyleProvider : public virtual IDescriptable, public Description<INodeItemStyleProvider>
				{
				public:
					virtual void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)=0;
					virtual GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()=0;
					virtual void									AttachListControl(GuiListControl* value)=0;
					virtual void									DetachListControl()=0;
					virtual int										GetItemStyleId(INodeProvider* node)=0;
					virtual INodeItemStyleController*				CreateItemStyle(int styleId)=0;
					virtual void									DestroyItemStyle(INodeItemStyleController* style)=0;
					virtual void									Install(INodeItemStyleController* style, INodeProvider* node)=0;
					virtual void									SetStyleSelected(INodeItemStyleController* style, bool value)=0;
				};
				
				class NodeItemStyleProvider : public Object, public virtual GuiSelectableListControl::IItemStyleProvider, public Description<NodeItemStyleProvider>
				{
				protected:
					Ptr<INodeItemStyleProvider>						nodeItemStyleProvider;
					GuiListControl*									listControl;
					INodeItemView*									nodeItemView;
				public:
					NodeItemStyleProvider(Ptr<INodeItemStyleProvider> provider);
					~NodeItemStyleProvider();

					void											AttachListControl(GuiListControl* value)override;
					void											DetachListControl()override;
					int												GetItemStyleId(int itemIndex)override;
					GuiListControl::IItemStyleController*			CreateItemStyle(int styleId)override;
					void											DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void											Install(GuiListControl::IItemStyleController* style, int itemIndex)override;
					void											SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

/***********************************************************************
GuiVirtualTreeListControl Predefined NodeProvider
***********************************************************************/

			namespace tree
			{
				class MemoryNodeProvider
					: public Object
					, public virtual INodeProvider
					, private collections::IList<Ptr<MemoryNodeProvider>>
					, public Description<MemoryNodeProvider>
				{
					typedef collections::List<Ptr<MemoryNodeProvider>> ChildList;
					typedef collections::IList<Ptr<MemoryNodeProvider>> IChildList;
					typedef collections::IEnumerator<Ptr<MemoryNodeProvider>> ChildListEnumerator;
				protected:
					MemoryNodeProvider*				parent;
					bool							expanding;
					int								childCount;
					int								totalVisibleNodeCount;
					int								offsetBeforeChildModified;
					Ptr<DescriptableObject>			data;
					ChildList						children;

					virtual INodeProviderCallback*	GetCallbackProxyInternal();
					void							OnChildTotalVisibleNodesChanged(int offset);
					void							OnBeforeChildModified(int start, int count, int newCount);
					void							OnAfterChildModified(int start, int count, int newCount);
					bool							OnRequestRemove(MemoryNodeProvider* child);
					bool							OnRequestInsert(MemoryNodeProvider* child);
				private:
					
					ChildListEnumerator*			CreateEnumerator()const;
					bool							Contains(const KeyType<Ptr<MemoryNodeProvider>>::Type& item)const;
					vint							Count()const;
					vint							Count();
					const							Ptr<MemoryNodeProvider>& Get(vint index)const;
					const							Ptr<MemoryNodeProvider>& operator[](vint index)const;
					vint							IndexOf(const KeyType<Ptr<MemoryNodeProvider>>::Type& item)const;
					vint							Add(const Ptr<MemoryNodeProvider>& item);
					bool							Remove(const KeyType<Ptr<MemoryNodeProvider>>::Type& item);
					bool							RemoveAt(vint index);
					bool							RemoveRange(vint index, vint count);
					bool							Clear();
					vint							Insert(vint index, const Ptr<MemoryNodeProvider>& item);
					bool							Set(vint index, const Ptr<MemoryNodeProvider>& item);
				public:
					MemoryNodeProvider();
					MemoryNodeProvider(const Ptr<DescriptableObject>& _data);
					~MemoryNodeProvider();

					Ptr<DescriptableObject>			GetData();
					void							SetData(const Ptr<DescriptableObject>& value);
					void							NotifyDataModified();
					IChildList&						Children();

					bool							GetExpanding()override;
					void							SetExpanding(bool value)override;
					int								CalculateTotalVisibleNodes()override;

					int								GetChildCount()override;
					INodeProvider*					GetParent()override;
					INodeProvider*					RequestChild(int index)override;
					void							ReleaseChild(INodeProvider* node)override;
				};

				class NodeRootProviderBase : public virtual INodeRootProvider, protected virtual INodeProviderCallback, public Description<NodeRootProviderBase>
				{
					collections::List<INodeProviderCallback*>			callbacks;
				protected:
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
				public:
					NodeRootProviderBase();
					~NodeRootProviderBase();
					
					bool							CanGetNodeByVisibleIndex()override;
					INodeProvider*					GetNodeByVisibleIndex(int index)override;
					bool							AttachCallback(INodeProviderCallback* value)override;
					bool							DetachCallback(INodeProviderCallback* value)override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};
				
				class MemoryNodeRootProvider
					: public MemoryNodeProvider
					, public NodeRootProviderBase
					, public Description<MemoryNodeRootProvider>
				{
				protected:
					INodeProviderCallback*			GetCallbackProxyInternal()override;
				public:
					MemoryNodeRootProvider();
					~MemoryNodeRootProvider();

					INodeProvider*					GetRootNode()override;
				};
			}

/***********************************************************************
GuiVirtualTreeListControl
***********************************************************************/

			class GuiVirtualTreeListControl : public GuiSelectableListControl, public Description<GuiVirtualTreeListControl>
			{
			protected:
				tree::NodeItemProvider*				nodeItemProvider;
				tree::INodeItemView*				nodeItemView;
				Ptr<tree::INodeItemStyleProvider>	nodeStyleProvider;
			public:
				GuiVirtualTreeListControl(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider);
				~GuiVirtualTreeListControl();

				tree::INodeItemView*				GetNodeItemView();
				tree::INodeRootProvider*			GetNodeRootProvider();
				tree::INodeItemStyleProvider*		GetNodeStyleProvider();
				Ptr<tree::INodeItemStyleProvider>	SetNodeStyleProvider(Ptr<tree::INodeItemStyleProvider> styleProvider);
			};

/***********************************************************************
TreeView
***********************************************************************/

			namespace tree
			{
				class ITreeViewItemView : public virtual INodeItemPrimaryTextView, public Description<ITreeViewItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual Ptr<GuiImageData>		GetNodeImage(INodeProvider* node)=0;
					virtual WString					GetNodeText(INodeProvider* node)=0;
				};

				class TreeViewItem : public Object, public Description<TreeViewItem>
				{
				public:
					Ptr<GuiImageData>				image;
					WString							text;

					TreeViewItem();
					TreeViewItem(const Ptr<GuiImageData>& _image, const WString& _text);
				};

				class TreeViewItemRootProvider
					: public MemoryNodeRootProvider
					, protected virtual ITreeViewItemView
					, public Description<TreeViewItemRootProvider>
				{
				protected:

					WString							GetPrimaryTextViewText(INodeProvider* node)override;
					Ptr<GuiImageData>				GetNodeImage(INodeProvider* node)override;
					WString							GetNodeText(INodeProvider* node)override;
				public:
					TreeViewItemRootProvider();
					~TreeViewItemRootProvider();

					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};
			}
			
			class GuiTreeView : public GuiVirtualTreeListControl, public Description<GuiTreeView>
			{
			public:
				class IStyleProvider : public virtual GuiVirtualTreeListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()=0;
					virtual Color										GetTextColor()=0;
				};
			protected:
				IStyleProvider*								styleProvider;
				Ptr<tree::TreeViewItemRootProvider>			nodes;
			public:
				GuiTreeView(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider=0);
				~GuiTreeView();

				IStyleProvider*								GetTreeViewStyleProvider();
				Ptr<tree::TreeViewItemRootProvider>			Nodes();
			};

			namespace tree
			{
				class TreeViewNodeItemStyleProvider
					: public Object
					, public virtual INodeItemStyleProvider
					, protected virtual INodeProviderCallback
					, public Description<TreeViewNodeItemStyleProvider>
				{
				protected:
#pragma warning(push)
#pragma warning(disable:4250)
					class ItemController : public list::ItemStyleControllerBase, public virtual INodeItemStyleController
					{
					protected:
						TreeViewNodeItemStyleProvider*		styleProvider;
						GuiSelectableButton*				backgroundButton;
						GuiSelectableButton*				expandingButton;
						compositions::GuiTableComposition*	table;
						elements::GuiImageFrameElement*		image;
						elements::GuiSolidLabelElement*		text;

						void								SwitchNodeExpanding();
						void								OnBackgroundButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						ItemController(TreeViewNodeItemStyleProvider* _styleProvider);

						INodeItemStyleProvider*				GetNodeStyleProvider()override;
						void								Install(INodeProvider* node);

						bool								GetSelected();
						void								SetSelected(bool value);
						void								UpdateExpandingButton(INodeProvider* associatedNode);
					};
#pragma warning(pop)

					GuiTreeView*							treeControl;
					GuiListControl::IItemStyleProvider*		bindedItemStyleProvider;
					ITreeViewItemView*						treeViewItemView;

				protected:
					ItemController*							GetRelatedController(INodeProvider* node);
					void									UpdateExpandingButton(INodeProvider* node);
					void									OnAttached(INodeRootProvider* provider)override;
					void									OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void									OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void									OnItemExpanded(INodeProvider* node)override;
					void									OnItemCollapsed(INodeProvider* node)override;
				public:
					TreeViewNodeItemStyleProvider();
					~TreeViewNodeItemStyleProvider();

					void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)override;
					GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()override;
					void									AttachListControl(GuiListControl* value)override;
					void									DetachListControl()override;
					int										GetItemStyleId(INodeProvider* node)override;
					INodeItemStyleController*				CreateItemStyle(int styleId)override;
					void									DestroyItemStyle(INodeItemStyleController* style)override;
					void									Install(INodeItemStyleController* style, INodeProvider* node)override;
					void									SetStyleSelected(INodeItemStyleController* style, bool value)override;
				};
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\EXTENDEDCONTROLS\GUICOMBOCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ComboBox Base
***********************************************************************/

			class GuiComboBoxBase : public GuiButton, public Description<GuiComboBoxBase>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void							ShowPopup()=0;
					virtual void							SelectItem()=0;
				};
				
				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void							SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void							OnClicked()=0;
					virtual void							OnPopupOpened()=0;
					virtual void							OnPopupClosed()=0;
					virtual void							OnItemSelected()=0;
					virtual GuiControl::IStyleController*	CreatePopupStyle()=0;
				};
			protected:

				class CommandExecutor : public Object, public virtual ICommandExecutor
				{
				protected:
					GuiComboBoxBase*						combo;

				public:
					CommandExecutor(GuiComboBoxBase* _combo);
					~CommandExecutor();

					void									ShowPopup()override;
					void									SelectItem()override;
				};

				Ptr<CommandExecutor>						commandExecutor;
				IStyleController*							styleController;
				GuiPopup*									popup;

				virtual void								SelectItem();
				void										OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnPopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnPopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxBase(IStyleController* _styleController);
				~GuiComboBoxBase();

				compositions::GuiNotifyEvent				PopupOpened;
				compositions::GuiNotifyEvent				PopupClosed;
				compositions::GuiNotifyEvent				ItemSelecting;
				compositions::GuiNotifyEvent				ItemSelected;

				void										ShowPopup();
				GuiPopup*									GetPopup();
			};

/***********************************************************************
ComboBox with GuiListControl
***********************************************************************/

			class GuiComboBoxListControl : public GuiComboBoxBase, public Description<GuiComboBoxListControl>
			{
			protected:
				GuiSelectableListControl*					containedListControl;
				GuiListControl::IItemPrimaryTextView*		primaryTextView;

				virtual void								DisplaySelectedContent(int itemIndex);
				void										OnListControlSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxListControl(IStyleController* _styleController, GuiSelectableListControl* _containedListControl);
				~GuiComboBoxListControl();

				compositions::GuiNotifyEvent				SelectedIndexChanged;
				
				void										SetFont(const FontProperties& value)override;
				GuiSelectableListControl*					GetContainedListControl();
				
				int											GetSelectedIndex();
				void										SetSelectedIndex(int value);
				GuiListControl::IItemProvider*				GetItemProvider();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\EXTENDEDCONTROLS\GUICONTAINERCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
/***********************************************************************
Tab Control
***********************************************************************/

			class GuiTab;

			class GuiTabPage : public Object, public Description<GuiTabPage>
			{
				friend class GuiTab;
				friend class Ptr<GuiTabPage>;
			protected:
				GuiControl*										container;
				GuiTab*											owner;
				WString											text;
				
				GuiTabPage();
				~GuiTabPage();

				bool											AssociateTab(GuiTab* _owner, GuiControl::IStyleController* _styleController);
				bool											DeassociateTab(GuiTab* _owner);
			public:
				compositions::GuiNotifyEvent					TextChanged;
				compositions::GuiNotifyEvent					PageInstalled;
				compositions::GuiNotifyEvent					PageUninstalled;
				compositions::GuiNotifyEvent					PageContainerReady;

				GuiControl*										GetContainer();
				GuiTab*											GetOwnerTab();
				const WString&									GetText();
				void											SetText(const WString& param);
				bool											GetSelected();
			};

			class GuiTab : public GuiControl, public Description<GuiTab>
			{
				friend class GuiTabPage;
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void								ShowTab(int index)=0;
				};
				
				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void								SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void								InsertTab(int index)=0;
					virtual void								SetTabText(int index, const WString& value)=0;
					virtual void								RemoveTab(int index)=0;
					virtual void								MoveTab(int oldIndex, int newIndex)=0;
					virtual void								SetSelectedTab(int index)=0;
					virtual GuiControl::IStyleController*		CreateTabPageStyleController()=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiTab*										tab;
				public:
					CommandExecutor(GuiTab* _tab);
					~CommandExecutor();

					void										ShowTab(int index)override;
				};

				Ptr<CommandExecutor>							commandExecutor;
				IStyleController*								styleController;
				collections::List<GuiTabPage*>					tabPages;
				GuiTabPage*										selectedPage;
			public:
				GuiTab(IStyleController* _styleController);
				~GuiTab();

				compositions::GuiNotifyEvent					SelectedPageChanged;

				GuiTabPage*										CreatePage(int index=-1);
				bool											CreatePage(GuiTabPage* page, int index=-1);
				bool											RemovePage(GuiTabPage* value);
				bool											MovePage(GuiTabPage* page, int newIndex);
				const collections::IReadonlyList<GuiTabPage*>&	GetPages();

				GuiTabPage*										GetSelectedPage();
				bool											SetSelectedPage(GuiTabPage* value);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\GUIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION
#define VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiApplication : public Object, private INativeControllerListener
			{
				friend void GuiApplicationInitialize();
				friend class GuiWindow;
				friend class GuiPopup;
				friend class Ptr<GuiApplication>;
			private:
				void											LeftButtonDown(Point position)override;
				void											LeftButtonUp(Point position)override;
				void											RightButtonDown(Point position)override;
				void											RightButtonUp(Point position)override;
				void											ClipboardUpdated()override;
			protected:
				GuiWindow*										mainWindow;
				collections::List<GuiWindow*>					windows;
				collections::SortedList<GuiPopup*>				openingPopups;

				GuiApplication();
				~GuiApplication();

				void											RegisterWindow(GuiWindow* window);
				void											UnregisterWindow(GuiWindow* window);
				void											RegisterPopupOpened(GuiPopup* popup);
				void											RegisterPopupClosed(GuiPopup* popup);
				void											OnMouseDown(Point location);
			public:
				void											Run(GuiWindow* _mainWindow);
				const collections::IReadonlyList<GuiWindow*>&	GetWindows();
				GuiWindow*										GetWindow(Point location);

				bool											IsInMainThread();
				void											InvokeAsync(INativeAsyncService::AsyncTaskProc* proc, void* argument);
				void											InvokeInMainThread(INativeAsyncService::AsyncTaskProc* proc, void* argument);
				bool											InvokeInMainThreadAndWait(INativeAsyncService::AsyncTaskProc* proc, void* argument, int milliseconds=-1);
				void											InvokeAsync(const Func<void()>& proc);
				void											InvokeInMainThread(const Func<void()>& proc);
				bool											InvokeInMainThreadAndWait(const Func<void()>& proc, int milliseconds=-1);

				template<typename T>
				void InvokeLambdaInMainThread(const T& proc)
				{
					InvokeInMainThread(Func<void()>(proc));
				}
				
				template<typename T>
				bool InvokeLambdaInMainThreadAndWait(const T& proc, int milliseconds=-1)
				{
					return InvokeInMainThreadAndWait(Func<void()>(proc), milliseconds);
				}
			};

			extern GuiApplication*								GetApplication();
		}
	}
}

extern void GuiApplicationMain();

#endif

/***********************************************************************
CONTROLS\GUITEXTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Operations
***********************************************************************/

			class GuiTextBoxCommonInterface;

			class GuiTextElementOperator : public Object, public Description<GuiTextElementOperator>
			{
			public:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual TextPos							GetLeftWord(TextPos pos)=0;
					virtual TextPos							GetRightWord(TextPos pos)=0;
					virtual void							GetWord(TextPos pos, TextPos& begin, TextPos& end)=0;
					virtual int								GetPageRows()=0;
					virtual bool							BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)=0;
					virtual void							AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
					virtual void							ScrollToView(Point point)=0;
					virtual int								GetTextMargin()=0;
				};

				class DefaultCallback : public Object, public ICallback, public Description<DefaultCallback>
				{
				protected:
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiGraphicsComposition*	textComposition;
					bool									readonly;
				public:
					DefaultCallback(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition);
					~DefaultCallback();

					TextPos									GetLeftWord(TextPos pos)override;
					TextPos									GetRightWord(TextPos pos)override;
					void									GetWord(TextPos pos, TextPos& begin, TextPos& end)override;
					int										GetPageRows()override;
					bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
				};

				class ITextEditCallback : public virtual IDescriptable, public Description<ITextEditCallback>
				{
				public:
					virtual void							Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock)=0;
					virtual void							Detach()=0;
					virtual void							TextEditNotify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
				};

			protected:
				elements::GuiColorizedTextElement*			textElement;
				compositions::GuiGraphicsComposition*		textComposition;
				GuiControl*									textControl;
				GuiTextBoxCommonInterface*					textBoxCommonInterface;
				ICallback*									callback;
				bool										dragging;
				bool										readonly;

				SpinLock									elementModifyLock;
				collections::List<Ptr<ITextEditCallback>>	textEditCallbacks;

				void										UpdateCaretPoint();
				void										Move(TextPos pos, bool shift);
				void										Modify(TextPos start, TextPos end, const WString& input);
				bool										ProcessKey(int code, bool shift, bool ctrl);
					
				void										OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void										OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void										OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);
			public:
				GuiTextElementOperator();
				~GuiTextElementOperator();

				void										Install(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition, GuiControl* _textControl);
				ICallback*									GetCallback();
				void										SetCallback(ICallback* value);
				bool										AttachTextEditCallback(Ptr<ITextEditCallback> value);
				bool										DetachTextEditCallback(Ptr<ITextEditCallback> value);
				GuiTextBoxCommonInterface*					GetTextBoxCommonInterface();
				void										SetTextBoxCommonInterface(GuiTextBoxCommonInterface* value);

				elements::GuiColorizedTextElement*			GetTextElement();
				compositions::GuiGraphicsComposition*		GetTextComposition();
				TextPos										GetNearestTextPos(Point point);
				void										Select(TextPos begin, TextPos end);
				WString										GetSelectionText();
				void										SetSelectionText(const WString& value);
				void										SetText(const WString& value);

				bool										CanCut();
				bool										CanCopy();
				bool										CanPaste();
				void										SelectAll();
				bool										Cut();
				bool										Copy();
				bool										Paste();

				bool										GetReadonly();
				void										SetReadonly(bool value);
			};

/***********************************************************************
Colorizer
***********************************************************************/
			
			class GuiTextBoxColorizerBase : public Object, public GuiTextElementOperator::ITextEditCallback
			{
			public:
				typedef collections::Array<elements::text::ColorEntry>			ColorArray;
			protected:
				elements::GuiColorizedTextElement*			element;
				SpinLock*									elementModifyLock;
				volatile int								colorizedLineCount;
				volatile bool								isColorizerRunning;
				volatile bool								isFinalizing;
				SpinLock									colorizerRunningEvent;

				static void									ColorizerThreadProc(void* argument);

				void										StartColorizer();
				void										StopColorizer();
			public:
				GuiTextBoxColorizerBase();
				~GuiTextBoxColorizerBase();

				void										Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock)override;
				void										Detach()override;
				void										TextEditNotify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;

				virtual int									GetLexerStartState()=0;
				virtual int									GetContextStartState()=0;
				virtual void								ColorizeLineWithCRLF(const wchar_t* text, unsigned __int32* colors, int length, int& lexerState, int& contextState)=0;
				virtual const ColorArray&					GetColors()=0;
			};

			class GuiTextBoxRegexColorizer : public GuiTextBoxColorizerBase
			{
			protected:
				Ptr<regex::RegexLexer>							lexer;
				Ptr<regex::RegexLexerColorizer>					colorizer;
				ColorArray										colors;

				elements::text::ColorEntry						defaultColor;
				collections::List<WString>						tokenRegexes;
				collections::List<elements::text::ColorEntry>	tokenColors;
				collections::List<elements::text::ColorEntry>	extraTokenColors;

				static void													ColorizerProc(void* argument, vint start, vint length, vint token);
			public:
				GuiTextBoxRegexColorizer();
				~GuiTextBoxRegexColorizer();

				elements::text::ColorEntry									GetDefaultColor();
				collections::IReadonlyList<WString>&						GetTokenRegexes();
				collections::IReadonlyList<elements::text::ColorEntry>&		GetTokenColors();
				collections::IReadonlyList<elements::text::ColorEntry>&		GetExtraTokenColors();
				int															GetExtraTokenIndexStart();
				
				bool														SetDefaultColor(elements::text::ColorEntry value);
				int															AddToken(const WString& regex, elements::text::ColorEntry color);
				int															AddExtraToken(elements::text::ColorEntry color);
				bool														Setup();
				virtual void												ColorizeTokenContextSensitive(const wchar_t* text, vint start, vint length, vint& token, int& contextState);


				int															GetLexerStartState()override;
				int															GetContextStartState()override;
				void														ColorizeLineWithCRLF(const wchar_t* text, unsigned __int32* colors, int length, int& lexerState, int& contextState)override;
				const ColorArray&											GetColors()override;
			};

/***********************************************************************
Common Interface
***********************************************************************/

			class GuiTextBoxCommonInterface : public Description<GuiTextBoxCommonInterface>
			{
				friend class GuiTextElementOperator;
			protected:
				GuiTextElementOperator*						textElementOperator;
				GuiControl*									textControl;
				Ptr<GuiTextBoxColorizerBase>				colorizer;

				void										RaiseTextChanged();
				void										RaiseSelectionChanged();
				void										InitializeCommonInterface(GuiControl* _textControl, GuiTextElementOperator* _textElementOperator);
			public:
				GuiTextBoxCommonInterface();
				~GuiTextBoxCommonInterface();

				compositions::GuiNotifyEvent				SelectionChanged;

				compositions::GuiGraphicsComposition*		GetTextComposition();

				Ptr<GuiTextBoxColorizerBase>				GetColorizer();
				void										SetColorizer(Ptr<GuiTextBoxColorizerBase> value);
				
				bool										CanCut();
				bool										CanCopy();
				bool										CanPaste();
				void										SelectAll();
				bool										Cut();
				bool										Copy();
				bool										Paste();
				
				WString										GetRowText(int row);
				WString										GetFragmentText(TextPos start, TextPos end);
				int											GetRowWidth(int row);
				int											GetRowHeight();
				int											GetMaxWidth();
				int											GetMaxHeight();
				TextPos										GetTextPosFromPoint(Point point);
				Point										GetPointFromTextPos(TextPos pos);
				Rect										GetRectFromTextPos(TextPos pos);
				TextPos										GetNearestTextPos(Point point);

				TextPos										GetCaretBegin();
				TextPos										GetCaretEnd();
				TextPos										GetCaretSmall();
				TextPos										GetCaretLarge();
				void										Select(TextPos begin, TextPos end);
				
				WString										GetSelectionText();
				void										SetSelectionText(const WString& value);

				bool										GetReadonly();
				void										SetReadonly(bool value);
			};

/***********************************************************************
MultilineTextBox
***********************************************************************/

			class GuiMultilineTextBox : public GuiScrollView, public GuiTextBoxCommonInterface, public Description<GuiMultilineTextBox>
			{
			public:
				static const int							TextMargin=3;

				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiBoundsComposition*		textComposition;
					GuiTextElementOperator					textElementOperator;
					Ptr<GuiTextElementOperator::ICallback>	defaultCallback;

				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					GuiTextElementOperator*					GetTextElementOperator();
					void									SetViewPosition(Point value);
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;

					WString									GetText();
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};

				class TextElementOperatorCallback : public GuiTextElementOperator::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiMultilineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiMultilineTextBox* _textControl);

					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					int										GetTextMargin()override;
				};

			protected:
				StyleController*							styleController;

				void										CalculateViewAndSetScroll();
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				Size										QueryFullSize()override;
				void										UpdateView(Rect viewBounds)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiMultilineTextBox(GuiMultilineTextBox::IStyleProvider* styleProvider);
				~GuiMultilineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
			};

/***********************************************************************
SinglelineTextBox
***********************************************************************/
			
			class GuiSinglelineTextBox : public GuiControl, public GuiTextBoxCommonInterface, public Description<GuiSinglelineTextBox>
			{
			public:
				static const int							TextMargin=3;

				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* background)=0;
				};

				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>						styleProvider;
					compositions::GuiBoundsComposition*		boundsComposition;
					compositions::GuiGraphicsComposition*	containerComposition;

					GuiSinglelineTextBox*					textBox;
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiTableComposition*		textCompositionTable;
					compositions::GuiCellComposition*		textComposition;
					GuiTextElementOperator					textElementOperator;
					Ptr<GuiTextElementOperator::ICallback>	defaultCallback;

				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetTextBox(GuiSinglelineTextBox* value);
					void									RearrangeTextElement();
					compositions::GuiBoundsComposition*		GetBoundsComposition();
					compositions::GuiGraphicsComposition*	GetContainerComposition();
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);

					WString									GetText();
					void									SetText(const WString& value);
					void									SetFont(const FontProperties& value);
					void									SetVisuallyEnabled(bool value);

					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					GuiTextElementOperator*					GetTextElementOperator();
					void									SetViewPosition(Point value);
				};

				class TextElementOperatorCallback : public GuiTextElementOperator::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiSinglelineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiSinglelineTextBox* _textControl);

					bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					int										GetTextMargin()override;
				};
			protected:
				StyleController*							styleController;
				
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiSinglelineTextBox(GuiSinglelineTextBox::IStyleProvider* styleProvider);
				~GuiSinglelineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\GUITHEMESTYLEFACTORY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY
#define VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY


namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			class ITheme : public IDescriptable, public Description<ITheme>
			{
			public:
				virtual controls::GuiControl::IStyleController*								CreateWindowStyle()=0;
				virtual controls::GuiLabel::IStyleController*								CreateLabelStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateGroupBoxStyle()=0;
				virtual controls::GuiTab::IStyleController*									CreateTabStyle()=0;
				virtual controls::GuiComboBoxBase::IStyleController*						CreateComboBoxStyle()=0;
				virtual controls::GuiScrollView::IStyleProvider*							CreateMultilineTextBoxStyle()=0;
				virtual controls::GuiSinglelineTextBox::IStyleProvider*						CreateTextBoxStyle()=0;
				virtual controls::GuiListView::IStyleProvider*								CreateListViewStyle()=0;
				virtual controls::GuiTreeView::IStyleProvider*								CreateTreeViewStyle()=0;
				
				virtual controls::GuiControl::IStyleController*								CreateMenuStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateMenuBarStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateMenuSplitterStyle()=0;
				virtual controls::GuiMenuButton::IStyleController*							CreateMenuBarButtonStyle()=0;
				virtual controls::GuiMenuButton::IStyleController*							CreateMenuItemButtonStyle()=0;
				
				virtual controls::GuiButton::IStyleController*								CreateButtonStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateToolstripButtonStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateCheckBoxStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateRadioButtonStyle()=0;
				
				virtual controls::GuiScroll::IStyleController*								CreateHScrollStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateVScrollStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateHTrackerStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateVTrackerStyle()=0;
				
				virtual controls::GuiScrollView::IStyleProvider*							CreateTextListStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateTextListItemStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateCheckTextListItemStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateRadioTextListItemStyle()=0;
			};

			extern ITheme*						GetCurrentTheme();
			extern void							SetCurrentTheme(ITheme* theam);

			namespace g
			{
				extern controls::GuiWindow*						NewWindow();
				extern controls::GuiLabel*						NewLabel();
				extern controls::GuiControl*					NewGroupBox();
				extern controls::GuiTab*						NewTab();
				extern controls::GuiComboBoxListControl*		NewComboBox(controls::GuiSelectableListControl* containedListControl);
				extern controls::GuiMultilineTextBox*			NewMultilineTextBox();
				extern controls::GuiSinglelineTextBox*			NewTextBox();
				extern controls::GuiListView*					NewListViewBigIcon();
				extern controls::GuiListView*					NewListViewSmallIcon();
				extern controls::GuiListView*					NewListViewList();
				extern controls::GuiListView*					NewListViewDetail();
				extern controls::GuiListView*					NewListViewTile();
				extern controls::GuiListView*					NewListViewInformation();
				extern controls::GuiTreeView*					NewTreeView();
				extern controls::GuiMenu*						NewMenu(controls::GuiControl* owner);
				extern controls::GuiMenuBar*					NewMenuBar();
				extern controls::GuiControl*					NewMenuSplitter();
				extern controls::GuiMenuButton*					NewMenuBarButton();
				extern controls::GuiMenuButton*					NewMenuItemButton();
				extern controls::GuiButton*						NewButton();
				extern controls::GuiSelectableButton*			NewToolstripButton();
				extern controls::GuiSelectableButton*			NewCheckBox();
				extern controls::GuiSelectableButton*			NewRadioButton();
				extern controls::GuiScroll*						NewHScroll();
				extern controls::GuiScroll*						NewVScroll();
				extern controls::GuiScroll*						NewHTracker();
				extern controls::GuiScroll*						NewVTracker();
				extern controls::GuiTextList*					NewTextList();
				extern controls::GuiTextList*					NewCheckTextList();
				extern controls::GuiTextList*					NewRadioTextList();
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\GUICOMMONSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMMONSTYLES
#define VCZH_PRESENTATION_CONTROLS_GUICOMMONSTYLES


namespace vl
{
	namespace presentation
	{
		namespace common_styles
		{

/***********************************************************************
Scrolls
***********************************************************************/

			class CommonScrollStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<CommonScrollStyle>
			{
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction											direction;
				controls::GuiScroll::ICommandExecutor*				commandExecutor;
				controls::GuiButton*								decreaseButton;
				controls::GuiButton*								increaseButton;
				controls::GuiButton*								handleButton;
				compositions::GuiPartialViewComposition*			handleComposition;
				compositions::GuiBoundsComposition*					boundsComposition;

				int													totalSize;
				int													pageSize;
				int													position;
				Point												draggingStartLocation;
				bool												draggingHandle;

				void												UpdateHandle();
				void												OnDecreaseButtonClicked(compositions::GuiGraphicsComposition* sender,compositions::GuiEventArgs& arguments);
				void												OnIncreaseButtonClicked(compositions::GuiGraphicsComposition* sender,compositions::GuiEventArgs& arguments);
				void												OnHandleMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseMove(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseUp(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);;
				void												OnBigMoveMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);

				virtual controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction)=0;
				virtual controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction)=0;
				virtual controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)=0;
				virtual void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)=0;
				void												BuildStyle(int defaultSize, int arrowSize);
			public:
				CommonScrollStyle(Direction _direction);
				~CommonScrollStyle();

				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*				GetContainerComposition()override;
				void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void												SetText(const WString& value)override;
				void												SetFont(const FontProperties& value)override;
				void												SetVisuallyEnabled(bool value)override;
				void												SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void												SetTotalSize(int value)override;
				void												SetPageSize(int value)override;
				void												SetPosition(int value)override;
			};
			
			class CommonTrackStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<CommonTrackStyle>
			{
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction											direction;
				controls::GuiScroll::ICommandExecutor*				commandExecutor;
				compositions::GuiBoundsComposition*					boundsComposition;
				controls::GuiButton*								handleButton;
				compositions::GuiTableComposition*					handleComposition;

				int													totalSize;
				int													pageSize;
				int													position;
				Point												draggingStartLocation;
				bool												draggingHandle;

				void												UpdateHandle();
				void												OnHandleMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseMove(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseUp(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				
				virtual controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)=0;
				virtual void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)=0;
				virtual void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)=0;
				void												BuildStyle(int trackThickness, int trackPadding, int handleLong, int handleShort);
			public:
				CommonTrackStyle(Direction _direction);
				~CommonTrackStyle();

				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*				GetContainerComposition()override;
				void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void												SetText(const WString& value)override;
				void												SetFont(const FontProperties& value)override;
				void												SetVisuallyEnabled(bool value)override;
				void												SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void												SetTotalSize(int value)override;
				void												SetPageSize(int value)override;
				void												SetPosition(int value)override;
			};

			class CommonFragmentBuilder
			{
			private:
				static compositions::GuiBoundsComposition*			BuildDockedElementContainer(elements::IGuiGraphicsElement* element);
			public:
				static void											FillUpArrow(elements::GuiPolygonElement* element);
				static void											FillDownArrow(elements::GuiPolygonElement* element);
				static void											FillLeftArrow(elements::GuiPolygonElement* element);
				static void											FillRightArrow(elements::GuiPolygonElement* element);

				static elements::GuiPolygonElement*					BuildUpArrow();
				static elements::GuiPolygonElement*					BuildDownArrow();
				static elements::GuiPolygonElement*					BuildLeftArrow();
				static elements::GuiPolygonElement*					BuildRightArrow();

				static compositions::GuiBoundsComposition*			BuildUpArrow(elements::GuiPolygonElement*& elementOut);
				static compositions::GuiBoundsComposition*			BuildDownArrow(elements::GuiPolygonElement*& elementOut);
				static compositions::GuiBoundsComposition*			BuildLeftArrow(elements::GuiPolygonElement*& elementOut);
				static compositions::GuiBoundsComposition*			BuildRightArrow(elements::GuiPolygonElement*& elementOut);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\GUIWIN7STYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
	GuiControl::IStyleController
		Win7EmptyStyle
		Win7WindowStyle
		Win7LabelStyle
		Win7MenuStyle
		Win7MenuBarStyle
		Win7MenuSplitterStyle
		Win7GroupBoxStyle
	GuiTab::IStyleController
		Win7TabStyle
	GuiSelectableButton::IStyleController
		Win7ButtonStyle(vertical|horizontal)
		Win7ToolstripButtonStyle
		Win7CheckBoxStyle(check|radio)
		Win7SelectableItemStyle
		Win7TabPageHeaderStyle
		Win7ListViewColumnDropDownStyle
		Win7ListViewColumnHeaderStyle
		Win7TreeViewExpandingButtonStyle
	GuiComboBoxBase::IStyleController
		Win7DropDownComboBoxStyle
	GuiMenuButton::IStyleController
		Win7MenuBarButtonStyle
		Win7MenuItemButtonStyle
	GuiScroll::IStyleController
		Win7ScrollStyle
		Win7TrackStyle
	GuiScrollView::IStyleProvider
		Win7ScrollViewProvider
		Win7MultilineTextBoxProvider
	GuiSinglelineTextBox::IStyleProvider
		Win7SinglelineTextBoxProvider
	list::TextItemStyleProvider::ITextItemStyleProvider
		Win7TextListProvider
		Win7CheckTextListProvider
		Win7RadioTextListProvider
	GuiListView::IStyleProvider
		Win7ListViewProvider
	GuiTreeView::IStyleProvider
		Win7TreeViewProvider
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES
#define VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Button Configuration
***********************************************************************/
			
			struct Win7ButtonColors
			{
				Color										borderColor;
				Color										backgroundColor;
				Color										g1;
				Color										g2;
				Color										g3;
				Color										g4;
				Color										textColor;
				Color										bulletLight;
				Color										bulletDark;

				bool operator==(const Win7ButtonColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor &&
						g1 == colors.g1 &&
						g2 == colors.g2 &&
						g3 == colors.g3 &&
						g4 == colors.g4 &&
						textColor == colors.textColor &&
						bulletLight == colors.bulletLight &&
						bulletDark == colors.bulletDark;
				}

				bool operator!=(const Win7ButtonColors& colors)
				{
					return !(*this==colors);
				}

				void										SetAlphaWithoutText(unsigned char a);

				static Win7ButtonColors						Blend(const Win7ButtonColors& c1, const Win7ButtonColors& c2, int ratio, int total);

				static Win7ButtonColors						ButtonNormal();
				static Win7ButtonColors						ButtonActive();
				static Win7ButtonColors						ButtonPressed();
				static Win7ButtonColors						ButtonDisabled();
				
				static Win7ButtonColors						ItemNormal();
				static Win7ButtonColors						ItemActive();
				static Win7ButtonColors						ItemSelected();
				static Win7ButtonColors						ItemDisabled();
				
				static Win7ButtonColors						CheckedNormal(bool selected);
				static Win7ButtonColors						CheckedActive(bool selected);
				static Win7ButtonColors						CheckedPressed(bool selected);
				static Win7ButtonColors						CheckedDisabled(bool selected);

				static Win7ButtonColors						ToolstripButtonNormal();
				static Win7ButtonColors						ToolstripButtonActive();
				static Win7ButtonColors						ToolstripButtonPressed();
				static Win7ButtonColors						ToolstripButtonDisabled();

				static Win7ButtonColors						MenuBarButtonNormal();
				static Win7ButtonColors						MenuBarButtonActive();
				static Win7ButtonColors						MenuBarButtonPressed();
				static Win7ButtonColors						MenuBarButtonDisabled();

				static Win7ButtonColors						MenuItemButtonNormal();
				static Win7ButtonColors						MenuItemButtonNormalActive();
				static Win7ButtonColors						MenuItemButtonDisabled();
				static Win7ButtonColors						MenuItemButtonDisabledActive();

				static Win7ButtonColors						TabPageHeaderNormal();
				static Win7ButtonColors						TabPageHeaderActive();
				static Win7ButtonColors						TabPageHeaderSelected();
			};

			struct Win7ButtonElements
			{
				elements::GuiSolidBorderElement*			rectBorderElement;
				elements::GuiRoundBorderElement*			roundBorderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		topGradientElement;
				elements::GuiGradientBackgroundElement*		bottomGradientElement;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			backgroundComposition;
				compositions::GuiTableComposition*			gradientComposition;

				static Win7ButtonElements					Create(bool verticalGradient, bool roundBorder, Alignment::Type horizontal=Alignment::Center, Alignment::Type vertical=Alignment::Center);
				void										Apply(const Win7ButtonColors& colors);
			};

			struct Win7CheckedButtonElements
			{
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		outerGradientElement;
				elements::GuiGradientBackgroundElement*		innerGradientElement;
				elements::GuiSolidLabelElement*				textElement;
				elements::GuiSolidLabelElement*				bulletTextElement;
				elements::GuiSolidBackgroundElement*		bulletBackgroundElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win7CheckedButtonElements			Create(elements::ElementShape::Type shape, bool backgroundVisible);
				void										Apply(const Win7ButtonColors& colors);
			};

			struct Win7MenuItemButtonElements
			{
				elements::GuiRoundBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::Gui3DSplitterElement*				splitterElement;
				compositions::GuiCellComposition*			splitterComposition;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				elements::GuiPolygonElement*				subMenuArrowElement;
				compositions::GuiGraphicsComposition*		subMenuArrowComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win7MenuItemButtonElements			Create();
				void										Apply(const Win7ButtonColors& colors);
				void										SetActive(bool value);
				void										SetSubMenuExisting(bool value);
			};

			struct Win7TextBoxColors
			{
				Color										borderColor;
				Color										backgroundColor;

				bool operator==(const Win7TextBoxColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor;
				}

				bool operator!=(const Win7TextBoxColors& colors)
				{
					return !(*this==colors);
				}

				static Win7TextBoxColors					Blend(const Win7TextBoxColors& c1, const Win7TextBoxColors& c2, int ratio, int total);

				static Win7TextBoxColors					Normal();
				static Win7TextBoxColors					Active();
				static Win7TextBoxColors					Focused();
				static Win7TextBoxColors					Disabled();
			};

/***********************************************************************
Helper Functions
***********************************************************************/
			
			extern int										Win7GetColorAnimationLength();
			extern Color									Win7GetSystemWindowColor();
			extern Color									Win7GetSystemTabContentColor();
			extern Color									Win7GetSystemBorderColor();
			extern Color									Win7GetSystemTextColor(bool enabled);
			extern void										Win7SetFont(elements::GuiSolidLabelElement* element, compositions::GuiBoundsComposition* composition, const FontProperties& fontProperties);
			extern void										Win7CreateSolidLabelElement(elements::GuiSolidLabelElement*& element, compositions::GuiBoundsComposition*& composition, Alignment::Type horizontal, Alignment::Type vertical);
			extern elements::text::ColorEntry				Win7GetTextBoxTextColor();

/***********************************************************************
Animation
***********************************************************************/

#define DEFINE_TRANSFERRING_ANIMATION(TSTATE, TSTYLECONTROLLER)\
				class TransferringAnimation : public compositions::GuiTimeBasedAnimation\
				{\
				protected:\
					TSTATE									colorBegin;\
					TSTATE									colorEnd;\
					TSTATE									colorCurrent;\
					TSTYLECONTROLLER*						style;\
					bool									stopped;\
					bool									disabled;\
					bool									enableAnimation;\
					void									PlayInternal(int currentPosition, int totalLength);\
				public:\
					TransferringAnimation(TSTYLECONTROLLER* _style, const TSTATE& begin);\
					void									Disable();\
					void									Play(int currentPosition, int totalLength)override;\
					void									Stop()override;\
					bool									GetEnableAnimation();\
					void									SetEnableAnimation(bool value);\
					void									Transfer(const TSTATE& end);\
				};\

/***********************************************************************
Container
***********************************************************************/

			class Win7EmptyStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7EmptyStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7EmptyStyle(Color color);
				~Win7EmptyStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7WindowStyle : public Win7EmptyStyle, public Description<Win7WindowStyle>
			{
			public:
				Win7WindowStyle();
				~Win7WindowStyle();
			};

			class Win7LabelStyle : public Object, public virtual controls::GuiLabel::IStyleController, public Description<Win7LabelStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				elements::GuiSolidLabelElement*				textElement;
			public:
				Win7LabelStyle();
				~Win7LabelStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				Color										GetDefaultTextColor()override;
				void										SetTextColor(Color value)override;
			};
			
			class Win7MenuStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win7MenuStyle();
				~Win7MenuStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
			
			class Win7MenuBarStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuBarStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7MenuBarStyle();
				~Win7MenuBarStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
			
			class Win7GroupBoxStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7GroupBoxStyle>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Color, Win7GroupBoxStyle)

				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			sinkBorderComposition;
				compositions::GuiBoundsComposition*			raisedBorderComposition;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			textBackgroundComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				elements::GuiSolidLabelElement*				textElement;
				Ptr<TransferringAnimation>					transferringAnimation;

				void										SetMargins(int fontSize);
			public:
				Win7GroupBoxStyle();
				~Win7GroupBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
			
			class Win7TabStyle : public Object, public virtual controls::GuiTab::IStyleController, public Description<Win7TabStyle>
			{
			protected:
				compositions::GuiTableComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				compositions::GuiStackComposition*			tabHeaderComposition;
				compositions::GuiBoundsComposition*			tabContentTopLineComposition;
				FontProperties								headerFont;
				controls::GuiTab::ICommandExecutor*			commandExecutor;

				Ptr<controls::GuiSelectableButton::MutexGroupController>	headerController;
				collections::List<controls::GuiSelectableButton*>			headerButtons;
				elements::GuiPolygonElement*								headerOverflowArrowElement;
				controls::GuiButton*										headerOverflowButton;
				controls::GuiMenu*											headerOverflowMenu;
				compositions::GuiStackComposition*							headerOverflowMenuStack;

				void										OnHeaderButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnTabHeaderBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnHeaderOverflowButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnHeaderOverflowMenuButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void										UpdateHeaderOverflowButtonVisibility();
				void										UpdateHeaderZOrder();
			public:
				Win7TabStyle();
				~Win7TabStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;

				void										SetCommandExecutor(controls::GuiTab::ICommandExecutor* value)override;
				void										InsertTab(int index)override;
				void										SetTabText(int index, const WString& value)override;
				void										RemoveTab(int index)override;
				void										MoveTab(int oldIndex, int newIndex)override;
				void										SetSelectedTab(int index)override;
				controls::GuiControl::IStyleController*		CreateTabPageStyleController()override;
			};

/***********************************************************************
Button
***********************************************************************/
			
			class Win7ButtonStyleBase : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ButtonStyleBase>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7ButtonStyleBase)

				Win7ButtonElements							elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;
				bool										transparentWhenInactive;
				bool										transparentWhenDisabled;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)=0;
			public:
				Win7ButtonStyleBase(bool verticalGradient, bool roundBorder, const Win7ButtonColors& initialColor, Alignment::Type horizontal, Alignment::Type vertical);
				~Win7ButtonStyleBase();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;

				bool										GetTransparentWhenInactive();
				void										SetTransparentWhenInactive(bool value);
				bool										GetTransparentWhenDisabled();
				void										SetTransparentWhenDisabled(bool value);
				bool										GetAutoSizeForText();
				void										SetAutoSizeForText(bool value);
			};
			
			class Win7ButtonStyle : public Win7ButtonStyleBase, public Description<Win7ButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7ButtonStyle(bool verticalGradient=true);
				~Win7ButtonStyle();
			};
			
			class Win7ToolstripButtonStyle : public Win7ButtonStyleBase, public Description<Win7ToolstripButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7ToolstripButtonStyle(bool transparent);
				~Win7ToolstripButtonStyle();
			};
			
			class Win7CheckBoxStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7CheckBoxStyle>
			{
			public:
				enum BulletStyle
				{
					CheckBox,
					RadioButton,
				};
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7CheckBoxStyle)

				Win7CheckedButtonElements					elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7CheckBoxStyle(BulletStyle bulletStyle, bool backgroundVisible=false);
				~Win7CheckBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

/***********************************************************************
Misc Buttons
***********************************************************************/
			
			class Win7SelectableItemStyle : public Win7ButtonStyleBase, public Description<Win7SelectableItemStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7SelectableItemStyle();
				~Win7SelectableItemStyle();
			};
			
			class Win7TabPageHeaderStyle : public Win7ButtonStyleBase, public Description<Win7TabPageHeaderStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7TabPageHeaderStyle();
				~Win7TabPageHeaderStyle();

				void										SetFont(const FontProperties& value)override;
			};
			
			class Win7ListViewColumnDropDownStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ListViewColumnDropDownStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			leftBorderComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			gradientComposition;
				compositions::GuiBoundsComposition*			arrowComposition;

				elements::GuiGradientBackgroundElement*		leftBorderElement;
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::GuiPolygonElement*				arrowElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7ListViewColumnDropDownStyle();
				~Win7ListViewColumnDropDownStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};
			
			class Win7ListViewColumnHeaderStyle : public Object, public virtual controls::GuiListViewColumnHeader::IStyleController, public Description<Win7ListViewColumnHeaderStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSubMenuExisting;
				bool										isSubMenuOpening;

				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			rightBorderComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			gradientComposition;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			arrowComposition;

				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		rightBorderElement;
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::GuiSolidLabelElement*				textElement;
				elements::GuiPolygonElement*				arrowElement;

				controls::GuiButton*						dropdownButton;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool subMenuExisting, bool subMenuOpening);
			public:
				Win7ListViewColumnHeaderStyle();
				~Win7ListViewColumnHeaderStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
				controls::GuiMenu::IStyleController*		CreateSubMenuStyleController()override;
				void										SetSubMenuExisting(bool value)override;
				void										SetSubMenuOpening(bool value)override;
				controls::GuiButton*						GetSubMenuHost()override;
				void										SetColumnSortingState(controls::GuiListViewColumnHeader::ColumnSortingState value)override;
			};
			
			class Win7TreeViewExpandingButtonStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7TreeViewExpandingButtonStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				elements::GuiPolygonElement*				polygonElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7TreeViewExpandingButtonStyle();
				~Win7TreeViewExpandingButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

/***********************************************************************
Menu Button
***********************************************************************/
			
			class Win7MenuBarButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7MenuBarButtonStyle>
			{
			protected:
				Win7ButtonElements							elements;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isOpening;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool opening);
			public:
				Win7MenuBarButtonStyle();
				~Win7MenuBarButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				controls::GuiMenu::IStyleController*		CreateSubMenuStyleController()override;
				void										SetSubMenuExisting(bool value)override;
				void										SetSubMenuOpening(bool value)override;
				controls::GuiButton*						GetSubMenuHost()override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};
			
			class Win7MenuItemButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7MenuItemButtonStyle>
			{
			protected:
				Win7MenuItemButtonElements					elements;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isOpening;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool opening);
			public:
				Win7MenuItemButtonStyle();
				~Win7MenuItemButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				controls::GuiMenu::IStyleController*		CreateSubMenuStyleController()override;
				void										SetSubMenuExisting(bool value)override;
				void										SetSubMenuOpening(bool value)override;
				controls::GuiButton*						GetSubMenuHost()override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};
			
			class Win7MenuSplitterStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuSplitterStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7MenuSplitterStyle();
				~Win7MenuSplitterStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

/***********************************************************************
ComboBox
***********************************************************************/
			
#pragma warning(push)
#pragma warning(disable:4250)
			class Win7DropDownComboBoxStyle : public Win7ButtonStyle, public virtual controls::GuiComboBoxBase::IStyleController, public Description<Win7DropDownComboBoxStyle>
			{
			protected:
				controls::GuiComboBoxBase::ICommandExecutor*	commandExecutor;
				compositions::GuiTableComposition*				table;
				compositions::GuiCellComposition*				textComposition;
				compositions::GuiCellComposition*				dropDownComposition;
				elements::GuiPolygonElement*					dropDownElement;

				void											TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7DropDownComboBoxStyle();
				~Win7DropDownComboBoxStyle();
				
				compositions::GuiGraphicsComposition*			GetContainerComposition()override;

				void											SetCommandExecutor(controls::GuiComboBoxBase::ICommandExecutor* value)override;
				void											OnClicked()override;
				void											OnPopupOpened()override;
				void											OnPopupClosed()override;
				void											OnItemSelected()override;
				controls::GuiControl::IStyleController*			CreatePopupStyle()override;
			};
#pragma warning(pop)

/***********************************************************************
Scroll
***********************************************************************/
			
			class Win7ScrollStyle : public common_styles::CommonScrollStyle, public Description<Win7ScrollStyle>
			{
			public:
				static const int							DefaultSize=18;
				static const int							ArrowSize=10;
			protected:
				controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction);
				controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction);
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction);
				void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)override;
			public:
				Win7ScrollStyle(Direction _direction);
				~Win7ScrollStyle();
			};
			
			class Win7TrackStyle : public common_styles::CommonTrackStyle, public Description<Win7TrackStyle>
			{
			public:
				static const int							TrackThickness=4;
				static const int							TrackPadding=8;
				static const int							HandleLong=21;
				static const int							HandleShort=10;

			protected:
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)override;
				void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)override;
				void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)override;
			public:
				Win7TrackStyle(Direction _direction);
				~Win7TrackStyle();
			};

/***********************************************************************
ScrollView
***********************************************************************/
			
			class Win7ScrollViewProvider : public Object, public virtual controls::GuiScrollView::IStyleProvider, public Description<Win7ScrollViewProvider>
			{
			public:
				Win7ScrollViewProvider();
				~Win7ScrollViewProvider();

				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;

				controls::GuiScroll::IStyleController*		CreateHorizontalScrollStyle()override;
				controls::GuiScroll::IStyleController*		CreateVerticalScrollStyle()override;
				int											GetDefaultScrollSize()override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

/***********************************************************************
TextBox
***********************************************************************/
			
			class Win7TextBoxBackground : public Object, public Description<Win7TextBoxBackground>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7TextBoxColors, Win7TextBoxBackground)
					
				elements::GuiRoundBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				compositions::GuiGraphicsComposition*		focusableComposition;
				bool										isMouseEnter;
				bool										isFocused;
				bool										isVisuallyEnabled;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiControl::IStyleController*		styleController;
				elements::GuiColorizedTextElement*			textElement;

				void										UpdateStyle();
				void										Apply(const Win7TextBoxColors& colors);

				void										OnBoundsMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				Win7TextBoxBackground();
				~Win7TextBoxBackground();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller);
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value);
				void										SetVisuallyEnabled(bool value);
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition);
				void										InitializeTextElement(elements::GuiColorizedTextElement* _textElement);
			};
			
			class Win7MultilineTextBoxProvider : public Win7ScrollViewProvider, public Description<Win7MultilineTextBoxProvider>
			{
			protected:
				Win7TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win7MultilineTextBoxProvider();
				~Win7MultilineTextBoxProvider();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};
			
			class Win7SinglelineTextBoxProvider : public Object, public virtual controls::GuiSinglelineTextBox::IStyleProvider, public Description<Win7SinglelineTextBoxProvider>
			{
			protected:
				Win7TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win7SinglelineTextBoxProvider();
				~Win7SinglelineTextBoxProvider();

				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

/***********************************************************************
List
***********************************************************************/
			
			class Win7TextListProvider : public Object, public virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider, public Description<Win7TextListProvider>
			{
			public:
				Win7TextListProvider();
				~Win7TextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()override;
				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};
			
			class Win7CheckTextListProvider : public Win7TextListProvider, public Description<Win7CheckTextListProvider>
			{
			public:
				Win7CheckTextListProvider();
				~Win7CheckTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};
			
			class Win7RadioTextListProvider : public Win7TextListProvider, public Description<Win7RadioTextListProvider>
			{
			public:
				Win7RadioTextListProvider();
				~Win7RadioTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

#pragma warning(push)
#pragma warning(disable:4250)
			class Win7ListViewProvider : public Win7MultilineTextBoxProvider, public virtual controls::GuiListView::IStyleProvider, public Description<Win7ListViewProvider>
			{
			public:
				Win7ListViewProvider();
				~Win7ListViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiListViewColumnHeader::IStyleController*	CreateColumnStyle()override;
				Color													GetPrimaryTextColor()override;
				Color													GetSecondaryTextColor()override;
				Color													GetItemSeparatorColor()override;
			};
			
			class Win7TreeViewProvider : public Win7MultilineTextBoxProvider, public virtual controls::GuiTreeView::IStyleProvider, public Description<Win7TreeViewProvider>
			{
			public:
				Win7TreeViewProvider();
				~Win7TreeViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()override;
				Color													GetTextColor()override;
			};
#pragma warning(pop)

/***********************************************************************
Theme
***********************************************************************/

			class Win7Theme : public theme::ITheme
			{
			public:
				Win7Theme();
				~Win7Theme();

				controls::GuiControl::IStyleController*								CreateWindowStyle()override;
				controls::GuiLabel::IStyleController*								CreateLabelStyle()override;
				controls::GuiControl::IStyleController*								CreateGroupBoxStyle()override;
				controls::GuiTab::IStyleController*									CreateTabStyle()override;
				controls::GuiComboBoxBase::IStyleController*						CreateComboBoxStyle()override;
				controls::GuiScrollView::IStyleProvider*							CreateMultilineTextBoxStyle()override;
				controls::GuiSinglelineTextBox::IStyleProvider*						CreateTextBoxStyle()override;
				controls::GuiListView::IStyleProvider*								CreateListViewStyle()override;
				controls::GuiTreeView::IStyleProvider*								CreateTreeViewStyle()override;
				
				controls::GuiControl::IStyleController*								CreateMenuStyle()override;
				controls::GuiControl::IStyleController*								CreateMenuBarStyle()override;
				controls::GuiControl::IStyleController*								CreateMenuSplitterStyle()override;
				controls::GuiMenuButton::IStyleController*							CreateMenuBarButtonStyle()override;
				controls::GuiMenuButton::IStyleController*							CreateMenuItemButtonStyle()override;

				controls::GuiButton::IStyleController*								CreateButtonStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateToolstripButtonStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateCheckBoxStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateRadioButtonStyle()override;
				
				controls::GuiScroll::IStyleController*								CreateHScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateVScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateHTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateVTrackerStyle()override;

				controls::GuiScrollView::IStyleProvider*							CreateTextListStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateCheckTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateRadioTextListItemStyle()override;
			};
		}
	}
}

#endif

/***********************************************************************
GACUI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI Header Files and Common Namespaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUI
#define VCZH_PRESENTATION_GACUI



using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;
using namespace vl::presentation::theme;

extern int SetupWindowsGDIRenderer();
extern int SetupWindowsDirect2DRenderer();

#endif

/***********************************************************************
GRAPHICSELEMENT\WINDOWSDIRECT2D\GUIGRAPHICSWINDOWSDIRECT2D.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSDIRECT2D
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSDIRECT2D

#include <D2D1.h>
#include <DWrite.h>
#include <wincodec.h>

namespace vl
{
	namespace presentation
	{
		namespace elements_windows_d2d
		{

/***********************************************************************
Functionality
***********************************************************************/

			class IWindowsDirect2DRenderTarget : public elements::IGuiGraphicsRenderTarget
			{
			public:
				virtual ID2D1RenderTarget*					GetDirect2DRenderTarget()=0;
				virtual ComPtr<ID2D1Bitmap>					GetBitmap(INativeImageFrame* frame)=0;
				virtual void								DestroyBitmapCache(INativeImageFrame* frame)=0;
				virtual void								SetTextAntialias(bool antialias, bool verticalAntialias)=0;

				virtual ID2D1SolidColorBrush*				CreateDirect2DBrush(Color color)=0;
				virtual void								DestroyDirect2DBrush(Color color)=0;
				virtual ID2D1LinearGradientBrush*			CreateDirect2DLinearBrush(Color c1, Color c2)=0;
				virtual void								DestroyDirect2DLinearBrush(Color c1, Color c2)=0;
			};

			class Direct2DTextFormatPackage
			{
			public:
				ComPtr<IDWriteTextFormat>		textFormat;
				DWRITE_TRIMMING					trimming;
				ComPtr<IDWriteInlineObject>		ellipseInlineObject;
			};

			class IWindowsDirect2DResourceManager : public Interface
			{
			public:
				virtual Direct2DTextFormatPackage*			CreateDirect2DTextFormat(const FontProperties& fontProperties)=0;
				virtual void								DestroyDirect2DTextFormat(const FontProperties& fontProperties)=0;
				virtual Ptr<elements::text::CharMeasurer>	CreateDirect2DCharMeasurer(const FontProperties& fontProperties)=0;
				virtual void								DestroyDirect2DCharMeasurer(const FontProperties& fontProperties)=0;
			};

			extern IWindowsDirect2DResourceManager*			GetWindowsDirect2DResourceManager();
			extern D2D1::ColorF								GetD2DColor(Color color);

/***********************************************************************
OS Supporting
***********************************************************************/

			class IWindowsDirect2DObjectProvider : public Interface
			{
			public:
				virtual ID2D1RenderTarget*					GetNativeWindowDirect2DRenderTarget(INativeWindow* window)=0;
				virtual ID2D1Factory*						GetDirect2DFactory()=0;
				virtual IDWriteFactory*						GetDirectWriteFactory()=0;
				virtual IWindowsDirect2DRenderTarget*		GetBindedRenderTarget(INativeWindow* window)=0;
				virtual void								SetBindedRenderTarget(INativeWindow* window, IWindowsDirect2DRenderTarget* renderTarget)=0;
				virtual IWICImagingFactory*					GetWICImagingFactory()=0;
				virtual IWICBitmap*							GetWICBitmap(INativeImageFrame* frame)=0;
			};

			extern IWindowsDirect2DObjectProvider*			GetWindowsDirect2DObjectProvider();
			extern void										SetWindowsDirect2DObjectProvider(IWindowsDirect2DObjectProvider* provider);
		}
	}
}

extern void RendererMainDirect2D();

#endif

/***********************************************************************
GRAPHICSELEMENT\WINDOWSDIRECT2D\GUIGRAPHICSRENDERERSWINDOWSDIRECT2D.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSDIRECT2D
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSDIRECT2D


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_d2d
		{
			using namespace elements;

#define DEFINE_BRUSH_ELEMENT_RENDERER(TELEMENT, TRENDERER, TBRUSH, TBRUSHPROPERTY)\
				DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, IWindowsDirect2DRenderTarget)\
			protected:\
				TBRUSHPROPERTY			oldColor;\
				TBRUSH*					brush;\
				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);\
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);\
				void					InitializeInternal();\
				void					FinalizeInternal();\
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);\
			public:\
				TRENDERER();\
				void					Render(Rect bounds)override;\
				void					OnElementStateChanged()override;\

/***********************************************************************
Renderers
***********************************************************************/


			class GuiSolidBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiSolidBorderElement, GuiSolidBorderElementRenderer, ID2D1SolidColorBrush, Color)
			};

			class GuiRoundBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiRoundBorderElement, GuiRoundBorderElementRenderer, ID2D1SolidColorBrush, Color)
			};

			class Gui3DBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DBorderElement, Gui3DBorderElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				ID2D1SolidColorBrush*	brush1;
				ID2D1SolidColorBrush*	brush2;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				Gui3DBorderElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DSplitterElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DSplitterElement, Gui3DSplitterElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				ID2D1SolidColorBrush*	brush1;
				ID2D1SolidColorBrush*	brush2;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				Gui3DSplitterElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiSolidBackgroundElement, GuiSolidBackgroundElementRenderer, ID2D1SolidColorBrush, Color)
			};

			class GuiGradientBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				typedef collections::Pair<Color, Color> ColorPair;
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiGradientBackgroundElement, GuiGradientBackgroundElementRenderer, ID2D1LinearGradientBrush, ColorPair)
			};

			class GuiSolidLabelElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidLabelElement, GuiSolidLabelElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color							oldColor;
				FontProperties					oldFont;
				WString							oldText;
				ID2D1SolidColorBrush*			brush;
				Direct2DTextFormatPackage*		textFormat;
				IDWriteTextLayout*				textLayout;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					CreateTextFormat(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyTextFormat(IWindowsDirect2DRenderTarget* _renderTarget);
				void					CreateTextLayout();
				void					DestroyTextLayout();
				void					UpdateMinSize();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiSolidLabelElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiImageFrameElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiImageFrameElement, GuiImageFrameElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				ComPtr<ID2D1Bitmap>		bitmap;

				void					UpdateBitmap(IWindowsDirect2DRenderTarget* renderTarget);

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiImageFrameElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiPolygonElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiPolygonElement, GuiPolygonElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color							oldBorderColor;
				Color							oldBackgroundColor;
				ID2D1SolidColorBrush*			borderBrush;
				ID2D1SolidColorBrush*			backgroundBrush;
				collections::Array<Point>		oldPoints;
				ComPtr<ID2D1PathGeometry>		geometry;

				void							CreateGeometry();
				void							DestroyGeometry();
				void							FillGeometry(Point offset);
				void							RecreateResource(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
				void							InitializeInternal();
				void							FinalizeInternal();
				void							RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiPolygonElementRenderer();

				void							Render(Rect bounds)override;
				void							OnElementStateChanged()override;
			};

			class GuiColorizedTextElementRenderer : public Object, public IGuiGraphicsRenderer, protected GuiColorizedTextElement::ICallback
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiColorizedTextElement, GuiColorizedTextElementRenderer, IWindowsDirect2DRenderTarget)

			public:
				struct ColorItemResource
				{
					Color						text;
					ID2D1SolidColorBrush*		textBrush;
					Color						background;
					ID2D1SolidColorBrush*		backgroundBrush;
				};

				struct ColorEntryResource
				{
					ColorItemResource			normal;
					ColorItemResource			selectedFocused;
					ColorItemResource			selectedUnfocused;

					bool						operator==(const ColorEntryResource& value){return false;}
					bool						operator!=(const ColorEntryResource& value){return true;}
				};

				typedef collections::Array<ColorEntryResource>			ColorArray;
			protected:
				FontProperties					oldFont;
				Direct2DTextFormatPackage*		textFormat;
				ColorArray						colors;
				Color							oldCaretColor;
				ID2D1SolidColorBrush*			caretBrush;
				
				void					CreateTextBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyTextBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					CreateCaretBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyCaretBrush(IWindowsDirect2DRenderTarget* _renderTarget);

				void					ColorChanged();
				void					FontChanged();
				text::CharMeasurer*		GetCharMeasurer();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\GDI\WINGDI.H
***********************************************************************/
/*******************************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::GDI Helper Library

Classes:
  WinRegion				£ºÍ¼ÐÎÇøÓò
  WinTransform			£º×ø±ê±ä»»
  WinBrush				£ºÍ¼ÐÎ»­Ë¢
  WinPen				£ºÍ¼ÐÎ»­±Ê
  WinFont				£º×ÖÌå
  WinDC					£ºÉè±¸ÉÏÏÂÎÄ
  WinControlDC			£º¿Ø¼þDC
  WinImageDC			£ºÍ¼ÐÎDC
  WinProxyDC			£º´úÀíDC
  WinDIB				£ºÉè±¸ÎÞ¹ØÎ»Í¼
  WinMetaFileBuilder	£ºÍ¼ÐÎÔªÎÄ¼þ±à¼­Æ÷
  WinMetaFile			£ºÍ¼ÐÎÔªÎÄ¼þ
  WinBitmap				£ºÎ»Í¼

Comments:
  WinDC::PolyDraw
    Points				£ºµãÊý×é
	Actions				£ºÒ»¸öËµÃ÷µãÊý×éÖÐµãµÄ×÷ÓÃµÄÊý×é£¬¿ÉÒÔÊÇÈçÏÂÄÚÈÝ£º
		PT_MOVETO		£ºÏûºÄ1¸öµãÖ´ÐÐMoveTo
		PT_LINETO		£ºÏûºÄ1¸öµãÖ´ÐÐLineTo
		PT_BEZIERTO		£ºÏûºÄ3¸öµãÍê³ÉBezierÇúÏß
		ÆäÖÐºóÁ½¸öÖµ¿ÉÒÔ¸úPT_CLOSEFIGURE½øÐÐor»ìºÏ£¬ÒÔ±ãÈÃÕâ¸öµã¸ú×îºóÒ»¸öPT_MOVETO»òMoveToµÄµãÁ¬Ïß×é³É·â±ÕÇúÏß
	PointCount			£ºµãÊý×éÖÐµãµÄÊýÁ¿
  WinDC::DrawBuffer
    Format: ²Î¼ûDrawTextº¯Êý
  Pen£º
	Style£º
		PS_SOLID¡¢PS_DASH¡¢PS_DOT¡¢PS_DASHDOT¡¢PS_DASHDOTDOT¡¢PS_USERSTYLE(Geometric»­±ÊÓÐÐ§)
	EndCap£º
		PS_ENDCAP_ROUND¡¢PS_ENDCAP_SQUARE¡¢PS_ENDCAP_FLAT
	Join£º
		PS_JOIN_BEVEL¡¢PS_JOIN_MITER¡¢PS_JOIN_ROUND
  Brush£º
	Hatch£º
		HS_BDIAGONAL¡¢HS_CROSS¡¢HS_DIAGCROSS¡¢HS_FDIAGONAL¡¢HS_HORIZONTAL¡¢HS_VERTICAL
  Region£º
	Combine£º
		RGN_AND¡¢RGN_OR¡¢RGN_XOR¡¢RGN_DIFF¡¢RGN_COPY
  ImageCopy£º
	Draw ROP£º
		BLACKNESS¡¢DSTINVERT¡¢MERGECOPY¡¢MERGEPAINT¡¢NOTSRCCOPY¡¢NOTSRCERASE¡¢
		PATCOPY¡¢PATINVERT¡¢PATPAINT¡¢SRCAND¡¢SRCCOPY¡¢SRCERASE¡¢SRCINVERT¡¢SRCPAINT¡¢WHITENESS
  WinDIB£º
	TransformAlphaChannel()£º	ÓÃÓÚÔÚÐÞ¸Ä·ÇalphaÍ¼Æ¬µÄalphaÍ¨µÀºó×ª»»ÎªalphaÍ¼Æ¬
	Generate¡Á¡Á¡Á()£º			ÓÃÓÚ×Ô¶¯Éú³É·ÇalphaÍ¼Æ¬µÄalphaÍ¨µÀÖµ
	±»WinDCµÄDraw»æÖÆµÄÊ±ºò£¬alphaÍ¼Æ¬ºÍ·ÇalphaÍ¼Æ¬»áÓÐ²»Í¬µÄÐ§¹û
*******************************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINGDI
#define VCZH_PRESENTATION_WINDOWS_GDI_WINGDI

#include<windows.h>

namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/*********************************************************************************************************
Í¼ÐÎ
*********************************************************************************************************/

			class WinRegion : public Object
			{
			public:
				typedef Ptr<WinRegion>	Ptr;

				friend bool IsEqual(WinRegion::Ptr Region1, WinRegion::Ptr Region2);
			protected:
				HRGN					FHandle;
			public:
				WinRegion(int Left, int Top, int Right, int Bottom, bool Rectangle);
				WinRegion(RECT Rect, bool Rectangle);
				WinRegion(int Left, int Top, int Right, int Bottom, int EllipseWidth, int EllipseHeight);
				WinRegion(POINT* Points, int Count, bool Alternate);
				WinRegion(WinRegion::Ptr Region);
				WinRegion(WinRegion::Ptr Region1, WinRegion::Ptr Region2, int CombineMode);
				WinRegion(HRGN RegionHandle);
				~WinRegion();

				HRGN					GetHandle();
				bool					ContainPoint(POINT Point);
				bool					ContainRect(RECT Rect);
				RECT					GetBoundRect();
				void					Move(int OffsetX, int OffsetY);
			};

			class WinTransform : public Object
			{
			protected:
				XFORM					FTransform;
			public:
				WinTransform(XFORM Transform);
				WinTransform(const WinTransform& Transform);

				WinTransform&			operator=(const WinTransform& Transform);
				WinTransform			operator*(const WinTransform& Transform);
				const XFORM*			GetHandle()const;

				static WinTransform		Translate(float OffsetX, float OffsetY);
				static WinTransform		Scale(float ScaleX, float ScaleY);
				static WinTransform		Rotate(float Angle);
				static WinTransform		Rotate(float Cos, float Sin);
				static WinTransform		ReflectX();
				static WinTransform		ReflectY();
				static WinTransform		Reflect(float VectorX, float VectorY);
				static WinTransform		Reflect(float OriginX, float OriginY, float VectorX, float VectorY);
				static WinTransform		AxisV(float Xx, float Xy, float Yx, float Yy);
				static WinTransform		AxisA(float AngleX, float LenX, float AngleY, float LenY);
			};
		
/*********************************************************************************************************
Í¼Ïñ
*********************************************************************************************************/

			class WinDC;
			class WinControlDC;
			class WinProxyDC;
			class WinImageDC;

			class WinMetaFileBuilder : public Object
			{
				friend class WinMetaFile;
			protected:
				int						FWidth;
				int						FHeight;
				WinProxyDC*				FDC;

				void					Create(int Width, int Height);
				void					Draw(HENHMETAFILE Handle);
				void					Destroy();
			public:

				WinMetaFileBuilder(int Width, int Height);
				~WinMetaFileBuilder();

				void					LoadFrom(WinMetaFile* File);
				void					SaveTo(WinMetaFile* File);
				void					LoadFrom(WString FileName);
				void					SaveTo(WString FileName);
				WinDC*					GetWinDC();
				int						GetWidth();
				int						GetHeight();
			};

			class WinMetaFile : public Object
			{
				friend class WinMetaFileBuilder;
			protected:
				HENHMETAFILE			FHandle;
				int						FWidth;
				int						FHeight;
			public:
				WinMetaFile(WString FileName);
				WinMetaFile(WinMetaFileBuilder* Builder);
				~WinMetaFile();

				HENHMETAFILE			GetHandle();
				int						GetWidth();
				int						GetHeight();
			};

			class WinBitmap : public Object
			{
			public:
				typedef Ptr<WinBitmap>		Ptr;
				enum BitmapBits
				{
					vbb2Bits,
					vbb24Bits,
					vbb32Bits
				};
			protected:
				BitmapBits				FBits;
				int						FWidth;
				int						FHeight;
				WinImageDC*				FDC;
				HBITMAP					FHandle;
				BYTE**					FScanLines;
				bool					FAlphaChannelBuilt;

				int						GetBitsFromBB(BitmapBits BB);
				int						GetLineBytes(int Width, BitmapBits BB);
				void					FillBitmapInfoHeader(int Width, int Height, BitmapBits Bits, BITMAPINFOHEADER* Header);
				HBITMAP					CreateDDB(int Width, int Height, BitmapBits Bits);
				HBITMAP					CreateDIB(int Width, int Height, BitmapBits Bits, BYTE**& ScanLines);
				void					Constructor(int Width, int Height, BitmapBits Bits, bool DIBSections);
			public:
				WinBitmap(int Width, int Height, BitmapBits Bits, bool DIBSections);
				WinBitmap(WString FileName, bool Use32Bits, bool DIBSections);
				~WinBitmap();

				void					SaveToFile(WString FileName);

				WinDC*					GetWinDC();
				int						GetWidth();
				int						GetHeight();
				int						GetLineBytes();
				BYTE**					GetScanLines();
				HBITMAP					GetBitmap();
				BitmapBits				GetBitmapBits();
				void					FillCompatibleHeader(BITMAPINFOHEADER* Header);

				bool					CanBuildAlphaChannel();
				bool					IsAlphaChannelBuilt();
				void					BuildAlphaChannel(bool autoPremultiply);
				void					GenerateTrans(COLORREF Color);
				void					GenerateAlpha(BYTE Alpha);
				void					GenerateTransAlpha(COLORREF Color, BYTE Alpha);
				void					GenerateLuminance();
				void					GenerateGrayLevel();
				void					Generate(BYTE(*Function)(COLORREF));
			};

/*********************************************************************************************************
²ÄÁÏ
*********************************************************************************************************/

			class WinBrush : public Object
			{
			public:
				typedef Ptr<WinBrush>		Ptr;
			protected:
				HBRUSH					FHandle;
				unsigned char*			FDIBMemory;
			public:
				WinBrush();
				WinBrush(COLORREF Color);
				WinBrush(int Hatch, COLORREF Color);
				WinBrush(WinBitmap::Ptr Bitmap);
				~WinBrush();

				HBRUSH					GetHandle();
			};

			class WinPen : public Object
			{
			public:
				typedef Ptr<WinPen>		Ptr;
			protected:
				HPEN					FHandle;
				unsigned char*			FDIBMemory;
			public:
				WinPen(int Style, int Width, COLORREF Color);
				WinPen(int Style, int EndCap, int Join, int Width, COLORREF Color);
				WinPen(int Style, int EndCap, int Join, int Hatch, int Width, COLORREF Color);
				WinPen(WinBitmap::Ptr DIB, int Style, int EndCap, int Join, int Width);
				~WinPen();

				HPEN					GetHandle();
			};

			class WinFont : public Object
			{
			public:
				typedef Ptr<WinFont>		Ptr;
			protected:
				LOGFONT					FFontInfo;
				HFONT					FHandle;
			public:
				WinFont(WString Name, int Height, int Width, int Escapement, int Orientation, int Weight, bool Italic, bool Underline, bool StrikeOut, bool Antialise);
				WinFont(LOGFONT* FontInfo);
				~WinFont();

				HFONT					GetHandle();
				LOGFONT*				GetInfo();
			};

/*********************************************************************************************************
Éè±¸ÉÏÏÂÎÄ
*********************************************************************************************************/

			extern WinBrush::Ptr		CreateDefaultBrush();
			extern WinPen::Ptr			CreateDefaultPen();
			extern WinFont::Ptr			CreateDefaultFont();

			class IWinResourceService : public Interface
			{
			public:
				virtual WinPen::Ptr		GetDefaultPen()=0;
				virtual WinBrush::Ptr	GetDefaultBrush()=0;
				virtual WinFont::Ptr	GetDefaultFont()=0;
			};
			extern IWinResourceService*	GetDefaultResourceService();
			extern void					SetDefaultResourceService(IWinResourceService* Service);

			class WinDC : public Object
			{
			protected:
				HDC						FHandle;

				WinPen::Ptr				FPen;
				WinBrush::Ptr			FBrush;
				WinFont::Ptr			FFont;

				HPEN					FOldPen;
				HBRUSH					FOldBrush;
				HFONT					FOldFont;

				void					Init();
			public:
				WinDC();
				~WinDC();

				HDC						GetHandle();

				WinPen::Ptr				GetPen();
				WinBrush::Ptr			GetBrush();
				WinFont::Ptr			GetFont();
				void					SetPen(WinPen::Ptr Pen);
				void					SetBrush(WinBrush::Ptr Brush);
				void					SetFont(WinFont::Ptr Font);
				COLORREF				GetBackColor();
				void					SetBackColor(COLORREF Color);
				COLORREF				GetTextColor();
				void					SetTextColor(COLORREF Color);
				bool					GetBackTransparent();
				void					SetBackTransparent(bool Transparent);
				POINT					GetBrushOrigin();
				void					SetBrushOrigin(POINT Point);

				void					DrawBuffer(int X, int Y, const wchar_t* Text, int CharCount);
				void					DrawBuffer(int X, int Y, const wchar_t* Text, int CharCount, int TabWidth, int TabOriginX);
				void					DrawBuffer(RECT Rect, const wchar_t* Text, int CharCount, UINT Format);
				void					DrawString(int X, int Y, WString Text);
				void					DrawString(int X, int Y, WString Text, int TabWidth, int TabOriginX);
				void					DrawString(RECT Rect, WString Text, UINT Format);
				SIZE					MeasureString(WString Text, int TabSize=-1);
				SIZE					MeasureBuffer(const wchar_t* Text, int CharCount, int TabSize=-1);
				SIZE					MeasureBuffer(const wchar_t* Text, int TabSize=-1);

				void					FillRegion(WinRegion::Ptr Region);
				void					FrameRegion(WinRegion::Ptr Region, int BlockWidth, int BlockHeight);

				void					MoveTo(int X, int Y);
				void					LineTo(int X, int Y);
				void					Rectangle(int Left, int Top, int Right, int Bottom);
				void					Rectangle(RECT Rect);
				void					FocusRectangle(int Left, int Top, int Right, int Bottom);
				void					FocusRectangle(RECT Rect);
				void					FillRect(int Left, int Top, int Right, int Bottom);
				void					FillRect(RECT Rect);
				void					Ellipse(int Left, int Top, int Right, int Bottom);
				void					Ellipse(RECT Rect);
				void					RoundRect(int Left, int Top, int Right, int Bottom, int EllipseWidth, int EllipseHeight);
				void					RoundRect(RECT Rect, int EllipseWidth, int EllipseHeight);
				void					PolyLine(const POINT* Points, int Count);
				void					PolyLineTo(const POINT* Points, int Count);
				void					PolyGon(const POINT* Points, int Count);
				void					PolyBezier(const POINT* Points, int Count);
				void					PolyBezierTo(const POINT* Points, int Count);
				void					PolyDraw(const POINT* Points, const BYTE* Actions, int PointCount);
				void					Arc(RECT Bound, POINT Start, POINT End);
				void					Arc(int Left, int Top, int Right, int Bottom, int StartX, int StartY, int EndX, int EndY);
				void					ArcTo(RECT Bound, POINT Start, POINT End);
				void					ArcTo(int Left, int Top, int Right, int Bottom, int StartX, int StartY, int EndX, int EndY);
				void					AngleArc(int X, int Y, int Radius, float StartAngle, float SweepAngle);
				void					AngleArc(int X, int Y, int Radius, double StartAngle, double SweepAngle);
				void					Chord(RECT Bound, POINT Start, POINT End);
				void					Chord(int Left, int Top, int Right, int Bottom, int StartX, int StartY, int EndX, int EndY);
				void					Pie(RECT Bound, POINT Start, POINT End);
				void					Pie(int Left, int Top, int Right, int Bottom, int StartX, int StartY, int EndX, int EndY);
				void					GradientTriangle(TRIVERTEX* Vertices, int VerticesCount, GRADIENT_TRIANGLE* Triangles, int TriangleCount);

				void					BeginPath();
				void					EndPath();
				void					ClosePath();
				void					WidenPath();
				void					DiscardPath();
				void					DrawPath();
				void					FillPath();
				void					DrawAndFillPath();
				WinRegion::Ptr			RegionFromPath();

				bool					PointInClip(POINT Point);
				bool					RectInClip(RECT Rect);
				void					ClipPath(int CombineMode);
				void					ClipRegion(WinRegion::Ptr Region);
				void					RemoveClip();
				void					MoveClip(int OffsetX, int OffsetY);
				void					CombineClip(WinRegion::Ptr Region, int CombineMode);
				void					IntersetClipRect(RECT Rect);
				void					ExcludeClipRect(RECT Rect);
				WinRegion::Ptr			GetClipRegion();
				RECT					GetClipBoundRect();

				WinTransform			GetTransform();
				void					SetTransform(const WinTransform& Transform);

				void					Copy(int dstX, int dstY, int dstW, int dstH, WinDC* Source, int srcX, int srcY, DWORD DrawROP=SRCCOPY);
				void					Copy(RECT dstRect, WinDC* Source, POINT srcPos, DWORD DrawROP=SRCCOPY);
				void					Copy(int dstX, int dstY, int dstW, int dstH, WinDC* Source, int srcX, int srcY ,int srcW, int srcH, DWORD DrawROP=SRCCOPY);
				void					Copy(RECT dstRect, WinDC* Source, RECT srcRect, DWORD DrawROP=SRCCOPY);
				void					Copy(POINT UpperLeft, POINT UpperRight, POINT LowerLeft, WinDC* Source, int srcX, int srcY, int srcW, int srcH);
				void					Copy(POINT UpperLeft, POINT UpperRight, POINT LowerLeft, WinDC* Source, RECT srcRect);
				void					CopyTrans(int dstX, int dstY, int dstW, int dstH, WinDC* Source, int srcX, int srcY ,int srcW, int srcH, COLORREF Color);
				void					CopyTrans(RECT dstRect, WinDC* Source, RECT srcRect, COLORREF Color);

				void					Draw(int dstX, int dstY, WinMetaFile* MetaFile);
				void					Draw(POINT Pos, WinMetaFile* MetaFile);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinMetaFile* MetaFile);
				void					Draw(RECT Rect, WinMetaFile* MetaFile);

				void					Draw(int dstX, int WinBitmap, WinBitmap::Ptr Bitmap);
				void					Draw(POINT Pos, WinBitmap::Ptr Bitmap);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, int srcX, int srcY);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, POINT Pos);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, int srcX, int srcY, int srcW, int srcH);
				void					Draw(RECT dstRect, WinBitmap::Ptr Bitmap, RECT srcRect);

				void					Draw(int dstX, int dstY, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(POINT Pos, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, int srcX, int srcY, unsigned char Alpha);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, POINT Pos, unsigned char Alpha);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, int srcX, int srcY, int srcW, int srcH, unsigned char Alpha);
				void					Draw(RECT dstRect, WinBitmap::Ptr Bitmap, RECT srcRect, unsigned char Alpha);
			};

			class WinControlDC : public WinDC
			{
			protected:
				HWND					FControlHandle;
			public:
				WinControlDC(HWND Handle);
				~WinControlDC();
			};

			class WinProxyDC : public WinDC
			{
			public:
				WinProxyDC();
				~WinProxyDC();

				void					Initialize(HDC Handle);
			};

			class WinImageDC : public WinDC
			{
			public:
				WinImageDC();
				~WinImageDC();
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\WINDOWSGDI\GUIGRAPHICSWINDOWSGDI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSGDI
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSGDI


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_gdi
		{

/***********************************************************************
Functionality
***********************************************************************/

			class IWindowsGDIRenderTarget : public elements::IGuiGraphicsRenderTarget
			{
			public:
				virtual windows::WinDC*					GetDC()=0;
			};

			class IWindowsGDIResourceManager : public Interface
			{
			public:
				virtual Ptr<windows::WinPen>				CreateGdiPen(Color color)=0;
				virtual void								DestroyGdiPen(Color color)=0;
				virtual Ptr<windows::WinBrush>				CreateGdiBrush(Color color)=0;
				virtual void								DestroyGdiBrush(Color color)=0;
				virtual Ptr<windows::WinFont>				CreateGdiFont(const FontProperties& fontProperties)=0;
				virtual void								DestroyGdiFont(const FontProperties& fontProperties)=0;
				virtual Ptr<elements::text::CharMeasurer>	CreateCharMeasurer(const FontProperties& fontProperties)=0;
				virtual void								DestroyCharMeasurer(const FontProperties& fontProperties)=0;

				virtual Ptr<windows::WinBitmap>				GetBitmap(INativeImageFrame* frame)=0;
				virtual void								DestroyBitmapCache(INativeImageFrame* frame)=0;
			};

			extern IWindowsGDIResourceManager*			GetWindowsGDIResourceManager();

/***********************************************************************
OS Supporting
***********************************************************************/

			class IWindowsGDIObjectProvider : public Interface
			{
			public:
				virtual windows::WinDC*						GetNativeWindowDC(INativeWindow* window)=0;
				virtual IWindowsGDIRenderTarget*			GetBindedRenderTarget(INativeWindow* window)=0;
				virtual void								SetBindedRenderTarget(INativeWindow* window, IWindowsGDIRenderTarget* renderTarget)=0;
				virtual IWICImagingFactory*					GetWICImagingFactory()=0;
				virtual IWICBitmap*							GetWICBitmap(INativeImageFrame* frame)=0;
			};

			extern IWindowsGDIObjectProvider*				GetWindowsGDIObjectProvider();
			extern void										SetWindowsGDIObjectProvider(IWindowsGDIObjectProvider* provider);
		}
	}
}

extern void RendererMainGDI();

#endif

/***********************************************************************
GRAPHICSELEMENT\WINDOWSGDI\GUIGRAPHICSRENDERERSWINDOWSGDI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSGDI
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSGDI


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_gdi
		{
			using namespace elements;

/***********************************************************************
Renderers
***********************************************************************/

			class GuiSolidBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidBorderElement, GuiSolidBorderElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor;
				Ptr<windows::WinPen>	pen;
				Ptr<windows::WinBrush>	brush;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiRoundBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiRoundBorderElement, GuiRoundBorderElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor;
				Ptr<windows::WinPen>	pen;
				Ptr<windows::WinBrush>	brush;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DBorderElement, Gui3DBorderElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				Ptr<windows::WinPen>	pen1;
				Ptr<windows::WinPen>	pen2;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DSplitterElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DSplitterElement, Gui3DSplitterElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				Ptr<windows::WinPen>	pen1;
				Ptr<windows::WinPen>	pen2;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidBackgroundElement, GuiSolidBackgroundElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor;
				Ptr<windows::WinPen>	pen;
				Ptr<windows::WinBrush>	brush;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiGradientBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiGradientBackgroundElement, GuiGradientBackgroundElementRenderer, IWindowsGDIRenderTarget)
			protected:
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidLabelElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidLabelElement, GuiSolidLabelElementRenderer, IWindowsGDIRenderTarget)
			protected:
				FontProperties			oldFont;
				Ptr<windows::WinFont>	font;

				void					UpdateMinSize();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiImageFrameElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiImageFrameElement, GuiImageFrameElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Ptr<windows::WinBitmap>		bitmap;

				void					UpdateBitmap();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiImageFrameElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiPolygonElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiPolygonElement, GuiPolygonElementRenderer, IWindowsGDIRenderTarget)
			protected:
				POINT*							points;
				int								pointCount;
				Color							oldPenColor;
				Color							oldBrushColor;
				Ptr<windows::WinPen>			pen;
				Ptr<windows::WinBrush>			brush;

				void							InitializeInternal();
				void							FinalizeInternal();
				void							RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiPolygonElementRenderer();
				~GuiPolygonElementRenderer();

				void							Render(Rect bounds)override;
				void							OnElementStateChanged()override;
			};

			class GuiColorizedTextElementRenderer : public Object, public IGuiGraphicsRenderer, protected GuiColorizedTextElement::ICallback
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiColorizedTextElement, GuiColorizedTextElementRenderer, IWindowsGDIRenderTarget)

			public:
				struct ColorItemResource
				{
					Color						text;
					Color						background;
					Ptr<windows::WinBrush>		backgroundBrush;
				};

				struct ColorEntryResource
				{
					ColorItemResource			normal;
					ColorItemResource			selectedFocused;
					ColorItemResource			selectedUnfocused;

					bool						operator==(const ColorEntryResource& value){return false;}
					bool						operator!=(const ColorEntryResource& value){return true;}
				};

				typedef collections::Array<ColorEntryResource>			ColorArray;
			protected:
				FontProperties			oldFont;
				Ptr<windows::WinFont>	font;
				ColorArray				colors;
				Color					oldCaretColor;
				Ptr<windows::WinPen>	caretPen;

				void					DestroyColors();
				void					ColorChanged();
				void					FontChanged();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSIMAGESERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSIMAGESERIVCE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSIMAGESERIVCE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsImageFrame : public Object, public INativeImageFrame
			{
			protected:
				INativeImage*													image;
				ComPtr<IWICBitmap>												frameBitmap;
				collections::Dictionary<void*, Ptr<INativeImageFrameCache>>		caches;

				void										Initialize(IWICBitmapSource* bitmapSource);
			public:
				WindowsImageFrame(INativeImage* _image, IWICBitmapFrameDecode* frameDecode);
				WindowsImageFrame(INativeImage* _image, IWICBitmap* sourceBitmap);
				~WindowsImageFrame();
				INativeImage*								GetImage();
				Size										GetSize();
				bool										SetCache(void* key, Ptr<INativeImageFrameCache> cache);
				Ptr<INativeImageFrameCache>					GetCache(void* key);
				Ptr<INativeImageFrameCache>					RemoveCache(void* key);
				IWICBitmap*									GetFrameBitmap();
			};

			class WindowsImage : public Object, public INativeImage
			{
			protected:
				INativeImageService*						imageService;
				ComPtr<IWICBitmapDecoder>					bitmapDecoder;
				collections::Array<Ptr<WindowsImageFrame>>	frames;
			public:
				WindowsImage(INativeImageService* _imageService, IWICBitmapDecoder* _bitmapDecoder);
				~WindowsImage();
				INativeImageService*						GetImageService();
				FormatType									GetFormat();
				int											GetFrameCount();
				INativeImageFrame*							GetFrame(int index);
			};

			class WindowsBitmapImage : public Object, public INativeImage
			{
			protected:
				INativeImageService*						imageService;
				Ptr<WindowsImageFrame>						frame;
				FormatType									formatType;
			public:
				WindowsBitmapImage(INativeImageService* _imageService, IWICBitmap* sourceBitmap, FormatType _formatType);
				~WindowsBitmapImage();
				INativeImageService*						GetImageService();
				FormatType									GetFormat();
				int											GetFrameCount();
				INativeImageFrame*							GetFrame(int index);
			};

			class WindowsImageService : public Object, public INativeImageService
			{
			protected:
				ComPtr<IWICImagingFactory>					imagingFactory;
			public:
				WindowsImageService();
				~WindowsImageService();
				Ptr<INativeImage>							CreateImageFromFile(const WString& path);
				Ptr<INativeImage>							CreateImageFromHBITMAP(HBITMAP handle);
				Ptr<INativeImage>							CreateImageFromHICON(HICON handle);
				IWICImagingFactory*							GetImagingFactory();
			};

			extern IWICImagingFactory*						GetWICImagingFactory();
			extern IWICBitmap*								GetWICBitmap(INativeImageFrame* frame);
			extern Ptr<INativeImage>						CreateImageFromHBITMAP(HBITMAP handle);
			extern Ptr<INativeImage>						CreateImageFromHICON(HICON handle);
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\WINNATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_WINNATIVEWINDOW
#define VCZH_PRESENTATION_WINDOWS_WINNATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/***********************************************************************
Windows Platform Native Controller
***********************************************************************/

			class IWindowsForm : public Interface
			{
			public:
				virtual HWND								GetWindowHandle()=0;
				virtual Interface*							GetGraphicsHandler()=0;
				virtual void								SetGraphicsHandler(Interface* handler)=0;
			};

			extern INativeController*						CreateWindowsNativeController(HINSTANCE hInstance);
			extern IWindowsForm*							GetWindowsForm(INativeWindow* window);
			extern void										DestroyWindowsNativeController(INativeController* controller);
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\DIRECT2D\WINDIRECT2DAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation

Interfaces:
***********************************************************************/
#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINDIRECT2DAPPLICATION
#define VCZH_PRESENTATION_WINDOWS_GDI_WINDIRECT2DAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			extern ID2D1RenderTarget*					GetNativeWindowDirect2DRenderTarget(INativeWindow* window);
			extern ID2D1Factory*						GetDirect2DFactory();
			extern IDWriteFactory*						GetDirectWriteFactory();
		}
	}
}

extern int WinMainDirect2D(HINSTANCE hInstance, void(*RendererMain)());

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\GDI\WINGDIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation

Interfaces:
***********************************************************************/
#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINGDIAPPLICATION
#define VCZH_PRESENTATION_WINDOWS_GDI_WINGDIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			extern WinDC*									GetNativeWindowDC(INativeWindow* window);
			extern HDC										GetNativeWindowHDC(INativeWindow* window);
		}
	}
}

extern int WinMainGDI(HINSTANCE hInstance, void(*RendererMain)());

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSASYNCSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSASYNCSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSASYNCSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsAsyncService : public INativeAsyncService
			{
			public:
				struct TaskItem
				{
					Semaphore*							semaphore;
					INativeAsyncService::AsyncTaskProc*	proc;
					void*								argument;

					TaskItem();
					TaskItem(Semaphore* _semaphore, INativeAsyncService::AsyncTaskProc* _proc, void* _argument);
					~TaskItem();

					bool operator==(const TaskItem& item)const{return false;}
					bool operator!=(const TaskItem& item)const{return true;}
				};
			protected:
				int								mainThreadId;
				SpinLock						taskListLock;
				collections::List<TaskItem>		taskItems;
			public:
				WindowsAsyncService();
				~WindowsAsyncService();
				void							ExecuteAsyncTasks();
				bool							IsInMainThread();
				void							InvokeAsync(INativeAsyncService::AsyncTaskProc* proc, void* argument);
				void							InvokeInMainThread(INativeAsyncService::AsyncTaskProc* proc, void* argument);
				bool							InvokeInMainThreadAndWait(INativeAsyncService::AsyncTaskProc* proc, void* argument, int milliseconds);
			};
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSCALLBACKSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSCALLBACKSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSCALLBACKSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsCallbackService : public Object, public INativeCallbackService
			{
			protected:
				collections::List<INativeControllerListener*>	listeners;

			public:
				WindowsCallbackService();
				bool											InstallListener(INativeControllerListener* listener);
				bool											UninstallListener(INativeControllerListener* listener);

				void											InvokeMouseHook(WPARAM message, Point location);
				void											InvokeGlobalTimer();
				void											InvokeClipboardUpdated();
				void											InvokeNativeWindowCreated(INativeWindow* window);
				void											InvokeNativeWindowDestroyed(INativeWindow* window);
			};
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSCLIPBOARDSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSCLIPBOARDSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSCLIPBOARDSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsClipboardService : public Object, public INativeClipboardService
			{
			protected:
				HWND					ownerHandle;
			public:
				WindowsClipboardService();
				void					SetOwnerHandle(HWND handle);
				bool					ContainsText();
				WString					GetText();
				bool					SetText(const WString& value);
			};
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSINPUTSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSINPUTSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSINPUTSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsInputService : public Object, public INativeInputService
			{
			protected:
				HWND								ownerHandle;
				HHOOK								mouseHook;
				bool								isTimerEnabled;
				HOOKPROC							mouseProc;
			public:
				WindowsInputService(HOOKPROC _mouseProc);

				void								SetOwnerHandle(HWND handle);
				void								StartHookMouse();
				void								StopHookMouse();
				bool								IsHookingMouse();
				void								StartTimer();
				void								StopTimer();
				bool								IsTimerEnabled();
				bool								IsKeyPressing(int code);
				bool								IsKeyToggled(int code);
			};

			extern bool								WinIsKeyPressing(int code);
			extern bool								WinIsKeyToggled(int code);
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSRESOURCESERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSRESOURCESERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSRESOURCESERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsCursor : public Object, public INativeCursor
			{
			protected:
				HCURSOR										handle;
				bool										isSystemCursor;
				SystemCursorType							systemCursorType;
			public:
				WindowsCursor(HCURSOR _handle);
				WindowsCursor(SystemCursorType type);
				bool										IsSystemCursor();
				SystemCursorType							GetSystemCursorType();
				HCURSOR										GetCursorHandle();
			};

			class WindowsResourceService : public Object, public INativeResourceService
			{
			protected:
				collections::Array<Ptr<WindowsCursor>>		systemCursors;
				FontProperties								defaultFont;
			public:
				WindowsResourceService();
				INativeCursor*								GetSystemCursor(INativeCursor::SystemCursorType type);
				INativeCursor*								GetDefaultSystemCursor();
				FontProperties								GetDefaultFont();
				void										SetDefaultFont(const FontProperties& value);
			};
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSSCREENSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSSCREENSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSSCREENSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsScreen : public Object, public INativeScreen
			{
				friend class WindowsScreenService;
			protected:
				HMONITOR										monitor;
			public:
				WindowsScreen();
				Rect											GetBounds();
				Rect											GetClientBounds();
				WString											GetName();
				bool											IsPrimary();
			};

			class WindowsScreenService : public Object, public INativeScreenService
			{
				typedef HWND (*HandleRetriver)(INativeWindow*);
			protected:
				collections::List<Ptr<WindowsScreen>>			screens;
				HandleRetriver									handleRetriver;
			public:

				struct MonitorEnumProcData
				{
					WindowsScreenService*	screenService;
					int						currentScreen;
				};

				WindowsScreenService(HandleRetriver _handleRetriver);

				static BOOL CALLBACK							MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData);
				void											RefreshScreenInformation();
				int												GetScreenCount();
				INativeScreen*									GetScreen(int index);
				INativeScreen*									GetScreen(INativeWindow* window);
			};
		}
	}
}

#endif
