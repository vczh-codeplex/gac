/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: ³Âè÷å«(vczh)
***********************************************************************/
#include "Vlpp.h"

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GACVLPPREFERENCES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI Vczh Library++ 3.0 References

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACVLPPREFERENCES
#define VCZH_PRESENTATION_GACVLPPREFERENCES


#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\GUITYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Common Types

Classes:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUITYPES
#define VCZH_PRESENTATION_GUITYPES


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Enumerations
***********************************************************************/
		
		namespace Alignment
		{
			/// <summary>
			/// Defines an alignment direction.
			/// </summary>
			enum Type
			{
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the left side.</summary>
				Left=0,
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the top side.</summary>
				Top=0,
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the center.</summary>
				Center=1,
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the right side.</summary>
				Right=2,
				/// <summary>[T:vl.presentation.Alignment.Type]Aligned to the bottom side.</summary>
				Bottom=2,
			};
		}

/***********************************************************************
TextPos
***********************************************************************/
		
		/// <summary>
		/// Represents the position in multiple lines of text.
		/// </summary>
		struct TextPos
		{
			/// <summary>
			/// Row number.
			/// </summary>
			int			row;
			/// <summary>
			/// Column number. If a line has 4 characters, there are 5 available column numbers(from 0 to 4) in this line.
			/// </summary>
			int			column;

			TextPos()
				:row(0) ,column(0)
			{
			}

			TextPos(int _row, int _column)
				:row(_row) ,column(_column)
			{
			}

			int Compare(const TextPos& value)const
			{
				if(row<value.row) return -1;
				if(row>value.row) return 1;
				if(column<value.column) return -1;
				if(column>value.column) return 1;
				return 0;
			}

			bool operator==(const TextPos& value)const {return Compare(value)==0;}
			bool operator!=(const TextPos& value)const {return Compare(value)!=0;}
			bool operator<(const TextPos& value)const {return Compare(value)<0;}
			bool operator<=(const TextPos& value)const {return Compare(value)<=0;}
			bool operator>(const TextPos& value)const {return Compare(value)>0;}
			bool operator>=(const TextPos& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
Point
***********************************************************************/
		
		/// <summary>
		/// Represents a position in a two dimensions space.
		/// </summary>
		struct Point
		{
			/// <summary>
			/// Position in x dimension.
			/// </summary>
			int			x;
			/// <summary>
			/// Position in y dimension.
			/// </summary>
			int			y;

			Point()
				:x(0) ,y(0)
			{
			}

			Point(int _x, int _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Point point)const
			{
				return x==point.x && y==point.y;
			}

			bool operator!=(Point point)const
			{
				return x!=point.x || y!=point.y;
			}
		};

/***********************************************************************
Size
***********************************************************************/
		
		/// <summary>
		/// Represents a size in a two dimensions space.
		/// </summary>
		struct Size
		{
			/// <summary>
			/// Size in x dimension.
			/// </summary>
			int			x;
			/// <summary>
			/// Size in y dimension.
			/// </summary>
			int			y;

			Size()
				:x(0) ,y(0)
			{
			}

			Size(int _x, int _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Size size)const
			{
				return x==size.x && y==size.y;
			}

			bool operator!=(Size size)const
			{
				return x!=size.x || y!=size.y;
			}
		};

/***********************************************************************
Rectangle
***********************************************************************/
		
		/// <summary>
		/// Represents a bounds in a two dimensions space.
		/// </summary>
		struct Rect
		{
			/// <summary>
			/// Left.
			/// </summary>
			int		x1;
			/// <summary>
			/// Top.
			/// </summary>
			int		y1;
			/// <summary>
			/// Left + Width.
			/// </summary>
			int		x2;
			/// <summary>
			/// Top + Height.
			/// </summary>
			int		y2;

			Rect()
				:x1(0), y1(0), x2(0), y2(0)
			{
			}

			Rect(int _x1, int _y1, int _x2, int _y2)
				:x1(_x1), y1(_y1), x2(_x2), y2(_y2)
			{
			}

			Rect(Point p, Size s)
				:x1(p.x), y1(p.y), x2(p.x+s.x), y2(p.y+s.y)
			{
			}

			bool operator==(Rect rect)const
			{
				return x1==rect.x1 && y1==rect.y1 && x2==rect.x2 && y2==rect.y2;
			}

			bool operator!=(Rect rect)const
			{
				return x1!=rect.x1 || y1!=rect.y1 || x2!=rect.x2 || y2!=rect.y2;
			}

			Point LeftTop()const
			{
				return Point(x1, y1);
			}

			Point RightBottom()const
			{
				return Point(x2, y2);
			}

			Size GetSize()const
			{
				return Size(x2-x1, y2-y1);
			}

			int Left()const
			{
				return x1;
			}

			int Right()const
			{
				return x2;
			}

			int Width()const
			{
				return x2-x1;
			}

			int Top()const
			{
				return y1;
			}

			int Bottom()const
			{
				return y2;
			}

			int Height()const
			{
				return y2-y1;
			}

			void Expand(int x, int y)
			{
				x1-=x;
				y1-=y;
				x2+=x;
				y2+=y;
			}

			void Expand(Size s)
			{
				x1-=s.x;
				y1-=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			void Move(int x, int y)
			{
				x1+=x;
				y1+=y;
				x2+=x;
				y2+=y;
			}

			void Move(Size s)
			{
				x1+=s.x;
				y1+=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			bool Contains(Point p)
			{
				return x1<=p.x && p.x<x2 && y1<=p.y && p.y<y2;
			}
		};

/***********************************************************************
2D operations
***********************************************************************/

		inline Point operator+(Point p, Size s)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator+(Size s, Point p)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator-(Point p, Size s)
		{
			return Point(p.x-s.x, p.y-s.y);
		}

		inline Size operator-(Point p1, Point p2)
		{
			return Size(p1.x-p2.x, p1.y-p2.y);
		}

		inline Size operator+(Size s1, Size s2)
		{
			return Size(s1.x+s2.x, s1.y+s2.y);
		}

		inline Size operator-(Size s1, Size s2)
		{
			return Size(s1.x-s2.x, s1.y-s2.y);
		}

		inline Size operator*(Size s, int i)
		{
			return Size(s.x*i, s.y*i);
		}

		inline Size operator/(Size s, int i)
		{
			return Size(s.x/i, s.y/i);
		}

		inline Point operator+=(Point& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Point operator-=(Point& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

		inline Size operator+=(Size& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Size operator-=(Size& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

/***********************************************************************
Color
***********************************************************************/
		
		struct Color
		{
			union
			{
				struct
				{
					unsigned char r;
					unsigned char g;
					unsigned char b;
					unsigned char a;
				};
				unsigned __int32 value;
			};

			Color()
				:r(0), g(0), b(0), a(255)
			{
			}

			Color(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a=255)
				:r(_r), g(_g), b(_b), a(_a)
			{
			}

			int Compare(Color color)const
			{
				return value-color.value;
			}

			bool operator==(Color color)const {return Compare(color)==0;}
			bool operator!=(Color color)const {return Compare(color)!=0;}
			bool operator<(Color color)const {return Compare(color)<0;}
			bool operator<=(Color color)const {return Compare(color)<=0;}
			bool operator>(Color color)const {return Compare(color)>0;}
			bool operator>=(Color color)const {return Compare(color)>=0;}
		};

/***********************************************************************
Margin
***********************************************************************/
		
		/// <summary>
		/// Represents a margin in a two dimensions space.
		/// </summary>
		struct Margin
		{
			/// <summary>
			/// The left margin.
			/// </summary>
			int		left;
			/// <summary>
			/// The top margin.
			/// </summary>
			int		top;
			/// <summary>
			/// The right margin.
			/// </summary>
			int		right;
			/// <summary>
			/// The bottom margin.
			/// </summary>
			int		bottom;

			Margin()
				:left(0), top(0), right(0), bottom(0)
			{
			}

			Margin(int _left, int _top, int _right, int _bottom)
				:left(_left), top(_top), right(_right), bottom(_bottom)
			{
			}

			bool operator==(Margin margin)const
			{
				return left==margin.left && top==margin.top && right==margin.right && bottom==margin.bottom;
			}

			bool operator!=(Margin margin)const
			{
				return left!=margin.left || top!=margin.top || right!=margin.right || bottom!=margin.bottom;
			}
		};

/***********************************************************************
Resources
***********************************************************************/
		
		/// <summary>
		/// Represents a font configuration.
		/// </summary>
		struct FontProperties
		{
			/// <summary>
			/// Font family (or font name, usually).
			/// </summary>
			WString				fontFamily;
			/// <summary>
			/// Font size in pixel.
			/// </summary>
			int					size;
			/// <summary>
			/// True if the font is bold.
			/// </summary>
			bool				bold;
			/// <summary>
			/// True if the font is italic.
			/// </summary>
			bool				italic;
			/// <summary>
			/// True if the font has a underline.
			/// </summary>
			bool				underline;
			/// <summary>
			/// True if the font has a strikeline.
			/// </summary>
			bool				strikeline;
			/// <summary>
			/// True if the font has anti alias rendering.
			/// </summary>
			bool				antialias;
			/// <summary>
			/// True if the font has anti alias rendering in vertical direction.
			/// </summary>
			bool				verticalAntialias;

			FontProperties()
				:size(0)
				,bold(false)
				,italic(false)
				,underline(false)
				,strikeline(false)
				,antialias(true)
				,verticalAntialias(false)
			{
			}
			
			int Compare(const FontProperties& value)const
			{
				int result=0;
				
				result=WString::Compare(fontFamily, value.fontFamily);
				if(result!=0) return result;

				result=size-value.size;
				if(result!=0) return result;

				result=(int)bold-(int)value.bold;
				if(result!=0) return result;

				result=(int)italic-(int)value.italic;
				if(result!=0) return result;

				result=(int)underline-(int)value.underline;
				if(result!=0) return result;

				result=(int)strikeline-(int)value.strikeline;
				if(result!=0) return result;

				result=(int)antialias-(int)value.antialias;
				if(result!=0) return result;

				return 0;
			}

			bool operator==(const FontProperties& value)const {return Compare(value)==0;}
			bool operator!=(const FontProperties& value)const {return Compare(value)!=0;}
			bool operator<(const FontProperties& value)const {return Compare(value)<0;}
			bool operator<=(const FontProperties& value)const {return Compare(value)<=0;}
			bool operator>(const FontProperties& value)const {return Compare(value)>0;}
			bool operator>=(const FontProperties& value)const {return Compare(value)>=0;}
		};
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\GUINATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window

Interfaces:
  INativeWindow							£º´°¿ÚÊÊÅäÆ÷
  INativeWindowListener					£º´°¿ÚÊÂ¼þ¼àÌýÆ÷
  INativeController						£ºÈ«¾Ö¿ØÖÆÆ÷
  INativeControllerListener				£ºÈ«¾ÖÊÂ¼þ¼àÌýÆ÷

Renderers:
  GUI_GRAPHICS_RENDERER_GDI
  GUI_GRAPHICS_RENDERER_DIRECT2D
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUINATIVEWINDOW
#define VCZH_PRESENTATION_GUINATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		class INativeWindow;
		class INativeWindowListener;
		class INativeController;
		class INativeControllerListener;

/***********************************************************************
System Object
***********************************************************************/

		/// <summary>
		/// Represents a screen.
		/// </summary>
		class INativeScreen : public Interface
		{
		public:
			/// <summary>
			/// Get the bounds of the screen.
			/// </summary>
			/// <returns>The bounds of the screen.</returns>
			virtual Rect				GetBounds()=0;
			/// <summary>
			/// Get the bounds of the screen client area.
			/// </summary>
			/// <returns>The bounds of the screen client area.</returns>
			virtual Rect				GetClientBounds()=0;
			/// <summary>
			/// Get the name of the screen.
			/// </summary>
			/// <returns>The name of the screen.</returns>
			virtual WString				GetName()=0;
			/// <summary>
			/// Test is the screen is a primary screen.
			/// </summary>
			/// <returns>Returns true if the screen is a primary screen.</returns>
			virtual bool				IsPrimary()=0;
		};
		
		/// <summary>
		/// Represents a cursor.
		/// </summary>
		class INativeCursor : public Interface
		{
		public:
			/// <summary>
			/// Represents a predefined cursor type.
			/// </summary>
			enum SystemCursorType
			{
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Small waiting cursor.
				/// </summary>
				SmallWaiting,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]large waiting cursor.
				/// </summary>
				LargeWaiting,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Arrow cursor.
				/// </summary>
				Arrow,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Cross cursor.
				/// </summary>
				Cross,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Hand cursor.
				/// </summary>
				Hand,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Help cursor.
				/// </summary>
				Help,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]I beam cursor.
				/// </summary>
				IBeam,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing in all direction cursor.
				/// </summary>
				SizeAll,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing NE-SW cursor.
				/// </summary>
				SizeNESW,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing N-S cursor.
				/// </summary>
				SizeNS,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing NW-SE cursor.
				/// </summary>
				SizeNWSE,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing W-E cursor.
				/// </summary>
				SizeWE,
				LastSystemCursor=SizeWE,
			};

			static const int			SystemCursorCount=LastSystemCursor+1;
		public:
			/// <summary>
			/// Test is the cursor a system provided cursor.
			/// </summary>
			/// <returns>Returns true if the cursor a system provided cursor.</returns>
			virtual bool				IsSystemCursor()=0;
			/// <summary>
			/// Get the cursor type if the cursor a system provided cursor.
			/// </summary>
			/// <returns>The cursor type.</returns>
			virtual SystemCursorType	GetSystemCursorType()=0;
		};

/***********************************************************************
Image Object
***********************************************************************/

		class INativeImageService;
		class INativeImage;
		class INativeImageFrame;
		
		/// <summary>
		/// Represents a customized cache object for an image frame.
		/// </summary>
		class INativeImageFrameCache : public Interface
		{
		public:
			/// <summary>
			/// Called when this cache object is attached to an image frame.
			/// </summary>
			/// <param name="frame">The image frame that attached to.</param>
			virtual void						OnAttach(INativeImageFrame* frame)=0;
			/// <summary>
			/// Called when this cache object is detached to an image frame.
			/// </summary>
			/// <param name="frame">The image frame that detached from.</param>
			virtual void						OnDetach(INativeImageFrame* frame)=0;
		};

		/// <summary>
		/// Represents an image frame.
		/// </summary>
		class INativeImageFrame : public Interface
		{
		public:
			/// <summary>
			/// Get the image that owns this frame.
			/// </summary>
			/// <returns>The image that owns this frame.</returns>
			virtual INativeImage*				GetImage()=0;
			/// <summary>
			/// Get the size of this frame.
			/// </summary>
			/// <returns>The size of this frame.</returns>
			virtual Size						GetSize()=0;

			/// <summary>
			/// Attach a customized cache object to this image frame and bind to a key.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			/// <param name="cache">The customized cache object.</param>
			virtual bool						SetCache(void* key, Ptr<INativeImageFrameCache> cache)=0;
			/// <summary>
			/// Get the attached customized cache object that is already binded to a key.
			/// </summary>
			/// <returns>The attached customized cache object.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			virtual Ptr<INativeImageFrameCache>	GetCache(void* key)=0;
			/// <summary>
			/// Get the attached customized cache object that is already binded to a key, and then detach it.
			/// </summary>
			/// <returns>The detached customized cache object.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			virtual Ptr<INativeImageFrameCache>	RemoveCache(void* key)=0;
		};
		
		/// <summary>
		/// Represents an image.
		/// </summary>
		class INativeImage : public Interface
		{
		public:
			/// <summary>
			/// Represents an image format.
			/// </summary>
			enum FormatType
			{
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Bitmap format.
				/// </summary>
				Bmp,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]GIF format.
				/// </summary>
				Gif,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Icon format.
				/// </summary>
				Icon,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]JPEG format.
				/// </summary>
				Jpeg,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]PNG format.
				/// </summary>
				Png,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]TIFF format.
				/// </summary>
				Tiff,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]WMP format.
				/// </summary>
				Wmp,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Unknown format.
				/// </summary>
				Unknown,
			};
			
			/// <summary>
			/// Get the image service that creates this image.
			/// </summary>
			/// <returns>The image service that creates this image.</returns>
			virtual INativeImageService*		GetImageService()=0;
			/// <summary>
			/// Get the image format.
			/// </summary>
			/// <returns>The image format.</returns>
			virtual FormatType					GetFormat()=0;
			/// <summary>
			/// Get the number of frames in this image.
			/// </summary>
			/// <returns>The number of frames in this image.</returns>
			virtual int							GetFrameCount()=0;
			/// <summary>
			/// Get the frame in this image by a specified frame index.
			/// </summary>
			/// <returns>The frame in this image by a specified frame index.</returns>
			/// <param name="index">The specified frame index.</param>
			virtual INativeImageFrame*			GetFrame(int index)=0;
		};
		
		/// <summary>
		/// Image service. To access this service, use [M:vl.presentation.INativeController.ImageService].
		/// </summary>
		class INativeImageService : public Interface
		{
		public:
			/// <summary>
			/// Create an image from file.
			/// </summary>
			/// <returns>The created image.</returns>
			/// <param name="path">The file path.</param>
			virtual Ptr<INativeImage>			CreateImageFromFile(const WString& path)=0;
		};

/***********************************************************************
Native Window
***********************************************************************/
		
		/// <summary>
		/// Represents a window.
		/// </summary>
		class INativeWindow : public Interface
		{
		public:
			/// <summary>
			/// Get the bounds of the window.
			/// </summary>
			/// <returns>The bounds of the window.</returns>
			virtual Rect				GetBounds()=0;
			/// <summary>
			/// Set the bounds of the window.
			/// </summary>
			/// <param name="bounds">The bounds of the window.</param>
			virtual void				SetBounds(const Rect& bounds)=0;
			/// <summary>
			/// Get the client size of the window.
			/// </summary>
			/// <returns>The client size of the window.</returns>
			virtual Size				GetClientSize()=0;
			/// <summary>
			/// Set the client size of the window.
			/// </summary>
			/// <param name="size">The client size of the window.</param>
			virtual void				SetClientSize(Size size)=0;
			/// <summary>
			/// Get the client bounds in screen space.
			/// </summary>
			/// <returns>The client bounds in screen space.</returns>
			virtual Rect				GetClientBoundsInScreen()=0;
			
			/// <summary>
			/// Get the title of the window. A title will be displayed as a name of this window.
			/// </summary>
			/// <returns>The title of the window.</returns>
			virtual WString				GetTitle()=0;
			/// <summary>
			/// Set the title of the window. A title will be displayed as a name of this window.
			/// </summary>
			/// <param name="title">The title of the window.</param>
			virtual void				SetTitle(WString title)=0;
			/// <summary>
			/// Get the mouse cursor of the window. When the mouse is on the window, the mouse cursor will be rendered.
			/// </summary>
			/// <returns>The mouse cursor of the window.</returns>
			virtual INativeCursor*		GetWindowCursor()=0;
			/// <summary>
			/// Set the mouse cursor of the window. When the mouse is on the window, the mouse cursor will be rendered.
			/// </summary>
			/// <param name="cursor">The mouse cursor of the window.</param>
			virtual void				SetWindowCursor(INativeCursor* cursor)=0;
			/// <summary>
			/// Get the caret point of the window. When an input method editor is opened, the input text box will be located to the caret point.
			/// </summary>
			/// <returns>The caret point of the window.</returns>
			virtual Point				GetCaretPoint()=0;
			/// <summary>
			/// Set the caret point of the window. When an input method editor is opened, the input text box will be located to the caret point.
			/// </summary>
			/// <param name="point">The caret point of the window.</param>
			virtual void				SetCaretPoint(Point point)=0;
			
			/// <summary>
			/// Get the parent window. A parent window doesn't contain a child window. It always displayed below the child windows. When a parent window is minimized or restored, so as its child windows.
			/// </summary>
			/// <returns>The parent window.</returns>
			virtual INativeWindow*		GetParent()=0;
			/// <summary>
			/// Set the parent window. A parent window doesn't contain a child window. It always displayed below the child windows. When a parent window is minimized or restored, so as its child windows.
			/// </summary>
			/// <param name="parent">The parent window.</param>
			virtual void				SetParent(INativeWindow* parent)=0;
			/// <summary>
			/// Test is the window always pass the focus to its parent window.
			/// </summary>
			/// <returns>Returns true if the window always pass the focus to its parent window.</returns>
			virtual bool				GetAlwaysPassFocusToParent()=0;
			/// <summary>
			/// Enable or disble always passing the focus to its parent window.
			/// </summary>
			/// <param name="value">True to enable always passing the focus to its parent window.</param>
			virtual void				SetAlwaysPassFocusToParent(bool value)=0;

			/// <summary>
			/// Show the window.
			/// </summary>
			virtual void				Show()=0;
			/// <summary>
			/// Show the window without activation.
			/// </summary>
			virtual void				ShowDeactivated()=0;
			/// <summary>
			/// Restore the window.
			/// </summary>
			virtual void				ShowRestored()=0;
			/// <summary>
			/// Maximize the window.
			/// </summary>
			virtual void				ShowMaximized()=0;
			/// <summary>
			/// Minimize the window.
			/// </summary>
			virtual void				ShowMinimized()=0;
			/// <summary>
			/// Hide the window.
			/// </summary>
			virtual void				Hide()=0;
			/// <summary>
			/// Test is the window visible.
			/// </summary>
			/// <returns>Returns true if the window is visible.</returns>
			virtual bool				IsVisible()=0;

			/// <summary>
			/// Enable the window.
			/// </summary>
			virtual void				Enable()=0;
			/// <summary>
			/// Disable the window.
			/// </summary>
			virtual void				Disable()=0;
			/// <summary>
			/// Test is the window enabled.
			/// </summary>
			/// <returns>Returns true if the window is enabled.</returns>
			virtual bool				IsEnabled()=0;
			
			/// <summary>
			/// Set focus to the window.
			/// </summary>
			virtual void				SetFocus()=0;
			/// <summary>
			/// Test is the window focused.
			/// </summary>
			/// <returns>Returns true if the window is focused.</returns>
			virtual bool				IsFocused()=0;
			/// <summary>
			/// Activate to the window.
			/// </summary>
			virtual void				SetActivate()=0;
			/// <summary>
			/// Test is the window activated.
			/// </summary>
			/// <returns>Returns true if the window is activated.</returns>
			virtual bool				IsActivated()=0;
			
			/// <summary>
			/// Show the icon in the task bar.
			/// </summary>
			virtual void				ShowInTaskBar()=0;
			/// <summary>
			/// Hide the icon in the task bar.
			/// </summary>
			virtual void				HideInTaskBar()=0;
			/// <summary>
			/// Test is the window icon appeared in the task bar.
			/// </summary>
			/// <returns>Returns true if the window icon appears in the task bar.</returns>
			virtual bool				IsAppearedInTaskBar()=0;
			
			/// <summary>
			/// Enable activation to the window.
			/// </summary>
			virtual void				EnableActivate()=0;
			/// <summary>
			/// Disable activation to the window.
			/// </summary>
			virtual void				DisableActivate()=0;
			/// <summary>
			/// Test is the window allowed to be activated.
			/// </summary>
			/// <returns>Returns true if the window is allowed to be activated.</returns>
			virtual bool				IsEnabledActivate()=0;
			
			/// <summary>
			/// Require mouse message capturing to this window. If the capture is required, all mouse message will be send to this window.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool				RequireCapture()=0;
			/// <summary>
			/// Release mouse message capturing to this window. If the capture is required, all mouse message will be send to this window.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool				ReleaseCapture()=0;

			/// <summary>
			/// Test is the maximize box visible.
			/// </summary>
			/// <returns>Returns true if the maximize box is visible.</returns>
			virtual bool				GetMaximizedBox()=0;
			/// <summary>
			/// Make the maximize box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the maximize box visible.</param>
			virtual void				SetMaximizedBox(bool visible)=0;
			/// <summary>
			/// Test is the minimize box visible.
			/// </summary>
			/// <returns>Returns true if the minimize box is visible.</returns>
			virtual bool				GetMinimizedBox()=0;
			/// <summary>
			/// Make the minimize box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the minimize box visible.</param>
			virtual void				SetMinimizedBox(bool visible)=0;
			/// <summary>
			/// Test is the border visible.
			/// </summary>
			/// <returns>Returns true if the border is visible.</returns>
			virtual bool				GetBorder()=0;
			/// <summary>
			/// Make the border visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the border visible.</param>
			virtual void				SetBorder(bool visible)=0;
			/// <summary>
			/// Test is the size box visible.
			/// </summary>
			/// <returns>Returns true if the size box is visible.</returns>
			virtual bool				GetSizeBox()=0;
			/// <summary>
			/// Make the size box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the size box visible.</param>
			virtual void				SetSizeBox(bool visible)=0;
			/// <summary>
			/// Test is the icon visible.
			/// </summary>
			/// <returns>Returns true if the icon is visible.</returns>
			virtual bool				GetIconVisible()=0;
			/// <summary>
			/// Make the icon visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the icon visible.</param>
			virtual void				SetIconVisible(bool visible)=0;
			/// <summary>
			/// Test is the title bar visible.
			/// </summary>
			/// <returns>Returns true if the title bar is visible.</returns>
			virtual bool				GetTitleBar()=0;
			/// <summary>
			/// Make the title bar visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the title bar visible.</param>
			virtual void				SetTitleBar(bool visible)=0;
			/// <summary>
			/// Test is the window always on top of the desktop.
			/// </summary>
			/// <returns>Returns true if the window is always on top of the desktop.</returns>
			virtual bool				GetTopMost()=0;
			/// <summary>
			/// Make the window always or never on top of the desktop.
			/// </summary>
			/// <param name="topmost">True to make the window always  on top of the desktop.</param>
			virtual void				SetTopMost(bool topmost)=0;
			
			/// <summary>
			/// Install an message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The listener to install.</param>
			virtual bool				InstallListener(INativeWindowListener* listener)=0;
			/// <summary>
			/// Uninstall an message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The listener to uninstall.</param>
			virtual bool				UninstallListener(INativeWindowListener* listener)=0;
			/// <summary>
			/// Redraw the content of the window.
			/// </summary>
			virtual void				RedrawContent()=0;
		};

		/// <summary>
		/// Mouse message information.
		/// </summary>
		struct NativeWindowMouseInfo
		{
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the left mouse button is pressed.</summary>
			bool						left;
			/// <summary>True if the middle mouse button is pressed.</summary>
			bool						middle;
			/// <summary>True if the right mouse button is pressed.</summary>
			bool						right;
			/// <summary>The mouse position of x dimension.</summary>
			int							x;
			/// <summary>The mouse position of y dimension.</summary>
			int							y;
			/// <summary>The delta of the wheel.</summary>
			int							wheel;
		};
		
		/// <summary>
		/// Key message information.
		/// </summary>
		struct NativeWindowKeyInfo
		{
			/// <summary>Key code of the key that sends this message.</summary>
			int							code;
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the alt button is pressed.</summary>
			bool						alt;
			/// <summary>True if the capslock button is pressed.</summary>
			bool						capslock;
		};
		
		/// <summary>
		/// Character message information.
		/// </summary>
		struct NativeWindowCharInfo
		{
			/// <summary>Character that sends this message.</summary>
			wchar_t						code;
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the alt button is pressed.</summary>
			bool						alt;
			/// <summary>True if the capslock button is pressed.</summary>
			bool						capslock;
		};
		
		/// <summary>
		/// Represents a message listener to an <see cref="INativeWindow"/>.
		/// </summary>
		class INativeWindowListener : public Interface
		{
		public:
			/// <summary>
			/// Called when the window is moving.
			/// </summary>
			/// <param name="bounds">The bounds. Message handler can change the bounds.</param>
			/// <param name="fixSizeOnly">True if the message raise only want the message handler to change the size.</param>
			virtual void				Moving(Rect& bounds, bool fixSizeOnly);
			/// <summary>
			/// Called when the window is moved.
			/// </summary>
			virtual void				Moved();
			/// <summary>
			/// Called when the window is enabled.
			/// </summary>
			virtual void				Enabled();
			/// <summary>
			/// Called when the window is disabled.
			/// </summary>
			virtual void				Disabled();
			/// <summary>
			/// Called when the window got the focus.
			/// </summary>
			virtual void				GotFocus();
			/// <summary>
			/// Called when the window lost the focus.
			/// </summary>
			virtual void				LostFocus();
			/// <summary>
			/// Called when the window is activated.
			/// </summary>
			virtual void				Activated();
			/// <summary>
			/// Called when the window is deactivated.
			/// </summary>
			virtual void				Deactivated();
			/// <summary>
			/// Called when the window is opened.
			/// </summary>
			virtual void				Opened();
			/// <summary>
			/// Called when the window is closing.
			/// </summary>
			/// <param name="cancel">Change the value to true to prevent the windows from being closed.</param>
			virtual void				Closing(bool& cancel);
			/// <summary>
			/// Called when the window is closed.
			/// </summary>
			virtual void				Closed();
			/// <summary>
			/// Called when the window is painting.
			/// </summary>
			virtual void				Paint();
			/// <summary>
			/// Called when the window is destroying.
			/// </summary>
			virtual void				Destroying();
			/// <summary>
			/// Called when the window is destroyed.
			/// </summary>
			virtual void				Destroyed();
			
			/// <summary>
			/// Called when the left mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the left mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the left mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the horizontal mouse wheel scrolls.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				HorizontalWheel(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the horizontal vertical wheel scrolls.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				VerticalWheel(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the mouse is moving on the window.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MouseMoving(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the mouse entered the window.
			/// </summary>
			virtual void				MouseEntered();
			/// <summary>
			/// Called when the mouse leaved the window.
			/// </summary>
			virtual void				MouseLeaved();
			
			/// <summary>
			/// Called a key is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				KeyDown(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a key is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				KeyUp(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a system key is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				SysKeyDown(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a system key is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				SysKeyUp(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called an input character is generated.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				Char(const NativeWindowCharInfo& info);
		};

/***********************************************************************
Native Window Services
***********************************************************************/

		/// <summary>
		/// System resource service. To access this service, use [M:vl.presentation.INativeController.ResourceService].
		/// </summary>
		class INativeResourceService : public virtual Interface
		{
		public:
			/// <summary>
			/// Get a cached cursor object using a predefined system cursor type;
			/// </summary>
			/// <returns>The cached cursor object.</returns>
			/// <param name="type">The predefined system cursor type.</param>
			virtual INativeCursor*			GetSystemCursor(INativeCursor::SystemCursorType type)=0;
			/// <summary>
			/// Get a cached cursor object using a default system cursor type;
			/// </summary>
			/// <returns>The cached cursor object.</returns>
			virtual INativeCursor*			GetDefaultSystemCursor()=0;

			/// <summary>
			/// Get the default font configuration of the system.
			/// </summary>
			/// <returns>The default font configuration of the system.</returns>
			virtual FontProperties			GetDefaultFont()=0;
			/// <summary>
			/// Override the default font configuration for the current process, only available GacUI library.
			/// </summary>
			/// <param name="value">The font configuration to override.</param>
			virtual void					SetDefaultFont(const FontProperties& value)=0;
		};
		
		/// <summary>
		/// Asynchronized operation service. GacUI is not a thread safe library except for this service. To access this service, use [M:vl.presentation.INativeController.AsyncService].
		/// </summary>
		class INativeAsyncService : public virtual Interface
		{
		public:
			typedef void (AsyncTaskProc)(void* arguments);

			/// <summary>
			/// Test is the current thread the main thread.
			/// </summary>
			/// <returns>Returns true if the current thread is the main thread.</returns>
			virtual bool					IsInMainThread()=0;
			/// <summary>
			/// Invoke a specified function with an specified argument in the main thread.
			/// </summary>
			/// <param name="proc">The specified function.</param>
			/// <param name="argument">The specified argument.</param>
			virtual void					InvokeInMainThread(AsyncTaskProc* proc, void* argument)=0;
			/// <summary>
			/// Invoke a specified function with an specified argument in the main thread and wait for the function to complete or timeout.
			/// </summary>
			/// <returns>Return true if the function complete. Return false if the function has not completed during a specified period of time.</returns>
			/// <param name="proc">The specified function.</param>
			/// <param name="argument">The specified argument.</param>
			/// <param name="milliseconds">The specified period of time to wait. Set to -1 (default value) to wait forever until the function completed.</param>
			virtual bool					InvokeInMainThreadAndWait(AsyncTaskProc* proc, void* argument, int milliseconds=-1)=0;
		};
		
		/// <summary>
		/// Clipboard service. To access this service, use [M:vl.presentation.INativeController.ClipboardService].
		/// </summary>
		class INativeClipboardService : public virtual Interface
		{
		public:
			/// <summary>
			/// Test is there a text in the clipboard.
			/// </summary>
			/// <returns>Returns true if there is a text in the clipboard.</returns>
			virtual bool					ContainsText()=0;
			/// <summary>
			/// Get the text in the clipboard.
			/// </summary>
			/// <returns>The text in the clipboard.</returns>
			virtual WString					GetText()=0;
			/// <summary>
			/// Copy the text to the clipboard.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="value">The text to copy to the clipboard.</param>
			virtual bool					SetText(const WString& value)=0;
		};
		
		/// <summary>
		/// Screen information service. To access this service, use [M:vl.presentation.INativeController.ScreenService].
		/// </summary>
		class INativeScreenService : public virtual Interface
		{
		public:
			/// <summary>
			/// Get the number of all available screens.
			/// </summary>
			///  <returns>The number of all available screens.</returns>
			virtual int						GetScreenCount()=0;
			/// <summary>
			/// Get the screen object by a specified screen index.
			/// </summary>
			/// <returns>The screen object.</returns>
			/// <param name="index">The specified screen index.</param>
			virtual INativeScreen*			GetScreen(int index)=0;
			/// <summary>
			/// Get the screen object where the main part of the specified window is inside.
			/// </summary>
			/// <returns>The screen object.</returns>
			/// <param name="index">The specified window.</param>
			virtual INativeScreen*			GetScreen(INativeWindow* window)=0;
		};
		
		/// <summary>
		/// Window service. To access this service, use [M:vl.presentation.INativeController.WindowService].
		/// </summary>
		class INativeWindowService : public virtual Interface
		{
		public:
			/// <summary>
			/// Create a window.
			/// </summary>
			/// <returns>The created window.</returns>
			virtual INativeWindow*			CreateNativeWindow()=0;
			/// <summary>
			/// Destroy a window.
			/// </summary>
			/// <param name="window">The window to destroy.</param>
			virtual void					DestroyNativeWindow(INativeWindow* window)=0;
			/// <summary>
			/// Get the main window.
			/// </summary>
			/// <returns>The main window.</returns>
			virtual INativeWindow*			GetMainWindow()=0;
			/// <summary>
			/// Get the window that under a specified position in screen space.
			/// </summary>
			/// <returns>The window that under a specified position in screen space.</returns>
			/// <param name="location">The specified position in screen space.</param>
			virtual INativeWindow*			GetWindow(Point location)=0;
			/// <summary>
			/// Make the specified window a main window, show that window, and wait until the windows is closed.
			/// </summary>
			/// <param name="window">The specified window.</param>
			virtual void					Run(INativeWindow* window)=0;
		};
		
		/// <summary>
		/// User input service. To access this service, use [M:vl.presentation.INativeController.InputService].
		/// </summary>
		class INativeInputService : public virtual Interface
		{
		public:
			/// <summary>
			/// Start to reveive global mouse message.
			/// </summary>
			virtual void					StartHookMouse()=0;
			/// <summary>
			/// Stop to receive global mouse message.
			/// </summary>
			virtual void					StopHookMouse()=0;
			/// <summary>
			/// Test is the global mouse message receiving enabled.
			/// </summary>
			/// <returns>Returns true if the global mouse message receiving is enabled.</returns>
			virtual bool					IsHookingMouse()=0;
			
			/// <summary>
			/// Start to reveive global timer message.
			/// </summary>
			virtual void					StartTimer()=0;
			/// <summary>
			/// Stop to receive global timer message.
			/// </summary>
			virtual void					StopTimer()=0;
			/// <summary>
			/// Test is the global timer message receiving enabled.
			/// </summary>
			/// <returns>Returns true if the global timer message receiving is enabled.</returns>
			virtual bool					IsTimerEnabled()=0;
			
			/// <summary>
			/// Test is the specified key pressing.
			/// </summary>
			/// <returns>Returns true if the specified key is pressing.</returns>
			virtual bool					IsKeyPressing(int code)=0;
			/// <summary>
			/// Test is the specified key toggled.
			/// </summary>
			/// <returns>Returns true if the specified key is toggled.</returns>
			virtual bool					IsKeyToggled(int code)=0;
		};
		
		/// <summary>
		/// Callback service. To access this service, use [M:vl.presentation.INativeController.CallbackService].
		/// </summary>
		class INativeCallbackService : public virtual Interface
		{
		public:
			/// <summary>
			/// Install a global message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The global message listener to install.</param>
			virtual bool					InstallListener(INativeControllerListener* listener)=0;
			/// <summary>
			/// Uninstall a global message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The global message listener to uninstall.</param>
			virtual bool					UninstallListener(INativeControllerListener* listener)=0;
		};

/***********************************************************************
Native Window Controller
***********************************************************************/

		/// <summary>
		/// Global native system service controller. Use [M:vl.presentation.GetCurrentController] to access this controller.
		/// </summary>
		class INativeController : public virtual Interface
		{
		public:
			/// <summary>
			/// Get the callback service.
			/// </summary>
			/// <returns>The callback service</returns>
			virtual INativeCallbackService*			CallbackService()=0;
			/// <summary>
			/// Get the system resource service.
			/// </summary>
			/// <returns>The system resource service</returns>
			virtual INativeResourceService*			ResourceService()=0;
			/// <summary>
			/// Get the asynchronized operation service.
			/// </summary>
			/// <returns>The asynchronized operation service</returns>
			virtual INativeAsyncService*			AsyncService()=0;
			/// <summary>
			/// Get the clipboard service.
			/// </summary>
			/// <returns>The clipboard service</returns>
			virtual INativeClipboardService*		ClipboardService()=0;
			/// <summary>
			/// Get the image service.
			/// </summary>
			/// <returns>The image service</returns>
			virtual INativeImageService*			ImageService()=0;
			/// <summary>
			/// Get the screen information service.
			/// </summary>
			/// <returns>The screen information service</returns>
			virtual INativeScreenService*			ScreenService()=0;
			/// <summary>
			/// Get the window service.
			/// </summary>
			/// <returns>The window service</returns>
			virtual INativeWindowService*			WindowService()=0;
			/// <summary>
			/// Get the user input service.
			/// </summary>
			/// <returns>The user input service</returns>
			virtual INativeInputService*			InputService()=0;
		};
		
		/// <summary>
		/// Represents a global message listener to an <see cref="INativeController"/>.
		/// </summary>
		class INativeControllerListener : public Interface
		{
		public:
			/// <summary>
			/// Called when the left mouse button is pressed. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>.
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					LeftButtonDown(Point position);
			/// <summary>
			/// Called when the left mouse button is released. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					LeftButtonUp(Point position);
			/// <summary>
			/// Called when the right mouse button is pressed. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					RightButtonDown(Point position);
			/// <summary>
			/// Called when the right mouse button is released. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					RightButtonUp(Point position);
			/// <summary>
			/// Called when the mouse is moving. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			virtual void					MouseMoving(Point position);
			/// <summary>
			/// Called when the global timer message raised. To receive or not receive this message, use <see cref="INativeInputService::StartTimer"/> or <see cref="INativeInputService::StopTimer"/>
			/// </summary>
			virtual void					GlobalTimer();
			/// <summary>
			/// Called when the content of the clipboard is updated.
			/// </summary>
			virtual void					ClipboardUpdated();
			/// <summary>
			/// Called when a window is created.
			/// </summary>
			/// <param name="window">The created window.</param>
			virtual void					NativeWindowCreated(INativeWindow* window);
			/// <summary>
			/// Called when a window is destroying.
			/// </summary>
			/// <param name="window">The destroying window.</param>
			virtual void					NativeWindowDestroying(INativeWindow* window);
		};

		/// <summary>
		/// Get the global native system service controller.
		/// </summary>
		/// <returns>The global native system service controller.</returns>
		extern								INativeController* GetCurrentController();
		/// <summary>
		/// Set the global native system service controller.
		/// </summary>
		/// <param name="controller">The global native system service controller.</param>
		extern void							SetCurrentController(INativeController* controller);
	}
}

/***********************************************************************
Native Window Provider
***********************************************************************/

/*
 * Virtual Keys, Standard Set
 */
#define VKEY_LBUTTON        0x01
#define VKEY_RBUTTON        0x02
#define VKEY_CANCEL         0x03
#define VKEY_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VKEY_XBUTTON1       0x05    /* NOT contiguous with L & RBUTTON */
#define VKEY_XBUTTON2       0x06    /* NOT contiguous with L & RBUTTON */

/*
 * 0x07 : unassigned
 */

#define VKEY_BACK           0x08
#define VKEY_TAB            0x09

/*
 * 0x0A - 0x0B : reserved
 */

#define VKEY_CLEAR          0x0C
#define VKEY_RETURN         0x0D

#define VKEY_SHIFT          0x10
#define VKEY_CONTROL        0x11
#define VKEY_MENU           0x12
#define VKEY_PAUSE          0x13
#define VKEY_CAPITAL        0x14

#define VKEY_KANA           0x15
#define VKEY_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VKEY_HANGUL         0x15
#define VKEY_JUNJA          0x17
#define VKEY_FINAL          0x18
#define VKEY_HANJA          0x19
#define VKEY_KANJI          0x19

#define VKEY_ESCAPE         0x1B

#define VKEY_CONVERT        0x1C
#define VKEY_NONCONVERT     0x1D
#define VKEY_ACCEPT         0x1E
#define VKEY_MODECHANGE     0x1F

#define VKEY_SPACE          0x20
#define VKEY_PRIOR          0x21
#define VKEY_NEXT           0x22
#define VKEY_END            0x23
#define VKEY_HOME           0x24
#define VKEY_LEFT           0x25
#define VKEY_UP             0x26
#define VKEY_RIGHT          0x27
#define VKEY_DOWN           0x28
#define VKEY_SELECT         0x29
#define VKEY_PRINT          0x2A
#define VKEY_EXECUTE        0x2B
#define VKEY_SNAPSHOT       0x2C
#define VKEY_INSERT         0x2D
#define VKEY_DELETE         0x2E
#define VKEY_HELP           0x2F

/*
 * VKEY_0 - VKEY_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
 * 0x40 : unassigned
 * VKEY_A - VKEY_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
 */

#define VKEY_LWIN           0x5B
#define VKEY_RWIN           0x5C
#define VKEY_APPS           0x5D

/*
 * 0x5E : reserved
 */

#define VKEY_SLEEP          0x5F

#define VKEY_NUMPAD0        0x60
#define VKEY_NUMPAD1        0x61
#define VKEY_NUMPAD2        0x62
#define VKEY_NUMPAD3        0x63
#define VKEY_NUMPAD4        0x64
#define VKEY_NUMPAD5        0x65
#define VKEY_NUMPAD6        0x66
#define VKEY_NUMPAD7        0x67
#define VKEY_NUMPAD8        0x68
#define VKEY_NUMPAD9        0x69
#define VKEY_MULTIPLY       0x6A
#define VKEY_ADD            0x6B
#define VKEY_SEPARATOR      0x6C
#define VKEY_SUBTRACT       0x6D
#define VKEY_DECIMAL        0x6E
#define VKEY_DIVIDE         0x6F
#define VKEY_F1             0x70
#define VKEY_F2             0x71
#define VKEY_F3             0x72
#define VKEY_F4             0x73
#define VKEY_F5             0x74
#define VKEY_F6             0x75
#define VKEY_F7             0x76
#define VKEY_F8             0x77
#define VKEY_F9             0x78
#define VKEY_F10            0x79
#define VKEY_F11            0x7A
#define VKEY_F12            0x7B
#define VKEY_F13            0x7C
#define VKEY_F14            0x7D
#define VKEY_F15            0x7E
#define VKEY_F16            0x7F
#define VKEY_F17            0x80
#define VKEY_F18            0x81
#define VKEY_F19            0x82
#define VKEY_F20            0x83
#define VKEY_F21            0x84
#define VKEY_F22            0x85
#define VKEY_F23            0x86
#define VKEY_F24            0x87

/*
 * 0x88 - 0x8F : unassigned
 */

#define VKEY_NUMLOCK        0x90
#define VKEY_SCROLL         0x91

/*
 * NEC PC-9800 kbd definitions
 */
#define VKEY_OEM_NEC_EQUAL  0x92   // '=' key on numpad

/*
 * Fujitsu/OASYS kbd definitions
 */
#define VKEY_OEM_FJ_JISHO   0x92   // 'Dictionary' key
#define VKEY_OEM_FJ_MASSHOU 0x93   // 'Unregister word' key
#define VKEY_OEM_FJ_TOUROKU 0x94   // 'Register word' key
#define VKEY_OEM_FJ_LOYA    0x95   // 'Left OYAYUBI' key
#define VKEY_OEM_FJ_ROYA    0x96   // 'Right OYAYUBI' key

/*
 * 0x97 - 0x9F : unassigned
 */

/*
 * VKEY_L* & VKEY_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VKEY_LSHIFT         0xA0
#define VKEY_RSHIFT         0xA1
#define VKEY_LCONTROL       0xA2
#define VKEY_RCONTROL       0xA3
#define VKEY_LMENU          0xA4
#define VKEY_RMENU          0xA5

#define VKEY_BROWSER_BACK        0xA6
#define VKEY_BROWSER_FORWARD     0xA7
#define VKEY_BROWSER_REFRESH     0xA8
#define VKEY_BROWSER_STOP        0xA9
#define VKEY_BROWSER_SEARCH      0xAA
#define VKEY_BROWSER_FAVORITES   0xAB
#define VKEY_BROWSER_HOME        0xAC

#define VKEY_VOLUME_MUTE         0xAD
#define VKEY_VOLUME_DOWN         0xAE
#define VKEY_VOLUME_UP           0xAF
#define VKEY_MEDIA_NEXT_TRACK    0xB0
#define VKEY_MEDIA_PREV_TRACK    0xB1
#define VKEY_MEDIA_STOP          0xB2
#define VKEY_MEDIA_PLAY_PAUSE    0xB3
#define VKEY_LAUNCH_MAIL         0xB4
#define VKEY_LAUNCH_MEDIA_SELECT 0xB5
#define VKEY_LAUNCH_APP1         0xB6
#define VKEY_LAUNCH_APP2         0xB7

/*
 * 0xB8 - 0xB9 : reserved
 */

#define VKEY_OEM_1          0xBA   // ';:' for US
#define VKEY_OEM_PLUS       0xBB   // '+' any country
#define VKEY_OEM_COMMA      0xBC   // ',' any country
#define VKEY_OEM_MINUS      0xBD   // '-' any country
#define VKEY_OEM_PERIOD     0xBE   // '.' any country
#define VKEY_OEM_2          0xBF   // '/?' for US
#define VKEY_OEM_3          0xC0   // '`~' for US

/*
 * 0xC1 - 0xD7 : reserved
 */

/*
 * 0xD8 - 0xDA : unassigned
 */

#define VKEY_OEM_4          0xDB  //  '[{' for US
#define VKEY_OEM_5          0xDC  //  '\|' for US
#define VKEY_OEM_6          0xDD  //  ']}' for US
#define VKEY_OEM_7          0xDE  //  ''"' for US
#define VKEY_OEM_8          0xDF

/*
 * 0xE0 : reserved
 */

/*
 * Various extended or enhanced keyboards
 */

#define VKEY_OEM_AX         0xE1  //  'AX' key on Japanese AX kbd
#define VKEY_OEM_102        0xE2  //  "<>" or "\|" on RT 102-key kbd.
#define VKEY_ICO_HELP       0xE3  //  Help key on ICO
#define VKEY_ICO_00         0xE4  //  00 key on ICO

#define VKEY_PROCESSKEY     0xE5
#define VKEY_ICO_CLEAR      0xE6
#define VKEY_PACKET         0xE7

/*
 * 0xE8 : unassigned
 */

/*
 * Nokia/Ericsson definitions
 */
#define VKEY_OEM_RESET      0xE9
#define VKEY_OEM_JUMP       0xEA
#define VKEY_OEM_PA1        0xEB
#define VKEY_OEM_PA2        0xEC
#define VKEY_OEM_PA3        0xED
#define VKEY_OEM_WSCTRL     0xEE
#define VKEY_OEM_CUSEL      0xEF
#define VKEY_OEM_ATTN       0xF0
#define VKEY_OEM_FINISH     0xF1
#define VKEY_OEM_COPY       0xF2
#define VKEY_OEM_AUTO       0xF3
#define VKEY_OEM_ENLW       0xF4
#define VKEY_OEM_BACKTAB    0xF5

#define VKEY_ATTN           0xF6
#define VKEY_CRSEL          0xF7
#define VKEY_EXSEL          0xF8
#define VKEY_EREOF          0xF9
#define VKEY_PLAY           0xFA
#define VKEY_ZOOM           0xFB
#define VKEY_NONAME         0xFC
#define VKEY_PA1            0xFD
#define VKEY_OEM_CLEAR      0xFE

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\REFLECTION\GUITYPEDESCRIPTOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Reflection

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUITYPEDESCRIPTOR
#define VCZH_PRESENTATION_REFLECTION_GUITYPEDESCRIPTOR


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Attribute
***********************************************************************/

		class ITypeDescriptor;

		class DescriptableObject
		{
			template<typename T>
			friend class Description;

			friend class DescriptableValue;
		protected:
			size_t							objectSize;
			ITypeDescriptor**				typeDescriptor;
		public:
			DescriptableObject();
			virtual ~DescriptableObject();
		};

		class IDescriptable : public virtual Interface, public virtual DescriptableObject
		{
		public:
			~IDescriptable(){}
		};
		
		template<typename T>
		class Description : public virtual DescriptableObject
		{
		protected:
			static ITypeDescriptor*			associatedTypeDescriptor;
		public:
			Description()
			{
				if(objectSize<sizeof(T))
				{
					objectSize=sizeof(T);
					typeDescriptor=&associatedTypeDescriptor;
				}
			}

			static void SetTypeDescroptorByTypeProvider(ITypeDescriptor* typeDescroptor)
			{
				associatedTypeDescriptor=typeDescroptor;
			}
		};

		template<typename T>
		ITypeDescriptor* Description<T>::associatedTypeDescriptor=0;

/***********************************************************************
DescriptableValue
***********************************************************************/

		class IType;

		class DescriptableValue : public Object
		{
		protected:
			IType*								type;
			signed __int64						dataSInt;
			unsigned __int64					dataUInt;
			double								dataFloat;
			bool								dataBool;
			wchar_t								dataChar;
			WString								dataString;
			Ptr<DescriptableObject>				dataDescriptableObject;
			DescriptableObject*					dataDescriptableObjectPointer;
			Ptr<Object>							dataObject;
			Object*								dataObjectPointer;
			Ptr<Interface>						dataInterface;
			Interface*							dataInterfacePointer;
			void*								dataRawPointer;

			void								Initialize();
		public:
			static DescriptableValue			Null;

			DescriptableValue();									// null
			DescriptableValue(IType* type, signed __int64 value);	// enum
			DescriptableValue(signed __int64 value);				// SInt
			DescriptableValue(unsigned __int64 value);				// UInt
			DescriptableValue(double value);						// Float
			DescriptableValue(bool value);							// Bool
			DescriptableValue(wchar_t value);						// Char
			DescriptableValue(const WString& value);				// String
			DescriptableValue(Ptr<DescriptableObject> value);		// descriptable object
			DescriptableValue(DescriptableObject* value);			// descriptable object pointer
			DescriptableValue(IType* _type, Ptr<Object> value);		// object, ObjectBox-ed structure
			DescriptableValue(IType* _type, Object* value);			// object pointer
			DescriptableValue(IType* _type, Ptr<Interface> value);	// interface
			DescriptableValue(IType* _type, Interface* value);		// interface pointer
			DescriptableValue(IType* _type, void* value);			// pointer, pointer/reference to struct
			DescriptableValue(const DescriptableValue& value);		// copy

			IType*								GetType()const;
			signed __int64						GetSInt()const;
			unsigned __int64					GetUInt()const;
			double								GetFloat()const;
			bool								GetBool()const;
			wchar_t								GetChar()const;
			WString								GetString()const;
			
			Ptr<DescriptableObject>				GetDescriptableObject()const;
			DescriptableObject*					GetDescriptableObjectPoitner()const;
			Ptr<Object>							GetRawObject()const;
			Object*								GetRawObjectPointer()const;
			Ptr<Interface>						GetInterface()const;
			Interface*							GetInterfacePointer()const;
			void*								GetRawPointer()const;

			bool								CanDelete()const;
			void								Delete();
		};

/***********************************************************************
ITypeDescriptor
***********************************************************************/

		class IType : public virtual Interface
		{
		public:
			enum TypeEnum
			{
				Void,
				SInt8,
				UInt8,
				SInt16,
				UInt16,
				SInt32,
				UInt32,
				SInt64,
				UInt64,
				Float,
				Double,
				Bool,
				Char,
				String,
				Enum,
				Struct,
				Class,
				Interface,

				Pointer,
				SmartPointer,
				Reference,
				ConstReference,
				RValueReference,
				Array,
				Const,
				Volatile,
			};

			virtual TypeEnum					GetTypeEnum()=0;
			virtual WString						GetName()=0;
			virtual ITypeDescriptor*			GetTypeDescriptor()=0;
			virtual bool						CanConvertTo(IType* targetType)=0;

			virtual IType*						GetElementType()=0;
			virtual int							GetArrayLength()=0;
			virtual IType*						GetReturnType()=0;
			virtual int							GetParameterCount()=0;
			virtual IType*						GetParameterType(int index)=0;
		};

		class IMemberDescriptor : public virtual Interface
		{
		public:
			enum MemberTypeEnum
			{
				Static,
				Abstract,
				Virtual,
				Normal,
			};

			virtual WString						GetName()=0;
			virtual ITypeDescriptor*			GetOwnerTypeDescriptor()=0;
			virtual MemberTypeEnum				GetMemberTypeEnum()=0;
		};

		class IParameterDescriptor : public virtual Interface
		{
		public:
			virtual WString						GetName()=0;
			virtual IType*						GetType()=0;
		};

		class IMethodDescriptor : public virtual IMemberDescriptor
		{
		public:
			virtual IType*						GetReturnType()=0;
			virtual int							GetParameterCount()=0;
			virtual IParameterDescriptor*		GetParameter(int index)=0;
			virtual DescriptableValue			Invoke(const DescriptableValue& thisObject, const collections::IReadonlyList<DescriptableValue>& parameters)=0;
		}; 

		class IPropertyDescriptor : public virtual IMemberDescriptor
		{
		public:
			virtual bool						CanGet()=0;
			virtual bool						CanSet()=0;
			virtual IType*						GetPropertyType()=0;
			virtual IMethodDescriptor*			GetSetter()=0;
			virtual IMethodDescriptor*			GetGetter()=0;
		};

		class ITypeDescriptor : public virtual Interface
		{
		public:
			virtual IType*						GetType()=0;
			virtual int							GetBaseTypeCount()=0;
			virtual IType*						GetBaseType(int index)=0;

			virtual int							GetConstructorCount()=0;
			virtual IMethodDescriptor*			GetConstructor(int index)=0;
			virtual IMethodDescriptor*			GetDefaultConstructor()=0;
			virtual int							GetMethodCount()=0;
			virtual IMethodDescriptor*			GetMethod(int index)=0;
			virtual int							GetPropertyCount()=0;
			virtual IPropertyDescriptor*		GetProperty(int index)=0;

			virtual IMethodDescriptor*			FindMethod(const WString& name, bool searchParent, bool searchStatic, bool searchInstance)=0;
			virtual void						FindMethods(const WString& name, bool searchParent, bool searchStatic, bool searchInstance, collections::List<IMethodDescriptor*>& methods)=0;
			virtual IPropertyDescriptor*		FindProperty(const WString& name, bool searchParent, bool searchStatic, bool searchInstance)=0;
		};

/***********************************************************************
Helper Functions
***********************************************************************/

		class ITypeProvider : public virtual Interface
		{
		public:
			virtual IType*			Void()=0;
			virtual IType*			SInt8()=0;
			virtual IType*			UInt8()=0;
			virtual IType*			SInt16()=0;
			virtual IType*			UInt16()=0;
			virtual IType*			SInt32()=0;
			virtual IType*			UInt32()=0;
			virtual IType*			SInt64()=0;
			virtual IType*			UInt64()=0;
			virtual IType*			Float()=0;
			virtual IType*			Double()=0;
			virtual IType*			Bool()=0;
			virtual IType*			Char()=0;
			virtual IType*			String()=0;
			virtual IType*			Pointer(IType* elementType)=0;
			virtual IType*			SmartPointer(IType* elementType)=0;
			virtual IType*			Reference(IType* elementType)=0;
			virtual IType*			ConstReference(IType* elementType)=0;
			virtual IType*			RValueReference(IType* elementType)=0;
			virtual IType*			Array(IType* elementType, int length)=0;

			virtual int				GetDescriptableTypeCount()=0;
			virtual IType*			GetDescriptableType(int index)=0;
			virtual IType*			FindType(const WString& name)=0;
		};

		extern ITypeProvider*		GetTypeProvider();
		extern void					SetTypeProvider(ITypeProvider* value);
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			class IGuiGraphicsElement;
			class IGuiGraphicsElementFactory;
			class IGuiGraphicsRenderer;
			class IGuiGraphicsRendererFactory;
			class IGuiGraphicsRenderTarget;

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// This is the interface for graphics elements.
			/// Graphics elements usually contains some information and helper functions for visible things.
			/// An graphics elements should be created using ElementType::Create.
			/// </summary>
			class IGuiGraphicsElement : public virtual IDescriptable, public Description<IGuiGraphicsElement>
			{
			public:
				/// <summary>
				/// Access the <see cref="IGuiGraphicsElementFactory"></see> that is used to create this graphics elements.
				/// </summary>
				/// <returns>Returns the related factory.</returns>
				virtual IGuiGraphicsElementFactory*		GetFactory()=0;
				/// <summary>
				/// Access the associated <see cref="IGuiGraphicsRenderer"></see> for this graphics element.
				/// </summary>
				/// <returns>Returns the related renderer.</returns>
				virtual IGuiGraphicsRenderer*			GetRenderer()=0;
			};

			/// <summary>
			/// This is the interface for graphics element factories.
			/// Graphics element factories should be registered using [M:vl.presentation.elements.GuiGraphicsResourceManager.RegisterElementFactory].
			/// </summary>
			class IGuiGraphicsElementFactory : public Interface
			{
			public:
				/// <summary>
				/// Get the name representing the kind of graphics element to be created.
				/// </summary>
				/// <returns>Returns the name of graphics elements.</returns>
				virtual WString							GetElementTypeName()=0;
				/// <summary>
				/// Create a <see cref="IGuiGraphicsElement"></see>.
				/// </summary>
				/// <returns>Returns the created graphics elements.</returns>
				virtual IGuiGraphicsElement*			Create()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderers.
			/// </summary>
			class IGuiGraphicsRenderer : public Interface
			{
			public:
				/// <summary>
				/// Access the graphics <see cref="IGuiGraphicsRendererFactory"></see> that is used to create this graphics renderer.
				/// </summary>
				/// <returns>Returns the related factory.</returns>
				virtual IGuiGraphicsRendererFactory*	GetFactory()=0;

				/// <summary>
				/// Initialize the grpahics renderer by binding a <see cref="IGuiGraphicsElement"></see> to it.
				/// </summary>
				/// <param name="element">The graphics element to bind.</param>
				virtual void							Initialize(IGuiGraphicsElement* element)=0;
				/// <summary>
				/// Release all resources that used by this renderer.
				/// </summary>
				virtual void							Finalize()=0;
				/// <summary>
				/// Set a <see cref="IGuiGraphicsRenderTarget"></see> to this element.
				/// </summary>
				/// <param name="renderTarget">The graphics render target. It can be NULL.</param>
				virtual void							SetRenderTarget(IGuiGraphicsRenderTarget* renderTarget)=0;
				/// <summary>
				/// Render the graphics element using a specified bounds.
				/// </summary>
				/// <param name="bounds">Bounds to decide the size and position of the binded graphics element.</param>
				virtual void							Render(Rect bounds)=0;
				/// <summary>
				/// Notify that the state in the binded graphics element is changed. This function is usually called by the element itself.
				/// </summary>
				virtual void							OnElementStateChanged()=0;
				/// <summary>
				/// Calculate the minimum size using the binded graphics element and its state.
				/// </summary>
				/// <returns>The minimum size.</returns>
				virtual Size							GetMinSize()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderer factories.
			/// Graphics renderers should be registered using [M:vl.presentation.elements.GuiGraphicsResourceManager.RegisterRendererFactory]. 
			/// </summary>
			class IGuiGraphicsRendererFactory : public Interface
			{
			public:
				/// <summary>
				/// Create a <see cref="IGuiGraphicsRenderer"></see>.
				/// </summary>
				/// <returns>Returns the created graphics renderer.</returns>
				virtual IGuiGraphicsRenderer*			Create()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderer targets.
			/// </summary>
			class IGuiGraphicsRenderTarget : public Interface
			{
			public:
				/// <summary>
				/// Notify the target to prepare for rendering.
				/// </summary>
				virtual void							StartRendering()=0;
				/// <summary>
				/// Notify the target to stop rendering.
				/// </summary>
				virtual void							StopRendering()=0;
				/// <summary>
				/// Apply a clipper to the render target.
				/// The result clipper is combined by all clippers in the clipper stack maintained by the render target.
				/// </summary>
				virtual void							PushClipper(Rect clipper)=0;
				/// <summary>
				/// Remove the last pushed clipper from the clipper stack.
				/// </summary>
				virtual void							PopClipper()=0;
				/// <summary>
				/// Get the combined clipper
				/// </summary>
				/// <returns>The combined clipper</returns>
				virtual Rect							GetClipper()=0;
				/// <summary>
				/// Test is the combined clipper is as large as the render target.
				/// </summary>
				/// <returns>Return true if the combined clipper is as large as the render target.</returns>
				virtual bool							IsClipperCoverWholeTarget()=0;
			};

/***********************************************************************
Resource Manager
***********************************************************************/

			/// <summary>
			/// This is a class for managing grpahics element factories and graphics renderer factories
			/// </summary>
			class GuiGraphicsResourceManager : public Object
			{
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsElementFactory>>		elementFactoryMap;
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsRendererFactory>>		rendererFactoryMap;
			protected:
				elementFactoryMap						elementFactories;
				rendererFactoryMap						rendererFactories;
			public:
				/// <summary>
				/// Create a graphics resource manager without any predefined factories
				/// </summary>
				GuiGraphicsResourceManager();
				~GuiGraphicsResourceManager();

				/// <summary>
				/// Register a <see cref="IGuiGraphicsElementFactory"></see> using the element type from <see cref="IGuiGraphicsElementFactory::GetElementTypeName"></see>.
				/// </summary>
				/// <param name="factory">The instance of the graphics element factory to register.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool							RegisterElementFactory(IGuiGraphicsElementFactory* factory);
				/// <summary>
				/// Register a <see cref="IGuiGraphicsRendererFactory"></see> and bind it to a registered <see cref="IGuiGraphicsElementFactory"></see>.
				/// </summary>
				/// <param name="elementTypeName">The element type to represent a graphics element factory.</param>
				/// <param name="factory">The instance of the graphics renderer factory to register.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool							RegisterRendererFactory(const WString& elementTypeName, IGuiGraphicsRendererFactory* factory);
				/// <summary>
				/// Get the instance of a registered <see cref="IGuiGraphicsElementFactory"></see> that is binded to a specified element type.
				/// </summary>
				/// <param name="elementTypeName">The element type to get a corresponding graphics element factory.</param>
				virtual IGuiGraphicsElementFactory*		GetElementFactory(const WString& elementTypeName);
				/// <summary>
				/// Get the instance of a registered <see cref="IGuiGraphicsRendererFactory"></see> that is binded to a specified element type.
				/// </summary>
				/// <param name="elementTypeName">The element type to get a corresponding graphics renderer factory.</param>
				virtual IGuiGraphicsRendererFactory*	GetRendererFactory(const WString& elementTypeName);
				/// <summary>
				/// Get the instance of a <see cref="IGuiGraphicsRenderTarget"></see> that is binded to an <see cref="INativeWindow"></see>.
				/// </summary>
				virtual IGuiGraphicsRenderTarget*		GetRenderTarget(INativeWindow* window)=0;
			};

			/// <summary>
			/// Get the current <see cref="GuiGraphicsResourceManager"></see>.
			/// </summary>
			/// <returns>Returns the current resource manager.</returns>
			extern GuiGraphicsResourceManager*			GetGuiGraphicsResourceManager();
			/// <summary>
			/// Set the current <see cref="GuiGraphicsResourceManager"></see>.
			/// </summary>
			/// <params name="resourceManager">The resource manager to set.</params>
			extern void									SetGuiGraphicsResourceManager(GuiGraphicsResourceManager* resourceManager);
			/// <summary>
			/// Helper function to register a <see cref="IGuiGraphicsElementFactory"></see> with a <see cref="IGuiGraphicsRendererFactory"></see> and bind them together.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			extern bool									RegisterFactories(IGuiGraphicsElementFactory* elementFactory, IGuiGraphicsRendererFactory* rendererFactory);

/***********************************************************************
Helpers
***********************************************************************/

#define DEFINE_GUI_GRAPHICS_ELEMENT(TELEMENT, ELEMENT_TYPE_NAME)\
			public:\
				class Factory : public Object, public IGuiGraphicsElementFactory\
				{\
				public:\
					WString GetElementTypeName()\
					{\
						return TELEMENT::GetElementTypeName();\
					}\
					IGuiGraphicsElement* Create()\
					{\
						TELEMENT* element=new TELEMENT;\
						element->factory=this;\
						element->renderer=GetGuiGraphicsResourceManager()->GetRendererFactory(GetElementTypeName())->Create();\
						element->renderer->Initialize(element);\
						return element;\
					}\
				};\
			protected:\
				IGuiGraphicsElementFactory*		factory;\
				Ptr<IGuiGraphicsRenderer>		renderer;\
			public:\
				static WString GetElementTypeName()\
				{\
					return ELEMENT_TYPE_NAME;\
				}\
				static TELEMENT* Create()\
				{\
					return dynamic_cast<TELEMENT*>(GetGuiGraphicsResourceManager()->GetElementFactory(TELEMENT::GetElementTypeName())->Create());\
				}\
				IGuiGraphicsElementFactory* GetFactory()override\
				{\
					return factory;\
				}\
				IGuiGraphicsRenderer* GetRenderer()override\
				{\
					return renderer.Obj();\
				}\

#define DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, TTARGET)\
			public:\
				class Factory : public Object, public IGuiGraphicsRendererFactory\
				{\
				public:\
					IGuiGraphicsRenderer* Create()\
					{\
						TRENDERER* renderer=new TRENDERER;\
						renderer->factory=this;\
						renderer->element=0;\
						renderer->renderTarget=0;\
						return renderer;\
					}\
				};\
			protected:\
				IGuiGraphicsRendererFactory*	factory;\
				TELEMENT*						element;\
				TTARGET*						renderTarget;\
				Size							minSize;\
			public:\
				static void Register()\
				{\
					RegisterFactories(new TELEMENT::Factory, new TRENDERER::Factory);\
				}\
				IGuiGraphicsRendererFactory* GetFactory()override\
				{\
					return factory;\
				}\
				void Initialize(IGuiGraphicsElement* _element)override\
				{\
					element=dynamic_cast<TELEMENT*>(_element);\
					InitializeInternal();\
				}\
				void Finalize()override\
				{\
					FinalizeInternal();\
				}\
				void SetRenderTarget(IGuiGraphicsRenderTarget* _renderTarget)override\
				{\
					TTARGET* oldRenderTarget=renderTarget;\
					renderTarget=dynamic_cast<TTARGET*>(_renderTarget);\
					RenderTargetChangedInternal(oldRenderTarget, renderTarget);\
				}\
				Size GetMinSize()override\
				{\
					return minSize;\
				}\

#define DEFINE_CACHED_RESOURCE_ALLOCATOR(TKEY, TVALUE)\
			public:\
				static const int DeadPackageMax=32;\
				struct Package\
				{\
					TVALUE							resource;\
					int								counter;\
					bool operator==(const Package& package)const{return false;}\
					bool operator!=(const Package& package)const{return true;}\
				};\
				struct DeadPackage\
				{\
					TKEY							key;\
					TVALUE							value;\
					bool operator==(const DeadPackage& package)const{return false;}\
					bool operator!=(const DeadPackage& package)const{return true;}\
				};\
				Dictionary<TKEY, Package>			aliveResources;\
				List<DeadPackage>					deadResources;\
			public:\
				TVALUE Create(const TKEY& key)\
				{\
					int index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values()[index];\
						package.counter++;\
						aliveResources.Set(key, package);\
						return package.resource;\
					}\
					TVALUE resource;\
					for(int i=0;i<deadResources.Count();i++)\
					{\
						if(deadResources[i].key==key)\
						{\
							DeadPackage deadPackage=deadResources[i];\
							deadResources.RemoveAt(i);\
							resource=deadPackage.value;\
							break;\
						}\
					}\
					if(!resource)\
					{\
						resource=CreateInternal(key);\
					}\
					Package package;\
					package.resource=resource;\
					package.counter=1;\
					aliveResources.Add(key, package);\
					return package.resource;\
				}\
				void Destroy(const TKEY& key)\
				{\
					int index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values()[index];\
						package.counter--;\
						if(package.counter==0)\
						{\
							aliveResources.Remove(key);\
							if(deadResources.Count()==DeadPackageMax)\
							{\
								deadResources.RemoveAt(DeadPackageMax-1);\
							}\
							DeadPackage deadPackage;\
							deadPackage.key=key;\
							deadPackage.value=package.resource;\
							deadResources.Insert(0, deadPackage);\
						}\
						else\
						{\
							aliveResources.Set(key, package);\
						}\
					}\
				}\

/***********************************************************************
Elements
***********************************************************************/

			namespace ElementShape
			{
				/// <summary>
				/// Defines an shape for some <see cref="IGuiGraphicsElement"></see>.
				/// </summary>
				enum Type
				{
					/// <summary>[T:vl.presentation.elements.ElementShape.Type]Rectangle shape.</summary>
					Rectangle,
					/// <summary>[T:vl.presentation.elements.ElementShape.Type]Ellipse shape.</summary>
					Ellipse,
				};
			};

			/// <summary>
			/// Defines a border element with a thickness of one pixel.
			/// </summary>
			class GuiSolidBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBorderElement, L"SolidBorder")
			protected:
				Color					color;
				ElementShape::Type		shape;

				GuiSolidBorderElement();
			public:
				~GuiSolidBorderElement();

				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape::Type		GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape::Type value);
			};
			
			/// <summary>
			/// Defines a rectangle border element with round corners and a thickness of one pixel.
			/// </summary>
			class GuiRoundBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiRoundBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiRoundBorderElement, L"RoundBorder")
			protected:
				Color					color;
				int						radius;

				GuiRoundBorderElement();
			public:
				~GuiRoundBorderElement();
				
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				
				/// <summary>
				/// Get the radius of round corners.
				/// </summary>
				/// <returns>The radius.</returns>
				int						GetRadius();
				/// <summary>
				/// Set the radius of round corners.
				/// </summary>
				/// <param name="value">The new radius.</param>
				void					SetRadius(int value);
			};
			
			/// <summary>
			/// Defines a 3D-like rectangle element with a thickness of two pixels.
			/// </summary>
			class Gui3DBorderElement : public Object, public IGuiGraphicsElement, public Description<Gui3DBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DBorderElement, L"3DBorder")
			protected:
				Color					color1;
				Color					color2;

				Gui3DBorderElement();
			public:
				~Gui3DBorderElement();
				
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Get the right-bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
			};
			
			/// <summary>
			/// Defines a 3D-like splitter element with a thickness of two pixels.
			/// </summary>
			class Gui3DSplitterElement : public Object, public IGuiGraphicsElement, public Description<Gui3DSplitterElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DSplitterElement, L"3DSplitter")
			public:
				/// <summary>
				/// Defines a direction of the <see cref="Gui3DSplitterElement"></see>.
				/// </summary>
				enum Direction
				{
					/// <summary>[T:vl.presentation.elements.Gui3DSplitterElement.Direction]Horizontal direction.</summary>
					Horizontal,
					/// <summary>[T:vl.presentation.elements.Gui3DSplitterElement.Direction]Vertical direction.</summary>
					Vertical,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;

				Gui3DSplitterElement();
			public:
				~Gui3DSplitterElement();
				
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Get the right-bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
				
				/// <summary>
				/// Get the direction.
				/// </summary>
				/// <returns>The direction.</returns>
				Direction				GetDirection();
				/// <summary>
				/// Set the direction.
				/// </summary>
				/// <param name="value">The new direction.</param>
				void					SetDirection(Direction value);
			};

			/// <summary>
			/// Defines a color-filled element without border.
			/// </summary>
			class GuiSolidBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBackgroundElement, L"SolidBackground")
			protected:
				Color					color;
				ElementShape::Type		shape;

				GuiSolidBackgroundElement();
			public:
				~GuiSolidBackgroundElement();
				
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape::Type		GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape::Type value);
			};
			
			/// <summary>
			/// Defines a color-filled gradient element without border.
			/// </summary>
			class GuiGradientBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiGradientBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiGradientBackgroundElement, L"GradientBackground")
			public:
				/// <summary>
				/// Defines a direction of the <see cref="Gui3DSplitterElement"></see>.
				/// </summary>
				enum Direction
				{
					/// <summary>[T:vl.presentation.elements.GuiGradientBackgroundElement.Direction]Horizontal direction.</summary>
					Horizontal,
					/// <summary>[T:vl.presentation.elements.GuiGradientBackgroundElement.Direction]vertical direction.</summary>
					Vertical,
					/// <summary>[T:vl.presentation.elements.GuiGradientBackgroundElement.Direction]Slash direction.</summary>
					Slash,
					/// <summary>[T:vl.presentation.elements.GuiGradientBackgroundElement.Direction]Back slash direction.</summary>
					Backslash,
				};
			protected:
				Color					color1, color2;
				Direction				direction;
				ElementShape::Type		shape;

				GuiGradientBackgroundElement();
			public:
				~GuiGradientBackgroundElement();
				
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Get the right bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
				
				/// <summary>
				/// Get the direction.
				/// </summary>
				/// <returns>The direction.</returns>
				Direction				GetDirection();
				/// <summary>
				/// Set the direction.
				/// </summary>
				/// <param name="value">The new direction.</param>
				void					SetDirection(Direction value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape::Type		GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape::Type value);
			};
			
			/// <summary>
			/// Defines an element of a plain text.
			/// </summary>
			class GuiSolidLabelElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidLabelElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidLabelElement, L"SolidLabel");
			protected:
				Color					color;
				FontProperties			fontProperties;
				WString					text;
				Alignment::Type			hAlignment;
				Alignment::Type			vAlignment;
				bool					wrapLine;
				bool					ellipse;
				bool					multiline;

				GuiSolidLabelElement();
			public:
				~GuiSolidLabelElement();
				
				/// <summary>
				/// Get the text color.
				/// </summary>
				/// <returns>The text color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the text color.
				/// </summary>
				/// <param name="value">The new text color.</param>
				void					SetColor(Color value);
				
				/// <summary>
				/// Get the text font.
				/// </summary>
				/// <returns>The text font.</returns>
				const FontProperties&	GetFont();
				/// <summary>
				/// Set the text font.
				/// </summary>
				/// <param name="value">The new text font.</param>
				void					SetFont(const FontProperties& value);
				
				/// <summary>
				/// Get the text.
				/// </summary>
				/// <returns>The text.</returns>
				const WString&			GetText();
				/// <summary>
				/// Set the text.
				/// </summary>
				/// <param name="value">The new text.</param>
				void					SetText(const WString& value);
				
				/// <summary>
				/// Get the horizontal alignment of the text.
				/// </summary>
				/// <returns>The horizontal alignment of the text.</returns>
				Alignment::Type			GetHorizontalAlignment();
				/// <summary>
				/// Get the vertical alignment of the text.
				/// </summary>
				/// <returns>The vertical alignment of the text.</returns>
				Alignment::Type			GetVerticalAlignment();
				/// <summary>
				/// Set alignments in both directions of the text.
				/// </summary>
				/// <param name="horizontal">The new horizontal alignment of the text.</param>
				/// <param name="vertical">The vertical alignment of the text.</param>
				void					SetAlignments(Alignment::Type horizontal, Alignment::Type vertical);
				
				/// <summary>
				/// Get if line auto-wrapping is enabled for this text.
				/// </summary>
				/// <returns>Return true if line auto-wrapping is enabled for this text.</returns>
				bool					GetWrapLine();
				/// <summary>
				/// Set if line auto-wrapping is enabled for this text.
				/// </summary>
				/// <param name="value">True if line auto-wrapping is enabled for this text.</param>
				void					SetWrapLine(bool value);
				
				/// <summary>
				/// Get if ellipse is enabled for this text. Ellipse will appear when the text is clipped.
				/// </summary>
				/// <returns>Return true if ellipse is enabled for this text.</returns>
				bool					GetEllipse();
				/// <summary>
				/// Set if ellipse is enabled for this text. Ellipse will appear when the text is clipped.
				/// </summary>
				/// <param name="value">True if ellipse is enabled for this text.</param>
				void					SetEllipse(bool value);
				
				/// <summary>
				/// Get if multiple lines is enabled for this text.
				/// </summary>
				/// <returns>Return true if multiple lines is enabled for this text.</returns>
				bool					GetMultiline();
				/// <summary>
				/// Set if multiple lines is enabled for this text.
				/// </summary>
				/// <param name="value">True if multiple lines is enabled for this text.</param>
				void					SetMultiline(bool value);
			};

			/// <summary>
			/// Defines an element containing an image.
			/// </summary>
			class GuiImageFrameElement : public Object, public IGuiGraphicsElement, public Description<GuiImageFrameElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiImageFrameElement, L"ImageFrame");
			protected:
				Ptr<INativeImage>		image;
				int						frameIndex;
				Alignment::Type			hAlignment;
				Alignment::Type			vAlignment;
				bool					stretch;

				GuiImageFrameElement();
			public:
				~GuiImageFrameElement();

				/// <summary>
				/// Get the containing image.
				/// </summary>
				/// <returns>The contining picture.</returns>
				Ptr<INativeImage>		GetImage();
				/// <summary>
				/// Get the index of the frame in the containing image.
				/// </summary>
				/// <returns>The index of the frame in the containing image</returns>
				int						GetFrameIndex();
				/// <summary>
				/// Set the containing image and the frame index.
				/// </summary>
				/// <param name="_image">The new containing image.</param>
				/// <param name="_frameIndex">The new frameIndex.</param>
				void					SetImage(Ptr<INativeImage> _image, int _frameIndex=0);
				
				/// <summary>
				/// Get the horizontal alignment of the image.
				/// </summary>
				/// <returns>The horizontal alignment of the image.</returns>
				Alignment::Type			GetHorizontalAlignment();
				/// <summary>
				/// Get the vertical alignment of the image.
				/// </summary>
				/// <returns>The vertical alignment of the image.</returns>
				Alignment::Type			GetVerticalAlignment();
				/// <summary>
				/// Set alignments in both directions of the image.
				/// </summary>
				/// <param name="horizontal">The new horizontal alignment of the image.</param>
				/// <param name="vertical">The vertical alignment of the image.</param>
				void					SetAlignments(Alignment::Type horizontal, Alignment::Type vertical);

				/// <summary>
				/// Get if stretching is enabled for this image.
				/// </summary>
				/// <returns>Return true if stretching is enabled for this image.</returns>
				bool					GetStretch();
				/// <summary>
				/// Set if stretching is enabled for this image.
				/// </summary>
				/// <param name="value">True if stretching is enabled for this image.</param>
				void					SetStretch(bool value);
			};

			/// <summary>
			/// Defines a polygon element with a thickness of one pixel.
			/// </summary>
			class GuiPolygonElement : public Object, public IGuiGraphicsElement, public Description<GuiPolygonElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiPolygonElement, L"Polygon");
			protected:
				Size							size;
				collections::Array<Point>		points;
				Color							borderColor;
				Color							backgroundColor;

				GuiPolygonElement();
			public:
				~GuiPolygonElement();

				/// <summary>
				/// Get a suggested size. The polygon element will be layouted to the center of the required bounds using this size.
				/// </summary>
				/// <returns>The suggested size.</returns>
				Size					GetSize();
				/// <summary>
				/// Set a suggested size. The polygon element will be layouted to the center of the required bounds using this size.
				/// </summary>
				/// <param name="value">The new size.</param>
				void					SetSize(Size value);

				/// <summary>
				/// Get a point of the polygon element using an index.
				/// </summary>
				/// <param name="index">The index to access a point.</param>
				/// <returns>The point of the polygon element associated with the index.</returns>
				const Point&			GetPoint(int index);
				/// <summary>
				/// Get the number of points
				/// </summary>
				/// <returns>The number of points.</returns>
				int						GetPointCount();
				/// <summary>
				/// Set all points to the polygon element.
				/// </summary>
				/// <param name="p">A pointer to a buffer that stores all points.</param>
				/// <param name="index">The number of points.</param>
				void					SetPoints(const Point* p, int count);
				
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetBorderColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetBorderColor(Color value);
				/// <summary>
				/// Get the background color.
				/// </summary>
				/// <returns>The background color.</returns>
				Color					GetBackgroundColor();
				/// <summary>
				/// Set the background color.
				/// </summary>
				/// <param name="value">The new background color.</param>
				void					SetBackgroundColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSTEXTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
ColorizedText
***********************************************************************/

			namespace text
			{
				/// <summary>
				/// Represents the extra information of a character to display.
				/// </summary>
				struct CharAtt
				{
					/// <summary>
					/// The distance from the head of the line to the right side of this character in pixel.
					/// </summary>
					unsigned __int32				rightOffset;
					/// <summary>
					/// The color index of the character. Use [M:vl.presentation.elements.GuiColorizedTextElement.GetColors] and [M:vl.presentation.elements.GuiColorizedTextElement.SetColors] to access the color table.
					/// </summary>
					unsigned __int32				colorIndex;
				};
				
				/// <summary>
				/// Represents a line of characters.
				/// </summary>
				struct TextLine
				{
					static const int				BlockSize=32;
					static const int				MaxWidth=0xFFFF;
					
					/// <summary>
					/// A character buffer starts from the first character of this line.
					/// </summary>
					wchar_t*						text;
					/// <summary>
					/// A extra information buffer starts from the first character of this line.
					/// </summary>
					CharAtt*						att;
					/// <summary>
					/// The number of available <see cref="CharAtt::rightOffset"/> in the buffer.
					/// </summary>
					int								availableOffsetCount;
					/// <summary>
					/// The number of elements in the allocated buffer memory.
					/// </summary>
					int								bufferLength;
					/// <summary>
					/// The number of available characters in the buffer.
					/// </summary>
					int								dataLength;

					TextLine();
					~TextLine();

					static int						CalculateBufferLength(int dataLength);
					bool							operator==(const TextLine& value)const{return false;}
					bool							operator!=(const TextLine& value)const{return true;}

					/// <summary>
					/// Initialize the <see cref="TextLine"/> instance to be an empty line.
					/// </summary>
					void							Initialize();
					/// <summary>
					/// Release all resources used in this line.
					/// </summary>
					void							Finalize();
					/// <summary>
					/// Test is the line initialized.
					/// </summary>
					/// <returns>Returns true if the line is initialized.</returns>
					bool							IsReady();
					/// <summary>
					/// Modify the characters in the line by replacing characters.
					/// </summary>
					/// <returns>Returns true if the modification succeeded.</returns>
					/// <param name="start">The position of the first character to be replaced.</param>
					/// <param name="count">The number of characters to be replaced.</param>
					/// <param name="input">The buffer to the characters to write into this line.</param>
					/// <param name="inputCount">The numbers of the characters to write into this line.</param>
					bool							Modify(int start, int count, const wchar_t* input, int inputCount);
					/// <summary>
					/// Split a text line into two by the position. The current line contains characters before this position. This function returns a new text line contains characters after this position.
					/// </summary>
					/// <returns>The new text line.</returns>
					/// <param name="index">.</param>
					TextLine						Split(int index);
					/// <summary>
					/// Append a text line after the this text line, and finalize the input text line.
					/// </summary>
					/// <param name="line">The text line that contains all characters and color indices to append and be finalized.</param>
					void							AppendAndFinalize(TextLine& line);
				};

				/// <summary>
				/// An abstract class for character size measuring in differect rendering technology.
				/// </summary>
				class CharMeasurer : public virtual IDescriptable
				{
				protected:
					IGuiGraphicsRenderTarget*		oldRenderTarget;
					int								rowHeight;
					int								widths[65536];
					
					/// <summary>
					/// Measure the width of a character.
					/// </summary>
					/// <returns>The width in pixel.</returns>
					/// <param name="character">The character to measure. This is a pure virtual member function to be overrided.</param>
					/// <param name="renderTarget">The render target which the character is going to be rendered. This is a pure virtual member function to be overrided.</param>
					virtual int						MeasureWidthInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)=0;
					/// <summary>
					/// Measure the height of a character.
					/// </summary>
					/// <returns>The height in pixel.</returns>
					/// <param name="renderTarget">The render target which the character is going to be rendered.</param>
					virtual int						GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)=0;
				public:

					/// <summary>
					/// Initialize a character measurer.
					/// </summary>
					/// <param name="_rowHeight">The default character height in pixel before the character measurer is binded to a render target.</param>
					CharMeasurer(int _rowHeight);
					~CharMeasurer();

					/// <summary>
					/// Bind a render target to this character measurer.
					/// </summary>
					/// <param name="value">The render target to bind.</param>
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					/// <summary>
					/// Measure the width of a character using the binded render target.
					/// </summary>
					/// <returns>The width of a character, in pixel.</returns>
					/// <param name="character">The character to measure.</param>
					int								MeasureWidth(wchar_t character);
					/// <summary>
					/// Measure the height of a character.
					/// </summary>
					/// <returns>The height of a character, in pixel.</returns>
					int								GetRowHeight();
				};

				/// <summary>
				/// A class to maintain multiple lines of text buffer.
				/// </summary>
				struct TextLines
				{
					typedef collections::List<TextLine>		TextLineList;
				protected:
					TextLineList					lines;
					CharMeasurer*					charMeasurer;
					IGuiGraphicsRenderTarget*		renderTarget;
					int								tabWidth;
					int								tabSpaceCount;
				public:
					TextLines();
					~TextLines();

					/// <summary>
					/// Returns the number of text lines.
					/// </summary>
					/// <returns>The number of text lines.</returns>
					int								GetCount();
					/// <summary>
					/// Returns the text line of a specified row number.
					/// </summary>
					/// <returns>The related text line object.</returns>
					/// <param name="row">The specified row number.</param>
					TextLine&						GetLine(int row);
					/// <summary>
					/// Returns the binded <see cref="CharMeasurer"/>.
					/// </summary>
					/// <returns>The binded <see cref="CharMeasurer"/>.</returns>
					CharMeasurer*					GetCharMeasurer();
					/// <summary>
					/// Binded a <see cref="CharMeasurer"/>.
					/// </summary>
					/// <param name="value">The <see cref="CharMeasurer"/> to bind.</param>
					void							SetCharMeasurer(CharMeasurer* value);
					/// <summary>
					/// Returns the binded <see cref="IGuiGraphicsRenderTarget"/>.
					/// </summary>
					/// <returns>The binded <see cref="IGuiGraphicsRenderTarget"/>.</returns>
					IGuiGraphicsRenderTarget*		GetRenderTarget();
					/// <summary>
					/// Binded a <see cref="IGuiGraphicsRenderTarget"/>.
					/// </summary>
					/// <param name="value">The <see cref="IGuiGraphicsRenderTarget"/> to bind.</param>
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					/// <summary>
					/// Returns a string from a specified range of the text lines.
					/// </summary>
					/// <returns>The string.</returns>
					/// <param name="start">The start position.</param>
					/// <param name="end">The end position.</param>
					WString							GetText(TextPos start, TextPos end);
					/// <summary>
					/// Returns the whole string in the text lines.
					/// </summary>
					/// <returns>The string.</returns>
					WString							GetText();
					/// <summary>
					/// Set the string to the text lines. This operation will modified every <see cref="TextLine"/> objects.
					/// </summary>
					/// <param name="value">The string to set into the text lines.</param>
					void							SetText(const WString& value);
					
					/// <summary>
					/// Remove text lines in a specified range.
					/// </summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="start">The first row number.</param>
					/// <param name="count">The number of text lines to be removed.</param>
					bool							RemoveLines(int start, int count);
					/// <summary>
					/// Test is a text position available in the text lines.
					/// </summary>
					/// <returns>Returns true if this position is available.</returns>
					/// <param name="pos">The text position to test.</param>
					bool							IsAvailable(TextPos pos);
					/// <summary>
					/// Normalize a text position to be available.
					/// </summary>
					/// <returns>The normalized text position.</returns>
					/// <param name="pos">The text position to normalize.</param>
					TextPos							Normalize(TextPos pos);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="inputs">The buffer to the string buffers to replace into the text lines.</param>
					/// <param name="inputCounts">The numbers of characters for each string buffer.</param>
					/// <param name="rows">The number of string buffers.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t** inputs, int* inputCounts, int rows);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The buffer to the string to replace into the text lines.</param>
					/// <param name="inputCount">The number of characters to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input, int inputCount);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The string to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The string to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const WString& input);
					/// <summary>
					/// Remove every text lines.
					/// </summary>
					void							Clear();
					
					/// <summary>
					/// Clear all cached <see cref="CharAtt::rightOffset"/>.
					/// </summary>
					void							ClearMeasurement();
					/// <summary>
					/// Returns the number of spaces to replace a tab character for rendering.
					/// </summary>
					/// <returns>The number of spaces to replace a tab character for rendering.</returns>
					int								GetTabSpaceCount();
					/// <summary>
					/// Set the number of spaces to replace a tab character for rendering.
					/// </summary>
					/// <param name="value">The number of spaces to replace a tab character for rendering.</param>
					void							SetTabSpaceCount(int value);
					/// <summary>
					/// Measure all characters in a specified row.
					/// </summary>
					/// <param name="row">The specified row number.</param>
					void							MeasureRow(int row);
					/// <summary>
					/// Returns the width of a specified row.
					/// </summary>
					/// <returns>The width of a specified row, in pixel.</returns>
					/// <param name="row">The specified row number.</param>
					int								GetRowWidth(int row);
					/// <summary>
					/// Returns the height of a row.
					/// </summary>
					/// <returns>The height of a row, in pixel.</returns>
					int								GetRowHeight();
					/// <summary>
					/// Returns the total width of the text lines.
					/// </summary>
					/// <returns>The width of the text lines, in pixel.</returns>
					int								GetMaxWidth();
					/// <summary>
					/// Returns the total height of the text lines.
					/// </summary>
					/// <returns>The height of the text lines, in pixel.</returns>
					int								GetMaxHeight();
					/// <summary>
					/// Get the text position near to specified point.
					/// </summary>
					/// <returns>The text position.</returns>
					/// <param name="row">The specified point, in pixel.</param>
					TextPos							GetTextPosFromPoint(Point point);
					/// <summary>
					/// Get the point of a specified text position.
					/// </summary>
					/// <returns>The point, in pixel. Returns (-1, -1) if the text position is not available.</returns>
					/// <param name="pos">The specified text position.</param>
					Point							GetPointFromTextPos(TextPos pos);
					/// <summary>
					/// Get the bounds of a specified text position.
					/// </summary>
					/// <returns>The bounds, in pixel. Returns (-1, -1, -1, -1) if the text position is not available.</returns>
					/// <param name="pos">The specified text position.</param>
					Rect							GetRectFromTextPos(TextPos pos);
				};
				
				/// <summary>
				/// Represents colors of a character.
				/// </summary>
				struct ColorItem
				{
					/// <summary>
					/// Text color.
					/// </summary>
					Color							text;
					/// <summary>
					/// Background color.
					/// </summary>
					Color							background;
				};
				
				/// <summary>
				/// Represents color entry in a color table. Use [M:vl.presentation.elements.GuiColorizedTextElement.GetColors] and [M:vl.presentation.elements.GuiColorizedTextElement.SetColors] to access the color table.
				/// </summary>
				struct ColorEntry
				{
					/// <summary>
					/// Colors in normal state.
					/// </summary>
					ColorItem						normal;
					/// <summary>
					/// Colors in focused and selected state.
					/// </summary>
					ColorItem						selectedFocused;
					/// <summary>
					/// Colors in not focused and selected state.
					/// </summary>
					ColorItem						selectedUnfocused;

					bool							operator==(const ColorEntry& value){return false;}
					bool							operator!=(const ColorEntry& value){return true;}
				};
			}
			
			/// <summary>
			/// Defines a text element with separate color configuration for each character.
			/// </summary>
			class GuiColorizedTextElement : public Object, public IGuiGraphicsElement, public Description<GuiColorizedTextElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiColorizedTextElement, L"ColorizedText");

				typedef collections::Array<text::ColorEntry>			ColorArray;
				typedef collections::IReadonlyList<text::ColorEntry>	IColorArray;
			public:
				/// <summary>
				/// An callback interface. Member functions will be called when colors or fonts of a <see cref="GuiColorizedTextElement"/> changed.
				/// </summary>
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					/// <summary>
					/// Called when the color table of a <see cref="GuiColorizedTextElement"/> changed.
					/// </summary>
					virtual void					ColorChanged()=0;
					/// <summary>
					/// Called when the font configuration of a <see cref="GuiColorizedTextElement"/> changed.
					/// </summary>
					virtual void					FontChanged()=0;
				};
			protected:
				ICallback*							callback;
				ColorArray							colors;
				FontProperties						font;
				Point								viewPosition;
				bool								isVisuallyEnabled;
				bool								isFocused;

				TextPos								caretBegin;
				TextPos								caretEnd;
				bool								caretVisible;
				Color								caretColor;

				text::TextLines						lines;

				GuiColorizedTextElement();
			public:
				~GuiColorizedTextElement();

				/// <summary>
				/// Get the internal <see cref="text::TextLines"/> object that stores all characters and colors.
				/// </summary>
				/// <returns>The internal <see cref="text::TextLines"/> object.</returns>
				text::TextLines&					GetLines();
				/// <summary>
				/// Get the binded callback object.
				/// </summary>
				/// <returns>The binded callback object.</returns>
				ICallback*							GetCallback();
				/// <summary>
				/// Bind a callback object.
				/// </summary>
				/// <param name="value">The callback object to bind.</param>
				void								SetCallback(ICallback* value);
				
				/// <summary>
				/// Get the binded color table. Use <see cref="text::CharAtt::colorIndex"/> to use colors in this color table.
				/// </summary>
				/// <returns>The binded color table.</returns>
				const IColorArray&					GetColors();
				/// <summary>
				/// Bind a color table. Use <see cref="text::CharAtt::colorIndex"/> to use colors in this color table. <see cref="ICallback::ColorChanged"/> will be called.
				/// </summary>
				/// <param name="value">The color table to bind.</param>
				void								SetColors(const ColorArray& value);
				/// <summary>
				/// Get the font configuration for all characters.
				/// </summary>
				/// <returns>The font configuration.</returns>
				const FontProperties&				GetFont();
				/// <summary>
				/// Set the font configuration for all characters. <see cref="ICallback::FontChanged"/> will be called.
				/// </summary>
				/// <param name="value">The font configuration.</param>
				void								SetFont(const FontProperties& value);
				/// <summary>
				/// Get the left-top position of the visible bounds of characters.
				/// </summary>
				/// <returns>The left-top position of the visible bounds of characters.</returns>
				Point								GetViewPosition();
				/// <summary>
				/// Set the left-top position of the visible bounds of characters.
				/// </summary>
				/// <param name="value">The left-top position of the visible bounds of characters.</param>
				void								SetViewPosition(Point value);
				/// <summary>
				/// Get the enabling state.
				/// </summary>
				/// <returns>Returns true if the element will be rendered as an enabled element.</returns>
				bool								GetVisuallyEnabled();
				/// <summary>
				/// Set the enabling state.
				/// </summary>
				/// <param name="value">True if the element will be rendered as an enabled element.</param>
				void								SetVisuallyEnabled(bool value);
				/// <summary>
				/// Get the focused state.
				/// </summary>
				/// <returns>Returns true if the element will be rendered as a focused element.</returns>
				bool								GetFocused();
				/// <summary>
				/// Set the focused state.
				/// </summary>
				/// <param name="value">True if the element will be rendered as a focused element.</param>
				void								SetFocused(bool value);
				
				/// <summary>
				/// Get the begin position of the selection area.
				/// </summary>
				/// <returns>The begin position of the selection area.</returns>
				TextPos								GetCaretBegin();
				/// <summary>
				/// Set the begin position of the selection area.
				/// </summary>
				/// <param name="value">The begin position of the selection area.</param>
				void								SetCaretBegin(TextPos value);
				/// <summary>
				/// Get the end position of the selection area.
				/// </summary>
				/// <returns>The end position of the selection area.</returns>
				TextPos								GetCaretEnd();
				/// <summary>
				/// Set the end position of the selection area.
				/// </summary>
				/// <param name="value">The end position of the selection area.</param>
				void								SetCaretEnd(TextPos value);
				/// <summary>
				/// Get the caret visibility.
				/// </summary>
				/// <returns>Returns true if characters in the selection range will be rendered using <see cref="text::ColorEntry::selectedFocused"/> or <see cref="text::ColorEntry::selectedUnfocused"/>.</returns>
				bool								GetCaretVisible();
				/// <summary>
				/// Set the caret visibility.
				/// </summary>
				/// <param name="value">True if characters in the selection range will be rendered using <see cref="text::ColorEntry::selectedFocused"/> or <see cref="text::ColorEntry::selectedUnfocused"/>.</param>
				void								SetCaretVisible(bool value);
				/// <summary>
				/// Get the color of the caret.
				/// </summary>
				/// <returns>The color of the caret.</returns>
				Color								GetCaretColor();
				/// <summary>
				/// Set the color of the caret.
				/// </summary>
				/// <param name="value">The color of the caret.</param>
				void								SetCaretColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSEVENTRECEIVER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Event Model

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiGraphicsComposition;

/***********************************************************************
Event
***********************************************************************/

			template<typename T>
			class GuiGraphicsEvent : public Object, public Description<GuiGraphicsEvent<T>>
			{
			public:
				typedef void(RawFunctionType)(GuiGraphicsComposition*, T&);
				typedef Func<RawFunctionType>						FunctionType;

				class IHandler : public virtual IDescriptable, public Description<IHandler>
				{
				public:
					virtual void			Execute(GuiGraphicsComposition* sender, T& argument)=0;
				};
				
				class FunctionHandler : public Object, public IHandler
				{
				protected:
					FunctionType		handler;
				public:
					FunctionHandler(const FunctionType& _handler)
						:handler(_handler)
					{
					}

					void Execute(GuiGraphicsComposition* sender, T& argument)override
					{
						handler(sender, argument);
					}
				};
			protected:
				struct HandlerNode
				{
					Ptr<IHandler>					handler;
					Ptr<HandlerNode>				next;
				};

				GuiGraphicsComposition*				sender;
				Ptr<HandlerNode>					handlers;
			public:
				GuiGraphicsEvent(GuiGraphicsComposition* _sender=0)
					:sender(_sender)
				{
				}

				~GuiGraphicsEvent()
				{
				}

				GuiGraphicsComposition* GetAssociatedComposition()
				{
					return sender;
				}

				void SetAssociatedComposition(GuiGraphicsComposition* _sender)
				{
					sender=_sender;
				}

				bool Attach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							return false;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					(*currentHandler)=new HandlerNode;
					(*currentHandler)->handler=handler;
					return true;
				}

				template<typename TClass, typename TMethod>
				Ptr<IHandler> AttachMethod(TClass* receiver, TMethod TClass::* method)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(receiver, method));
					Attach(handler);
					return handler;
				}

				Ptr<IHandler> AttachFunction(RawFunctionType* function)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(function));
					Attach(handler);
					return handler;
				}

				template<typename T>
				Ptr<IHandler> AttachLambda(const T& lambda)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(lambda));
					Attach(handler);
					return handler;
				}

				bool Detach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							Ptr<HandlerNode> next=(*currentHandler)->next;
							(*currentHandler)=next;
							return true;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					return false;
				}

				void Execute(T& argument)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						(*currentHandler)->handler->Execute(sender, argument);
						currentHandler=&(*currentHandler)->next;
					}
				}
			};

/***********************************************************************
Predefined Events
***********************************************************************/

			/// <summary>Notify event arguments.</summary>
			struct GuiEventArgs
			{
				/// <summary>The event raiser composition.</summary>
				GuiGraphicsComposition*		compositionSource;
				/// <summary>The nearest parent of the event raiser composition that contains an event receiver. If the event raiser composition contains an event receiver, it will be the event raiser composition.</summary>
				GuiGraphicsComposition*		eventSource;
				/// <summary>Set this field to true will stop the event routing. This is a signal that the event is properly handeled, and the event handler want to override the default behavior.</summary>
				bool						handled;

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiEventArgs()
					:compositionSource(0)
					,eventSource(0)
					,handled(false)
				{
				}

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiEventArgs(GuiGraphicsComposition* composition)
					:compositionSource(composition)
					,eventSource(composition)
					,handled(false)
				{
				}
			};
			
			/// <summary>Request event arguments.</summary>
			struct GuiRequestEventArgs : public GuiEventArgs
			{
				/// <summary>Set this field to false in event handlers will stop the corresponding action.</summary>
				bool		cancel;
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiRequestEventArgs()
					:cancel(false)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiRequestEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,cancel(false)
				{
				}
			};
			
			/// <summary>Keyboard event arguments.</summary>
			struct GuiKeyEventArgs : public GuiEventArgs, public NativeWindowKeyInfo
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiKeyEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiKeyEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			/// <summary>Char input event arguments.</summary>
			struct GuiCharEventArgs : public GuiEventArgs, public NativeWindowCharInfo
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiCharEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiCharEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			/// <summary>Mouse event arguments.</summary>
			struct GuiMouseEventArgs : public GuiEventArgs, public NativeWindowMouseInfo
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiMouseEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiEventArgs>				GuiNotifyEvent;
			typedef GuiGraphicsEvent<GuiRequestEventArgs>		GuiRequestEvent;
			typedef GuiGraphicsEvent<GuiKeyEventArgs>			GuiKeyEvent;
			typedef GuiGraphicsEvent<GuiCharEventArgs>			GuiCharEvent;
			typedef GuiGraphicsEvent<GuiMouseEventArgs>			GuiMouseEvent;

/***********************************************************************
Event Receiver
***********************************************************************/

			/// <summary>
			/// Contains all available user input events for a <see cref="GuiGraphicsComposition"/>. Almost all events are routed events. Routed events means, not only the activated composition receives the event, all it direct or indirect parents receives the event. The argument(all derives from <see cref="GuiEventArgs"/>) for the event will store the original event raiser composition.
			/// </summary>
			class GuiGraphicsEventReceiver : public Object
			{
			protected:
				GuiGraphicsComposition*			sender;
			public:
				GuiGraphicsEventReceiver(GuiGraphicsComposition* _sender);
				~GuiGraphicsEventReceiver();

				GuiGraphicsComposition*			GetAssociatedComposition();

				/// <summary>Left mouse button down event.</summary>
				GuiMouseEvent					leftButtonDown;
				/// <summary>Left mouse button up event.</summary>
				GuiMouseEvent					leftButtonUp;
				/// <summary>Left mouse button double click event.</summary>
				GuiMouseEvent					leftButtonDoubleClick;
				/// <summary>Middle mouse button down event.</summary>
				GuiMouseEvent					middleButtonDown;
				/// <summary>Middle mouse button up event.</summary>
				GuiMouseEvent					middleButtonUp;
				/// <summary>Middle mouse button double click event.</summary>
				GuiMouseEvent					middleButtonDoubleClick;
				/// <summary>Right mouse button down event.</summary>
				GuiMouseEvent					rightButtonDown;
				/// <summary>Right mouse button up event.</summary>
				GuiMouseEvent					rightButtonUp;
				/// <summary>Right mouse button double click event.</summary>
				GuiMouseEvent					rightButtonDoubleClick;
				/// <summary>Horizontal wheel scrolling event.</summary>
				GuiMouseEvent					horizontalWheel;
				/// <summary>Vertical wheel scrolling event.</summary>
				GuiMouseEvent					verticalWheel;
				/// <summary>Mouse move event.</summary>
				GuiMouseEvent					mouseMove;
				/// <summary>Mouse enter event.</summary>
				GuiNotifyEvent					mouseEnter;
				/// <summary>Mouse leave event.</summary>
				GuiNotifyEvent					mouseLeave;
				
				/// <summary>Preview key event.</summary>
				GuiKeyEvent						previewKey;
				/// <summary>Key down event.</summary>
				GuiKeyEvent						keyDown;
				/// <summary>Key up event.</summary>
				GuiKeyEvent						keyUp;
				/// <summary>System key down event.</summary>
				GuiKeyEvent						systemKeyDown;
				/// <summary>System key up event.</summary>
				GuiKeyEvent						systemKeyUp;
				/// <summary>Preview char input event.</summary>
				GuiCharEvent					previewCharInput;
				/// <summary>Char input event.</summary>
				GuiCharEvent					charInput;
				/// <summary>Got focus event.</summary>
				GuiNotifyEvent					gotFocus;
				/// <summary>Lost focus event.</summary>
				GuiNotifyEvent					lostFocus;
				/// <summary>Caret notify event. This event is raised when a caret graph need to change the visibility state.</summary>
				GuiNotifyEvent					caretNotify;
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class IGuiStyleController;
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{
			class GuiGraphicsHost;

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// Represents a composition for <see cref="elements::IGuiGraphicsElement"/>. A composition is a way to define the size and the position using the information from graphics elements and sub compositions.
			/// When a graphics composition is destroyed, all sub composition will be destroyed. The life cycle of the contained graphics element is partially controlled by the smart pointer to the graphics element inside the composition.
			/// </summary>
			class GuiGraphicsComposition : public Object, public Description<GuiGraphicsComposition>
			{
				typedef collections::IReadonlyList<GuiGraphicsComposition*> ICompositionList;
				typedef collections::List<GuiGraphicsComposition*> CompositionList;

				friend class controls::GuiControl;
				friend class GuiGraphicsHost;
			public:
				/// <summary>
				/// Minimum size limitation.
				/// </summary>
				enum MinSizeLimitation
				{
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.MinSizeLimitation]No limitation for the minimum size.</summary>
					NoLimit,
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.MinSizeLimitation]Minimum size of this composition is the minimum size of the contained graphics element.</summary>
					LimitToElement,
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.MinSizeLimitation]Minimum size of this composition is combiniation of sub compositions and the minimum size of the contained graphics element.</summary>
					LimitToElementAndChildren,
				};
				
				/// <summary>
				/// Relation between the composition size and the parent composition.
				/// </summary>
				enum ParentSizeAffection
				{
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.ParentSizeAffection]The size doesn't aware of the parent composition.</summary>
					NotAffectedByParent,
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.ParentSizeAffection]The size partially limited by the parent composition.</summary>
					AffectedByParent,
					/// <summary>[T:vl.presentation.compositions.GuiGraphicsComposition.ParentSizeAffection]The size is decided by the parent composition.</summary>
					TotallyDecidedByParent,
				};
			protected:
				CompositionList								children;
				GuiGraphicsComposition*						parent;
				Ptr<elements::IGuiGraphicsElement>			ownedElement;
				bool										visible;
				elements::IGuiGraphicsRenderTarget*			renderTarget;
				MinSizeLimitation							minSizeLimitation;

				Ptr<compositions::GuiGraphicsEventReceiver>	eventReceiver;
				controls::GuiControl*						associatedControl;
				GuiGraphicsHost*							associatedHost;
				INativeCursor*								associatedCursor;

				Margin										margin;
				Margin										internalMargin;
				Size										preferredMinSize;

				virtual void								OnControlParentChanged(controls::GuiControl* control);
				virtual void								OnChildInserted(GuiGraphicsComposition* child);
				virtual void								OnChildRemoved(GuiGraphicsComposition* child);
				virtual void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent);
				virtual void								OnRenderTargetChanged();
				
				virtual void								SetAssociatedControl(controls::GuiControl* control);
				virtual void								SetAssociatedHost(GuiGraphicsHost* host);
			public:
				GuiGraphicsComposition();
				~GuiGraphicsComposition();

				/// <summary>Get the parent composition.</summary>
				/// <returns>The parent composition.</returns>
				GuiGraphicsComposition*						GetParent();
				/// <summary>Get all child compositions ordered by z-order from low to high.</summary>
				/// <returns>Child compositions.</returns>
				const ICompositionList&						Children();
				/// <summary>Add a composition as a child.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to add.</param>
				bool										AddChild(GuiGraphicsComposition* child);
				/// <summary>Add a composition as a child with a specified z-order.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The z-order. 0 means the lowest position.</param>
				/// <param name="child">The child composition to add.</param>
				bool										InsertChild(int index, GuiGraphicsComposition* child);
				/// <summary>Remove a child composition.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to remove.</param>
				bool										RemoveChild(GuiGraphicsComposition* child);
				/// <summary>Move a child composition to a new z-order.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to move.</param>
				/// <param name="newIndex">The new z-order. 0 means the lowest position.</param>
				bool										MoveChild(GuiGraphicsComposition* child, int newIndex);

				/// <summary>Get the contained graphics element.</summary>
				/// <returns>The contained graphics element.</returns>
				Ptr<elements::IGuiGraphicsElement>			GetOwnedElement();
				/// <summary>Set the contained graphics element.</summary>
				/// <param name="element">The new graphics element to set.</param>
				void										SetOwnedElement(Ptr<elements::IGuiGraphicsElement> element);
				/// <summary>Get the visibility of the composition.</summary>
				/// <returns>Returns true if the composition is visible.</returns>
				bool										GetVisible();
				/// <summary>Set the visibility of the composition.</summary>
				/// <param name="value">Set to true to make the composition visible.</param>
				void										SetVisible(bool value);
				/// <summary>Get the minimum size limitation of the composition.</summary>
				/// <returns>The minimum size limitation of the composition.</returns>
				MinSizeLimitation							GetMinSizeLimitation();
				/// <summary>Set the minimum size limitation of the composition.</summary>
				/// <param name="value">The minimum size limitation of the composition.</param>
				void										SetMinSizeLimitation(MinSizeLimitation value);
				/// <summary>Get the binded render target.</summary>
				/// <returns>The binded render target.</returns>
				elements::IGuiGraphicsRenderTarget*			GetRenderTarget();
				/// <summary>Set the binded render target. This function is designed for internal usage. Users are not suggested to call this function directly.</summary>
				/// <param name="value">The binded render target.</param>
				void										SetRenderTarget(elements::IGuiGraphicsRenderTarget* value);

				/// <summary>Render the composition using an offset.</summary>
				/// <param name="offset">The offset.</param>
				void										Render(Size offset);
				/// <summary>Get the event receiver object. All user input events can be found in this object. If an event receiver is never been requested from the composition, the event receiver will not be created, and all route events will not pass through this event receiver(performance will be better).</summary>
				/// <returns>The event receiver.</returns>
				compositions::GuiGraphicsEventReceiver*		GetEventReceiver();
				/// <summary>Test if any event receiver has already been requested.</summary>
				/// <returns>Returns true if any event receiver has already been requested.</returns>
				bool										HasEventReceiver();
				/// <summary>Find a deepest composition that under a specified location. If the location is inside a compsition but not hit any sub composition, this function will return this composition.</summary>
				/// <returns>The deepest composition that under a specified location.</returns>
				/// <param name="location">The specified location.</param>
				GuiGraphicsComposition*						FindComposition(Point location);
				/// <summary>Get the bounds in the top composition space.</summary>
				/// <returns>The bounds in the top composition space.</returns>
				Rect										GetGlobalBounds();

				/// <summary>Get the associated control. A control is associated to a composition only when the composition represents the bounds of this control. Such a composition usually comes from a control template.</summary>
				/// <returns>The associated control.</returns>
				controls::GuiControl*						GetAssociatedControl();
				/// <summary>Get the associated graphics host. A graphics host is associated to a composition only when the composition becomes the bounds of the graphics host.</summary>
				/// <returns>The associated graphics host.</returns>
				GuiGraphicsHost*							GetAssociatedHost();
				/// <summary>Get the associated cursor.</summary>
				/// <returns>The associated cursor.</returns>
				INativeCursor*								GetAssociatedCursor();
				/// <summary>Set the associated cursor.</summary>
				/// <param name="cursor">The associated cursor.</param>
				void										SetAssociatedCursor(INativeCursor* cursor);
				
				/// <summary>Get the related control. A related control is the deepest control that contains this composition.</summary>
				/// <returns>The related control.</returns>
				controls::GuiControl*						GetRelatedControl();
				/// <summary>Get the related graphics host. A related graphics host is the graphics host that contains this composition.</summary>
				/// <returns>The related graphics host.</returns>
				GuiGraphicsHost*							GetRelatedGraphicsHost();
				/// <summary>Get the related control host. A related control host is the control host that contains this composition.</summary>
				/// <returns>The related control host.</returns>
				controls::GuiControlHost*					GetRelatedControlHost();
				/// <summary>Get the related cursor. A related cursor is from the deepest composition that contains this composition and associated with a cursor.</summary>
				/// <returns>The related cursor.</returns>
				INativeCursor*								GetRelatedCursor();
				
				/// <summary>Get the margin.</summary>
				/// <returns>The margin.</returns>
				virtual Margin								GetMargin();
				/// <summary>Set the margin.</summary>
				/// <param name="value">The margin.</param>
				virtual void								SetMargin(Margin value);
				/// <summary>Get the internal margin.</summary>
				/// <returns>The internal margin.</returns>
				virtual Margin								GetInternalMargin();
				/// <summary>Set the internal margin.</summary>
				/// <param name="value">The internal margin.</param>
				virtual void								SetInternalMargin(Margin value);
				/// <summary>Get the preferred minimum size.</summary>
				/// <returns>The preferred minimum size.</returns>
				virtual Size								GetPreferredMinSize();
				/// <summary>Set the preferred minimum size.</summary>
				/// <param name="value">The preferred minimum size.</param>
				virtual void								SetPreferredMinSize(Size value);
				/// <summary>Get the client area.</summary>
				/// <returns>The client area.</returns>
				virtual Rect								GetClientArea();
				
				/// <summary>Get the parent size affection.</summary>
				/// <returns>The parent size affection.</returns>
				virtual ParentSizeAffection					GetAffectionFromParent()=0;
				/// <summary>Test is the size calculation affected by the parent.</summary>
				/// <returns>Returns true if the size calculation is affected by the parent.</returns>
				virtual bool								IsSizeAffectParent()=0;
				/// <summary>Get the preferred minimum client size.</summary>
				/// <returns>The preferred minimum client size.</returns>
				virtual Size								GetMinPreferredClientSize()=0;
				/// <summary>Get the preferred bounds.</summary>
				/// <returns>The preferred bounds.</returns>
				virtual Rect								GetPreferredBounds()=0;
				/// <summary>Get the bounds.</summary>
				/// <returns>The bounds.</returns>
				virtual Rect								GetBounds()=0;
			};

			/// <summary>
			/// A general implementation for <see cref="GuiGraphicsComposition"/>.
			/// </summary>
			class GuiGraphicsSite : public GuiGraphicsComposition, public Description<GuiGraphicsSite>
			{
			protected:

				/// <summary>Calculate the final bounds from an expected bounds.</summary>
				/// <returns>The final bounds according to some configuration like margin, minimum size, etc..</returns>
				/// <param name="expectedBounds">The expected bounds.</param>
				virtual Rect						GetBoundsInternal(Rect expectedBounds);
			public:
				GuiGraphicsSite();
				~GuiGraphicsSite();
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetPreferredBounds()override;
			};

/***********************************************************************
Basic Compositions
***********************************************************************/
			
			/// <summary>
			/// Represents a composition for the client area in an <see cref="INativeWindow"/>.
			/// </summary>
			class GuiWindowComposition : public GuiGraphicsSite, public Description<GuiWindowComposition>
			{
			protected:
				INativeWindow*						attachedWindow;
			public:
				GuiWindowComposition();
				~GuiWindowComposition();
				
				/// <summary>Get the attached native window object.</summary>
				/// <returns>The attached native window object.</returns>
				INativeWindow*						GetAttachedWindow();
				/// <summary>Attached a native window object.</summary>
				/// <param name="window">The native window object to attach.</param>
				void								SetAttachedWindow(INativeWindow* window);

				Rect								GetBounds()override;
				void								SetMargin(Margin value)override;
			};

			/// <summary>
			/// Represents a composition that is free to change the expected bounds.
			/// </summary>
			class GuiBoundsComposition : public GuiGraphicsSite, public Description<GuiBoundsComposition>
			{
			protected:
				Rect								compositionBounds;
				Rect								previousBounds;
				Margin								alignmentToParent;
				
			public:
				GuiBoundsComposition();
				~GuiBoundsComposition();

				/// <summary>Event that will be raised when the final bounds is changed.</summary>
				compositions::GuiNotifyEvent		BoundsChanged;
				
				ParentSizeAffection					GetAffectionFromParent()override;
				Rect								GetPreferredBounds()override;
				Rect								GetBounds()override;
				/// <summary>Set the expected bounds.</summary>
				/// <param name="value">The expected bounds.</param>
				void								SetBounds(Rect value);

				/// <summary>Make the composition not aligned to its parent.</summary>
				void								ClearAlignmentToParent();
				/// <summary>Get the alignment to its parent. -1 in each alignment component means that the corressponding side is not aligned to its parent.</summary>
				/// <returns>The alignment to its parent.</returns>
				Margin								GetAlignmentToParent();
				/// <summary>Set the alignment to its parent. -1 in each alignment component means that the corressponding side is not aligned to its parent.</summary>
				/// <param name="value">The alignment to its parent.</param>
				void								SetAlignmentToParent(Margin value);
				/// <summary>Test is the composition aligned to its parent.</summary>
				/// <returns>Returns true if the composition is aligned to its parent.</returns>
				bool								IsAlignedToParent();
			};

/***********************************************************************
Table Compositions
***********************************************************************/

			class GuiTableComposition;
			class GuiCellComposition;

			/// <summary>
			/// Represnets a sizing configuration for a row or a column.
			/// </summary>
			struct GuiCellOption
			{
				/// <summary>Sizing algorithm</summary>
				enum ComposeType
				{
					/// <summary>[T:vl.presentation.compositions.GuiCellOption.ComposeType]Set the size to an absolute value.</summary>
					Absolute,
					/// <summary>[T:vl.presentation.compositions.GuiCellOption.ComposeType]Set the size to a percentage number of the whole table.</summary>
					Percentage,
					/// <summary>[T:vl.presentation.compositions.GuiCellOption.ComposeType]Set the size to the minimum size of the cell element.</summary>
					MinSize,
				};

				/// <summary>Sizing algorithm</summary>
				ComposeType		composeType;
				/// <summary>The absolute size when <see cref="GuiCellOption::composeType"/> is <see cref="ComposeType"/>::Absolute.</summary>
				int				absolute;
				/// <summary>The percentage number when <see cref="GuiCellOption::composeType"/> is <see cref="ComposeType"/>::Percentage.</summary>
				double			percentage;

				GuiCellOption()
					:composeType(Absolute)
					,absolute(20)
					,percentage(0)
				{
				}

				bool operator==(const GuiCellOption& value){return false;}
				bool operator!=(const GuiCellOption& value){return true;}

				/// <summary>Creates an absolute sizing option</summary>
				/// <returns>The created option.</returns>
				/// <param name="value">The absolute size.</param>
				static GuiCellOption AbsoluteOption(int value)
				{
					GuiCellOption option;
					option.composeType=Absolute;
					option.absolute=value;
					return option;
				}
				
				/// <summary>Creates an percantage sizing option</summary>
				/// <returns>The created option.</returns>
				/// <param name="value">The percentage number.</param>
				static GuiCellOption PercentageOption(double value)
				{
					GuiCellOption option;
					option.composeType=Percentage;
					option.percentage=value;
					return option;
				}
				
				/// <summary>Creates an minimum sizing option</summary>
				/// <returns>The created option.</returns>
				static GuiCellOption MinSizeOption()
				{
					GuiCellOption option;
					option.composeType=MinSize;
					return option;
				}
			};

			/// <summary>
			/// Represents a table composition.
			/// </summary>
			class GuiTableComposition : public GuiBoundsComposition, public Description<GuiTableComposition>
			{
				friend class GuiCellComposition;
			protected:
				int											rows;
				int											columns;
				int											cellPadding;
				int											rowExtending;
				int											columnExtending;
				collections::Array<GuiCellOption>			rowOptions;
				collections::Array<GuiCellOption>			columnOptions;
				collections::Array<GuiCellComposition*>		cellCompositions;
				collections::Array<Rect>					cellBounds;
				Rect										previousBounds;
				Size										previousContentMinSize;
				Size										tableContentMinSize;

				int									GetSiteIndex(int _rows, int _columns, int _row, int _column);
				void								SetSitedCell(int _row, int _column, GuiCellComposition* cell);

				void								UpdateCellBoundsInternal(
														collections::Array<int>& dimSizes,
														int& dimSize, 
														collections::Array<GuiCellOption>& dimOptions,
														int GuiTableComposition::* dim1,
														int GuiTableComposition::* dim2,
														int (*getSize)(Size),
														int (*getLocation)(GuiCellComposition*),
														int (*getSpan)(GuiCellComposition*),
														int (*getRow)(int, int),
														int (*getCol)(int, int),
														int maxPass
														);
				void								UpdateCellBoundsPercentages(
														collections::Array<int>& dimSizes,
														int dimSize,
														int maxDimSize,
														collections::Array<GuiCellOption>& dimOptions
														);
				int									UpdateCellBoundsOffsets(
														collections::Array<int>& offsets,
														collections::Array<int>& sizes,
														int start,
														int max
														);
				
				void								UpdateCellBoundsInternal();
				void								UpdateTableContentMinSize();
				void								OnRenderTargetChanged()override;
			public:
				GuiTableComposition();
				~GuiTableComposition();

				/// <summary>Get the number of rows.</summary>
				/// <returns>The number of rows.</returns>
				int									GetRows();
				/// <summary>Get the number of columns.</summary>
				/// <returns>The number of columns.</returns>
				int									GetColumns();
				/// <summary>Change the number of rows and columns.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="_rows">The number of rows.</param>
				/// <param name="_columns">The number of columns.</param>
				bool								SetRowsAndColumns(int _rows, int _columns);
				/// <summary>Get the cell composition that covers the specified cell location.</summary>
				/// <returns>The cell composition that covers the specified cell location.</returns>
				/// <param name="_rows">The number of rows.</param>
				/// <param name="_columns">The number of columns.</param>
				GuiCellComposition*					GetSitedCell(int _row, int _column);

				/// <summary>Get the sizing option of the specified row.</summary>
				/// <returns>The sizing option of the specified row.</returns>
				/// <param name="_rows">The specified row number.</param>
				GuiCellOption						GetRowOption(int _row);
				/// <summary>Set the sizing option of the specified row.</summary>
				/// <param name="_rows">The specified row number.</param>
				/// <param name="option">The sizing option of the specified row.</param>
				void								SetRowOption(int _row, GuiCellOption option);
				/// <summary>Get the sizing option of the specified column.</summary>
				/// <returns>The sizing option of the specified column.</returns>
				/// <param name="_column">The specified column number.</param>
				GuiCellOption						GetColumnOption(int _column);
				/// <summary>Set the sizing option of the specified column.</summary>
				/// <param name="_column">The specified column number.</param>
				/// <param name="option">The sizing option of the specified column.</param>
				void								SetColumnOption(int _column, GuiCellOption option);

				/// <summary>Get the cell padding. A cell padding is the distance between a table client area and a cell, or between two cells.</summary>
				/// <returns>The cell padding.</returns>
				int									GetCellPadding();
				/// <summary>Set the cell padding. A cell padding is the distance between a table client area and a cell, or between two cells.</summary>
				/// <param name="_column">The cell padding.</param>
				void								SetCellPadding(int value);
				/// <summary>Get the cell area in the space of the table's parent composition's client area.</summary>
				/// <returns>The cell area.</returns>
				Rect								GetCellArea();
				/// <summary>Update the sizing of the table and cells after all rows' and columns' sizing options are prepared.</summary>
				void								UpdateCellBounds();
				
				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
			};

			/// <summary>
			/// Represents a cell composition of a <see cref="GuiTableComposition"/>.
			/// </summary>
			class GuiCellComposition : public GuiGraphicsSite, public Description<GuiCellComposition>
			{
				friend class GuiTableComposition;
			protected:
				int									row;
				int									rowSpan;
				int									column;
				int									columnSpan;
				GuiTableComposition*				tableParent;
				
				void								ClearSitedCells(GuiTableComposition* table);
				void								SetSitedCells(GuiTableComposition* table);
				void								ResetSiteInternal();
				bool								SetSiteInternal(int _row, int _column, int _rowSpan, int _columnSpan);
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnTableRowsAndColumnsChanged();
			public:
				GuiCellComposition();
				~GuiCellComposition();

				/// <summary>Get the owner table composition.</summary>
				/// <returns>The owner table composition.</returns>
				GuiTableComposition*				GetTableParent();

				/// <summary>Get the row number for this cell composition.</summary>
				/// <returns>The row number for this cell composition.</returns>
				int									GetRow();
				/// <summary>Get the total numbers of acrossed rows for this cell composition.</summary>
				/// <returns>The total numbers of acrossed rows for this cell composition.</returns>
				int									GetRowSpan();
				/// <summary>Get the column number for this cell composition.</summary>
				/// <returns>The column number for this cell composition.</returns>
				int									GetColumn();
				/// <summary>Get the total numbers of acrossed columns for this cell composition.</summary>
				/// <returns>The total numbers of acrossed columns for this cell composition.</returns>
				int									GetColumnSpan();
				/// <summary>Set the position for this cell composition in the table.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="_row">The row number for this cell composition.</param>
				/// <param name="_column">The column number for this cell composition.</param>
				/// <param name="_rowSpan">The total numbers of acrossed rows for this cell composition.</param>
				/// <param name="_columnSpan">The total numbers of acrossed columns for this cell composition.</param>
				bool								SetSite(int _row, int _column, int _rowSpan, int _columnSpan);

				Rect								GetBounds()override;
			};

/***********************************************************************
Stack Compositions
***********************************************************************/

			class GuiStackComposition;
			class GuiStackItemComposition;

			/// <summary>
			/// Represents a stack composition.
			/// </summary>
			class GuiStackComposition : public GuiBoundsComposition, public Description<GuiStackComposition>
			{
				friend class GuiStackItemComposition;

				typedef collections::List<GuiStackItemComposition*>				ItemCompositionList;
				typedef collections::IReadonlyList<GuiStackItemComposition*>	IItemCompositionList;
			public:
				/// <summary>Stack item layout direction.</summary>
				enum Direction
				{
					/// <summary>[T:vl.presentation.compositions.GuiStackComposition.Direction]Stack items is layouted horizontally.</summary>
					Horizontal,
					/// <summary>[T:vl.presentation.compositions.GuiStackComposition.Direction]Stack items is layouted vertically.</summary>
					Vertical,
				};
			protected:
				Direction							direction;
				ItemCompositionList					stackItems;
				collections::Array<Rect>			stackItemBounds;
				Size								stackItemTotalSize;
				int									padding;
				Rect								previousBounds;
				Margin								extraMargin;

				void								UpdateStackItemBounds();
				void								FixStackItemSizes();
				void								OnChildInserted(GuiGraphicsComposition* child)override;
				void								OnChildRemoved(GuiGraphicsComposition* child)override;
			public:
				GuiStackComposition();
				~GuiStackComposition();

				/// <summary>Get all stack items inside the stack composition.</summary>
				/// <returns>All stack items inside the stack composition.</returns>
				const IItemCompositionList&			GetStackItems();
				/// <summary>Insert an stack item at a specified position.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The position.</param>
				/// <param name="item">The statck item to insert.</param>
				bool								InsertStackItem(int index, GuiStackItemComposition* item);
				
				/// <summary>Get the stack item layout direction.</summary>
				/// <returns>The stack item layout direction.</returns>
				Direction							GetDirection();
				/// <summary>Set the stack item layout direction.</summary>
				/// <param name="value">The stack item layout direction.</param>
				void								SetDirection(Direction value);
				/// <summary>Get the stack item padding.</summary>
				/// <returns>The stack item padding.</returns>
				int									GetPadding();
				/// <summary>Set the stack item padding.</summary>
				/// <param name="value">The stack item padding.</param>
				void								SetPadding(int value);

				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
				
				/// <summary>Get the extra margin inside the stack composition.</summary>
				/// <returns>The extra margin inside the stack composition.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin inside the stack composition.</summary>
				/// <param name="value">The extra margin inside the stack composition.</param>
				void								SetExtraMargin(Margin value);
			};
			
			/// <summary>
			/// Represents a stack item composition of a <see cref="GuiStackComposition"/>.
			/// </summary>
			class GuiStackItemComposition : public GuiGraphicsSite, public Description<GuiStackItemComposition>
			{
				friend class GuiStackComposition;
			protected:
				GuiStackComposition*				stackParent;
				Rect								bounds;
				Margin								extraMargin;

				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				Size								GetMinSize();
			public:
				GuiStackItemComposition();
				~GuiStackItemComposition();
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
				/// <summary>Set the expected bounds of a stack item. In most of the cases only the size of the bounds is used.</summary>
				/// <param name="value">The expected bounds of a stack item.</param>
				void								SetBounds(Rect value);
				
				/// <summary>Get the extra margin for this stack item. An extra margin is used to enlarge the bounds of the stack item, but only the non-extra part will be used for decide the stack item layout.</summary>
				/// <returns>The extra margin for this stack item.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin for this stack item. An extra margin is used to enlarge the bounds of the stack item, but only the non-extra part will be used for decide the stack item layout.</summary>
				/// <param name="value">The extra margin for this stack item.</param>
				void								SetExtraMargin(Margin value);
			};

/***********************************************************************
Specialized Compositions
***********************************************************************/

			/// <summary>
			/// Represents a composition that is aligned to one border of the parent composition.
			/// </summary>
			class GuiSideAlignedComposition : public GuiGraphicsSite, public Description<GuiSideAlignedComposition>
			{
			public:
				/// <summary>The border to align.</summary>
				enum Direction
				{
					/// <summary>[T:vl.presentation.compositions.GuiSideAlignedComposition.Direction]The left border.</summary>
					Left,
					/// <summary>[T:vl.presentation.compositions.GuiSideAlignedComposition.Direction]The top border.</summary>
					Top,
					/// <summary>[T:vl.presentation.compositions.GuiSideAlignedComposition.Direction]The right border.</summary>
					Right,
					/// <summary>[T:vl.presentation.compositions.GuiSideAlignedComposition.Direction]The bottom border.</summary>
					Bottom,
				};
			protected:
				Direction							direction;
				int									maxLength;
				double								maxRatio;
			public:
				GuiSideAlignedComposition();
				~GuiSideAlignedComposition();
				
				/// <summary>Get the border to align.</summary>
				/// <returns>The border to align.</returns>
				Direction							GetDirection();
				/// <summary>Set the border to align.</summary>
				/// <param name="value">The border to align.</param>
				void								SetDirection(Direction value);
				/// <summary>Get the maximum length of this composition.</summary>
				/// <returns>The maximum length of this composition.</returns>
				int									GetMaxLength();
				/// <summary>Set the maximum length of this composition.</summary>
				/// <param name="value">The maximum length of this composition.</param>
				void								SetMaxLength(int value);
				/// <summary>Get the maximum ratio to limit the size according to the size of the parent.</summary>
				/// <returns>The maximum ratio to limit the size according to the size of the parent.</returns>
				double								GetMaxRatio();
				/// <summary>Set the maximum ratio to limit the size according to the size of the parent.</summary>
				/// <param name="value">The maximum ratio to limit the size according to the size of the parent.</param>
				void								SetMaxRatio(double value);
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};

			/// <summary>
			/// Represents a composition that its location and size are decided by the client area of the parent composition by setting ratios.
			/// </summary>
			class GuiPartialViewComposition : public GuiGraphicsSite, public Description<GuiPartialViewComposition>
			{
			protected:
				double								wRatio;
				double								wPageSize;
				double								hRatio;
				double								hPageSize;

			public:
				GuiPartialViewComposition();
				~GuiPartialViewComposition();
				
				/// <summary>Get the width ratio to decided the horizontal location. Value in [0, 1-pageSize].</summary>
				/// <returns>The width ratio to decided the horizontal location.</returns>
				double								GetWidthRatio();
				/// <summary>Get the page size to decide the horizontal size. Value in [0, 1].</summary>
				/// <returns>The page size to decide the horizontal size.</returns>
				double								GetWidthPageSize();
				/// <summary>Get the height ratio to decided the vertical location. Value in [0, 1-pageSize].</summary>
				/// <returns>The height ratio to decided the vertical location.</returns>
				double								GetHeightRatio();
				/// <summary>Get the page size to decide the vertical size. Value in [0, 1].</summary>
				/// <returns>The page size to decide the vertical size.</returns>
				double								GetHeightPageSize();
				/// <summary>Set the width ratio to decided the horizontal location. Value in [0, 1-pageSize].</summary>
				/// <param name="value">The width ratio to decided the horizontal location.</param>
				void								SetWidthRatio(double value);
				/// <summary>Set the page size to decide the horizontal size. Value in [0, 1].</summary>
				/// <param name="value">The page size to decide the horizontal size.</param>
				void								SetWidthPageSize(double value);
				/// <summary>Set the height ratio to decided the vertical location. Value in [0, 1-pageSize].</summary>
				/// <param name="value">The height ratio to decided the vertical location.</param>
				void								SetHeightRatio(double value);
				/// <summary>Set the page size to decide the vertical size. Value in [0, 1].</summary>
				/// <param name="value">The page size to decide the vertical size.</param>
				void								SetHeightPageSize(double value);
				
				ParentSizeAffection					GetAffectionFromParent()override;
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\GUIGRAPHICSHOST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Animation
***********************************************************************/

			/// <summary>
			/// Represents an animation. Use [M:vl.presentation.compositions.GuiGraphicsHost.GetAnimationManager] to access this object.
			/// </summary>
			class IGuiGraphicsAnimation : public virtual IDescriptable, public Description<IGuiGraphicsAnimation>
			{
			public:
				/// <summary>Get the total length.</summary>
				/// <returns>The total length.</returns>
				virtual int						GetTotalLength()=0;
				/// <summary>Get the current position. Value in [0, TotalLength-1]. This function doesn't return a internal state. It return the suggested current position at the moment this function is called.</summary>
				/// <returns>The current position.</returns>
				virtual int						GetCurrentPosition()=0;
				/// <summary>Display a state in the animation with the specified current position and the specified total length.</summary>
				/// <param name="currentPosition">The current position. When this function is called by [T:vl.presentation.compositions.GuiGraphicsAnimationManager], this value comes from <see cref="IGuiGraphicsAnimation::GetCurrentPosition"/>.</param>
				/// <param name="totalLength">The total length. When this function is called by [T:vl.presentation.compositions.GuiGraphicsAnimationManager], this value comes from <see cref="IGuiGraphicsAnimation::GetTotalLength"/>.</param>
				virtual void					Play(int currentPosition, int totalLength)=0;
				/// <summary>Stop the animation.</summary>
				virtual void					Stop()=0;
			};

			/// <summary>
			/// Animation manager.
			/// </summary>
			class GuiGraphicsAnimationManager : public Object
			{
				typedef collections::List<Ptr<IGuiGraphicsAnimation>>		AnimationList;
			protected:
				AnimationList					playingAnimations;
			public:
				GuiGraphicsAnimationManager();
				~GuiGraphicsAnimationManager();

				/// <summary>Add a new animation.</summary>
				/// <param name="animation">The new animation to add.</param>
				void							AddAnimation(Ptr<IGuiGraphicsAnimation> animation);
				/// <summary>Test is the animation manager contains any alive animation.</summary>
				/// <returns>Returns true if the animation manager contains any alive animation.</returns>
				bool							HasAnimation();
				/// <summary>Play all alive animations. Any animation that comes to the end will be removed.</summary>
				void							Play();
			};

/***********************************************************************
Host
***********************************************************************/

			/// <summary>
			/// GuiGraphicsHost hosts an <see cref="GuiWindowComposition"/> in an <see cref="INativeWindow"/>. The composition will fill the whole window.
			/// </summary>
			class GuiGraphicsHost : public Object, private INativeWindowListener, private INativeControllerListener, public Description<GuiGraphicsHost>
			{
				typedef collections::List<GuiGraphicsComposition*>		CompositionList;
			public:
				static const unsigned __int64	CaretInterval=500;
			protected:
				INativeWindow*					nativeWindow;
				GuiWindowComposition*			windowComposition;
				GuiGraphicsComposition*			focusedComposition;
				Size							previousClientSize;
				Size							minSize;
				Point							caretPoint;
				unsigned __int64				lastCaretTime;

				GuiGraphicsAnimationManager		animationManager;
				GuiGraphicsComposition*			mouseCaptureComposition;
				CompositionList					mouseEnterCompositions;

				void							MouseCapture(const NativeWindowMouseInfo& info);
				void							MouseUncapture(const NativeWindowMouseInfo& info);
				void							OnCharInput(const NativeWindowCharInfo& info, GuiGraphicsComposition* composition, GuiCharEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							OnKeyInput(const NativeWindowKeyInfo& info, GuiGraphicsComposition* composition, GuiKeyEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							RaiseMouseEvent(GuiMouseEventArgs& arguments, GuiGraphicsComposition* composition, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void							OnMouseInput(const NativeWindowMouseInfo& info, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				
			private:
				void							Moving(Rect& bounds, bool fixSizeOnly)override;
				void							Moved()override;

				void							LeftButtonDown(const NativeWindowMouseInfo& info)override;
				void							LeftButtonUp(const NativeWindowMouseInfo& info)override;
				void							LeftButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							RightButtonDown(const NativeWindowMouseInfo& info)override;
				void							RightButtonUp(const NativeWindowMouseInfo& info)override;
				void							RightButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonDown(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonUp(const NativeWindowMouseInfo& info)override;
				void							MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void							HorizontalWheel(const NativeWindowMouseInfo& info)override;
				void							VerticalWheel(const NativeWindowMouseInfo& info)override;
				void							MouseMoving(const NativeWindowMouseInfo& info)override;
				void							MouseEntered()override;
				void							MouseLeaved()override;

				void							KeyDown(const NativeWindowKeyInfo& info)override;
				void							KeyUp(const NativeWindowKeyInfo& info)override;
				void							SysKeyDown(const NativeWindowKeyInfo& info)override;
				void							SysKeyUp(const NativeWindowKeyInfo& info)override;
				void							Char(const NativeWindowCharInfo& info)override;

				void							GlobalTimer()override;
			public:
				GuiGraphicsHost();
				~GuiGraphicsHost();

				/// <summary>Get the associated window.</summary>
				/// <returns>The associated window.</returns>
				INativeWindow*					GetNativeWindow();
				/// <summary>Associate a window. A <see cref="GuiWindowComposition"/> will fill and appear in the window.</summary>
				/// <param name="_nativeWindow">The window to associated.</param>
				void							SetNativeWindow(INativeWindow* _nativeWindow);
				/// <summary>Get the main <see cref="GuiWindowComposition"/>. If a window is associated, everything that put into the main composition will be shown in the window.</summary>
				/// <returns>The main compositoin.</returns>
				GuiGraphicsComposition*			GetMainComposition();
				/// <summary>Render the main composition and all content to the associated window.</summary>
				void							Render();

				/// <summary>Set the focus composition. A focused composition will receive keyboard messages.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="composition">The composition to set focus. This composition should be or in the main composition.</param>
				bool							SetFocus(GuiGraphicsComposition* composition);
				/// <summary>Get the focus composition. A focused composition will receive keyboard messages.</summary>
				/// <returns>The focus composition.</returns>
				GuiGraphicsComposition*			GetFocusedComposition();
				/// <summary>Get the caret point. A caret point is the position to place the edit box of the activated input method editor.</summary>
				/// <returns>The caret point.</returns>
				Point							GetCaretPoint();
				/// <summary>Set the caret point. A caret point is the position to place the edit box of the activated input method editor.</summary>
				/// <param name="value">The caret point.</param>
				/// <param name="referenceComposition">The point space. If this argument is null, the "value" argument will use the point space of the client area in the main composition.</param>
				void							SetCaretPoint(Point value, GuiGraphicsComposition* referenceComposition=0);

				/// <summary>Get the animation manager.</summary>
				/// <returns>The animation manager.</returns>
				GuiGraphicsAnimationManager*	GetAnimationManager();
			};

/***********************************************************************
Helpers
***********************************************************************/
			
			/// <summary>
			/// Represents a time based animation.
			/// </summary>
			class GuiTimeBasedAnimation : public IGuiGraphicsAnimation, public Description<GuiTimeBasedAnimation>
			{
			protected:
				unsigned __int64				startTime;
				int								length;
			public:
				/// <summary>Create an animation with a specified length in milliseconds.</summary>
				/// <param name="totalMilliseconds">The specified length in milliseconds.</param>
				GuiTimeBasedAnimation(int totalMilliseconds);
				~GuiTimeBasedAnimation();

				/// <summary>Restart an animation with a specified length in milliseconds.</summary>
				/// <param name="totalMilliseconds">The specified length in milliseconds. If the value is -1, it will use the previous length.</param>
				void							Restart(int totalMilliseconds=-1);
				int								GetTotalLength()override;
				int								GetCurrentPosition()override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\GUIBASICCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Basic Construction
***********************************************************************/

			class GuiControl : public Object, public Description<GuiControl>
			{
				friend class compositions::GuiGraphicsComposition;
				typedef collections::List<GuiControl*>		ControlList;
			public:
				class IStyleController : public virtual IDescriptable, public Description<IStyleController>
				{
				public:
					virtual compositions::GuiBoundsComposition*	GetBoundsComposition()=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void								SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					virtual void								SetText(const WString& value)=0;
					virtual void								SetFont(const FontProperties& value)=0;
					virtual void								SetVisuallyEnabled(bool value)=0;
				};

				class IStyleProvider : public virtual IDescriptable, public Description<IStyleProvider>
				{
				public:
					virtual void								AssociateStyleController(IStyleController* controller)=0;
					virtual void								SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					virtual void								SetText(const WString& value)=0;
					virtual void								SetFont(const FontProperties& value)=0;
					virtual void								SetVisuallyEnabled(bool value)=0;
				};
			protected:
				Ptr<IStyleController>							styleController;
				compositions::GuiBoundsComposition*				boundsComposition;
				compositions::GuiGraphicsComposition*			focusableComposition;
				compositions::GuiGraphicsEventReceiver*			eventReceiver;

				bool									isEnabled;
				bool									isVisuallyEnabled;
				bool									isVisible;
				WString									text;
				FontProperties							font;

				GuiControl*								parent;
				ControlList								children;

				virtual void							OnChildInserted(GuiControl* control);
				virtual void							OnChildRemoved(GuiControl* control);
				virtual void							OnParentChanged(GuiControl* oldParent, GuiControl* newParent);
				virtual void							OnParentLineChanged();
				virtual void							OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget);
				virtual void							OnBeforeReleaseGraphicsHost();
				virtual void							UpdateVisuallyEnabled();
				void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);
			public:
				GuiControl(IStyleController* _styleController);
				~GuiControl();

				compositions::GuiNotifyEvent			VisibleChanged;
				compositions::GuiNotifyEvent			EnabledChanged;
				compositions::GuiNotifyEvent			VisuallyEnabledChanged;
				compositions::GuiNotifyEvent			TextChanged;
				compositions::GuiNotifyEvent			FontChanged;

				compositions::GuiEventArgs				GetNotifyEventArguments();
				IStyleController*						GetStyleController();
				compositions::GuiBoundsComposition*		GetBoundsComposition();
				compositions::GuiGraphicsComposition*	GetContainerComposition();
				compositions::GuiGraphicsComposition*	GetFocusableComposition();
				compositions::GuiGraphicsEventReceiver*	GetEventReceiver();
				GuiControl*								GetParent();
				int										GetChildrenCount();
				GuiControl*								GetChild(int index);
				
				virtual GuiControlHost*					GetRelatedControlHost();
				virtual bool							GetVisuallyEnabled();
				virtual bool							GetEnabled();
				virtual void							SetEnabled(bool value);
				virtual bool							GetVisible();
				virtual void							SetVisible(bool value);
				virtual const WString&					GetText();
				virtual void							SetText(const WString& value);
				virtual const FontProperties&			GetFont();
				virtual void							SetFont(const FontProperties& value);

				virtual IDescriptable*					QueryService(const WString& identifier);

				template<typename T>
				T* QueryService()
				{
					return dynamic_cast<T*>(QueryService(T::Identifier));
				}
			};

			class GuiComponent : public Object, public Description<GuiComponent>
			{
				friend class GuiControlHost;
			private:
				GuiControlHost*							controlHost;

				void									SetControlHost(GuiControlHost* value);
			public:
				GuiComponent();
				~GuiComponent();

				GuiControlHost*							GetControlHost();
			};

			class GuiImageData
			{
			protected:
				Ptr<INativeImage>				image;
				int								frameIndex;

			public:
				GuiImageData();
				GuiImageData(Ptr<INativeImage> _image, int _frameIndex);
				~GuiImageData();

				Ptr<INativeImage>				GetImage();
				int								GetFrameIndex();
			};

/***********************************************************************
Buttons
***********************************************************************/

			class GuiButton : public GuiControl, public Description<GuiButton>
			{
			public:
				enum ControlState
				{
					Normal,
					Active,
					Pressed,
				};

				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						Transfer(ControlState value)=0;
				};
			protected:
				IStyleController*						styleController;
				bool									mousePressing;
				bool									mouseHoving;
				ControlState							controlState;
				
				void									OnParentLineChanged()override;
				void									UpdateControlState();
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiButton(IStyleController* _styleController);
				~GuiButton();

				compositions::GuiNotifyEvent			Clicked;
			};

			class GuiSelectableButton : public GuiButton, public Description<GuiSelectableButton>
			{
			public:
				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						SetSelected(bool value)=0;
				};

				class GroupController : public GuiComponent, public Description<GroupController>
				{
				protected:
					collections::List<GuiSelectableButton*>	buttons;
				public:
					GroupController();
					~GroupController();

					virtual void						Attach(GuiSelectableButton* button);
					virtual void						Detach(GuiSelectableButton* button);
					virtual void						OnSelectedChanged(GuiSelectableButton* button)=0;
				};

				class MutexGroupController : public GroupController, public Description<MutexGroupController>
				{
				protected:
					bool								suppress;
				public:
					MutexGroupController();
					~MutexGroupController();

					void								OnSelectedChanged(GuiSelectableButton* button)override;
				};

			protected:
				IStyleController*						styleController;
				GroupController*						groupController;
				bool									autoSelection;
				bool									isSelected;

				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiSelectableButton(IStyleController* _styleController);
				~GuiSelectableButton();

				compositions::GuiNotifyEvent			GroupControllerChanged;
				compositions::GuiNotifyEvent			AutoSelectionChanged;
				compositions::GuiNotifyEvent			SelectedChanged;

				virtual GroupController*				GetGroupController();
				virtual void							SetGroupController(GroupController* value);

				virtual bool							GetAutoSelection();
				virtual void							SetAutoSelection(bool value);

				virtual bool							GetSelected();
				virtual void							SetSelected(bool value);
			};

/***********************************************************************
Scrolls
***********************************************************************/

			class GuiScroll : public GuiControl, public Description<GuiScroll>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void						SmallDecrease()=0;
					virtual void						SmallIncrease()=0;
					virtual void						BigDecrease()=0;
					virtual void						BigIncrease()=0;

					virtual void						SetTotalSize(int value)=0;
					virtual void						SetPageSize(int value)=0;
					virtual void						SetPosition(int value)=0;
				};

				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void						SetTotalSize(int value)=0;
					virtual void						SetPageSize(int value)=0;
					virtual void						SetPosition(int value)=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiScroll*							scroll;
				public:
					CommandExecutor(GuiScroll* _scroll);
					~CommandExecutor();

					void								SmallDecrease()override;
					void								SmallIncrease()override;
					void								BigDecrease()override;
					void								BigIncrease()override;

					void								SetTotalSize(int value)override;
					void								SetPageSize(int value)override;
					void								SetPosition(int value)override;
				};

				IStyleController*						styleController;
				Ptr<CommandExecutor>					commandExecutor;
				int										totalSize;
				int										pageSize;
				int										position;
				int										smallMove;
				int										bigMove;
			public:
				GuiScroll(IStyleController* _styleController);
				~GuiScroll();
				
				compositions::GuiNotifyEvent			TotalSizeChanged;
				compositions::GuiNotifyEvent			PageSizeChanged;
				compositions::GuiNotifyEvent			PositionChanged;
				compositions::GuiNotifyEvent			SmallMoveChanged;
				compositions::GuiNotifyEvent			BigMoveChanged;

				virtual int								GetTotalSize();
				virtual void							SetTotalSize(int value);
				virtual int								GetPageSize();
				virtual void							SetPageSize(int value);
				virtual int								GetPosition();
				virtual void							SetPosition(int value);
				virtual int								GetSmallMove();
				virtual void							SetSmallMove(int value);
				virtual int								GetBigMove();
				virtual void							SetBigMove(int value);

				int										GetMinPosition();
				int										GetMaxPosition();
			};

			class GuiScrollView : public GuiControl, public Description<GuiScrollView>
			{
			public:
				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiScroll::IStyleController*			CreateHorizontalScrollStyle()=0;
					virtual GuiScroll::IStyleController*			CreateVerticalScrollStyle()=0;
					virtual int										GetDefaultScrollSize()=0;
					virtual compositions::GuiGraphicsComposition*	InstallBackground(compositions::GuiBoundsComposition* boundsComposition)=0;
				};

				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>						styleProvider;
					GuiScrollView*							scrollView;
					GuiScroll*								horizontalScroll;
					GuiScroll*								verticalScroll;
					compositions::GuiBoundsComposition*		boundsComposition;
					compositions::GuiTableComposition*		tableComposition;
					compositions::GuiCellComposition*		containerCellComposition;
					compositions::GuiBoundsComposition*		containerComposition;
					bool									horizontalAlwaysVisible;
					bool									verticalAlwaysVisible;

					void									UpdateTable();
				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetScrollView(GuiScrollView* _scrollView);
					void									AdjustView(Size fullSize);
					IStyleProvider*							GetStyleProvider();

					GuiScroll*								GetHorizontalScroll();
					GuiScroll*								GetVerticalScroll();
					compositions::GuiTableComposition*		GetInternalTableComposition();
					compositions::GuiBoundsComposition*		GetInternalContainerComposition();

					bool									GetHorizontalAlwaysVisible();
					void									SetHorizontalAlwaysVisible(bool value);
					bool									GetVerticalAlwaysVisible();
					void									SetVerticalAlwaysVisible(bool value);

					compositions::GuiBoundsComposition*		GetBoundsComposition()override;
					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};
			protected:

				StyleController*						styleController;
				bool									supressScrolling;

				void									OnContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnVerticalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									CallUpdateView();
				void									Initialize();

				virtual Size							QueryFullSize()=0;
				virtual void							UpdateView(Rect viewBounds)=0;

				GuiScrollView(StyleController* _styleController);
			public:
				GuiScrollView(IStyleProvider* styleProvider);
				~GuiScrollView();

				void									CalculateView();
				Size									GetViewSize();
				Rect									GetViewBounds();

				GuiScroll*								GetHorizontalScroll();
				GuiScroll*								GetVerticalScroll();
				bool									GetHorizontalAlwaysVisible();
				void									SetHorizontalAlwaysVisible(bool value);
				bool									GetVerticalAlwaysVisible();
				void									SetVerticalAlwaysVisible(bool value);
			};

			class GuiScrollContainer : public GuiScrollView, public Description<GuiScrollContainer>
			{
			public:
				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					compositions::GuiBoundsComposition*		controlContainerComposition;
				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									MoveContainer(Point leftTop);
				};

			protected:
				StyleController*						styleController;

				void									OnControlContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				Size									QueryFullSize()override;
				void									UpdateView(Rect viewBounds)override;
			public:
				GuiScrollContainer(GuiScrollContainer::IStyleProvider* styleProvider);
				~GuiScrollContainer();
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\GUIWINDOWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Control Host
***********************************************************************/

			class GuiControlHost : public GuiControl, private INativeWindowListener, public Description<GuiControlHost>
			{
			protected:
				compositions::GuiGraphicsHost*			host;
				collections::List<GuiComponent*>		components;

			private:
				void									Enabled()override;
				void									Disabled()override;
				void									GotFocus()override;
				void									LostFocus()override;
				void									Activated()override;
				void									Deactivated()override;
				void									Opened()override;
				void									Closing(bool& cancel)override;
				void									Closed()override;
				void									Destroying()override;
			public:
				GuiControlHost(GuiControl::IStyleController* _styleController);
				~GuiControlHost();
				
				compositions::GuiNotifyEvent			WindowGotFocus;
				compositions::GuiNotifyEvent			WindowLostFocus;
				compositions::GuiNotifyEvent			WindowActivated;
				compositions::GuiNotifyEvent			WindowDeactivated;
				compositions::GuiNotifyEvent			WindowOpened;
				compositions::GuiRequestEvent			WindowClosing;
				compositions::GuiNotifyEvent			WindowClosed;
				compositions::GuiNotifyEvent			WindowDestroying;

				compositions::GuiGraphicsHost*			GetGraphicsHost();
				compositions::GuiGraphicsComposition*	GetMainComposition();
				INativeWindow*							GetNativeWindow();
				void									SetNativeWindow(INativeWindow* window);
				void									Render();

				bool									GetEnabled()override;
				void									SetEnabled(bool value)override;
				bool									GetFocused();
				void									SetFocused();
				bool									GetActivated();
				void									SetActivated();
				bool									GetShowInTaskBar();
				void									SetShowInTaskBar(bool value);
				bool									GetEnabledActivate();
				void									SetEnabledActivate(bool value);

				bool									GetMaximizedBox();
				void									SetMaximizedBox(bool visible);
				bool									GetMinimizedBox();
				void									SetMinimizedBox(bool visible);
				bool									GetBorder();
				void									SetBorder(bool visible);
				bool									GetSizeBox();
				void									SetSizeBox(bool visible);
				bool									GetIconVisible();
				void									SetIconVisible(bool visible);
				bool									GetTitleBar();
				void									SetTitleBar(bool visible);
				bool									GetTopMost();
				void									SetTopMost(bool topmost);

				bool									AddComponent(GuiComponent* component);
				bool									RemoveComponent(GuiComponent* component);
				bool									ContainsComponent(GuiComponent* component);

				Size									GetClientSize();
				void									SetClientSize(Size value);
				Rect									GetBounds();
				void									SetBounds(Rect value);
				GuiControlHost*							GetRelatedControlHost()override;
				const WString&							GetText()override;
				void									SetText(const WString& value)override;

				INativeScreen*							GetRelatedScreen();
				void									Show();
				void									ShowDeactivated();
				void									ShowRestored();
				void									ShowMaximized();
				void									ShowMinimized();
				void									Hide();
				void									Close();
				bool									GetOpening();
			};

/***********************************************************************
Window
***********************************************************************/

			class GuiWindow : public GuiControlHost, public Description<GuiWindow>
			{
				friend class GuiApplication;
			protected:
				virtual void							MouseClickedOnOtherWindow(GuiWindow* window);
			public:
				GuiWindow(GuiControl::IStyleController* _styleController);
				~GuiWindow();
			};

			class GuiPopup : public GuiWindow, public Description<GuiPopup>
			{
			protected:
				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
			public:
				GuiPopup(GuiControl::IStyleController* _styleController);
				~GuiPopup();

				bool									IsClippedByScreen(Point location);
				void									ShowPopup(Point location);
				void									ShowPopup(GuiControl* control, bool preferredTopBottomSide);
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\GUILISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
List Control
***********************************************************************/

			class GuiListControl : public GuiScrollView, public Description<GuiListControl>
			{
			public:
				class IItemProvider;
				class IItemStyleController;
				class IItemStyleProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class IItemProviderCallback : public virtual IDescriptable, public Description<IItemProviderCallback>
				{
				public:
					virtual void								OnAttached(IItemProvider* provider)=0;
					virtual void								OnItemModified(int start, int count, int newCount)=0;
				};

				class IItemArrangerCallback : public virtual IDescriptable, public Description<IItemArrangerCallback>
				{
				public:
					virtual IItemStyleController*					RequestItem(int itemIndex)=0;
					virtual void									ReleaseItem(IItemStyleController* style)=0;
					virtual void									SetViewLocation(Point value)=0;
					virtual Size									GetStylePreferredSize(IItemStyleController* style)=0;
					virtual void									SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)=0;
					virtual void									SetStyleBounds(IItemStyleController* style, Rect bounds)=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void									OnTotalSizeChanged()=0;
				};

				//-----------------------------------------------------------
				// Common Views
				//-----------------------------------------------------------

				class IItemPrimaryTextView : public virtual IDescriptable, public Description<IItemPrimaryTextView>
				{
				public:
					static const wchar_t* const					Identifier;

					virtual WString								GetPrimaryTextViewText(int itemIndex)=0;
					virtual bool								ContainsPrimaryText(int itemIndex)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				class IItemProvider : public virtual IDescriptable, public Description<IItemProvider>
				{
				public:
					virtual bool								AttachCallback(IItemProviderCallback* value)=0;
					virtual bool								DetachCallback(IItemProviderCallback* value)=0;
					virtual int									Count()=0;
					virtual IDescriptable*						RequestView(const WString& identifier)=0;
					virtual void								ReleaseView(IDescriptable* view)=0;
				};

				class IItemStyleController : public virtual IDescriptable, public Description<IItemStyleController>
				{
				public:
					virtual IItemStyleProvider*					GetStyleProvider()=0;
					virtual int									GetItemStyleId()=0;
					virtual compositions::GuiBoundsComposition*	GetBoundsComposition()=0;
					virtual bool								IsCacheable()=0;
					virtual bool								IsInstalled()=0;
					virtual void								OnInstalled()=0;
					virtual void								OnUninstalled()=0;
				};

				class IItemStyleProvider : public virtual IDescriptable, public Description<IItemStyleProvider>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual int									GetItemStyleId(int itemIndex)=0;
					virtual IItemStyleController*				CreateItemStyle(int styleId)=0;
					virtual void								DestroyItemStyle(IItemStyleController* style)=0;
					virtual void								Install(IItemStyleController* style, int itemIndex)=0;
				};

				class IItemArranger : public virtual IItemProviderCallback, public Description<IItemArranger>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual IItemArrangerCallback*				GetCallback()=0;
					virtual void								SetCallback(IItemArrangerCallback* value)=0;
					virtual Size								GetTotalSize()=0;
					virtual IItemStyleController*				GetVisibleStyle(int itemIndex)=0;
					virtual int									GetVisibleIndex(IItemStyleController* style)=0;
					virtual void								OnViewChanged(Rect bounds)=0;
				};

				class IItemCoordinateTransformer : public virtual IDescriptable, public Description<IItemCoordinateTransformer>
				{
				public:
					virtual Size								RealSizeToVirtualSize(Size size)=0;
					virtual Size								VirtualSizeToRealSize(Size size)=0;
					virtual Point								RealPointToVirtualPoint(Size realFullSize, Point point)=0;
					virtual Point								VirtualPointToRealPoint(Size realFullSize, Point point)=0;
					virtual Rect								RealRectToVirtualRect(Size realFullSize, Rect rect)=0;
					virtual Rect								VirtualRectToRealRect(Size realFullSize, Rect rect)=0;
					virtual Margin								RealMarginToVirtualMargin(Margin margin)=0;
					virtual Margin								VirtualMarginToRealMargin(Margin margin)=0;
				};

			protected:
				class ItemCallback : public IItemProviderCallback, public IItemArrangerCallback
				{
					typedef collections::List<IItemStyleController*>			StyleList;
				protected:
					GuiListControl*								listControl;
					IItemProvider*								itemProvider;
					StyleList									cachedStyles;
					StyleList									installedStyles;

				public:
					ItemCallback(GuiListControl* _listControl);
					~ItemCallback();

					void										ClearCache();

					void										OnAttached(IItemProvider* provider)override;
					void										OnItemModified(int start, int count, int newCount)override;
					IItemStyleController*						RequestItem(int itemIndex)override;
					void										ReleaseItem(IItemStyleController* style)override;
					void										SetViewLocation(Point value)override;
					Size										GetStylePreferredSize(IItemStyleController* style);
					void										SetStyleAlignmentToParent(IItemStyleController* style, Margin margin);
					void										SetStyleBounds(IItemStyleController* style, Rect bounds);
					compositions::GuiGraphicsComposition*		GetContainerComposition()override;
					void										OnTotalSizeChanged()override;
				};

				Ptr<ItemCallback>								callback;
				Ptr<IItemProvider>								itemProvider;
				Ptr<IItemStyleProvider>							itemStyleProvider;
				Ptr<IItemArranger>								itemArranger;
				Ptr<IItemCoordinateTransformer>					itemCoordinateTransformer;
				Size											fullSize;

				virtual void									OnItemModified(int start, int count, int newCount);
				virtual void									OnStyleInstalled(int itemIndex, IItemStyleController* style);
				virtual void									OnStyleUninstalled(IItemStyleController* style);
				
				void											OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void											OnBeforeReleaseGraphicsHost()override;
				Size											QueryFullSize()override;
				void											UpdateView(Rect viewBounds)override;
				
				void											OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											SetStyleProviderAndArranger(Ptr<IItemStyleProvider> styleProvider, Ptr<IItemArranger> arranger);
			public:
				GuiListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider, bool acceptFocus=false);
				~GuiListControl();

				compositions::GuiNotifyEvent					StyleProviderChanged;
				compositions::GuiNotifyEvent					ArrangerChanged;
				compositions::GuiNotifyEvent					CoordinateTransformerChanged;

				virtual IItemProvider*							GetItemProvider();
				virtual IItemStyleProvider*						GetStyleProvider();
				virtual Ptr<IItemStyleProvider>					SetStyleProvider(Ptr<IItemStyleProvider> value);
				virtual IItemArranger*							GetArranger();
				virtual Ptr<IItemArranger>						SetArranger(Ptr<IItemArranger> value);
				virtual IItemCoordinateTransformer*				GetCoordinateTransformer();
				virtual Ptr<IItemCoordinateTransformer>			SetCoordinateTransformer(Ptr<IItemCoordinateTransformer> value);
			};

/***********************************************************************
Selectable List Control
***********************************************************************/

			class GuiSelectableListControl : public GuiListControl, public Description<GuiSelectableListControl>
			{
			public:
				class IItemStyleProvider : public virtual GuiListControl::IItemStyleProvider, public Description<IItemStyleProvider>
				{
				public:
					virtual void								SetStyleSelected(IItemStyleController* style, bool value)=0;
				};

			protected:
				class StyleEvents
				{
				protected:
					GuiSelectableListControl*					listControl;
					IItemStyleController*						style;
					Ptr<compositions::GuiMouseEvent::IHandler>	leftButtonDownHandler;

					void										OnBoundsLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				public:
					StyleEvents(GuiSelectableListControl* _listControl, IItemStyleController* _style);
					~StyleEvents();

					void										AttachEvents();
					void										DetachEvents();
				};

				friend class collections::ReadonlyListEnumerator<Ptr<StyleEvents>>;
				typedef collections::Dictionary<IItemStyleController*, Ptr<StyleEvents>>	VisibleStyleMap;

			protected:

				Ptr<IItemStyleProvider>							selectableStyleProvider;
				collections::SortedList<int>					selectedItems;
				VisibleStyleMap									visibleStyles;
				bool											multiSelect;

				void											OnItemModified(int start, int count, int newCount)override;
				void											OnStyleInstalled(int itemIndex, IItemStyleController* style)override;
				void											OnStyleUninstalled(IItemStyleController* style)override;
				virtual void									OnItemSelectionChanged(int itemIndex, bool value);
				virtual void									OnItemSelectionCleared();
			public:
				GuiSelectableListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider);
				~GuiSelectableListControl();

				compositions::GuiNotifyEvent					SelectionChanged;

				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;

				bool											GetMultiSelect();
				void											SetMultiSelect(bool value);
				
				const collections::IReadonlyList<int>&			GetSelectedItems();
				bool											GetSelected(int itemIndex);
				void											SetSelected(int itemIndex, bool value);
				void											ClearSelection();
			};

/***********************************************************************
Predefined ItemCoordinateTransformer
***********************************************************************/

			namespace list
			{
				class DefaultItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<DefaultItemCoordinateTransformer>
				{
				public:
					DefaultItemCoordinateTransformer();
					~DefaultItemCoordinateTransformer();

					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
				};

				class AxisAlignedItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<AxisAlignedItemCoordinateTransformer>
				{
				public:
					enum Alignment
					{
						LeftDown,
						RightDown,
						LeftUp,
						RightUp,
						DownLeft,
						DownRight,
						UpLeft,
						UpRight,
					};
				protected:
					Alignment									alignment;

				public:
					AxisAlignedItemCoordinateTransformer(Alignment _alignment);
					~AxisAlignedItemCoordinateTransformer();

					Alignment									GetAlignment();
					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
				};
			};

/***********************************************************************
Predefined ItemArranger
***********************************************************************/

			namespace list
			{
				class RangedItemArrangerBase : public Object, virtual public GuiListControl::IItemArranger, public Description<RangedItemArrangerBase>
				{
					typedef collections::List<GuiListControl::IItemStyleController*>		StyleList;
				protected:
					GuiListControl::IItemArrangerCallback*		callback;
					GuiListControl::IItemProvider*				itemProvider;
					Rect										viewBounds;
					int											startIndex;
					StyleList									visibleStyles;

					virtual void								ClearStyles();
					virtual void								OnStylesCleared()=0;
					virtual Size								OnCalculateTotalSize()=0;
					virtual void								OnViewChangedInternal(Rect oldBounds, Rect newBounds)=0;
				public:
					RangedItemArrangerBase();
					~RangedItemArrangerBase();

					void										OnAttached(GuiListControl::IItemProvider* provider)override;
					void										OnItemModified(int start, int count, int newCount)override;
					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemArrangerCallback*		GetCallback()override;
					void										SetCallback(GuiListControl::IItemArrangerCallback* value)override;
					Size										GetTotalSize()override;
					GuiListControl::IItemStyleController*		GetVisibleStyle(int itemIndex)override;
					int											GetVisibleIndex(GuiListControl::IItemStyleController* style)override;
					void										OnViewChanged(Rect bounds)override;
				};

				class FixedHeightItemArranger : public RangedItemArrangerBase, public Description<FixedHeightItemArranger>
				{
				protected:
					int											rowHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					virtual int									GetWidth();
					virtual int									GetYOffset();
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightItemArranger();
					~FixedHeightItemArranger();
				};

				class FixedSizeMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedSizeMultiColumnItemArranger>
				{
				protected:
					Size										itemSize;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(Size itemSize, Rect bounds, int count, int& start, int& end);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedSizeMultiColumnItemArranger();
					~FixedSizeMultiColumnItemArranger();
				};

				class FixedHeightMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedHeightMultiColumnItemArranger>
				{
				protected:
					int											itemHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(int itemHeight, Rect bounds, int& rows, int& startColumn);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightMultiColumnItemArranger();
					~FixedHeightMultiColumnItemArranger();
				};
			}

/***********************************************************************
Predefined ItemStyleController
***********************************************************************/

			namespace list
			{
				class ItemStyleControllerBase : public Object, public virtual GuiListControl::IItemStyleController, public Description<ItemStyleControllerBase>
				{
				protected:
					GuiListControl::IItemStyleProvider*			provider;
					int											styleId;
					compositions::GuiBoundsComposition*			boundsComposition;
					GuiControl*									associatedControl;
					bool										isInstalled;

					void										Initialize(compositions::GuiBoundsComposition* _boundsComposition, GuiControl* _associatedControl);
					void										Finalize();

					ItemStyleControllerBase(GuiListControl::IItemStyleProvider* _provider, int _styleId);
				public:
					~ItemStyleControllerBase();
					
					GuiListControl::IItemStyleProvider*			GetStyleProvider()override;
					int											GetItemStyleId()override;
					compositions::GuiBoundsComposition*			GetBoundsComposition()override;
					bool										IsCacheable()override;
					bool										IsInstalled()override;
					void										OnInstalled()override;
					void										OnUninstalled()override;
				};
			}

/***********************************************************************
Predefined ItemProvider
***********************************************************************/

			namespace list
			{
				class ItemProviderBase : public Object, public virtual GuiListControl::IItemProvider, public Description<ItemProviderBase>
				{
				protected:
					collections::List<GuiListControl::IItemProviderCallback*>	callbacks;

					virtual void								InvokeOnItemModified(int start, int count, int newCount);
				public:
					ItemProviderBase();
					~ItemProviderBase();

					bool										AttachCallback(GuiListControl::IItemProviderCallback* value);
					bool										DetachCallback(GuiListControl::IItemProviderCallback* value);
				};

				template<typename T, typename K=typename KeyType<T>::Type>
				class ListWrapperProvider : public ItemProviderBase, public collections::IList<T, K>
				{
				protected:
					collections::IList<T, K>*			proxy;

					ListWrapperProvider()
						:proxy(0)
					{
					}
				public:
					ListWrapperProvider(collections::IList<T, K>* _proxy)
						:proxy(_proxy)
					{
					}

					~ListWrapperProvider()
					{
					}

					bool NotifyUpdate(int start, int count=1)
					{
						if(start<0 || start>=proxy->Count() || count<=0 || start+count>proxy->Count())
						{
							return false;
						}
						else
						{
							InvokeOnItemModified(start, count, count);
							return true;
						}
					}

					collections::IEnumerator<T>* CreateEnumerator()const
					{
						return proxy->CreateEnumerator();
					}

					bool Contains(const K& item)const
					{
						return proxy->Contains(item);
					}

					vint Count()const
					{
						return proxy->Count();
					}

					vint Count()
					{
						return proxy->Count();
					}

					const T& Get(vint index)const
					{
						return proxy->Get(index);
					}

					const T& operator[](vint index)const
					{
						return (*proxy)[index];
					}

					vint IndexOf(const K& item)const
					{
						return proxy->IndexOf(item);
					}

					vint Add(const T& item)
					{
						return Insert(proxy->Count(), item);
					}

					bool Remove(const K& item)
					{
						vint index=proxy->IndexOf(item);
						if(index==-1) return false;
						return RemoveAt(index);
					}

					bool RemoveAt(vint index)
					{
						if(proxy->RemoveAt(index))
						{
							InvokeOnItemModified(index, 1, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					bool RemoveRange(vint index, vint count)
					{
						if(proxy->RemoveRange(index, count))
						{
							InvokeOnItemModified(index, count, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					bool Clear()
					{
						vint count=proxy->Count();
						if(proxy->Clear())
						{
							InvokeOnItemModified(0, count, 0);
							return true;
						}
						else
						{
							return false;
						}
					}

					vint Insert(vint index, const T& item)
					{
						vint result=proxy->Insert(index, item);
						InvokeOnItemModified(index, 0, 1);
						return result;
					}

					bool Set(vint index, const T& item)
					{
						if(proxy->Set(index, item))
						{
							InvokeOnItemModified(index, 1, 1);
							return true;
						}
						else
						{
							return false;
						}
					}
				};

				template<typename T>
				class ListProvider : public ListWrapperProvider<T>
				{
				protected:
					collections::List<T>		list;

				public:
					ListProvider()
					{
						proxy=&list.Wrap();
					}

					~ListProvider()
					{
					}
				};
			}
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUITEXTLISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualTextList;

			namespace list
			{

/***********************************************************************
TextList Style Provider
***********************************************************************/

				class TextItemStyleProvider : public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<TextItemStyleProvider>
				{
				public:
					class ITextItemStyleProvider : public virtual IDescriptable, public Description<ITextItemStyleProvider>
					{
					public:
						virtual GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()=0;
						virtual GuiSelectableButton::IStyleController*		CreateBulletStyleController()=0;
					};

					class ITextItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<ITextItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual WString							GetText(int itemIndex)=0;
						virtual bool							GetChecked(int itemIndex)=0;
						virtual void							SetCheckedSilently(int itemIndex, bool value)=0;
					};

					class TextItemStyleController : public ItemStyleControllerBase, public Description<TextItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						GuiSelectableButton*					bulletButton;
						elements::GuiSolidLabelElement*			textElement;
						TextItemStyleProvider*					textItemStyleProvider;

						void									OnBulletSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						TextItemStyleController(TextItemStyleProvider* provider);
						~TextItemStyleController();

						bool									GetSelected();
						void									SetSelected(bool value);
						bool									GetChecked();
						void									SetChecked(bool value);
						const WString&							GetText();
						void									SetText(const WString& value);
					};

				protected:
					Ptr<ITextItemStyleProvider>					textItemStyleProvider;
					ITextItemView*								textItemView;
					GuiListControl*								listControl;

					void										OnStyleCheckedChanged(TextItemStyleController* style);
				public:
					TextItemStyleProvider(ITextItemStyleProvider* _textItemStyleProvider);
					~TextItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					int											GetItemStyleId(int itemIndex)override;
					GuiListControl::IItemStyleController*		CreateItemStyle(int styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, int itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};

/***********************************************************************
TextList Data Source
***********************************************************************/

				class TextItem
				{
					friend class TextItemProvider;
				protected:
					WString										text;
					bool										checked;
				public:
					TextItem();
					TextItem(const TextItem& item);
					TextItem(const WString& _text, bool _checked=false);
					TextItem(const wchar_t* _text, bool _checked=false);
					~TextItem();

					bool										operator==(const TextItem& value)const;
					bool										operator!=(const TextItem& value)const;

					const WString&								GetText()const;
					bool										GetChecked()const;
				};

				class TextItemProvider : public ListProvider<TextItem>, protected TextItemStyleProvider::ITextItemView, public Description<TextItemProvider>
				{
				protected:
					bool										ContainsPrimaryText(int itemIndex)override;
					WString										GetPrimaryTextViewText(int itemIndex)override;
					WString										GetText(int itemIndex)override;
					bool										GetChecked(int itemIndex)override;
					void										SetCheckedSilently(int itemIndex, bool value)override;
				public:
					TextItemProvider();
					~TextItemProvider();
					
					void										SetText(int itemIndex, const WString& value);
					void										SetChecked(int itemIndex, bool value);

					IDescriptable*								RequestView(const WString& identifier)override;
					void										ReleaseView(IDescriptable* view)override;
				};
			}

/***********************************************************************
TextList Control
***********************************************************************/

			class GuiVirtualTextList : public GuiSelectableListControl, public Description<GuiVirtualTextList>
			{
			public:
				GuiVirtualTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualTextList();
				
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value);
				Ptr<GuiListControl::IItemStyleProvider>			ChangeItemStyle(list::TextItemStyleProvider::ITextItemStyleProvider* itemStyleProvider);
			};

			class GuiTextList : public GuiVirtualTextList, public Description<GuiTextList>
			{
			protected:
				list::TextItemProvider*							items;
			public:
				GuiTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider);
				~GuiTextList();

				list::TextItemProvider&							GetItems();
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUILISTVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiListViewBase;

			namespace list
			{

/***********************************************************************
ListView Base
***********************************************************************/

				class ListViewItemStyleProviderBase: public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<ListViewItemStyleProviderBase>
				{
				public:
					class ListViewItemStyleController : public ItemStyleControllerBase, public Description<ListViewItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						ListViewItemStyleProviderBase*			listViewItemStyleProvider;

					public:
						ListViewItemStyleController(ListViewItemStyleProviderBase* provider);
						~ListViewItemStyleController();

						bool									GetSelected();
						void									SetSelected(bool value);
					};

				protected:
					GuiListViewBase*							listControl;

				public:
					ListViewItemStyleProviderBase();
					~ListViewItemStyleProviderBase();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					int											GetItemStyleId(int itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

			class GuiListViewBase : public GuiSelectableListControl, public Description<GuiListViewBase>
			{
			public:
				class IStyleProvider : public virtual GuiSelectableListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiSelectableButton::IStyleController*		CreateColumnStyle()=0;
					virtual Color										GetPrimaryTextColor()=0;
					virtual Color										GetSecondaryTextColor()=0;
					virtual Color										GetItemSeparatorColor()=0;
				};

			protected:
				IStyleProvider*									styleProvider;

			public:
				GuiListViewBase(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiListViewBase();
				
				IStyleProvider*									GetListViewStyleProvider();
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value);
			};

/***********************************************************************
ListView ItemStyleProvider
***********************************************************************/

			namespace list
			{
				class ListViewItemStyleProvider : public ListViewItemStyleProviderBase, public Description<ListViewItemStyleProvider>
				{
				public:
					class IListViewItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<IListViewItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual Ptr<GuiImageData>				GetSmallImage(int itemIndex)=0;
						virtual Ptr<GuiImageData>				GetLargeImage(int itemIndex)=0;
						virtual WString							GetText(int itemIndex)=0;
						virtual WString							GetSubItem(int itemIndex, int index)=0;

						virtual int								GetDataColumnCount()=0;
						virtual int								GetDataColumn(int index)=0;

						virtual int								GetColumnCount()=0;
						virtual WString							GetColumnText(int index)=0;
					};

					class IListViewItemContent : public virtual IDescriptable, public Description<IListViewItemContent>
					{
					public:
						virtual compositions::GuiBoundsComposition*	GetContentComposition()=0;
						virtual compositions::GuiBoundsComposition*	GetBackgroundDecorator()=0;
						virtual void								Install(GuiListViewBase::IStyleProvider* styleProvider, IListViewItemView* view, int itemIndex)=0;
					};

					class IListViewItemContentProvider : public virtual IDescriptable, public Description<IListViewItemContentProvider>
					{
					public:
						virtual GuiListControl::IItemCoordinateTransformer*		CreatePreferredCoordinateTransformer()=0;
						virtual GuiListControl::IItemArranger*					CreatePreferredArranger()=0;
						virtual IListViewItemContent*							CreateItemContent(const FontProperties& font)=0;
						virtual void											AttachListControl(GuiListControl* value)=0;
						virtual void											DetachListControl()=0;
					};

					class ListViewContentItemStyleController : public ListViewItemStyleController, public Description<ListViewContentItemStyleController>
					{
					protected:
						ListViewItemStyleProvider*				listViewItemStyleProvider;
						Ptr<IListViewItemContent>				content;
					public:
						ListViewContentItemStyleController(ListViewItemStyleProvider* provider);
						~ListViewContentItemStyleController();

						IListViewItemContent*					GetItemContent();
						void									Install(IListViewItemView* view, int itemIndex);
					};

				protected:

					typedef collections::List<GuiListControl::IItemStyleController*>				ItemStyleList;
					typedef collections::IReadonlyList<GuiListControl::IItemStyleController*>		IItemStyleList;

					IListViewItemView*							listViewItemView;
					Ptr<IListViewItemContentProvider>			listViewItemContentProvider;
					ItemStyleList								itemStyles;
				public:
					ListViewItemStyleProvider(IListViewItemContentProvider* itemContentProvider);
					~ListViewItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemStyleController*		CreateItemStyle(int styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, int itemIndex)override;

					const IItemStyleList&						GetCreatedItemStyles();
					bool										IsItemStyleAttachedToListView(GuiListControl::IItemStyleController* itemStyle);
				};
			}

/***********************************************************************
ListView ItemContentProvider
***********************************************************************/

			namespace list
			{
				class ListViewBigIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewBigIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewBigIconContentProvider(Size _iconSize=Size(32, 32));
					~ListViewBigIconContentProvider();

					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewSmallIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewSmallIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewSmallIconContentProvider(Size _iconSize=Size(16, 16));
					~ListViewSmallIconContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewListContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewListContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewListContentProvider(Size _iconSize=Size(16, 16));
					~ListViewListContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewTileContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewTileContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						void											RemoveTextElement(int textRow);
						elements::GuiSolidLabelElement*					CreateTextElement(int textRow, const FontProperties& font);
						void											ResetTextTable(int textRows);
					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewTileContentProvider(Size _iconSize=Size(32, 32));
					~ListViewTileContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewInformationContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewInformationContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						FontProperties									baselineFont;
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						elements::GuiSolidBackgroundElement*			bottomLine;
						compositions::GuiBoundsComposition*				bottomLineComposition;

					public:
						ItemContent(Size iconSize, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
				public:
					ListViewInformationContentProvider(Size _iconSize=Size(32, 32));
					~ListViewInformationContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};

/***********************************************************************
ListView ItemContentProvider(Detailed)
***********************************************************************/

				class ListViewColumnItemArranger : public FixedHeightItemArranger, public Description<ListViewColumnItemArranger>
				{
					typedef collections::List<GuiButton*>								ColumnHeaderButtonList;
					typedef collections::List<compositions::GuiBoundsComposition*>		ColumnHeaderSplitterList;
				public:
					static const int							SplitterWidth=8;

					class IColumnItemViewCallback : public virtual IDescriptable, public Description<IColumnItemViewCallback>
					{
					public:
						virtual void							OnColumnChanged()=0;
						virtual void							OnColumnSizeChanged(int index)=0;
					};

					class IColumnItemView : public virtual IDescriptable, public Description<IColumnItemView>
					{
					public:
						static const wchar_t* const				Identifier;
						
						virtual bool							AttachCallback(IColumnItemViewCallback* value)=0;
						virtual bool							DetachCallback(IColumnItemViewCallback* value)=0;
						virtual int								GetColumnCount()=0;
						virtual WString							GetColumnText(int index)=0;
						virtual int								GetColumnSize(int index)=0;
						virtual void							SetColumnSize(int index, int value)=0;
					};
				protected:
					class ColumnItemViewCallback : public Object, public virtual IColumnItemViewCallback
					{
					protected:
						ListViewColumnItemArranger*				arranger;
					public:
						ColumnItemViewCallback(ListViewColumnItemArranger* _arranger);
						~ColumnItemViewCallback();

						void									OnColumnChanged();
						void									OnColumnSizeChanged(int index);
					};

					GuiListViewBase*							listView;
					GuiListViewBase::IStyleProvider*			styleProvider;
					IColumnItemView*							columnItemView;
					Ptr<ColumnItemViewCallback>					columnItemViewCallback;
					compositions::GuiStackComposition*			columnHeaders;
					ColumnHeaderButtonList						columnHeaderButtons;
					ColumnHeaderSplitterList					columnHeaderSplitters;
					bool										splitterDragging;
					int											splitterLatestX;

					void										ColumnHeaderSplitterLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);

					void										RearrangeItemBounds()override;
					int											GetWidth()override;
					int											GetYOffset()override;
					Size										OnCalculateTotalSize()override;
					void										DeleteColumnButtons();
					void										RebuildColumns();
					void										UpdateColumnSize(int index);
				public:
					ListViewColumnItemArranger();
					~ListViewColumnItemArranger();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
				};
				
				class ListViewDetailContentProvider
					: public Object
					, public virtual ListViewItemStyleProvider::IListViewItemContentProvider
					, protected virtual ListViewColumnItemArranger::IColumnItemViewCallback
					, public Description<ListViewDetailContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::List<elements::GuiSolidLabelElement*>		SubItemList;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						SubItemList										subItems;

						GuiListControl::IItemProvider*					itemProvider;
						ListViewColumnItemArranger::IColumnItemView*	columnItemView;

					public:
						ItemContent(Size iconSize, const FontProperties& font, GuiListControl::IItemProvider* _itemProvider);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											UpdateSubItemSize();
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, int itemIndex)override;
					};

					Size												iconSize;
					GuiListControl::IItemProvider*						itemProvider;
					ListViewColumnItemArranger::IColumnItemView*		columnItemView;
					ListViewItemStyleProvider*							listViewItemStyleProvider;

					void												OnColumnChanged()override;
					void												OnColumnSizeChanged(int index)override;
				public:
					ListViewDetailContentProvider(Size _iconSize=Size(16, 16));
					~ListViewDetailContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
			}

/***********************************************************************
ListView
***********************************************************************/

			namespace list
			{
				class ListViewItem
				{
				public:
					Ptr<GuiImageData>							smallImage;
					Ptr<GuiImageData>							largeImage;
					WString										text;
					collections::List<WString>					subItems;
				};

				class ListViewColumn
				{
				public:
					WString										text;
					int											size;

					ListViewColumn(const WString& _text=L"", int _size=160);
				};

				class ListViewItemProvider
					: public ListProvider<Ptr<ListViewItem>>
					, protected virtual ListViewItemStyleProvider::IListViewItemView
					, protected virtual ListViewColumnItemArranger::IColumnItemView
					, public Description<ListViewItemProvider>
				{
					typedef collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					collections::List<int>						dataColumns;
					collections::List<Ptr<ListViewColumn>>		columns;
					ColumnItemViewCallbackList					columnItemViewCallbacks;

					bool										ContainsPrimaryText(int itemIndex)override;
					WString										GetPrimaryTextViewText(int itemIndex)override;
					Ptr<GuiImageData>							GetSmallImage(int itemIndex)override;
					Ptr<GuiImageData>							GetLargeImage(int itemIndex)override;
					WString										GetText(int itemIndex)override;
					WString										GetSubItem(int itemIndex, int index)override;
					int											GetDataColumnCount()override;
					int											GetDataColumn(int index)override;

					bool										AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool										DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					int											GetColumnCount()override;
					WString										GetColumnText(int index)override;
					int											GetColumnSize(int index)override;
					void										SetColumnSize(int index, int value)override;
				public:
					ListViewItemProvider();
					~ListViewItemProvider();

					IDescriptable*								RequestView(const WString& identifier)override;
					void										ReleaseView(IDescriptable* view)override;

					collections::IList<int>&					GetDataColumns();
					void										NotifyDataColumnsUpdated();
					collections::IList<Ptr<ListViewColumn>>&	GetColumns();
					void										NotifyColumnsUpdated();
				};
			}

			class GuiVirtualListView : public GuiListViewBase, public Description<GuiVirtualListView>
			{
			public:
				GuiVirtualListView(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualListView();
				
				void											ChangeItemStyle(list::ListViewItemStyleProvider::IListViewItemContentProvider* contentProvider);
			};

			class GuiListView : public GuiVirtualListView, public Description<GuiListView>
			{
			protected:
				list::ListViewItemProvider*						items;
			public:
				GuiListView(IStyleProvider* _styleProvider);
				~GuiListView();
				
				list::ListViewItemProvider&						GetItems();
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUITREEVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiVirtualTreeListControl NodeProvider
***********************************************************************/

			namespace tree
			{
				class INodeProvider;
				class INodeRootProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class INodeProviderCallback : public virtual IDescriptable, public Description<INodeProviderCallback>
				{
				public:
					virtual void					OnAttached(INodeRootProvider* provider)=0;
					virtual void					OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)=0;
					virtual void					OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)=0;
					virtual void					OnItemExpanded(INodeProvider* node)=0;
					virtual void					OnItemCollapsed(INodeProvider* node)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				class INodeProvider : public virtual IDescriptable, public Description<INodeProvider>
				{
				public:
					virtual bool					GetExpanding()=0;
					virtual void					SetExpanding(bool value)=0;
					virtual int						CalculateTotalVisibleNodes()=0;

					virtual int						GetChildCount()=0;
					virtual INodeProvider*			GetParent()=0;
					virtual INodeProvider*			RequestChild(int index)=0;
					virtual void					ReleaseChild(INodeProvider* node)=0;
				};

				class INodeRootProvider : public virtual IDescriptable, public Description<INodeRootProvider>
				{
				public:
					virtual INodeProvider*			GetRootNode()=0;
					virtual bool					CanGetNodeByVisibleIndex()=0;
					virtual INodeProvider*			GetNodeByVisibleIndex(int index)=0;
					virtual bool					AttachCallback(INodeProviderCallback* value)=0;
					virtual bool					DetachCallback(INodeProviderCallback* value)=0;
					virtual IDescriptable*			RequestView(const WString& identifier)=0;
					virtual void					ReleaseView(IDescriptable* view)=0;
				};
			}

			namespace tree
			{
				//-----------------------------------------------------------
				// Tree to ListControl (IItemProvider)
				//-----------------------------------------------------------

				class INodeItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<INodeItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual INodeProvider*			RequestNode(int index)=0;
					virtual void					ReleaseNode(INodeProvider* node)=0;
					virtual int						CalculateNodeVisibilityIndex(INodeProvider* node)=0;
				};

				class INodeItemPrimaryTextView : public virtual IDescriptable, public Description<INodeItemPrimaryTextView>
				{
				public:
					static const wchar_t* const		Identifier;
					
					virtual WString					GetPrimaryTextViewText(INodeProvider* node)=0;
				};

				class NodeItemProvider
					: public list::ItemProviderBase
					, protected virtual INodeProviderCallback
					, protected virtual INodeItemView
					, public Description<NodeItemProvider>
				{
				protected:
					Ptr<INodeRootProvider>			root;
					INodeItemPrimaryTextView*		nodeItemPrimaryTextView;
					int								offsetBeforeChildModified;

					INodeProvider*					GetNodeByOffset(INodeProvider* provider, int offset);
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
					int								CalculateNodeVisibilityIndexInternal(INodeProvider* node);
					int								CalculateNodeVisibilityIndex(INodeProvider* node)override;
					
					bool							ContainsPrimaryText(int itemIndex)override;
					WString							GetPrimaryTextViewText(int itemIndex)override;
					INodeProvider*					RequestNode(int index)override;
					void							ReleaseNode(INodeProvider* node)override;
				public:
					NodeItemProvider(INodeRootProvider* _root);
					~NodeItemProvider();

					Ptr<INodeRootProvider>			GetRoot();
					int								Count()override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};

				//-----------------------------------------------------------
				// Tree to ListControl (IItemStyleProvider)
				//-----------------------------------------------------------

				class INodeItemStyleProvider;

				class INodeItemStyleController : public virtual GuiListControl::IItemStyleController, public Description<INodeItemStyleController>
				{
				public:
					virtual INodeItemStyleProvider*					GetNodeStyleProvider()=0;
				};

				class INodeItemStyleProvider : public virtual IDescriptable, public Description<INodeItemStyleProvider>
				{
				public:
					virtual void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)=0;
					virtual GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()=0;
					virtual void									AttachListControl(GuiListControl* value)=0;
					virtual void									DetachListControl()=0;
					virtual int										GetItemStyleId(INodeProvider* node)=0;
					virtual INodeItemStyleController*				CreateItemStyle(int styleId)=0;
					virtual void									DestroyItemStyle(INodeItemStyleController* style)=0;
					virtual void									Install(INodeItemStyleController* style, INodeProvider* node)=0;
					virtual void									SetStyleSelected(INodeItemStyleController* style, bool value)=0;
				};

				class NodeItemStyleProvider : public Object, public virtual GuiSelectableListControl::IItemStyleProvider, public Description<NodeItemStyleProvider>
				{
				protected:
					Ptr<INodeItemStyleProvider>						nodeItemStyleProvider;
					GuiListControl*									listControl;
					INodeItemView*									nodeItemView;
				public:
					NodeItemStyleProvider(Ptr<INodeItemStyleProvider> provider);
					~NodeItemStyleProvider();

					void											AttachListControl(GuiListControl* value)override;
					void											DetachListControl()override;
					int												GetItemStyleId(int itemIndex)override;
					GuiListControl::IItemStyleController*			CreateItemStyle(int styleId)override;
					void											DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void											Install(GuiListControl::IItemStyleController* style, int itemIndex)override;
					void											SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

/***********************************************************************
GuiVirtualTreeListControl Predefined NodeProvider
***********************************************************************/

			namespace tree
			{
				class MemoryNodeProvider
					: public Object
					, public virtual INodeProvider
					, private collections::IList<Ptr<MemoryNodeProvider>>
					, public Description<MemoryNodeProvider>
				{
					typedef collections::List<Ptr<MemoryNodeProvider>> ChildList;
					typedef collections::IList<Ptr<MemoryNodeProvider>> IChildList;
					typedef collections::IEnumerator<Ptr<MemoryNodeProvider>> ChildListEnumerator;
				protected:
					MemoryNodeProvider*				parent;
					bool							expanding;
					int								childCount;
					int								totalVisibleNodeCount;
					int								offsetBeforeChildModified;
					Ptr<DescriptableObject>			data;
					ChildList						children;

					virtual INodeProviderCallback*	GetCallbackProxyInternal();
					void							OnChildTotalVisibleNodesChanged(int offset);
					void							OnBeforeChildModified(int start, int count, int newCount);
					void							OnAfterChildModified(int start, int count, int newCount);
					bool							OnRequestRemove(MemoryNodeProvider* child);
					bool							OnRequestInsert(MemoryNodeProvider* child);
				private:
					
					ChildListEnumerator*			CreateEnumerator()const;
					bool							Contains(const KeyType<Ptr<MemoryNodeProvider>>::Type& item)const;
					vint							Count()const;
					vint							Count();
					const							Ptr<MemoryNodeProvider>& Get(vint index)const;
					const							Ptr<MemoryNodeProvider>& operator[](vint index)const;
					vint							IndexOf(const KeyType<Ptr<MemoryNodeProvider>>::Type& item)const;
					vint							Add(const Ptr<MemoryNodeProvider>& item);
					bool							Remove(const KeyType<Ptr<MemoryNodeProvider>>::Type& item);
					bool							RemoveAt(vint index);
					bool							RemoveRange(vint index, vint count);
					bool							Clear();
					vint							Insert(vint index, const Ptr<MemoryNodeProvider>& item);
					bool							Set(vint index, const Ptr<MemoryNodeProvider>& item);
				public:
					MemoryNodeProvider();
					MemoryNodeProvider(const Ptr<DescriptableObject>& _data);
					~MemoryNodeProvider();

					Ptr<DescriptableObject>			GetData();
					void							SetData(const Ptr<DescriptableObject>& value);
					void							NotifyDataModified();
					IChildList&						Children();

					bool							GetExpanding()override;
					void							SetExpanding(bool value)override;
					int								CalculateTotalVisibleNodes()override;

					int								GetChildCount()override;
					INodeProvider*					GetParent()override;
					INodeProvider*					RequestChild(int index)override;
					void							ReleaseChild(INodeProvider* node)override;
				};

				class NodeRootProviderBase : public virtual INodeRootProvider, protected virtual INodeProviderCallback, public Description<NodeRootProviderBase>
				{
					collections::List<INodeProviderCallback*>			callbacks;
				protected:
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
				public:
					NodeRootProviderBase();
					~NodeRootProviderBase();
					
					bool							CanGetNodeByVisibleIndex()override;
					INodeProvider*					GetNodeByVisibleIndex(int index)override;
					bool							AttachCallback(INodeProviderCallback* value)override;
					bool							DetachCallback(INodeProviderCallback* value)override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};

				class MemoryNodeRootProvider
					: public MemoryNodeProvider
					, public NodeRootProviderBase
					, public Description<MemoryNodeRootProvider>
				{
				protected:
					INodeProviderCallback*			GetCallbackProxyInternal()override;
				public:
					MemoryNodeRootProvider();
					~MemoryNodeRootProvider();

					INodeProvider*					GetRootNode()override;
				};
			}

/***********************************************************************
GuiVirtualTreeListControl
***********************************************************************/

			class GuiVirtualTreeListControl : public GuiSelectableListControl, public Description<GuiVirtualTreeListControl>
			{
			protected:
				tree::NodeItemProvider*				nodeItemProvider;
				tree::INodeItemView*				nodeItemView;
				Ptr<tree::INodeItemStyleProvider>	nodeStyleProvider;
			public:
				GuiVirtualTreeListControl(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider);
				~GuiVirtualTreeListControl();

				tree::INodeItemView*				GetNodeItemView();
				tree::INodeRootProvider*			GetNodeRootProvider();
				tree::INodeItemStyleProvider*		GetNodeStyleProvider();
				Ptr<tree::INodeItemStyleProvider>	SetNodeStyleProvider(Ptr<tree::INodeItemStyleProvider> styleProvider);
			};

/***********************************************************************
TreeView
***********************************************************************/

			namespace tree
			{
				class ITreeViewItemView : public virtual INodeItemPrimaryTextView, public Description<ITreeViewItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual Ptr<GuiImageData>		GetNodeImage(INodeProvider* node)=0;
					virtual WString					GetNodeText(INodeProvider* node)=0;
				};

				class TreeViewItem : public Object, public Description<TreeViewItem>
				{
				public:
					Ptr<GuiImageData>				image;
					WString							text;

					TreeViewItem();
					TreeViewItem(const Ptr<GuiImageData>& _image, const WString& _text);
				};

				class TreeViewItemRootProvider
					: public MemoryNodeRootProvider
					, protected virtual ITreeViewItemView
					, public Description<TreeViewItemRootProvider>
				{
				protected:

					WString							GetPrimaryTextViewText(INodeProvider* node)override;
					Ptr<GuiImageData>				GetNodeImage(INodeProvider* node)override;
					WString							GetNodeText(INodeProvider* node)override;
				public:
					TreeViewItemRootProvider();
					~TreeViewItemRootProvider();

					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};
			}
			
			class GuiTreeView : public GuiVirtualTreeListControl, public Description<GuiTreeView>
			{
			public:
				class IStyleProvider : public virtual GuiVirtualTreeListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()=0;
					virtual Color										GetTextColor()=0;
				};
			protected:
				IStyleProvider*								styleProvider;
				Ptr<tree::TreeViewItemRootProvider>			nodes;
			public:
				GuiTreeView(IStyleProvider* _styleProvider, tree::INodeRootProvider* _nodeRootProvider=0);
				~GuiTreeView();

				IStyleProvider*								GetTreeViewStyleProvider();
				Ptr<tree::TreeViewItemRootProvider>			Nodes();
			};

			namespace tree
			{
				class TreeViewNodeItemStyleProvider
					: public Object
					, public virtual INodeItemStyleProvider
					, protected virtual INodeProviderCallback
					, public Description<TreeViewNodeItemStyleProvider>
				{
				protected:
#pragma warning(push)
#pragma warning(disable:4250)
					class ItemController : public list::ItemStyleControllerBase, public virtual INodeItemStyleController
					{
					protected:
						TreeViewNodeItemStyleProvider*		styleProvider;
						GuiSelectableButton*				backgroundButton;
						GuiSelectableButton*				expandingButton;
						compositions::GuiTableComposition*	table;
						elements::GuiImageFrameElement*		image;
						elements::GuiSolidLabelElement*		text;

						void								SwitchNodeExpanding();
						void								OnBackgroundButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						ItemController(TreeViewNodeItemStyleProvider* _styleProvider);

						INodeItemStyleProvider*				GetNodeStyleProvider()override;
						void								Install(INodeProvider* node);

						bool								GetSelected();
						void								SetSelected(bool value);
						void								UpdateExpandingButton(INodeProvider* associatedNode);
					};
#pragma warning(pop)

					GuiTreeView*							treeControl;
					GuiListControl::IItemStyleProvider*		bindedItemStyleProvider;
					ITreeViewItemView*						treeViewItemView;

				protected:
					ItemController*							GetRelatedController(INodeProvider* node);
					void									UpdateExpandingButton(INodeProvider* node);
					void									OnAttached(INodeRootProvider* provider)override;
					void									OnBeforeItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void									OnAfterItemModified(INodeProvider* parentNode, int start, int count, int newCount)override;
					void									OnItemExpanded(INodeProvider* node)override;
					void									OnItemCollapsed(INodeProvider* node)override;
				public:
					TreeViewNodeItemStyleProvider();
					~TreeViewNodeItemStyleProvider();

					void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)override;
					GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()override;
					void									AttachListControl(GuiListControl* value)override;
					void									DetachListControl()override;
					int										GetItemStyleId(INodeProvider* node)override;
					INodeItemStyleController*				CreateItemStyle(int styleId)override;
					void									DestroyItemStyle(INodeItemStyleController* style)override;
					void									Install(INodeItemStyleController* style, INodeProvider* node)override;
					void									SetStyleSelected(INodeItemStyleController* style, bool value)override;
				};
			}
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUICOMBOCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ComboBox Base
***********************************************************************/

			class GuiComboBoxBase : public GuiButton, public Description<GuiComboBoxBase>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void							ShowPopup()=0;
					virtual void							SelectItem()=0;
				};

				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void							SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void							OnClicked()=0;
					virtual void							OnPopupOpened()=0;
					virtual void							OnPopupClosed()=0;
					virtual void							OnItemSelected()=0;
					virtual GuiControl::IStyleController*	CreatePopupStyle()=0;
				};
			protected:

				class CommandExecutor : public Object, public virtual ICommandExecutor
				{
				protected:
					GuiComboBoxBase*						combo;

				public:
					CommandExecutor(GuiComboBoxBase* _combo);
					~CommandExecutor();

					void									ShowPopup()override;
					void									SelectItem()override;
				};

				Ptr<CommandExecutor>						commandExecutor;
				IStyleController*							styleController;
				GuiPopup*									popup;

				virtual void								SelectItem();
				void										OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnPopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnPopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxBase(IStyleController* _styleController);
				~GuiComboBoxBase();

				compositions::GuiNotifyEvent				PopupOpened;
				compositions::GuiNotifyEvent				PopupClosed;
				compositions::GuiNotifyEvent				ItemSelecting;
				compositions::GuiNotifyEvent				ItemSelected;

				void										ShowPopup();
				GuiPopup*									GetPopup();
			};

/***********************************************************************
ComboBox with GuiListControl
***********************************************************************/

			class GuiComboBoxListControl : public GuiComboBoxBase, public Description<GuiComboBoxListControl>
			{
			protected:
				GuiSelectableListControl*					containedListControl;
				GuiListControl::IItemPrimaryTextView*		primaryTextView;

				virtual void								DisplaySelectedContent(int itemIndex);
				void										OnListControlSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxListControl(IStyleController* _styleController, GuiSelectableListControl* _containedListControl);
				~GuiComboBoxListControl();

				compositions::GuiNotifyEvent				SelectedIndexChanged;
				
				void										SetFont(const FontProperties& value)override;
				GuiSelectableListControl*					GetContainedListControl();

				int											GetSelectedIndex();
				void										SetSelectedIndex(int value);
				GuiListControl::IItemProvider*				GetItemProvider();
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUICONTAINERCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
/***********************************************************************
Tab Control
***********************************************************************/

			class GuiTab;

			class GuiTabPage : public Object, public Description<GuiTabPage>
			{
				friend class GuiTab;
				friend class Ptr<GuiTabPage>;
			protected:
				GuiControl*										container;
				GuiTab*											owner;
				WString											text;
				
				GuiTabPage();
				~GuiTabPage();

				bool											AssociateTab(GuiTab* _owner, GuiControl::IStyleController* _styleController);
			public:
				compositions::GuiNotifyEvent					TextChanged;

				GuiControl*										GetContainer();
				GuiTab*											GetOwnerTab();
				const WString&									GetText();
				void											SetText(const WString& value);
				bool											GetSelected();
			};

			class GuiTab : public GuiControl, public Description<GuiTab>
			{
				friend class GuiTabPage;
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void								ShowTab(int index)=0;
				};

				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void								SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void								InsertTab(int index)=0;
					virtual void								SetTabText(int index, const WString& value)=0;
					virtual void								RemoveTab(int index)=0;
					virtual void								MoveTab(int oldIndex, int newIndex)=0;
					virtual void								SetSelectedTab(int index)=0;
					virtual GuiControl::IStyleController*		CreateTabPageStyleController()=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiTab*										tab;
				public:
					CommandExecutor(GuiTab* _tab);
					~CommandExecutor();

					void										ShowTab(int index)override;
				};

				Ptr<CommandExecutor>							commandExecutor;
				IStyleController*								styleController;
				collections::List<GuiTabPage*>					tabPages;
				GuiTabPage*										selectedPage;
			public:
				GuiTab(IStyleController* _styleController);
				~GuiTab();

				compositions::GuiNotifyEvent					SelectedPageChanged;

				GuiTabPage*										CreatePage(int index=-1);
				bool											CreatePage(GuiTabPage* page, int index=-1);
				bool											RemovePage(GuiTabPage* value);
				bool											MovePage(GuiTabPage* page, int newIndex);
				const collections::IReadonlyList<GuiTabPage*>&	GetPages();

				GuiTabPage*										GetSelectedPage();
				bool											SetSelectedPage(GuiTabPage* value);
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\EXTENDEDCONTROLS\GUIMENUCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Menu Service
***********************************************************************/

			class GuiMenu;

			class IGuiMenuService : public virtual IDescriptable, public Description<IGuiMenuService>
			{
			public:
				static const wchar_t* const				Identifier;

				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				GuiMenu*								openingMenu;
			public:
				IGuiMenuService();

				virtual IGuiMenuService*				GetParent()=0;
				virtual Direction						GetPreferredDirection()=0;
				virtual bool							IsActiveState()=0;

				virtual void							MenuItemExecuted();
				virtual GuiMenu*						GetOpeningMenu();
				virtual void							MenuOpened(GuiMenu* menu);
				virtual void							MenuClosed(GuiMenu* menu);
			};

/***********************************************************************
Menu
***********************************************************************/

			class GuiMenu : public GuiPopup, private IGuiMenuService, public Description<GuiMenu>
			{
			private:
				IGuiMenuService*						parentMenuService;

				IGuiMenuService*						GetParent();
				Direction								GetPreferredDirection();
				bool									IsActiveState();
			protected:
				GuiControl*								owner;

				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
				void									OnWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenu(GuiControl::IStyleController* _styleController, GuiControl* _owner);
				~GuiMenu();

				void									UpdateMenuService();
				IDescriptable*							QueryService(const WString& identifier)override;
			};

			class GuiMenuBar : public GuiControl, private IGuiMenuService, public Description<GuiMenuBar>
			{
			private:
				IGuiMenuService*						GetParent();
				Direction								GetPreferredDirection();
				bool									IsActiveState();
			public:
				GuiMenuBar(GuiControl::IStyleController* _styleController);
				~GuiMenuBar();
				
				IDescriptable*							QueryService(const WString& identifier)override;
			};

/***********************************************************************
MenuButton
***********************************************************************/

			class GuiMenuButton : public GuiButton, public Description<GuiMenuButton>
			{
			public:
				class IStyleController : public GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual GuiMenu::IStyleController*	CreateSubMenuStyleController()=0;
					virtual void						SetSubMenuExisting(bool value)=0;
					virtual void						SetSubMenuOpening(bool value)=0;
				};
			protected:
				IStyleController*						styleController;
				GuiMenu*								subMenu;
				Size									preferredMenuClientSize;
				IGuiMenuService*						ownerMenuService;

				void									OpenSubMenuInternal();
				void									OnParentLineChanged()override;
				void									OnSubMenuWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnSubMenuWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenuButton(IStyleController* _styleController);
				~GuiMenuButton();

				compositions::GuiNotifyEvent			SubMenuOpeningChanged;

				bool									IsSubMenuExists();
				GuiMenu*								GetSubMenu();
				void									CreateSubMenu(GuiMenu::IStyleController* subMenuStyleController=0);
				void									DestroySubMenu();

				bool									GetSubMenuOpening();
				void									SetSubMenuOpening(bool value);

				Size									GetPreferredMenuClientSize();
				void									SetPreferredMenuClientSize(Size value);
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\GUIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION
#define VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiApplication : public Object, private INativeControllerListener
			{
				friend void GuiApplicationInitialize();
				friend class GuiWindow;
				friend class Ptr<GuiApplication>;
			private:
				void											LeftButtonDown(Point position)override;
				void											LeftButtonUp(Point position)override;
				void											RightButtonDown(Point position)override;
				void											RightButtonUp(Point position)override;
			protected:
				GuiWindow*										mainWindow;
				collections::List<GuiWindow*>					windows;

				GuiApplication();
				~GuiApplication();

				void											RegisterWindow(GuiWindow* window);
				void											UnregisterWindow(GuiWindow* window);
				void											OnMouseDown(Point location);
			public:
				void											Run(GuiWindow* _mainWindow);
				const collections::IReadonlyList<GuiWindow*>&	GetWindows();
				GuiWindow*										GetWindow(Point location);

				bool											IsInMainThread();
				void											InvokeInMainThread(INativeAsyncService::AsyncTaskProc* proc, void* argument);
				bool											InvokeInMainThreadAndWait(INativeAsyncService::AsyncTaskProc* proc, void* argument, int milliseconds=-1);
				void											InvokeInMainThread(const Func<void()>& proc);
				bool											InvokeInMainThreadAndWait(const Func<void()>& proc, int milliseconds=-1);

				template<typename T>
				void InvokeLambdaInMainThread(const T& proc)
				{
					InvokeInMainThread(Func<void()>(proc));
				}
				
				template<typename T>
				bool InvokeLambdaInMainThreadAndWait(const T& proc, int milliseconds=-1)
				{
					return InvokeInMainThreadAndWait(Func<void()>(proc));
				}
			};

			extern GuiApplication*								GetApplication();
		}
	}
}

extern void GuiApplicationMain();

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\GUITEXTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Operations
***********************************************************************/

			class GuiTextBoxCommonInterface;

			class GuiTextElementOperator : public Object, public Description<GuiTextElementOperator>
			{
			public:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual TextPos							GetLeftWord(TextPos pos)=0;
					virtual TextPos							GetRightWord(TextPos pos)=0;
					virtual void							GetWord(TextPos pos, TextPos& begin, TextPos& end)=0;
					virtual int								GetPageRows()=0;
					virtual bool							BeforeModify(TextPos& start, TextPos& end, const WString& originalText, WString& inputText)=0;
					virtual void							AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
					virtual void							ScrollToView(Point point)=0;
					virtual int								GetTextMargin()=0;
				};

				class DefaultCallback : public Object, public ICallback, public Description<DefaultCallback>
				{
				protected:
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiGraphicsComposition*	textComposition;
					bool									readonly;
				public:
					DefaultCallback(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition);
					~DefaultCallback();

					TextPos									GetLeftWord(TextPos pos)override;
					TextPos									GetRightWord(TextPos pos)override;
					void									GetWord(TextPos pos, TextPos& begin, TextPos& end)override;
					int										GetPageRows()override;
					bool									BeforeModify(TextPos& start, TextPos& end, const WString& originalText, WString& inputText)override;
				};
			protected:
				elements::GuiColorizedTextElement*			textElement;
				compositions::GuiGraphicsComposition*		textComposition;
				GuiControl*									textControl;
				GuiTextBoxCommonInterface*					textBoxCommonInterface;
				ICallback*									callback;
				bool										dragging;

				void										UpdateCaretPoint();
				void										Move(TextPos pos, bool shift);
				void										Modify(TextPos start, TextPos end, const WString& input);
				void										ProcessKey(int code, bool shift, bool ctrl);
					
				void										OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void										OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void										OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);
			public:
				GuiTextElementOperator();
				~GuiTextElementOperator();

				void										Install(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition, GuiControl* _textControl);
				ICallback*									GetCallback();
				void										SetCallback(ICallback* value);
				GuiTextBoxCommonInterface*					GetTextBoxCommonInterface();
				void										SetTextBoxCommonInterface(GuiTextBoxCommonInterface* value);

				elements::GuiColorizedTextElement*			GetTextElement();
				compositions::GuiGraphicsComposition*		GetTextComposition();
				TextPos										GetNearestTextPos(Point point);
				void										Select(TextPos begin, TextPos end);
				WString										GetSelectionText();
				void										SetSelectionText(const WString& value);

				bool										CanCut();
				bool										CanCopy();
				bool										CanPaste();
				void										SelectAll();
				bool										Cut();
				bool										Copy();
				bool										Paste();
			};

			class GuiTextBoxCommonInterface : public Description<GuiTextBoxCommonInterface>
			{
				friend class GuiTextElementOperator;
			protected:
				GuiTextElementOperator*						textElementOperator;
				GuiControl*									textControl;

				void										RaiseTextChanged();
				void										RaiseSelectionChanged();
				void										InitializeCommonInterface(GuiControl* _textControl, GuiTextElementOperator* _textElementOperator);
			public:
				GuiTextBoxCommonInterface();
				~GuiTextBoxCommonInterface();

				compositions::GuiNotifyEvent				SelectionChanged;

				compositions::GuiGraphicsComposition*		GetTextComposition();

				bool										CanCut();
				bool										CanCopy();
				bool										CanPaste();
				void										SelectAll();
				bool										Cut();
				bool										Copy();
				bool										Paste();
				
				WString										GetRowText(int row);
				WString										GetFragmentText(TextPos start, TextPos end);
				int											GetRowWidth(int row);
				int											GetRowHeight();
				int											GetMaxWidth();
				int											GetMaxHeight();
				TextPos										GetTextPosFromPoint(Point point);
				Point										GetPointFromTextPos(TextPos pos);
				Rect										GetRectFromTextPos(TextPos pos);
				TextPos										GetNearestTextPos(Point point);

				TextPos										GetCaretBegin();
				TextPos										GetCaretEnd();
				TextPos										GetCaretSmall();
				TextPos										GetCaretLarge();
				void										Select(TextPos begin, TextPos end);

				WString										GetSelectionText();
				void										SetSelectionText(const WString& value);
			};

/***********************************************************************
TextBox
***********************************************************************/

			class GuiMultilineTextBox : public GuiScrollView, public GuiTextBoxCommonInterface, public Description<GuiMultilineTextBox>
			{
			public:
				static const int							TextMargin=3;

				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiBoundsComposition*		textComposition;
					GuiTextElementOperator					textElementOperator;
					Ptr<GuiTextElementOperator::ICallback>	defaultCallback;

				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					GuiTextElementOperator*					GetTextElementOperator();
					void									SetViewPosition(Point value);
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;

					WString									GetText();
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};

				class TextElementOperatorCallback : public GuiTextElementOperator::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiMultilineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiMultilineTextBox* _textControl);

					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					int										GetTextMargin()override;
				};

			protected:
				StyleController*							styleController;

				void										CalculateViewAndSetScroll();
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				Size										QueryFullSize()override;
				void										UpdateView(Rect viewBounds)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiMultilineTextBox(GuiMultilineTextBox::IStyleProvider* styleProvider);
				~GuiMultilineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
			};

			class GuiSinglelineTextBox : public GuiControl, public GuiTextBoxCommonInterface, public Description<GuiSinglelineTextBox>
			{
			public:
				static const int							TextMargin=3;

				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* background)=0;
				};

				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>						styleProvider;
					compositions::GuiBoundsComposition*		boundsComposition;
					compositions::GuiGraphicsComposition*	containerComposition;

					GuiSinglelineTextBox*					textBox;
					elements::GuiColorizedTextElement*		textElement;
					compositions::GuiTableComposition*		textCompositionTable;
					compositions::GuiCellComposition*		textComposition;
					GuiTextElementOperator					textElementOperator;
					Ptr<GuiTextElementOperator::ICallback>	defaultCallback;

				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetTextBox(GuiSinglelineTextBox* value);
					void									RearrangeTextElement();
					compositions::GuiBoundsComposition*		GetBoundsComposition();
					compositions::GuiGraphicsComposition*	GetContainerComposition();
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);

					WString									GetText();
					void									SetText(const WString& value);
					void									SetFont(const FontProperties& value);
					void									SetVisuallyEnabled(bool value);

					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					GuiTextElementOperator*					GetTextElementOperator();
					void									SetViewPosition(Point value);
				};

				class TextElementOperatorCallback : public GuiTextElementOperator::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiSinglelineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiSinglelineTextBox* _textControl);

					bool									BeforeModify(TextPos& start, TextPos& end, const WString& originalText, WString& inputText)override;
					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					int										GetTextMargin()override;
				};
			protected:
				StyleController*							styleController;
				
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiSinglelineTextBox(GuiSinglelineTextBox::IStyleProvider* styleProvider);
				~GuiSinglelineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\STYLES\GUICOMMONSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMMONSTYLES
#define VCZH_PRESENTATION_CONTROLS_GUICOMMONSTYLES


namespace vl
{
	namespace presentation
	{
		namespace common_styles
		{

/***********************************************************************
Scrolls
***********************************************************************/

			class CommonScrollStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<CommonScrollStyle>
			{
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction											direction;
				controls::GuiScroll::ICommandExecutor*				commandExecutor;
				controls::GuiButton*								decreaseButton;
				controls::GuiButton*								increaseButton;
				controls::GuiButton*								handleButton;
				compositions::GuiPartialViewComposition*			handleComposition;
				compositions::GuiBoundsComposition*					boundsComposition;

				int													totalSize;
				int													pageSize;
				int													position;
				Point												draggingStartLocation;
				bool												draggingHandle;

				void												UpdateHandle();
				void												OnDecreaseButtonClicked(compositions::GuiGraphicsComposition* sender,compositions::GuiEventArgs& arguments);
				void												OnIncreaseButtonClicked(compositions::GuiGraphicsComposition* sender,compositions::GuiEventArgs& arguments);
				void												OnHandleMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseMove(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseUp(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);;
				void												OnBigMoveMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);

				virtual controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction)=0;
				virtual controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction)=0;
				virtual controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)=0;
				virtual void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)=0;
				void												BuildStyle(int defaultSize, int arrowSize);
			public:
				CommonScrollStyle(Direction _direction);
				~CommonScrollStyle();

				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*				GetContainerComposition()override;
				void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void												SetText(const WString& value)override;
				void												SetFont(const FontProperties& value)override;
				void												SetVisuallyEnabled(bool value)override;
				void												SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void												SetTotalSize(int value)override;
				void												SetPageSize(int value)override;
				void												SetPosition(int value)override;
			};

			class CommonTrackStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<CommonTrackStyle>
			{
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction											direction;
				controls::GuiScroll::ICommandExecutor*				commandExecutor;
				compositions::GuiBoundsComposition*					boundsComposition;
				controls::GuiButton*								handleButton;
				compositions::GuiTableComposition*					handleComposition;

				int													totalSize;
				int													pageSize;
				int													position;
				Point												draggingStartLocation;
				bool												draggingHandle;

				void												UpdateHandle();
				void												OnHandleMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseMove(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseUp(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				
				virtual controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)=0;
				virtual void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)=0;
				virtual void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)=0;
				void												BuildStyle(int trackThickness, int trackPadding, int handleLong, int handleShort);
			public:
				CommonTrackStyle(Direction _direction);
				~CommonTrackStyle();

				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*				GetContainerComposition()override;
				void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void												SetText(const WString& value)override;
				void												SetFont(const FontProperties& value)override;
				void												SetVisuallyEnabled(bool value)override;
				void												SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void												SetTotalSize(int value)override;
				void												SetPageSize(int value)override;
				void												SetPosition(int value)override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\CONTROLS\STYLES\GUIWIN7STYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
	GuiControl::IStyleController
		Win7EmptyStyle
		Win7WindowStyle
		Win7MenuStyle
		Win7MenuBarStyle
		Win7MenuSplitterStyle
		Win7GroupBoxStyle
		Win7TabStyle
	GuiSelectableButton::IStyleController
		Win7ButtonStyle(vertical|horizontal)
		Win7ToolstripButtonStyle
		Win7CheckBoxStyle(check|radio)
		Win7SelectableItemStyle
		Win7TabPageHeaderStyle
		Win7ListViewColumnDropDownStyle
		Win7ListViewColumnHeaderStyle
		Win7TreeViewExpandingButtonStyle
	GuiComboBoxBase::IStyleController
		Win7DropDownComboBoxStyle
	GuiMenuButton::IStyleController
		Win7MenuBarButtonStyle
		Win7MenuItemButtonStyle
	GuiScroll::IStyleController
		Win7ScrollStyle
		Win7TrackStyle
	GuiScrollView::IStyleProvider
		Win7ScrollViewProvider
		Win7MultilineTextBoxProvider
	GuiSinglelineTextBox::IStyleProvider
		Win7SinglelineTextBoxProvider
	list::TextItemStyleProvider::ITextItemStyleProvider
		Win7TextListProvider
		Win7CheckTextListProvider
		Win7RadioTextListProvider
	GuiListView::IStyleProvider
		Win7ListViewProvider
	GuiTreeView::IStyleProvider
		Win7TreeViewProvider
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES
#define VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Button Configuration
***********************************************************************/
			
			struct Win7ButtonColors
			{
				Color										borderColor;
				Color										backgroundColor;
				Color										g1;
				Color										g2;
				Color										g3;
				Color										g4;
				Color										textColor;
				Color										bulletLight;
				Color										bulletDark;

				bool operator==(const Win7ButtonColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor &&
						g1 == colors.g1 &&
						g2 == colors.g2 &&
						g3 == colors.g3 &&
						g4 == colors.g4 &&
						textColor == colors.textColor &&
						bulletLight == colors.bulletLight &&
						bulletDark == colors.bulletDark;
				}

				bool operator!=(const Win7ButtonColors& colors)
				{
					return !(*this==colors);
				}

				void										SetAlphaWithoutText(unsigned char a);

				static Win7ButtonColors						Blend(const Win7ButtonColors& c1, const Win7ButtonColors& c2, int ratio, int total);

				static Win7ButtonColors						ButtonNormal();
				static Win7ButtonColors						ButtonActive();
				static Win7ButtonColors						ButtonPressed();
				static Win7ButtonColors						ButtonDisabled();
				
				static Win7ButtonColors						ItemNormal();
				static Win7ButtonColors						ItemActive();
				static Win7ButtonColors						ItemSelected();
				static Win7ButtonColors						ItemDisabled();
				
				static Win7ButtonColors						CheckedNormal(bool selected);
				static Win7ButtonColors						CheckedActive(bool selected);
				static Win7ButtonColors						CheckedPressed(bool selected);
				static Win7ButtonColors						CheckedDisabled(bool selected);

				static Win7ButtonColors						ToolstripButtonNormal();
				static Win7ButtonColors						ToolstripButtonActive();
				static Win7ButtonColors						ToolstripButtonPressed();
				static Win7ButtonColors						ToolstripButtonDisabled();

				static Win7ButtonColors						MenuBarButtonNormal();
				static Win7ButtonColors						MenuBarButtonActive();
				static Win7ButtonColors						MenuBarButtonPressed();
				static Win7ButtonColors						MenuBarButtonDisabled();

				static Win7ButtonColors						MenuItemButtonNormal();
				static Win7ButtonColors						MenuItemButtonNormalActive();
				static Win7ButtonColors						MenuItemButtonDisabled();
				static Win7ButtonColors						MenuItemButtonDisabledActive();

				static Win7ButtonColors						TabPageHeaderNormal();
				static Win7ButtonColors						TabPageHeaderActive();
				static Win7ButtonColors						TabPageHeaderSelected();
			};

			struct Win7ButtonElements
			{
				elements::GuiSolidBorderElement*			rectBorderElement;
				elements::GuiRoundBorderElement*			roundBorderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		topGradientElement;
				elements::GuiGradientBackgroundElement*		bottomGradientElement;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			backgroundComposition;
				compositions::GuiTableComposition*			gradientComposition;

				static Win7ButtonElements					Create(bool verticalGradient, bool roundBorder, Alignment::Type horizontal=Alignment::Center, Alignment::Type vertical=Alignment::Center);
				void										Apply(const Win7ButtonColors& colors);
			};

			struct Win7CheckedButtonElements
			{
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		outerGradientElement;
				elements::GuiGradientBackgroundElement*		innerGradientElement;
				elements::GuiSolidLabelElement*				textElement;
				elements::GuiSolidLabelElement*				bulletTextElement;
				elements::GuiSolidBackgroundElement*		bulletBackgroundElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win7CheckedButtonElements			Create(elements::ElementShape::Type shape, bool backgroundVisible);
				void										Apply(const Win7ButtonColors& colors);
			};

			struct Win7MenuItemButtonElements
			{
				elements::GuiRoundBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::Gui3DSplitterElement*				splitterElement;
				compositions::GuiCellComposition*			splitterComposition;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				elements::GuiSolidLabelElement*				subMenuTextElement;
				compositions::GuiGraphicsComposition*		subMenuTextComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win7MenuItemButtonElements			Create();
				void										Apply(const Win7ButtonColors& colors);
				void										SetActive(bool value);
				void										SetSubMenuExisting(bool value);
			};

			struct Win7TextBoxColors
			{
				Color										borderColor;
				Color										backgroundColor;

				bool operator==(const Win7TextBoxColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor;
				}

				bool operator!=(const Win7TextBoxColors& colors)
				{
					return !(*this==colors);
				}

				static Win7TextBoxColors					Blend(const Win7TextBoxColors& c1, const Win7TextBoxColors& c2, int ratio, int total);

				static Win7TextBoxColors					Normal();
				static Win7TextBoxColors					Active();
				static Win7TextBoxColors					Focused();
				static Win7TextBoxColors					Disabled();
			};

/***********************************************************************
Helper Functions
***********************************************************************/
			
			extern int										Win7GetColorAnimationLength();
			extern Color									Win7GetSystemWindowColor();
			extern Color									Win7GetSystemTabContentColor();
			extern Color									Win7GetSystemBorderColor();
			extern Color									Win7GetSystemTextColor(bool enabled);
			extern void										Win7SetFont(elements::GuiSolidLabelElement* element, compositions::GuiBoundsComposition* composition, const FontProperties& fontProperties);
			extern void										Win7CreateSolidLabelElement(elements::GuiSolidLabelElement*& element, compositions::GuiBoundsComposition*& composition, Alignment::Type horizontal, Alignment::Type vertical);

/***********************************************************************
Animation
***********************************************************************/

#define DEFINE_TRANSFERRING_ANIMATION(TSTATE, TSTYLECONTROLLER)\
				class TransferringAnimation : public compositions::GuiTimeBasedAnimation\
				{\
				protected:\
					TSTATE									colorBegin;\
					TSTATE									colorEnd;\
					TSTATE									colorCurrent;\
					TSTYLECONTROLLER*						style;\
					bool									stopped;\
					bool									enableAnimation;\
				public:\
					TransferringAnimation(TSTYLECONTROLLER* _style, const TSTATE& begin);\
					void									Play(int currentPosition, int totalLength)override;\
					void									Stop()override;\
					bool									GetEnableAnimation();\
					void									SetEnableAnimation(bool value);\
					void									Transfer(const TSTATE& end);\
				};\

/***********************************************************************
Container
***********************************************************************/

			class Win7EmptyStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7EmptyStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7EmptyStyle(Color color);
				~Win7EmptyStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7WindowStyle : public Win7EmptyStyle, public Description<Win7WindowStyle>
			{
			public:
				Win7WindowStyle();
				~Win7WindowStyle();
			};

			class Win7MenuStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win7MenuStyle();
				~Win7MenuStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7MenuBarStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuBarStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7MenuBarStyle();
				~Win7MenuBarStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7GroupBoxStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7GroupBoxStyle>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Color, Win7GroupBoxStyle)

				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			sinkBorderComposition;
				compositions::GuiBoundsComposition*			raisedBorderComposition;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			textBackgroundComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				elements::GuiSolidLabelElement*				textElement;
				Ptr<TransferringAnimation>					transferringAnimation;

				void										SetMargins(int fontSize);
			public:
				Win7GroupBoxStyle();
				~Win7GroupBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7TabStyle : public Object, public virtual controls::GuiTab::IStyleController, public Description<Win7TabStyle>
			{
			protected:
				compositions::GuiTableComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				compositions::GuiStackComposition*			tabHeaderComposition;
				compositions::GuiBoundsComposition*			tabContentTopLineComposition;
				FontProperties								headerFont;
				controls::GuiTab::ICommandExecutor*			commandExecutor;

				Ptr<controls::GuiSelectableButton::MutexGroupController>	headerController;
				collections::List<controls::GuiSelectableButton*>			headerButtons;

				void										OnHeaderButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										UpdateHeaderZOrder();
			public:
				Win7TabStyle();
				~Win7TabStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;

				void										SetCommandExecutor(controls::GuiTab::ICommandExecutor* value)override;
				void										InsertTab(int index)override;
				void										SetTabText(int index, const WString& value)override;
				void										RemoveTab(int index)override;
				void										MoveTab(int oldIndex, int newIndex)override;
				void										SetSelectedTab(int index)override;
				controls::GuiControl::IStyleController*		CreateTabPageStyleController()override;
			};

/***********************************************************************
Button
***********************************************************************/

			class Win7ButtonStyleBase : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ButtonStyleBase>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7ButtonStyleBase)

				Win7ButtonElements							elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;
				bool										transparentWhenInactive;
				bool										transparentWhenDisabled;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)=0;
			public:
				Win7ButtonStyleBase(bool verticalGradient, bool roundBorder, const Win7ButtonColors& initialColor, Alignment::Type horizontal, Alignment::Type vertical);
				~Win7ButtonStyleBase();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;

				bool										GetTransparentWhenInactive();
				void										SetTransparentWhenInactive(bool value);
				bool										GetTransparentWhenDisabled();
				void										SetTransparentWhenDisabled(bool value);
				bool										GetAutoSizeForText();
				void										SetAutoSizeForText(bool value);
			};

			class Win7ButtonStyle : public Win7ButtonStyleBase, public Description<Win7ButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7ButtonStyle(bool verticalGradient=true);
				~Win7ButtonStyle();
			};

			class Win7ToolstripButtonStyle : public Win7ButtonStyleBase, public Description<Win7ToolstripButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7ToolstripButtonStyle(bool transparent);
				~Win7ToolstripButtonStyle();
			};

			class Win7CheckBoxStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7CheckBoxStyle>
			{
			public:
				enum BulletStyle
				{
					CheckBox,
					RadioButton,
				};
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7CheckBoxStyle)

				Win7CheckedButtonElements					elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7CheckBoxStyle(BulletStyle bulletStyle, bool backgroundVisible=true);
				~Win7CheckBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

/***********************************************************************
Misc Buttons
***********************************************************************/

			class Win7SelectableItemStyle : public Win7ButtonStyleBase, public Description<Win7SelectableItemStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7SelectableItemStyle();
				~Win7SelectableItemStyle();
			};

			class Win7TabPageHeaderStyle : public Win7ButtonStyleBase, public Description<Win7TabPageHeaderStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7TabPageHeaderStyle();
				~Win7TabPageHeaderStyle();

				void										SetFont(const FontProperties& value)override;
			};

			class Win7ListViewColumnDropDownStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ListViewColumnDropDownStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			leftBorderComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			gradientComposition;
				compositions::GuiBoundsComposition*			textComposition;

				elements::GuiGradientBackgroundElement*		leftBorderElement;
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::GuiSolidLabelElement*				textElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7ListViewColumnDropDownStyle();
				~Win7ListViewColumnDropDownStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7ListViewColumnHeaderStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ListViewColumnHeaderStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			rightBorderComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			gradientComposition;
				compositions::GuiBoundsComposition*			textComposition;

				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		rightBorderElement;
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::GuiSolidLabelElement*				textElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7ListViewColumnHeaderStyle();
				~Win7ListViewColumnHeaderStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7TreeViewExpandingButtonStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7TreeViewExpandingButtonStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				elements::GuiPolygonElement*				polygonElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7TreeViewExpandingButtonStyle();
				~Win7TreeViewExpandingButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

/***********************************************************************
Menu Button
***********************************************************************/

			class Win7MenuBarButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7MenuBarButtonStyle>
			{
			protected:
				Win7ButtonElements							elements;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isOpening;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool opening);
			public:
				Win7MenuBarButtonStyle();
				~Win7MenuBarButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				controls::GuiMenu::IStyleController*		CreateSubMenuStyleController()override;
				void										SetSubMenuExisting(bool value)override;
				void										SetSubMenuOpening(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7MenuItemButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7MenuItemButtonStyle>
			{
			protected:
				Win7MenuItemButtonElements					elements;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isOpening;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool opening);
			public:
				Win7MenuItemButtonStyle();
				~Win7MenuItemButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				controls::GuiMenu::IStyleController*		CreateSubMenuStyleController()override;
				void										SetSubMenuExisting(bool value)override;
				void										SetSubMenuOpening(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7MenuSplitterStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuSplitterStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7MenuSplitterStyle();
				~Win7MenuSplitterStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

/***********************************************************************
ComboBox
***********************************************************************/
			
#pragma warning(push)
#pragma warning(disable:4250)
			class Win7DropDownComboBoxStyle : public Win7ButtonStyle, public virtual controls::GuiComboBoxBase::IStyleController, public Description<Win7DropDownComboBoxStyle>
			{
			protected:
				controls::GuiComboBoxBase::ICommandExecutor*	commandExecutor;
				compositions::GuiTableComposition*				table;
				compositions::GuiCellComposition*				textComposition;
				compositions::GuiCellComposition*				dropDownComposition;
				elements::GuiSolidLabelElement*					dropDownElement;

				void											TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7DropDownComboBoxStyle();
				~Win7DropDownComboBoxStyle();
				
				compositions::GuiGraphicsComposition*			GetContainerComposition()override;

				void											SetCommandExecutor(controls::GuiComboBoxBase::ICommandExecutor* value)override;
				void											OnClicked()override;
				void											OnPopupOpened()override;
				void											OnPopupClosed()override;
				void											OnItemSelected()override;
				controls::GuiControl::IStyleController*			CreatePopupStyle()override;
			};
#pragma warning(pop)

/***********************************************************************
Scroll
***********************************************************************/

			class Win7ScrollStyle : public common_styles::CommonScrollStyle, public Description<Win7ScrollStyle>
			{
			public:
				static const int							DefaultSize=18;
				static const int							ArrowSize=10;
			protected:
				controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction);
				controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction);
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction);
				void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)override;
			public:
				Win7ScrollStyle(Direction _direction);
				~Win7ScrollStyle();
			};

			class Win7TrackStyle : public common_styles::CommonTrackStyle, public Description<Win7TrackStyle>
			{
			public:
				static const int							TrackThickness=4;
				static const int							TrackPadding=8;
				static const int							HandleLong=21;
				static const int							HandleShort=10;

			protected:
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)override;
				void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)override;
				void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)override;
			public:
				Win7TrackStyle(Direction _direction);
				~Win7TrackStyle();
			};

/***********************************************************************
ScrollView
***********************************************************************/

			class Win7ScrollViewProvider : public Object, public virtual controls::GuiScrollView::IStyleProvider, public Description<Win7ScrollViewProvider>
			{
			public:
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;

				controls::GuiScroll::IStyleController*		CreateHorizontalScrollStyle()override;
				controls::GuiScroll::IStyleController*		CreateVerticalScrollStyle()override;
				int											GetDefaultScrollSize()override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

/***********************************************************************
TextBox
***********************************************************************/

			class Win7TextBoxBackground : public Object, public Description<Win7TextBoxBackground>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7TextBoxColors, Win7TextBoxBackground)
					
				elements::GuiRoundBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				compositions::GuiGraphicsComposition*		focusableComposition;
				bool										isMouseEnter;
				bool										isFocused;
				bool										isVisuallyEnabled;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiControl::IStyleController*		styleController;
				elements::GuiColorizedTextElement*			textElement;

				void										UpdateStyle();
				void										Apply(const Win7TextBoxColors& colors);

				void										OnBoundsMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				Win7TextBoxBackground();
				~Win7TextBoxBackground();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller);
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value);
				void										SetVisuallyEnabled(bool value);
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition);
				void										InitializeTextElement(elements::GuiColorizedTextElement* _textElement);
			};

			class Win7MultilineTextBoxProvider : public Win7ScrollViewProvider, public Description<Win7MultilineTextBoxProvider>
			{
			protected:
				Win7TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win7MultilineTextBoxProvider();
				~Win7MultilineTextBoxProvider();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

			class Win7SinglelineTextBoxProvider : public Object, public virtual controls::GuiSinglelineTextBox::IStyleProvider, public Description<Win7SinglelineTextBoxProvider>
			{
			protected:
				Win7TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win7SinglelineTextBoxProvider();
				~Win7SinglelineTextBoxProvider();

				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

/***********************************************************************
List
***********************************************************************/

			class Win7TextListProvider : public Object, public virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider, public Description<Win7TextListProvider>
			{
			public:
				Win7TextListProvider();
				~Win7TextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()override;
				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

			class Win7CheckTextListProvider : public Win7TextListProvider, public Description<Win7CheckTextListProvider>
			{
			public:
				Win7CheckTextListProvider();
				~Win7CheckTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

			class Win7RadioTextListProvider : public Win7TextListProvider, public Description<Win7RadioTextListProvider>
			{
			public:
				Win7RadioTextListProvider();
				~Win7RadioTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

#pragma warning(push)
#pragma warning(disable:4250)
			class Win7ListViewProvider : public Win7MultilineTextBoxProvider, public virtual controls::GuiListView::IStyleProvider, public Description<Win7ListViewProvider>
			{
			public:
				Win7ListViewProvider();
				~Win7ListViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiSelectableButton::IStyleController*		CreateColumnStyle()override;
				Color													GetPrimaryTextColor()override;
				Color													GetSecondaryTextColor()override;
				Color													GetItemSeparatorColor()override;
			};
			
			class Win7TreeViewProvider : public Win7MultilineTextBoxProvider, public virtual controls::GuiTreeView::IStyleProvider, public Description<Win7TreeViewProvider>
			{
			public:
				Win7TreeViewProvider();
				~Win7TreeViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()override;
				Color													GetTextColor()override;
			};
#pragma warning(pop)
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GACUI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI Header Files and Common Namespaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUI
#define VCZH_PRESENTATION_GACUI



using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;

extern int SetupWindowsGDIRenderer();
extern int SetupWindowsDirect2DRenderer();

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\WINDOWSDIRECT2D\GUIGRAPHICSWINDOWSDIRECT2D.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSDIRECT2D
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSDIRECT2D

#include <D2D1.h>
#include <DWrite.h>
#include <wincodec.h>

namespace vl
{
	namespace presentation
	{
		namespace elements_windows_d2d
		{

/***********************************************************************
Functionality
***********************************************************************/

			class IWindowsDirect2DRenderTarget : public elements::IGuiGraphicsRenderTarget
			{
			public:
				virtual ID2D1RenderTarget*					GetDirect2DRenderTarget()=0;
				virtual ComPtr<ID2D1Bitmap>					GetBitmap(INativeImageFrame* frame)=0;
				virtual void								DestroyBitmapCache(INativeImageFrame* frame)=0;

				virtual ID2D1SolidColorBrush*				CreateDirect2DBrush(Color color)=0;
				virtual void								DestroyDirect2DBrush(Color color)=0;
				virtual ID2D1LinearGradientBrush*			CreateDirect2DLinearBrush(Color c1, Color c2)=0;
				virtual void								DestroyDirect2DLinearBrush(Color c1, Color c2)=0;
			};

			class Direct2DTextFormatPackage
			{
			public:
				ComPtr<IDWriteTextFormat>		textFormat;
				DWRITE_TRIMMING					trimming;
				ComPtr<IDWriteInlineObject>		ellipseInlineObject;
			};

			class IWindowsDirect2DResourceManager : public Interface
			{
			public:
				virtual Direct2DTextFormatPackage*			CreateDirect2DTextFormat(const FontProperties& fontProperties)=0;
				virtual void								DestroyDirect2DTextFormat(const FontProperties& fontProperties)=0;
				virtual Ptr<elements::text::CharMeasurer>	CreateDirect2DCharMeasurer(const FontProperties& fontProperties)=0;
				virtual void								DestroyDirect2DCharMeasurer(const FontProperties& fontProperties)=0;
			};

			extern IWindowsDirect2DResourceManager*			GetWindowsDirect2DResourceManager();
			extern D2D1::ColorF								GetD2DColor(Color color);

/***********************************************************************
OS Supporting
***********************************************************************/

			class IWindowsDirect2DObjectProvider : public Interface
			{
			public:
				virtual ID2D1RenderTarget*					GetNativeWindowDirect2DRenderTarget(INativeWindow* window)=0;
				virtual ID2D1Factory*						GetDirect2DFactory()=0;
				virtual IDWriteFactory*						GetDirectWriteFactory()=0;
				virtual IWindowsDirect2DRenderTarget*		GetBindedRenderTarget(INativeWindow* window)=0;
				virtual void								SetBindedRenderTarget(INativeWindow* window, IWindowsDirect2DRenderTarget* renderTarget)=0;
				virtual IWICImagingFactory*					GetWICImagingFactory()=0;
				virtual IWICBitmapDecoder*					GetWICBitmapDecoder(INativeImage* image)=0;
				virtual IWICBitmap*							GetWICBitmap(INativeImageFrame* frame)=0;
			};

			extern IWindowsDirect2DObjectProvider*			GetWindowsDirect2DObjectProvider();
			extern void										SetWindowsDirect2DObjectProvider(IWindowsDirect2DObjectProvider* provider);
		}
	}
}

extern void RendererMainDirect2D();

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\WINDOWSDIRECT2D\GUIGRAPHICSRENDERERSWINDOWSDIRECT2D.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSDIRECT2D
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSDIRECT2D


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_d2d
		{
			using namespace elements;

#define DEFINE_BRUSH_ELEMENT_RENDERER(TELEMENT, TRENDERER, TBRUSH, TBRUSHPROPERTY)\
				DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, IWindowsDirect2DRenderTarget)\
			protected:\
				TBRUSHPROPERTY			oldColor;\
				TBRUSH*					brush;\
				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);\
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);\
				void					InitializeInternal();\
				void					FinalizeInternal();\
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);\
			public:\
				TRENDERER();\
				void					Render(Rect bounds)override;\
				void					OnElementStateChanged()override;\

/***********************************************************************
Renderers
***********************************************************************/


			class GuiSolidBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiSolidBorderElement, GuiSolidBorderElementRenderer, ID2D1SolidColorBrush, Color)
			};

			class GuiRoundBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiRoundBorderElement, GuiRoundBorderElementRenderer, ID2D1SolidColorBrush, Color)
			};

			class Gui3DBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DBorderElement, Gui3DBorderElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				ID2D1SolidColorBrush*	brush1;
				ID2D1SolidColorBrush*	brush2;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				Gui3DBorderElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DSplitterElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DSplitterElement, Gui3DSplitterElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				ID2D1SolidColorBrush*	brush1;
				ID2D1SolidColorBrush*	brush2;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				Gui3DSplitterElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiSolidBackgroundElement, GuiSolidBackgroundElementRenderer, ID2D1SolidColorBrush, Color)
			};

			class GuiGradientBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				typedef collections::Pair<Color, Color> ColorPair;
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiGradientBackgroundElement, GuiGradientBackgroundElementRenderer, ID2D1LinearGradientBrush, ColorPair)
			};

			class GuiSolidLabelElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidLabelElement, GuiSolidLabelElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color							oldColor;
				FontProperties					oldFont;
				WString							oldText;
				ID2D1SolidColorBrush*			brush;
				Direct2DTextFormatPackage*		textFormat;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					CreateTextFormat(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyTextFormat(IWindowsDirect2DRenderTarget* _renderTarget);
				void					UpdateMinSize();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiSolidLabelElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiImageFrameElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiImageFrameElement, GuiImageFrameElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				ComPtr<ID2D1Bitmap>		bitmap;

				void					UpdateBitmap(IWindowsDirect2DRenderTarget* renderTarget);

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiImageFrameElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiPolygonElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiPolygonElement, GuiPolygonElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color							oldBorderColor;
				Color							oldBackgroundColor;
				ID2D1SolidColorBrush*			borderBrush;
				ID2D1SolidColorBrush*			backgroundBrush;
				collections::Array<Point>		oldPoints;
				ComPtr<ID2D1PathGeometry>		geometry;

				void							CreateGeometry();
				void							DestroyGeometry();
				void							FillGeometry(Point offset);
				void							RecreateResource(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
				void							InitializeInternal();
				void							FinalizeInternal();
				void							RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiPolygonElementRenderer();

				void							Render(Rect bounds)override;
				void							OnElementStateChanged()override;
			};

			class GuiColorizedTextElementRenderer : public Object, public IGuiGraphicsRenderer, protected GuiColorizedTextElement::ICallback
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiColorizedTextElement, GuiColorizedTextElementRenderer, IWindowsDirect2DRenderTarget)

			public:
				struct ColorItemResource
				{
					Color						text;
					ID2D1SolidColorBrush*		textBrush;
					Color						background;
					ID2D1SolidColorBrush*		backgroundBrush;
				};

				struct ColorEntryResource
				{
					ColorItemResource			normal;
					ColorItemResource			selectedFocused;
					ColorItemResource			selectedUnfocused;

					bool						operator==(const ColorEntryResource& value){return false;}
					bool						operator!=(const ColorEntryResource& value){return true;}
				};

				typedef collections::Array<ColorEntryResource>			ColorArray;
			protected:
				FontProperties					oldFont;
				Direct2DTextFormatPackage*		textFormat;
				ColorArray						colors;
				Color							oldCaretColor;
				ID2D1SolidColorBrush*			caretBrush;
				
				void					CreateTextBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyTextBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					CreateCaretBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyCaretBrush(IWindowsDirect2DRenderTarget* _renderTarget);

				void					ColorChanged();
				void					FontChanged();
				text::CharMeasurer*		GetCharMeasurer();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\WINDOWS\GDI\WINGDI.H
***********************************************************************/
/*******************************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::GDI Helper Library

Classes:
  WinRegion				£ºÍ¼ÐÎÇøÓò
  WinTransform			£º×ø±ê±ä»»
  WinBrush				£ºÍ¼ÐÎ»­Ë¢
  WinPen				£ºÍ¼ÐÎ»­±Ê
  WinFont				£º×ÖÌå
  WinDC					£ºÉè±¸ÉÏÏÂÎÄ
  WinControlDC			£º¿Ø¼þDC
  WinImageDC			£ºÍ¼ÐÎDC
  WinProxyDC			£º´úÀíDC
  WinDIB				£ºÉè±¸ÎÞ¹ØÎ»Í¼
  WinMetaFileBuilder	£ºÍ¼ÐÎÔªÎÄ¼þ±à¼­Æ÷
  WinMetaFile			£ºÍ¼ÐÎÔªÎÄ¼þ
  WinBitmap				£ºÎ»Í¼

Comments:
  WinDC::PolyDraw
    Points				£ºµãÊý×é
	Actions				£ºÒ»¸öËµÃ÷µãÊý×éÖÐµãµÄ×÷ÓÃµÄÊý×é£¬¿ÉÒÔÊÇÈçÏÂÄÚÈÝ£º
		PT_MOVETO		£ºÏûºÄ1¸öµãÖ´ÐÐMoveTo
		PT_LINETO		£ºÏûºÄ1¸öµãÖ´ÐÐLineTo
		PT_BEZIERTO		£ºÏûºÄ3¸öµãÍê³ÉBezierÇúÏß
		ÆäÖÐºóÁ½¸öÖµ¿ÉÒÔ¸úPT_CLOSEFIGURE½øÐÐor»ìºÏ£¬ÒÔ±ãÈÃÕâ¸öµã¸ú×îºóÒ»¸öPT_MOVETO»òMoveToµÄµãÁ¬Ïß×é³É·â±ÕÇúÏß
	PointCount			£ºµãÊý×éÖÐµãµÄÊýÁ¿
  WinDC::DrawBuffer
    Format: ²Î¼ûDrawTextº¯Êý
  Pen£º
	Style£º
		PS_SOLID¡¢PS_DASH¡¢PS_DOT¡¢PS_DASHDOT¡¢PS_DASHDOTDOT¡¢PS_USERSTYLE(Geometric»­±ÊÓÐÐ§)
	EndCap£º
		PS_ENDCAP_ROUND¡¢PS_ENDCAP_SQUARE¡¢PS_ENDCAP_FLAT
	Join£º
		PS_JOIN_BEVEL¡¢PS_JOIN_MITER¡¢PS_JOIN_ROUND
  Brush£º
	Hatch£º
		HS_BDIAGONAL¡¢HS_CROSS¡¢HS_DIAGCROSS¡¢HS_FDIAGONAL¡¢HS_HORIZONTAL¡¢HS_VERTICAL
  Region£º
	Combine£º
		RGN_AND¡¢RGN_OR¡¢RGN_XOR¡¢RGN_DIFF¡¢RGN_COPY
  ImageCopy£º
	Draw ROP£º
		BLACKNESS¡¢DSTINVERT¡¢MERGECOPY¡¢MERGEPAINT¡¢NOTSRCCOPY¡¢NOTSRCERASE¡¢
		PATCOPY¡¢PATINVERT¡¢PATPAINT¡¢SRCAND¡¢SRCCOPY¡¢SRCERASE¡¢SRCINVERT¡¢SRCPAINT¡¢WHITENESS
  WinDIB£º
	TransformAlphaChannel()£º	ÓÃÓÚÔÚÐÞ¸Ä·ÇalphaÍ¼Æ¬µÄalphaÍ¨µÀºó×ª»»ÎªalphaÍ¼Æ¬
	Generate¡Á¡Á¡Á()£º			ÓÃÓÚ×Ô¶¯Éú³É·ÇalphaÍ¼Æ¬µÄalphaÍ¨µÀÖµ
	±»WinDCµÄDraw»æÖÆµÄÊ±ºò£¬alphaÍ¼Æ¬ºÍ·ÇalphaÍ¼Æ¬»áÓÐ²»Í¬µÄÐ§¹û
*******************************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINGDI
#define VCZH_PRESENTATION_WINDOWS_GDI_WINGDI

#include<windows.h>

namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/*********************************************************************************************************
Í¼ÐÎ
*********************************************************************************************************/

			class WinRegion : public Object
			{
			public:
				typedef Ptr<WinRegion>	Ptr;

				friend bool IsEqual(WinRegion::Ptr Region1, WinRegion::Ptr Region2);
			protected:
				HRGN					FHandle;
			public:
				WinRegion(int Left, int Top, int Right, int Bottom, bool Rectangle);
				WinRegion(RECT Rect, bool Rectangle);
				WinRegion(int Left, int Top, int Right, int Bottom, int EllipseWidth, int EllipseHeight);
				WinRegion(POINT* Points, int Count, bool Alternate);
				WinRegion(WinRegion::Ptr Region);
				WinRegion(WinRegion::Ptr Region1, WinRegion::Ptr Region2, int CombineMode);
				WinRegion(HRGN RegionHandle);
				~WinRegion();

				HRGN					GetHandle();
				bool					ContainPoint(POINT Point);
				bool					ContainRect(RECT Rect);
				RECT					GetBoundRect();
				void					Move(int OffsetX, int OffsetY);
			};

			class WinTransform : public Object
			{
			protected:
				XFORM					FTransform;
			public:
				WinTransform(XFORM Transform);
				WinTransform(const WinTransform& Transform);

				WinTransform&			operator=(const WinTransform& Transform);
				WinTransform			operator*(const WinTransform& Transform);
				const XFORM*			GetHandle()const;

				static WinTransform		Translate(float OffsetX, float OffsetY);
				static WinTransform		Scale(float ScaleX, float ScaleY);
				static WinTransform		Rotate(float Angle);
				static WinTransform		Rotate(float Cos, float Sin);
				static WinTransform		ReflectX();
				static WinTransform		ReflectY();
				static WinTransform		Reflect(float VectorX, float VectorY);
				static WinTransform		Reflect(float OriginX, float OriginY, float VectorX, float VectorY);
				static WinTransform		AxisV(float Xx, float Xy, float Yx, float Yy);
				static WinTransform		AxisA(float AngleX, float LenX, float AngleY, float LenY);
			};
		
/*********************************************************************************************************
Í¼Ïñ
*********************************************************************************************************/

			class WinDC;
			class WinControlDC;
			class WinProxyDC;
			class WinImageDC;

			class WinMetaFileBuilder : public Object
			{
				friend class WinMetaFile;
			protected:
				int						FWidth;
				int						FHeight;
				WinProxyDC*				FDC;

				void					Create(int Width, int Height);
				void					Draw(HENHMETAFILE Handle);
				void					Destroy();
			public:

				WinMetaFileBuilder(int Width, int Height);
				~WinMetaFileBuilder();

				void					LoadFrom(WinMetaFile* File);
				void					SaveTo(WinMetaFile* File);
				void					LoadFrom(WString FileName);
				void					SaveTo(WString FileName);
				WinDC*					GetWinDC();
				int						GetWidth();
				int						GetHeight();
			};

			class WinMetaFile : public Object
			{
				friend class WinMetaFileBuilder;
			protected:
				HENHMETAFILE			FHandle;
				int						FWidth;
				int						FHeight;
			public:
				WinMetaFile(WString FileName);
				WinMetaFile(WinMetaFileBuilder* Builder);
				~WinMetaFile();

				HENHMETAFILE			GetHandle();
				int						GetWidth();
				int						GetHeight();
			};

			class WinBitmap : public Object
			{
			public:
				typedef Ptr<WinBitmap>		Ptr;
				enum BitmapBits
				{
					vbb2Bits,
					vbb24Bits,
					vbb32Bits
				};
			protected:
				BitmapBits				FBits;
				int						FWidth;
				int						FHeight;
				WinImageDC*				FDC;
				HBITMAP					FHandle;
				BYTE**					FScanLines;
				bool					FAlphaChannelBuilt;

				int						GetBitsFromBB(BitmapBits BB);
				int						GetLineBytes(int Width, BitmapBits BB);
				void					FillBitmapInfoHeader(int Width, int Height, BitmapBits Bits, BITMAPINFOHEADER* Header);
				HBITMAP					CreateDDB(int Width, int Height, BitmapBits Bits);
				HBITMAP					CreateDIB(int Width, int Height, BitmapBits Bits, BYTE**& ScanLines);
				void					Constructor(int Width, int Height, BitmapBits Bits, bool DIBSections);
			public:
				WinBitmap(int Width, int Height, BitmapBits Bits, bool DIBSections);
				WinBitmap(WString FileName, bool Use32Bits, bool DIBSections);
				~WinBitmap();

				void					SaveToFile(WString FileName);

				WinDC*					GetWinDC();
				int						GetWidth();
				int						GetHeight();
				int						GetLineBytes();
				BYTE**					GetScanLines();
				HBITMAP					GetBitmap();
				BitmapBits				GetBitmapBits();
				void					FillCompatibleHeader(BITMAPINFOHEADER* Header);

				bool					CanBuildAlphaChannel();
				bool					IsAlphaChannelBuilt();
				void					BuildAlphaChannel(bool autoPremultiply);
				void					GenerateTrans(COLORREF Color);
				void					GenerateAlpha(BYTE Alpha);
				void					GenerateTransAlpha(COLORREF Color, BYTE Alpha);
				void					GenerateLuminance();
				void					GenerateGrayLevel();
				void					Generate(BYTE(*Function)(COLORREF));
			};

/*********************************************************************************************************
²ÄÁÏ
*********************************************************************************************************/

			class WinBrush : public Object
			{
			public:
				typedef Ptr<WinBrush>		Ptr;
			protected:
				HBRUSH					FHandle;
				unsigned char*			FDIBMemory;
			public:
				WinBrush();
				WinBrush(COLORREF Color);
				WinBrush(int Hatch, COLORREF Color);
				WinBrush(WinBitmap::Ptr Bitmap);
				~WinBrush();

				HBRUSH					GetHandle();
			};

			class WinPen : public Object
			{
			public:
				typedef Ptr<WinPen>		Ptr;
			protected:
				HPEN					FHandle;
				unsigned char*			FDIBMemory;
			public:
				WinPen(int Style, int Width, COLORREF Color);
				WinPen(int Style, int EndCap, int Join, int Width, COLORREF Color);
				WinPen(int Style, int EndCap, int Join, int Hatch, int Width, COLORREF Color);
				WinPen(WinBitmap::Ptr DIB, int Style, int EndCap, int Join, int Width);
				~WinPen();

				HPEN					GetHandle();
			};

			class WinFont : public Object
			{
			public:
				typedef Ptr<WinFont>		Ptr;
			protected:
				LOGFONT					FFontInfo;
				HFONT					FHandle;
			public:
				WinFont(WString Name, int Height, int Width, int Escapement, int Orientation, int Weight, bool Italic, bool Underline, bool StrikeOut, bool Antialise);
				WinFont(LOGFONT* FontInfo);
				~WinFont();

				HFONT					GetHandle();
				LOGFONT*				GetInfo();
			};

/*********************************************************************************************************
Éè±¸ÉÏÏÂÎÄ
*********************************************************************************************************/

			extern WinBrush::Ptr		CreateDefaultBrush();
			extern WinPen::Ptr			CreateDefaultPen();
			extern WinFont::Ptr			CreateDefaultFont();

			class IWinResourceService : public Interface
			{
			public:
				virtual WinPen::Ptr		GetDefaultPen()=0;
				virtual WinBrush::Ptr	GetDefaultBrush()=0;
				virtual WinFont::Ptr	GetDefaultFont()=0;
			};
			extern IWinResourceService*	GetDefaultResourceService();
			extern void					SetDefaultResourceService(IWinResourceService* Service);

			class WinDC : public Object
			{
			protected:
				HDC						FHandle;

				WinPen::Ptr				FPen;
				WinBrush::Ptr			FBrush;
				WinFont::Ptr			FFont;

				HPEN					FOldPen;
				HBRUSH					FOldBrush;
				HFONT					FOldFont;

				void					Init();
			public:
				WinDC();
				~WinDC();

				HDC						GetHandle();

				WinPen::Ptr				GetPen();
				WinBrush::Ptr			GetBrush();
				WinFont::Ptr			GetFont();
				void					SetPen(WinPen::Ptr Pen);
				void					SetBrush(WinBrush::Ptr Brush);
				void					SetFont(WinFont::Ptr Font);
				COLORREF				GetBackColor();
				void					SetBackColor(COLORREF Color);
				COLORREF				GetTextColor();
				void					SetTextColor(COLORREF Color);
				bool					GetBackTransparent();
				void					SetBackTransparent(bool Transparent);
				POINT					GetBrushOrigin();
				void					SetBrushOrigin(POINT Point);

				void					DrawBuffer(int X, int Y, const wchar_t* Text, int CharCount);
				void					DrawBuffer(int X, int Y, const wchar_t* Text, int CharCount, int TabWidth, int TabOriginX);
				void					DrawBuffer(RECT Rect, const wchar_t* Text, int CharCount, UINT Format);
				void					DrawString(int X, int Y, WString Text);
				void					DrawString(int X, int Y, WString Text, int TabWidth, int TabOriginX);
				void					DrawString(RECT Rect, WString Text, UINT Format);
				SIZE					MeasureString(WString Text, int TabSize=-1);
				SIZE					MeasureBuffer(const wchar_t* Text, int CharCount, int TabSize=-1);
				SIZE					MeasureBuffer(const wchar_t* Text, int TabSize=-1);

				void					FillRegion(WinRegion::Ptr Region);
				void					FrameRegion(WinRegion::Ptr Region, int BlockWidth, int BlockHeight);

				void					MoveTo(int X, int Y);
				void					LineTo(int X, int Y);
				void					Rectangle(int Left, int Top, int Right, int Bottom);
				void					Rectangle(RECT Rect);
				void					FocusRectangle(int Left, int Top, int Right, int Bottom);
				void					FocusRectangle(RECT Rect);
				void					FillRect(int Left, int Top, int Right, int Bottom);
				void					FillRect(RECT Rect);
				void					Ellipse(int Left, int Top, int Right, int Bottom);
				void					Ellipse(RECT Rect);
				void					RoundRect(int Left, int Top, int Right, int Bottom, int EllipseWidth, int EllipseHeight);
				void					RoundRect(RECT Rect, int EllipseWidth, int EllipseHeight);
				void					PolyLine(const POINT* Points, int Count);
				void					PolyLineTo(const POINT* Points, int Count);
				void					PolyGon(const POINT* Points, int Count);
				void					PolyBezier(const POINT* Points, int Count);
				void					PolyBezierTo(const POINT* Points, int Count);
				void					PolyDraw(const POINT* Points, const BYTE* Actions, int PointCount);
				void					Arc(RECT Bound, POINT Start, POINT End);
				void					Arc(int Left, int Top, int Right, int Bottom, int StartX, int StartY, int EndX, int EndY);
				void					ArcTo(RECT Bound, POINT Start, POINT End);
				void					ArcTo(int Left, int Top, int Right, int Bottom, int StartX, int StartY, int EndX, int EndY);
				void					AngleArc(int X, int Y, int Radius, float StartAngle, float SweepAngle);
				void					AngleArc(int X, int Y, int Radius, double StartAngle, double SweepAngle);
				void					Chord(RECT Bound, POINT Start, POINT End);
				void					Chord(int Left, int Top, int Right, int Bottom, int StartX, int StartY, int EndX, int EndY);
				void					Pie(RECT Bound, POINT Start, POINT End);
				void					Pie(int Left, int Top, int Right, int Bottom, int StartX, int StartY, int EndX, int EndY);
				void					GradientTriangle(TRIVERTEX* Vertices, int VerticesCount, GRADIENT_TRIANGLE* Triangles, int TriangleCount);

				void					BeginPath();
				void					EndPath();
				void					ClosePath();
				void					WidenPath();
				void					DiscardPath();
				void					DrawPath();
				void					FillPath();
				void					DrawAndFillPath();
				WinRegion::Ptr			RegionFromPath();

				bool					PointInClip(POINT Point);
				bool					RectInClip(RECT Rect);
				void					ClipPath(int CombineMode);
				void					ClipRegion(WinRegion::Ptr Region);
				void					RemoveClip();
				void					MoveClip(int OffsetX, int OffsetY);
				void					CombineClip(WinRegion::Ptr Region, int CombineMode);
				void					IntersetClipRect(RECT Rect);
				void					ExcludeClipRect(RECT Rect);
				WinRegion::Ptr			GetClipRegion();
				RECT					GetClipBoundRect();

				WinTransform			GetTransform();
				void					SetTransform(const WinTransform& Transform);

				void					Copy(int dstX, int dstY, int dstW, int dstH, WinDC* Source, int srcX, int srcY, DWORD DrawROP=SRCCOPY);
				void					Copy(RECT dstRect, WinDC* Source, POINT srcPos, DWORD DrawROP=SRCCOPY);
				void					Copy(int dstX, int dstY, int dstW, int dstH, WinDC* Source, int srcX, int srcY ,int srcW, int srcH, DWORD DrawROP=SRCCOPY);
				void					Copy(RECT dstRect, WinDC* Source, RECT srcRect, DWORD DrawROP=SRCCOPY);
				void					Copy(POINT UpperLeft, POINT UpperRight, POINT LowerLeft, WinDC* Source, int srcX, int srcY, int srcW, int srcH);
				void					Copy(POINT UpperLeft, POINT UpperRight, POINT LowerLeft, WinDC* Source, RECT srcRect);
				void					CopyTrans(int dstX, int dstY, int dstW, int dstH, WinDC* Source, int srcX, int srcY ,int srcW, int srcH, COLORREF Color);
				void					CopyTrans(RECT dstRect, WinDC* Source, RECT srcRect, COLORREF Color);

				void					Draw(int dstX, int dstY, WinMetaFile* MetaFile);
				void					Draw(POINT Pos, WinMetaFile* MetaFile);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinMetaFile* MetaFile);
				void					Draw(RECT Rect, WinMetaFile* MetaFile);

				void					Draw(int dstX, int WinBitmap, WinBitmap::Ptr Bitmap);
				void					Draw(POINT Pos, WinBitmap::Ptr Bitmap);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, int srcX, int srcY);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, POINT Pos);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, int srcX, int srcY, int srcW, int srcH);
				void					Draw(RECT dstRect, WinBitmap::Ptr Bitmap, RECT srcRect);

				void					Draw(int dstX, int dstY, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(POINT Pos, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, int srcX, int srcY, unsigned char Alpha);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, POINT Pos, unsigned char Alpha);
				void					Draw(int dstX, int dstY, int dstW, int dstH, WinBitmap::Ptr Bitmap, int srcX, int srcY, int srcW, int srcH, unsigned char Alpha);
				void					Draw(RECT dstRect, WinBitmap::Ptr Bitmap, RECT srcRect, unsigned char Alpha);
			};

			class WinControlDC : public WinDC
			{
			protected:
				HWND					FControlHandle;
			public:
				WinControlDC(HWND Handle);
				~WinControlDC();
			};

			class WinProxyDC : public WinDC
			{
			public:
				WinProxyDC();
				~WinProxyDC();

				void					Initialize(HDC Handle);
			};

			class WinImageDC : public WinDC
			{
			public:
				WinImageDC();
				~WinImageDC();
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\WINDOWSGDI\GUIGRAPHICSWINDOWSGDI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSGDI
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSGDI


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_gdi
		{

/***********************************************************************
Functionality
***********************************************************************/

			class IWindowsGDIRenderTarget : public elements::IGuiGraphicsRenderTarget
			{
			public:
				virtual windows::WinDC*					GetDC()=0;
			};

			class IWindowsGDIResourceManager : public Interface
			{
			public:
				virtual Ptr<windows::WinPen>				CreateGdiPen(Color color)=0;
				virtual void								DestroyGdiPen(Color color)=0;
				virtual Ptr<windows::WinBrush>				CreateGdiBrush(Color color)=0;
				virtual void								DestroyGdiBrush(Color color)=0;
				virtual Ptr<windows::WinFont>				CreateGdiFont(const FontProperties& fontProperties)=0;
				virtual void								DestroyGdiFont(const FontProperties& fontProperties)=0;
				virtual Ptr<elements::text::CharMeasurer>	CreateCharMeasurer(const FontProperties& fontProperties)=0;
				virtual void								DestroyCharMeasurer(const FontProperties& fontProperties)=0;

				virtual Ptr<windows::WinBitmap>				GetBitmap(INativeImageFrame* frame)=0;
				virtual void								DestroyBitmapCache(INativeImageFrame* frame)=0;
			};

			extern IWindowsGDIResourceManager*			GetWindowsGDIResourceManager();

/***********************************************************************
OS Supporting
***********************************************************************/

			class IWindowsGDIObjectProvider : public Interface
			{
			public:
				virtual windows::WinDC*						GetNativeWindowDC(INativeWindow* window)=0;
				virtual IWindowsGDIRenderTarget*			GetBindedRenderTarget(INativeWindow* window)=0;
				virtual void								SetBindedRenderTarget(INativeWindow* window, IWindowsGDIRenderTarget* renderTarget)=0;
				virtual IWICImagingFactory*					GetWICImagingFactory()=0;
				virtual IWICBitmapDecoder*					GetWICBitmapDecoder(INativeImage* image)=0;
				virtual IWICBitmap*							GetWICBitmap(INativeImageFrame* frame)=0;
			};

			extern IWindowsGDIObjectProvider*				GetWindowsGDIObjectProvider();
			extern void										SetWindowsGDIObjectProvider(IWindowsGDIObjectProvider* provider);
		}
	}
}

extern void RendererMainGDI();

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\GRAPHICSELEMENT\WINDOWSGDI\GUIGRAPHICSRENDERERSWINDOWSGDI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSGDI
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSGDI


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_gdi
		{
			using namespace elements;

/***********************************************************************
Renderers
***********************************************************************/

			class GuiSolidBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidBorderElement, GuiSolidBorderElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor;
				Ptr<windows::WinPen>	pen;
				Ptr<windows::WinBrush>	brush;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiRoundBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiRoundBorderElement, GuiRoundBorderElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor;
				Ptr<windows::WinPen>	pen;
				Ptr<windows::WinBrush>	brush;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DBorderElement, Gui3DBorderElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				Ptr<windows::WinPen>	pen1;
				Ptr<windows::WinPen>	pen2;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DSplitterElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DSplitterElement, Gui3DSplitterElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				Ptr<windows::WinPen>	pen1;
				Ptr<windows::WinPen>	pen2;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidBackgroundElement, GuiSolidBackgroundElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor;
				Ptr<windows::WinPen>	pen;
				Ptr<windows::WinBrush>	brush;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiGradientBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiGradientBackgroundElement, GuiGradientBackgroundElementRenderer, IWindowsGDIRenderTarget)
			protected:
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidLabelElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidLabelElement, GuiSolidLabelElementRenderer, IWindowsGDIRenderTarget)
			protected:
				FontProperties			oldFont;
				Ptr<windows::WinFont>	font;

				void					UpdateMinSize();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiImageFrameElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiImageFrameElement, GuiImageFrameElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Ptr<windows::WinBitmap>		bitmap;

				void					UpdateBitmap();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiImageFrameElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiPolygonElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiPolygonElement, GuiPolygonElementRenderer, IWindowsGDIRenderTarget)
			protected:
				POINT*							points;
				int								pointCount;
				Color							oldPenColor;
				Color							oldBrushColor;
				Ptr<windows::WinPen>			pen;
				Ptr<windows::WinBrush>			brush;

				void							InitializeInternal();
				void							FinalizeInternal();
				void							RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiPolygonElementRenderer();
				~GuiPolygonElementRenderer();

				void							Render(Rect bounds)override;
				void							OnElementStateChanged()override;
			};

			class GuiColorizedTextElementRenderer : public Object, public IGuiGraphicsRenderer, protected GuiColorizedTextElement::ICallback
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiColorizedTextElement, GuiColorizedTextElementRenderer, IWindowsGDIRenderTarget)

			public:
				struct ColorItemResource
				{
					Color						text;
					Color						background;
					Ptr<windows::WinBrush>		backgroundBrush;
				};

				struct ColorEntryResource
				{
					ColorItemResource			normal;
					ColorItemResource			selectedFocused;
					ColorItemResource			selectedUnfocused;

					bool						operator==(const ColorEntryResource& value){return false;}
					bool						operator!=(const ColorEntryResource& value){return true;}
				};

				typedef collections::Array<ColorEntryResource>			ColorArray;
			protected:
				FontProperties			oldFont;
				Ptr<windows::WinFont>	font;
				ColorArray				colors;
				Color					oldCaretColor;
				Ptr<windows::WinPen>	caretPen;

				void					DestroyColors();
				void					ColorChanged();
				void					FontChanged();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\WINDOWS\WINNATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_WINNATIVEWINDOW
#define VCZH_PRESENTATION_WINDOWS_WINNATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/***********************************************************************
Windows Platform Native Controller
***********************************************************************/

			class IWindowsForm : public Interface
			{
			public:
				virtual HWND								GetWindowHandle()=0;
				virtual Interface*							GetGraphicsHandler()=0;
				virtual void								SetGraphicsHandler(Interface* handler)=0;
			};

			extern INativeController*						CreateWindowsNativeController(HINSTANCE hInstance);
			extern IWindowsForm*							GetWindowsForm(INativeWindow* window);
			extern void										DestroyWindowsNativeController(INativeController* controller);

			extern IWICImagingFactory*						GetWICImagingFactory();
			extern IWICBitmapDecoder*						GetWICBitmapDecoder(INativeImage* image);
			extern IWICBitmap*								GetWICBitmap(INativeImageFrame* frame);
		}
	}
}

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\WINDOWS\DIRECT2D\WINDIRECT2DAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation

Interfaces:
***********************************************************************/
#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINDIRECT2DAPPLICATION
#define VCZH_PRESENTATION_WINDOWS_GDI_WINDIRECT2DAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			extern ID2D1RenderTarget*					GetNativeWindowDirect2DRenderTarget(INativeWindow* window);
			extern ID2D1Factory*						GetDirect2DFactory();
			extern IDWriteFactory*						GetDirectWriteFactory();
		}
	}
}

extern int WinMainDirect2D(HINSTANCE hInstance, void(*RendererMain)());

#endif

/***********************************************************************
E:\CODEPLEX\GAC\WORKSPACE\LIBRARIES\GACUI\SOURCE\NATIVEWINDOW\WINDOWS\GDI\WINGDIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: ³Âè÷å«(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation

Interfaces:
***********************************************************************/
#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINGDIAPPLICATION
#define VCZH_PRESENTATION_WINDOWS_GDI_WINGDIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			extern WinDC*									GetNativeWindowDC(INativeWindow* window);
			extern HDC										GetNativeWindowHDC(INativeWindow* window);
		}
	}
}

extern int WinMainGDI(HINSTANCE hInstance, void(*RendererMain)());

#endif
